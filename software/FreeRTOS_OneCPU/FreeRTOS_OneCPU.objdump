
FreeRTOS_OneCPU.elf:     file format elf32-littlenios2
FreeRTOS_OneCPU.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x01000250

Program Header:
    LOAD off    0x00001000 vaddr 0x01000000 paddr 0x01000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x01000020 paddr 0x01000020 align 2**12
         filesz 0x0002ad18 memsz 0x0002ad18 flags r-x
    LOAD off    0x0002bd38 vaddr 0x0102ad38 paddr 0x0102c9b8 align 2**12
         filesz 0x00001c80 memsz 0x00001c80 flags rw-
    LOAD off    0x0002e638 vaddr 0x0102e638 paddr 0x0102e638 align 2**12
         filesz 0x00000000 memsz 0x008006ac flags rw-
    LOAD off    0x0002e000 vaddr 0x01800000 paddr 0x01800000 align 2**12
         filesz 0x00000100 memsz 0x00000100 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  01000000  01000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000230  01000020  01000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00028f8c  01000250  01000250  00001250  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00001b5c  010291dc  010291dc  0002a1dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .resource_table 00000100  01800000  01800000  0002e000  2**8
                  CONTENTS, ALLOC, LOAD, DATA
  5 .rwdata       00001c80  0102ad38  0102c9b8  0002bd38  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  6 .bss          00800732  0102e638  0102e638  0002e638  2**2
                  ALLOC, SMALL_DATA
  7 .sdram        00000000  0182ece4  0182ece4  0002e100  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0002e100  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000016c0  00000000  00000000  0002e128  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00040c39  00000000  00000000  0002f7e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000edb2  00000000  00000000  00070421  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001528a  00000000  00000000  0007f1d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000078a4  00000000  00000000  00094460  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00007f5d  00000000  00000000  0009bd04  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0001d823  00000000  00000000  000a3c61  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000060  00000000  00000000  000c1484  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00001bd0  00000000  00000000  000c14e8  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  000cb7d6  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000a  00000000  00000000  000cb7d9  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  000cb7e3  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  000cb7e4  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   0000000b  00000000  00000000  000cb7e5  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    0000000b  00000000  00000000  000cb7f0  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   0000000b  00000000  00000000  000cb7fb  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 0000000c  00000000  00000000  000cb806  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 0000001c  00000000  00000000  000cb812  2**0
                  CONTENTS, READONLY
 27 .jdi          0000494a  00000000  00000000  000cb82e  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     0029ff80  00000000  00000000  000d0178  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
01000000 l    d  .entry	00000000 .entry
01000020 l    d  .exceptions	00000000 .exceptions
01000250 l    d  .text	00000000 .text
010291dc l    d  .rodata	00000000 .rodata
01800000 l    d  .resource_table	00000000 .resource_table
0102ad38 l    d  .rwdata	00000000 .rwdata
0102e638 l    d  .bss	00000000 .bss
0182ece4 l    d  .sdram	00000000 .sdram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../FreeRTOS_OneCPU_bsp//obj/HAL/src/crt0.o
01000298 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/Source/portable/GCC/NiosII/port_asm.o
01000020 l       .exceptions	00000000 save_context
0100009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
010000ac l       .exceptions	00000000 hw_irq_test
01000150 l       .exceptions	00000000 soft_exceptions
010000c0 l       .exceptions	00000000 hw_irq_handler
010000d4 l       .exceptions	00000000 restore_context
0100016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
0100092c l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
01000c2c l     F .text	0000002c prvReadGp
01000d90 l     F .text	00000088 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_2.c
0102e6d0 l     O .bss	00800000 ucHeap
0102c948 l     O .rwdata	00000002 heapSTRUCT_SIZE
0102e638 l     O .bss	00000008 xStart
0102e640 l     O .bss	00000008 xEnd
0102c94c l     O .rwdata	00000004 xFreeBytesRemaining
0102e648 l     O .bss	00000004 xHeapHasBeenInitialised.2596
01001390 l     F .text	00000074 prvHeapInit
00000000 l    df *ABS*	00000000 queue.c
010015c0 l     F .text	00000084 prvInitialiseNewQueue
01001644 l     F .text	00000060 prvInitialiseMutex
0100241c l     F .text	0000018c prvCopyDataToQueue
010027d0 l     F .text	00000058 prvIsQueueFull
01002644 l     F .text	000000f4 prvUnlockQueue
010025a8 l     F .text	0000009c prvCopyDataFromQueue
01002738 l     F .text	00000050 prvIsQueueEmpty
010023cc l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
0100369c l     F .text	00000080 prvInitialiseNewStreamBuffer
01003628 l     F .text	00000074 prvBytesInBuffer
01002dd0 l     F .text	000000d4 prvWriteMessageToBuffer
01003420 l     F .text	000000f4 prvWriteBytesToBuffer
01003188 l     F .text	000000bc prvReadMessageFromBuffer
01003514 l     F .text	00000114 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
0182e6d0 l     O .bss	00000064 pxReadyTasksLists
0182e734 l     O .bss	00000014 xDelayedTaskList1
0182e748 l     O .bss	00000014 xDelayedTaskList2
0102e650 l     O .bss	00000004 pxDelayedTaskList
0102e654 l     O .bss	00000004 pxOverflowDelayedTaskList
0182e75c l     O .bss	00000014 xPendingReadyList
0182e770 l     O .bss	00000014 xTasksWaitingTermination
0102e658 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0182e784 l     O .bss	00000014 xSuspendedTaskList
0102e65c l     O .bss	00000004 uxCurrentNumberOfTasks
0102e660 l     O .bss	00000004 xTickCount
0102e664 l     O .bss	00000004 uxTopReadyPriority
0102e668 l     O .bss	00000004 xSchedulerRunning
0102e66c l     O .bss	00000004 uxPendedTicks
0102e670 l     O .bss	00000004 xYieldPending
0102e674 l     O .bss	00000004 xNumOfOverflows
0102e678 l     O .bss	00000004 uxTaskNumber
0102e67c l     O .bss	00000004 xNextTaskUnblockTime
0102e680 l     O .bss	00000004 xIdleTaskHandle
0102e684 l     O .bss	00000004 uxSchedulerSuspended
01003804 l     F .text	000001e4 prvInitialiseNewTask
010039e8 l     F .text	000000fc prvAddNewTaskToReadyList
01004d38 l     F .text	000000b8 prvInitialiseTaskLists
01004f34 l     F .text	00000044 prvDeleteTCB
01004f78 l     F .text	00000054 prvResetNextTaskUnblockTime
01005b6c l     F .text	000000e8 prvAddCurrentTaskToDelayedList
0100416c l     F .text	0000006c prvTaskIsTaskSuspended
01004d1c l     F .text	0000001c prvIdleTask
01004df0 l     F .text	00000080 prvCheckTasksWaitingTermination
01004e70 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 atomic_mutex.c
01005c54 l     F .text	00000030 __metal_mutex_init
01005c84 l     F .text	00000024 __metal_mutex_deinit
01005ca8 l     F .text	00000058 __metal_mutex_acquire
01005d00 l     F .text	00000030 __metal_mutex_release
01005d30 l     F .text	00000034 metal_mutex_init
01005d64 l     F .text	00000034 metal_mutex_deinit
01005d98 l     F .text	00000034 metal_mutex_acquire
01005dcc l     F .text	00000034 metal_mutex_release
00000000 l    df *ABS*	00000000 helper.c
01005ed0 l     F .text	00000030 system_metal_logger
01029214 l     O .rodata	0000000c __func__.4223
00000000 l    df *ABS*	00000000 metal-test.c
01005f98 l     F .text	00000064 metal_list_add_before
01005ffc l     F .text	0000003c metal_list_add_tail
0102c950 l     O .rwdata	00000008 test_cases
00000000 l    df *ABS*	00000000 device.c
01006294 l     F .text	00000040 metal_list_init
010062d4 l     F .text	00000064 metal_list_add_before
01006338 l     F .text	0000003c metal_list_add_tail
01006374 l     F .text	00000068 metal_list_del
010063dc l     F .text	0000003c __metal_cache_flush
01006418 l     F .text	0000003c __metal_cache_invalidate
01006454 l     F .text	0000003c metal_cache_flush
01006490 l     F .text	0000003c metal_cache_invalidate
010292e8 l     O .rodata	00000013 __func__.2868
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 alloc.c
01006c90 l     F .text	00000030 metal_allocate_memory
01006cc0 l     F .text	00000034 metal_free_memory
0102c958 l     O .rwdata	00000004 test_count
01006cf4 l     F .text	000000b8 alloc_thread
01006dac l     F .text	00000048 alloc
01006df4 l     F .text	00000034 metal_test_alloc
0102ad64 l     O .rwdata	00000010 metal_test_alloc.2899
00000000 l    df *ABS*	00000000 atomic.c
0102c95c l     O .rwdata	00000004 atomic_test_count
01006e28 l     F .text	0000008c atomic_thread
01006eb4 l     F .text	000000d0 atomic
01006f84 l     F .text	00000034 metal_test_atomic
0102ad74 l     O .rwdata	00000010 metal_test_atomic.2410
00000000 l    df *ABS*	00000000 condition.c
00000000 l    df *ABS*	00000000 device.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 io.c
00000000 l    df *ABS*	00000000 irq.c
00000000 l    df *ABS*	00000000 mutex.c
01007218 l     F .text	00000030 __metal_mutex_init
01007248 l     F .text	00000024 __metal_mutex_deinit
0100726c l     F .text	00000058 __metal_mutex_acquire
010072c4 l     F .text	00000030 __metal_mutex_release
010072f4 l     F .text	00000034 metal_mutex_init
01007328 l     F .text	00000034 metal_mutex_deinit
0100735c l     F .text	00000034 metal_mutex_acquire
01007390 l     F .text	00000034 metal_mutex_release
0102c960 l     O .rwdata	00000004 mutex_test_count
010073c4 l     F .text	0000006c mutex_thread
01007430 l     F .text	00000064 mutex
01007494 l     F .text	00000034 metal_test_mutex
0102ad84 l     O .rwdata	00000010 metal_test_mutex.2703
00000000 l    df *ABS*	00000000 irq_common.c
010074c8 l     F .text	00000064 metal_irq_handle
0100752c l     F .text	00000038 sys_irq_enable
01007564 l     F .text	00000038 sys_irq_disable
0182e798 l     O .bss	00000100 irqs
0100759c l     F .text	000000dc metal_nios2_irq_set_enable
0102938c l     O .rodata	0000001b __func__.2615
0102ad94 l     O .rwdata	00000020 nios2_irq_cntr
010293a8 l     O .rodata	00000015 __func__.2625
00000000 l    df *ABS*	00000000 sys.c
00000000 l    df *ABS*	00000000 shmem.c
00000000 l    df *ABS*	00000000 sleep.c
010078f8 l     F .text	0000003c __metal_sleep_usec
01007934 l     F .text	00000030 metal_sleep_usec
01007964 l     F .text	000000c0 sleep
01007a24 l     F .text	00000034 metal_test_sleep
0102adb4 l     O .rwdata	00000010 metal_test_sleep.2891
00000000 l    df *ABS*	00000000 threads.c
01007a58 l     F .text	0000005c thread_wrapper
00000000 l    df *ABS*	00000000 time.c
00000000 l    df *ABS*	00000000 init.c
01007ef8 l     F .text	00000040 metal_list_init
00000000 l    df *ABS*	00000000 io.c
01008024 l     F .text	0000005c metal_io_virt
00000000 l    df *ABS*	00000000 irq.c
01008710 l     F .text	00000064 metal_list_add_before
01008774 l     F .text	0000003c metal_list_add_tail
0102c964 l     O .rwdata	00000008 irq_cntrs
010087b0 l     F .text	000000f4 metal_irq_allocate
01008970 l     F .text	00000094 metal_irq_get_controller
01008a04 l     F .text	00000060 _metal_irq_set_enable
00000000 l    df *ABS*	00000000 log.c
00000000 l    df *ABS*	00000000 shmem.c
01008c90 l     F .text	00000064 metal_list_add_before
01008cf4 l     F .text	0000003c metal_list_add_tail
01008d30 l     F .text	00000028 metal_io_region_size
0102947c l     O .rodata	0000001d __func__.2743
00000000 l    df *ABS*	00000000 softirq.c
01008ed8 l     F .text	00000064 metal_irq_handle
0102e68c l     O .bss	00000004 metal_softirq_avail
0102c96c l     O .rwdata	00000004 metal_softirq_num
0182e898 l     O .bss	00000200 metal_softirqs
0182ea98 l     O .bss	00000040 metal_softirq_pending
0182ead8 l     O .bss	00000040 metal_softirq_enabled
01008f3c l     F .text	000000b4 metal_softirq_set_enable
0102adc4 l     O .rwdata	00000020 metal_softirq_cntr
00000000 l    df *ABS*	00000000 rpmsg_retarget.c
010092a4 l     F .text	00000030 __metal_mutex_init
010092d4 l     F .text	00000024 __metal_mutex_deinit
010092f8 l     F .text	00000058 __metal_mutex_acquire
01009350 l     F .text	00000030 __metal_mutex_release
01009380 l     F .text	00000034 metal_mutex_init
010093b4 l     F .text	00000034 metal_mutex_deinit
010093e8 l     F .text	00000034 metal_mutex_acquire
0100941c l     F .text	00000034 metal_mutex_release
01009450 l     F .text	00000030 metal_spinlock_init
01009480 l     F .text	000000ac metal_spinlock_acquire
0100952c l     F .text	00000030 metal_spinlock_release
0100955c l     F .text	0000007c rpmsg_send
010095d8 l     F .text	0000004c is_rpmsg_ept_ready
0102e690 l     O .bss	00000004 rpmsg_default_rpc
01009624 l     F .text	000000f0 rpmsg_rpc_ept_cb
01009714 l     F .text	00000074 rpmsg_service_unbind
00000000 l    df *ABS*	00000000 elf_loader.c
01009fdc l     F .text	00000030 metal_allocate_memory
0100a00c l     F .text	00000034 metal_free_memory
0100a040 l     F .text	0000004c elf_is_64
0100a08c l     F .text	00000050 elf_ehdr_size
0100a0dc l     F .text	0000005c elf_phoff
0100a138 l     F .text	00000060 elf_phentsize
0100a198 l     F .text	00000060 elf_phnum
0100a1f8 l     F .text	0000005c elf_shoff
0100a254 l     F .text	00000060 elf_shentsize
0100a2b4 l     F .text	00000060 elf_shnum
0100a314 l     F .text	00000060 elf_shstrndx
0100a374 l     F .text	00000058 elf_phtable_ptr
0100a3cc l     F .text	00000058 elf_shtable_ptr
0100a424 l     F .text	00000058 elf_shstrtab_ptr
0100a47c l     F .text	00000058 elf_load_state
0100a4d4 l     F .text	000001a0 elf_parse_segment
0100a674 l     F .text	000000fc elf_get_segment_from_index
0100a770 l     F .text	00000180 elf_get_section_from_name
0100a8f0 l     F .text	00000104 elf_get_section_from_index
0100a9f4 l     F .text	00000238 elf_parse_section
0100ac2c l     F .text	000000d0 elf_next_load_segment
0100acfc l     F .text	00000040 elf_info_size
01029690 l     O .rodata	00000010 __func__.3420
010296a0 l     O .rodata	00000009 __func__.3451
010296ac l     O .rodata	00000015 __func__.3477
00000000 l    df *ABS*	00000000 remoteproc.c
0100bbf4 l     F .text	00000030 metal_allocate_memory
0100bc24 l     F .text	00000034 metal_free_memory
0100bc58 l     F .text	00000074 metal_bitmap_set_bit
0100bccc l     F .text	0000005c metal_bitmap_is_bit_set
0100bd28 l     F .text	00000040 metal_bitmap_is_bit_clear
0100bd68 l     F .text	0000006c metal_bitmap_next_clear_bit
0100bdd4 l     F .text	00000040 metal_list_init
0100be14 l     F .text	00000064 metal_list_add_before
0100be78 l     F .text	0000003c metal_list_add_tail
0100beb4 l     F .text	00000068 metal_list_del
0100bf1c l     F .text	0000005c metal_io_virt
0100bf78 l     F .text	00000054 metal_io_virt_to_offset
0100bfcc l     F .text	000000d0 metal_io_phys
0100c09c l     F .text	000000d8 metal_io_phys_to_offset
0100c174 l     F .text	00000044 metal_io_phys_to_virt
0100c1b8 l     F .text	00000030 __metal_mutex_init
0100c1e8 l     F .text	00000058 __metal_mutex_acquire
0100c240 l     F .text	00000030 __metal_mutex_release
0100c270 l     F .text	00000034 metal_mutex_init
0100c2a4 l     F .text	00000034 metal_mutex_acquire
0100c2d8 l     F .text	00000034 metal_mutex_release
0100c30c l     F .text	00000024 RPROC_ERR_PTR
0100c330 l     F .text	00000088 vring_size
0100c3b8 l     F .text	0000005c remoteproc_check_fw_format
0100c414 l     F .text	00000178 remoteproc_get_mem
0100c58c l     F .text	00000048 remoteproc_datopa
0100c5d4 l     F .text	00000048 remoteproc_patoda
0100c61c l     F .text	0000015c remoteproc_get_rsc_table
0100c778 l     F .text	00000054 remoteproc_parse_rsc_table
01029c40 l     O .rodata	00000010 __func__.3717
01029c50 l     O .rodata	00000018 __func__.3753
0100e84c l     F .text	0000004c remoteproc_virtio_notify
01029c68 l     O .rodata	00000019 __func__.3786
01029c84 l     O .rodata	00000019 __func__.3807
00000000 l    df *ABS*	00000000 remoteproc_virtio.c
0100ed3c l     F .text	0000005c metal_io_virt
0100ed98 l     F .text	00000054 metal_io_virt_to_offset
0100edec l     F .text	00000198 metal_io_read
01029d44 l     O .rodata	0000000e __func__.2652
0100ef84 l     F .text	0000017c metal_io_write
01029d54 l     O .rodata	0000000f __func__.2661
0100f100 l     F .text	00000030 metal_allocate_memory
0100f130 l     F .text	00000034 metal_free_memory
0100f164 l     F .text	00000060 virtqueue_allocate
0100f1c4 l     F .text	000000bc rproc_virtio_virtqueue_notify
01029d24 l     O .rodata	0000001e __func__.3350
0100f280 l     F .text	00000084 rproc_virtio_get_status
0100f304 l     F .text	000000d4 rproc_virtio_set_status
0100f3d8 l     F .text	00000084 rproc_virtio_get_dfeatures
0100f45c l     F .text	00000098 rproc_virtio_get_features
0100f4f4 l     F .text	000000cc rproc_virtio_set_features
0100f5c0 l     F .text	00000054 rproc_virtio_negotiate_features
0100f614 l     F .text	00000030 rproc_virtio_read_config
0100f644 l     F .text	00000030 rproc_virtio_write_config
0100f674 l     F .text	00000044 rproc_virtio_reset_device
01029d00 l     O .rodata	00000024 remoteproc_virtio_dispatch_funcs
00000000 l    df *ABS*	00000000 rsc_table_parser.c
0100fba4 l     F .text	00000054 metal_io_virt_to_offset
01029d64 l     O .rodata	00000010 rsc_handler_table
010103a0 l     F .text	00000028 handle_dummy_rsc
01029da8 l     O .rodata	00000009 __func__.3038
00000000 l    df *ABS*	00000000 rpmsg.c
01010544 l     F .text	00000058 __metal_mutex_acquire
0101059c l     F .text	00000030 __metal_mutex_release
010105cc l     F .text	00000034 metal_mutex_acquire
01010600 l     F .text	00000034 metal_mutex_release
01010634 l     F .text	00000064 metal_list_add_before
01010698 l     F .text	0000003c metal_list_add_tail
010106d4 l     F .text	00000068 metal_list_del
0101073c l     F .text	00000074 metal_bitmap_set_bit
010107b0 l     F .text	0000005c metal_bitmap_is_bit_set
0101080c l     F .text	00000078 metal_bitmap_clear_bit
01010884 l     F .text	00000040 metal_bitmap_is_bit_clear
010108c4 l     F .text	0000006c metal_bitmap_next_clear_bit
01010930 l     F .text	00000094 rpmsg_init_ept
010109c4 l     F .text	00000074 rpmsg_get_address
01010a38 l     F .text	0000004c rpmsg_release_address
01010a84 l     F .text	00000050 rpmsg_is_address_set
01010ad4 l     F .text	00000054 rpmsg_set_address
01010db8 l     F .text	00000084 rpmsg_unregister_endpoint
00000000 l    df *ABS*	00000000 rpmsg_virtio.c
010110c8 l     F .text	0000003c __metal_sleep_usec
01011104 l     F .text	00000030 metal_sleep_usec
01011134 l     F .text	00000040 metal_list_init
01011174 l     F .text	00000034 metal_list_is_empty
010111a8 l     F .text	00000054 metal_io_virt_to_offset
010111fc l     F .text	00000030 __metal_mutex_init
0101122c l     F .text	00000024 __metal_mutex_deinit
01011250 l     F .text	00000058 __metal_mutex_acquire
010112a8 l     F .text	00000030 __metal_mutex_release
010112d8 l     F .text	00000034 metal_mutex_init
0101130c l     F .text	00000034 metal_mutex_deinit
01011340 l     F .text	00000034 metal_mutex_acquire
01011374 l     F .text	00000034 metal_mutex_release
010113a8 l     F .text	00000094 rpmsg_init_ept
0101143c l     F .text	0000002c rpmsg_virtio_get_role
01011468 l     F .text	0000005c rpmsg_virtio_set_status
010114c4 l     F .text	00000048 rpmsg_virtio_get_status
0101150c l     F .text	00000048 rpmsg_virtio_get_features
01011554 l     F .text	0000005c rpmsg_virtio_create_virtqueues
010115b0 l     F .text	00000040 rpmsg_get_ept_from_addr
010116c8 l     F .text	000000b0 rpmsg_virtio_return_buffer
01011778 l     F .text	000000b8 rpmsg_virtio_enqueue_buffer
01011830 l     F .text	000000bc rpmsg_virtio_get_tx_buffer
010118ec l     F .text	00000090 rpmsg_virtio_get_rx_buffer
0101197c l     F .text	0000006c rpmsg_virtio_wait_remote_ready
010119e8 l     F .text	0000007c _rpmsg_virtio_get_buffer_size
01011a64 l     F .text	0000021c rpmsg_virtio_send_offchannel_raw
01011c80 l     F .text	00000024 rpmsg_virtio_tx_callback
01011ca4 l     F .text	00000238 rpmsg_virtio_rx_callback
01011edc l     F .text	000001dc rpmsg_virtio_ns_callback
00000000 l    df *ABS*	00000000 virtio.c
01012590 l     F .text	00000088 vring_size
01012618 l     F .text	00000054 metal_io_virt_to_offset
01029e1c l     O .rodata	00000048 virtio_ident_table
01029e9c l     O .rodata	00000028 virtio_common_feature_desc
010126dc l     F .text	0000012c virtio_feature_name
00000000 l    df *ABS*	00000000 virtqueue.c
010129cc l     F .text	000000a0 vring_init
01012a6c l     F .text	00000060 vring_need_event
01012acc l     F .text	00000034 metal_free_memory
01012b00 l     F .text	0000005c metal_io_virt
01012b5c l     F .text	00000054 metal_io_virt_to_offset
01012bb0 l     F .text	000000d0 metal_io_phys
01012c80 l     F .text	000000d8 metal_io_phys_to_offset
01012d58 l     F .text	00000044 metal_io_phys_to_virt
01012d9c l     F .text	00000044 metal_io_virt_to_phys
01012de0 l     F .text	00000044 virtqueue_phys_to_virt
01012e24 l     F .text	00000044 virtqueue_virt_to_phys
01013a24 l     F .text	000000dc vq_ring_init
010137c4 l     F .text	0000014c vq_ring_add_buffer
01013b00 l     F .text	000000a0 vq_ring_update_avail
01013910 l     F .text	00000114 vq_ring_free_chain
01013ba0 l     F .text	000001a4 vq_ring_enable_interrupt
01013d90 l     F .text	000001b8 vq_ring_must_notify
01013f48 l     F .text	00000048 vq_ring_notify
01013f90 l     F .text	00000048 virtqueue_nused
01013fd8 l     F .text	00000048 virtqueue_navail
00000000 l    df *ABS*	00000000 platform_info.c
01014020 l     F .text	0000005c metal_io_virt
0101407c l     F .text	000000d0 metal_io_phys
0101414c l     F .text	000000d8 metal_io_phys_to_offset
01014224 l     F .text	00000044 metal_io_phys_to_virt
01014268 l     F .text	00000030 metal_allocate_memory
01014298 l     F .text	00000034 metal_free_memory
010142cc l     F .text	00000024 rpmsg_virtio_get_rpmsg_device
0102e694 l     O .bss	00000004 ipi_phys_addr
0102ae50 l     O .rwdata	00000018 rproc_priv
0182eb18 l     O .bss	00000038 rproc_inst
0182eb50 l     O .bss	0000000c shpool
010142f0 l     F .text	0000013c platform_create_proc
00000000 l    df *ABS*	00000000 rpmsg-echo.c
0101473c l     F .text	0000007c rpmsg_send
0182eb5c l     O .bss	00000040 lept
0102e698 l     O .bss	00000004 shutdown_req
010147b8 l     F .text	0000008c rpmsg_endpoint_cb
01014844 l     F .text	00000040 rpmsg_service_unbind
00000000 l    df *ABS*	00000000 rsc_table.c
00000000 l    df *ABS*	00000000 zynqmp_r5_a53_rproc.c
01014a64 l     F .text	00000064 metal_list_add_before
01014ac8 l     F .text	0000003c metal_list_add_tail
01014b04 l     F .text	0000003c metal_irq_unregister
01014b40 l     F .text	0000005c metal_io_virt
01014b9c l     F .text	000000d0 metal_io_phys
01014c6c l     F .text	000000d8 metal_io_phys_to_offset
01014d44 l     F .text	00000044 metal_io_phys_to_virt
01014d88 l     F .text	00000198 metal_io_read
0102a288 l     O .rodata	0000000e __func__.3432
01014f20 l     F .text	0000017c metal_io_write
0102a298 l     O .rodata	0000000f __func__.3441
0101509c l     F .text	00000050 metal_device_io_region
010150ec l     F .text	00000030 metal_allocate_memory
0101511c l     F .text	00000034 metal_free_memory
01015150 l     F .text	000000a0 remoteproc_init_mem
010151f0 l     F .text	00000060 remoteproc_add_mem
01015250 l     F .text	000000f4 zynqmp_r5_a53_proc_irq_handler
01015344 l     F .text	00000190 zynqmp_r5_a53_proc_init
010154d4 l     F .text	000000bc zynqmp_r5_a53_proc_remove
01015590 l     F .text	00000188 zynqmp_r5_a53_proc_mmap
01015718 l     F .text	00000088 zynqmp_r5_a53_proc_notify
00000000 l    df *ABS*	00000000 assert.c
00000000 l    df *ABS*	00000000 fiprintf.c
00000000 l    df *ABS*	00000000 impure.c
0102ae8c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 snprintf.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 vfprintf.c
0102aa32 l     O .rodata	00000010 zeroes.4389
0102aa42 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfiprintfr_1.c
00000000 l    df *ABS*	00000000 vfprintf.c
0102aa52 l     O .rodata	00000010 zeroes.4404
0101ac14 l     F .text	000000bc __sbprintf
0102aa62 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 abort.c
00000000 l    df *ABS*	00000000 dtoa.c
0101ae3c l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0101c96c l     F .text	00000008 __fp_unlock
0101c980 l     F .text	0000019c __sinit.part.1
0101cb1c l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
0102b2d0 l     O .rwdata	00000020 lc_ctype_charset
0102b2b0 l     O .rwdata	00000020 lc_message_charset
0102b2f0 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
0102aa90 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 signal.c
00000000 l    df *ABS*	00000000 signalr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 vfprintf.c
0102abc4 l     O .rodata	00000010 blanks.4332
0102abb4 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 vfprintf.c
010212dc l     F .text	000000fc __sprint_r.part.0
0102abe4 l     O .rodata	00000010 blanks.4348
0102abd4 l     O .rodata	00000010 zeroes.4349
01022868 l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_close.c
01026524 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
010266f0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_fstat.c
01026750 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_getpid.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
01026a0c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_kill.c
01026aec l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
01026c58 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
01026d44 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
01026f18 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0102c9a4 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
01027194 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
010272c8 l     F .text	00000034 alt_dev_reg
010272fc l     F .text	0000003c alt_get_errno
01027338 l     F .text	00000068 alt_avalon_mutex_reg
0102b8d8 l     O .rwdata	00001060 jtag_uart_0
0102c938 l     O .rwdata	00000010 mutex_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
01027664 l     F .text	0000020c altera_avalon_jtag_uart_irq
01027870 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_mutex.c
01027ea8 l     F .text	0000003c alt_get_errno
01027ee4 l     F .text	0000007c alt_mutex_trylock
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
01028174 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
010284ec l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
01028750 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
01028890 l     F .text	0000003c alt_get_errno
010288cc l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0101f2ec g     F .text	00000074 _mprec_log10
01007678 g     F .text	00000068 metal_nios2_irq_isr
0100ba24 g     F .text	00000080 elf_get_entry
0101f3d8 g     F .text	0000008c __any_on
01006668 g     F .text	000000a4 metal_bus_find
01022e04 g     F .text	00000054 _isatty_r
0102aa9c g     O .rodata	00000028 __mprec_tinytens
0101442c g     F .text	00000084 platform_init
01026e54 g     F .text	0000007c alt_main
01015bd0 g     F .text	000000c0 _puts_r
01013030 g     F .text	00000130 virtqueue_get_buffer
0182ebe4 g     O .bss	00000100 alt_irq
0182ebc4 g     O .bss	00000020 _metal
01022e58 g     F .text	00000060 _lseek_r
010000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
0100496c g     F .text	00000064 vTaskPlaceOnUnorderedEventList
01001350 g     F .text	00000020 xPortGetFreeHeapSize
01000684 g     F .text	0000003c xEventGroupGetBitsFromISR
0102c9b8 g       *ABS*	00000000 __flash_rwdata_start
01025050 g     F .text	00000088 .hidden __eqdf2
0182ece4 g       *ABS*	00000000 __alt_heap_start
01003e28 g     F .text	00000058 uxTaskPriorityGet
01013430 g     F .text	00000034 virtqueue_enable_cb
0101fd34 g     F .text	0000005c _kill_r
01005e68 g     F .text	00000034 atomic_mutex_acquire
01015b94 g     F .text	0000003c printf
01023070 g     F .text	0000009c _wcrtomb_r
01010bd8 g     F .text	000000a0 rpmsg_send_ns_message
0101fafc g     F .text	00000084 _signal_r
0101fe6c g     F .text	0000005c __sseek
0101ccbc g     F .text	00000010 __sinit
01022f18 g     F .text	00000140 __swbuf_r
0101d784 g     F .text	0000007c _setlocale_r
0101cb24 g     F .text	00000068 __sfmoreglue
01008c68 g     F .text	00000028 metal_get_log_level
01002ea4 g     F .text	00000158 xStreamBufferReceive
01026ef4 g     F .text	00000024 __malloc_unlock
01016598 g     F .text	0000001c strerror
01008d58 g     F .text	000000b8 metal_shmem_register_generic
010002f0 g     F .text	00000184 xEventGroupSync
0101e30c g     F .text	0000015c memmove
010078b8 g     F .text	00000040 metal_shmem_open
01005370 g     F .text	00000054 vTaskEnterCritical
0101cca4 g     F .text	00000018 _cleanup
01015d7c g     F .text	000000e4 snprintf
01001a38 g     F .text	000000e8 xQueueGenericSendFromISR
01004654 g     F .text	00000040 pcTaskGetName
0102801c g     F .text	00000040 altera_avalon_mutex_trylock
0101e468 g     F .text	000000a8 _Balloc
01002a90 g     F .text	00000088 xStreamBufferSpacesAvailable
01008c34 g     F .text	00000034 metal_set_log_level
010250d8 g     F .text	000000dc .hidden __gtdf2
01028c88 g     F .text	00000024 altera_nios2_gen2_irq_init
01002988 g     F .text	0000009c xStreamBufferReset
0102e688 g     O .bss	00000004 atomic_mutex
01000000 g     F .entry	0000001c __reset
01001700 g     F .text	00000090 xQueueGiveMutexRecursive
0102e64c g     O .bss	00000004 pxCurrentTCB
010280b0 g     F .text	00000074 altera_avalon_mutex_is_mine
0100709c g     F .text	00000034 metal_sys_finish
01000020 g       *ABS*	00000000 __flash_exceptions_start
0100c860 g     F .text	0000009c remoteproc_init
01022da8 g     F .text	0000005c _fstat_r
01008080 g     F .text	00000168 metal_io_init
0102e6b4 g     O .bss	00000004 errno
01007770 g     F .text	00000038 sys_irq_restore_enable
0101fde8 g     F .text	00000008 __seofread
010200a0 g     F .text	0000123c ___svfiprintf_internal_r
01007888 g     F .text	00000030 metal_machine_io_mem_map
01002ce0 g     F .text	000000f0 xStreamBufferSendFromISR
0100691c g     F .text	000000a4 metal_generic_dev_open
0102e6c0 g     O .bss	00000004 alt_argv
01034948 g       *ABS*	00000000 _gp
01027164 g     F .text	00000030 usleep
0102adfc g     O .rwdata	00000054 ipi_device
01008e10 g     F .text	000000c8 metal_shmem_open_generic
01006aa8 g     F .text	00000088 metal_generic_dev_dma_unmap
01003ecc g     F .text	000001a4 vTaskPrioritySet
0102683c g     F .text	00000020 getpid
01004bd8 g     F .text	0000003c vTaskInternalSetTimeOutState
010098d0 g     F .text	000000b4 rpmsg_rpc_release
010067f8 g     F .text	00000090 metal_device_close
01000474 g     F .text	000001a8 xEventGroupWaitBits
0100cfdc g     F .text	00000d80 remoteproc_load
010071bc g     F .text	00000028 metal_irq_save_disable
0100bba8 g     F .text	0000004c elf_get_load_state
0102b758 g     O .rwdata	00000180 alt_fd_list
0101284c g     F .text	00000180 virtio_create_virtqueues
01000d38 g     F .text	00000038 xPortStartScheduler
01004414 g     F .text	00000048 vTaskEndScheduler
0102868c g     F .text	00000090 alt_find_dev
010158f4 g     F .text	00000148 memcpy
0100491c g     F .text	00000050 vTaskPlaceOnEventList
01004ac4 g     F .text	000000c8 vTaskRemoveFromUnorderedEventList
01007864  w    F .text	00000024 metal_generic_default_poll
0101c974 g     F .text	0000000c _cleanup_r
0102633c g     F .text	000000dc .hidden __floatsidf
01028814 g     F .text	0000007c alt_io_redirect
010251b4 g     F .text	000000f4 .hidden __ltdf2
01002248 g     F .text	0000007c xQueuePeekFromISR
010291dc g       *ABS*	00000000 __DTOR_END__
01006fe0 g     F .text	00000084 metal_generic_dev_sys_open
01015c90 g     F .text	00000014 puts
01001284 g     F .text	000000cc vPortFree
01015f3c g     F .text	0000065c _strerror_r
0101f9c8 g     F .text	00000074 __fpclassifyd
0101f248 g     F .text	000000a4 __ratio
0100fa78 g     F .text	000000cc rproc_virtio_notified
0102284c g     F .text	0000001c __vfiprintf_internal
01009b1c g     F .text	00000038 rpmsg_set_default_rpc
01001da4 g     F .text	00000210 xQueueSemaphoreTake
01027a68 g     F .text	0000021c altera_avalon_jtag_uart_read
01015b64 g     F .text	00000030 _printf_r
01023e00 g     F .text	00000064 .hidden __udivsi3
01026a48 g     F .text	000000a4 isatty
0101fb80 g     F .text	000000bc _raise_r
01014a2c g     F .text	00000038 get_resource_table
010157a0 g     F .text	00000068 __assert_func
0102aaec g     O .rodata	000000c8 __mprec_tens
01004ed4 g     F .text	00000060 uxTaskGetStackHighWaterMark
01007ab4 g     F .text	00000100 metal_run
0101d800 g     F .text	0000000c __locale_charset
01000a30 g     F .text	0000008c vListInsertEnd
01028e58 g     F .text	00000090 alt_icache_flush
0102e6b0 g     O .bss	00000004 __malloc_top_pad
0101fd90 g     F .text	00000004 _getpid_r
0100cdac g     F .text	00000068 remoteproc_get_io_with_va
0100029c g     F .text	00000054 xEventGroupCreate
0102c978 g     O .rwdata	00000004 __mb_cur_max
0101d830 g     F .text	0000000c _localeconv_r
0101e874 g     F .text	0000003c __i2b
0101d140 g     F .text	000004bc __sfvwrite_r
0101fc3c g     F .text	000000a8 __sigtramp_r
01012808 g     F .text	00000044 virtio_describe
0101fa3c g     F .text	00000054 _sbrk_r
01008bd8 g     F .text	00000034 metal_set_log_handler
010008b4 g     F .text	0000003c vEventGroupSetBitsCallback
010042a4 g     F .text	000000e0 xTaskResumeFromISR
01007f38 g     F .text	000000ac metal_init
0100fb44 g     F .text	00000060 rproc_virtio_wait_remote_ready
01022eb8 g     F .text	00000060 _read_r
01000a04 g     F .text	0000002c vListInitialiseItem
01026630 g     F .text	00000078 alt_dcache_flush
0102c998 g     O .rwdata	00000004 alt_max_fd
01000e18 g     F .text	00000048 vPortSysTickHandler
01022a9c g     F .text	000000f0 _fclose_r
0100ccb0 g     F .text	00000064 remoteproc_get_io_with_pa
01001bfc g     F .text	000001a8 xQueueReceive
0101c93c g     F .text	00000030 fflush
0102e6ac g     O .bss	00000004 __malloc_max_sbrked_mem
010081e8 g     F .text	000001b4 metal_io_block_read
01003e80 g     F .text	0000004c uxTaskPriorityGetFromISR
01000e60 g     F .text	00000170 alt_irq_register
01013244 g     F .text	00000114 virtqueue_get_available_buffer
01023ebc g     F .text	000008ac .hidden __adddf3
0100dd5c g     F .text	00000a50 remoteproc_load_noblock
0101eff0 g     F .text	0000010c __b2d
010237d0 g     F .text	00000538 .hidden __umoddi3
01026d80 g     F .text	000000d4 lseek
01028124 g     F .text	00000050 altera_avalon_mutex_first_lock
0100e898 g     F .text	00000390 remoteproc_create_virtio
0102c970 g     O .rwdata	00000004 _global_impure_ptr
010006c0 g     F .text	00000180 xEventGroupSetBits
0101f464 g     F .text	00000564 _realloc_r
0182ece4 g       *ABS*	00000000 __bss_end
01000fd0 g     F .text	000000e0 alt_iic_isr_register
01028b80 g     F .text	00000108 alt_tick
01023258 g     F .text	00000578 .hidden __udivdi3
01022d04 g     F .text	00000024 _fputwc_r
0102aac4 g     O .rodata	00000028 __mprec_bigtens
0101e658 g     F .text	00000104 __s2b
0101ae24 g     F .text	00000018 abort
01009b54 g     F .text	00000130 _open
01026418 g     F .text	000000a8 .hidden __floatunsidf
01006fb8 g     F .text	00000028 metal_condition_wait
0101ed30 g     F .text	00000060 __mcmp
010010b0 g     F .text	000001d4 pvPortMalloc
01008b30 g     F .text	0000003c metal_irq_enable
0101ccdc g     F .text	00000018 __fp_lock_all
010269c0 g     F .text	0000004c alt_ic_irq_enabled
010077a8 g     F .text	00000040 sys_irq_save_disable
01002390 g     F .text	0000003c vQueueDelete
010064cc g     F .text	000000f8 metal_bus_register
01000d70 g     F .text	00000020 vPortEndScheduler
0100099c g     F .text	00000068 vListInitialise
01003244 g     F .text	00000058 xStreamBufferIsEmpty
01028ae4 g     F .text	0000009c alt_alarm_stop
0102e6b8 g     O .bss	00000004 alt_irq_active
01009984 g     F .text	00000198 rpmsg_rpc_send
0100017c g     F .exceptions	000000d4 alt_irq_handler
0102b730 g     O .rwdata	00000028 alt_dev_null
01010c78 g     F .text	00000140 rpmsg_get_endpoint
010045e0 g     F .text	00000028 xTaskGetTickCount
01001884 g     F .text	000001b4 xQueueGenericSend
01027f60 g     F .text	00000054 altera_avalon_mutex_open
01002b58 g     F .text	00000188 xStreamBufferSend
0100339c g     F .text	00000084 xStreamBufferReceiveCompletedFromISR
010266a8 g     F .text	00000048 alt_dcache_flush_all
0101e75c g     F .text	00000068 __hi0bits
010262bc g     F .text	00000080 .hidden __fixdfsi
01002ffc g     F .text	000000a8 xStreamBufferNextMessageLengthBytes
01005134 g     F .text	000000fc xTaskPriorityDisinherit
01009080 g     F .text	00000030 metal_softirq_init
0102c9b8 g       *ABS*	00000000 __ram_rwdata_end
010115f0  w    F .text	0000007c rpmsg_virtio_shm_pool_get_buffer
0102c990 g     O .rwdata	00000008 alt_dev_list
010271d0 g     F .text	000000f8 write
010049d0 g     F .text	000000f4 xTaskRemoveFromEventList
0102c9a8 g     O .rwdata	00000008 alt_mutex_list
0102ad38 g       *ABS*	00000000 __ram_rodata_end
0102678c g     F .text	000000b0 fstat
0100061c g     F .text	00000068 xEventGroupClearBits
01026b28 g     F .text	00000130 kill
010251b4 g     F .text	000000f4 .hidden __ledf2
010071e4 g     F .text	00000034 metal_irq_restore_enable
01001fb4 g     F .text	000001b0 xQueuePeek
0101eaa8 g     F .text	00000140 __pow5mult
0102e6a4 g     O .bss	00000004 __nlocale_changed
010213f0 g     F .text	0000145c ___vfiprintf_internal_r
01023e64 g     F .text	00000058 .hidden __umodsi3
0100ce14 g     F .text	000001c8 remoteproc_mmap
01008ff0 g     F .text	00000090 metal_softirq_set
0100c8fc g     F .text	00000084 remoteproc_remove
01800000 g     O .resource_table	00000100 resources
01008b6c g     F .text	0000003c metal_irq_disable
0182ece4 g       *ABS*	00000000 end
010030a4 g     F .text	000000e4 xStreamBufferReceiveFromISR
01003ae4 g     F .text	000000e8 vTaskDelete
010275a4 g     F .text	000000c0 altera_avalon_jtag_uart_init
01005468 g     F .text	00000038 pvTaskIncrementMutexHeldCount
010291cc g       *ABS*	00000000 __CTOR_LIST__
02000000 g       *ABS*	00000000 __alt_stack_pointer
010281ec g     F .text	0000007c alt_avalon_timer_sc_init
010264c0 g     F .text	00000064 .hidden __clzsi2
01015ca4 g     F .text	000000d8 _snprintf_r
01027c84 g     F .text	00000224 altera_avalon_jtag_uart_write
01007ea8 g     F .text	00000050 metal_get_timestamp
0101cccc g     F .text	00000004 __sfp_lock_acquire
0101e228 g     F .text	000000e4 memchr
01018a00 g     F .text	000021f8 ___vfprintf_internal_r
01004c14 g     F .text	000000e0 xTaskCheckForTimeOut
0101ce30 g     F .text	00000310 _free_r
01004ff4 g     F .text	00000140 xTaskPriorityInherit
0101d80c g     F .text	00000010 __locale_mb_cur_max
0102904c g     F .text	00000180 __call_exitprocs
01011018 g     F .text	000000b0 rpmsg_destroy_ept
01002924 g     F .text	00000064 vStreamBufferDelete
0102e6a0 g     O .bss	00000004 __mlocale_changed
010054a0 g     F .text	000000b0 ulTaskNotifyTake
0102c97c g     O .rwdata	00000004 __malloc_sbrk_base
01000250 g     F .text	0000004c _start
0102e6c8 g     O .bss	00000004 _alt_tick_rate
0100445c g     F .text	0000002c vTaskSuspendAll
01003d18 g     F .text	00000110 eTaskGetState
0100329c g     F .text	0000007c xStreamBufferIsFull
01004608 g     F .text	0000002c xTaskGetTickCountFromISR
010189e0 g     F .text	00000008 _user_strerror
0100670c g     F .text	000000ec metal_device_open
0101ebe8 g     F .text	00000148 __lshift
01013160 g     F .text	00000040 virtqueue_get_buffer_length
0102e6cc g     O .bss	00000004 _alt_nticks
0101fcf8 g     F .text	00000018 signal
01026f54 g     F .text	000000fc read
010273d8 g     F .text	00000068 alt_sys_init
01007bb4 g     F .text	00000214 metal_run_noblock
0101fed0 g     F .text	000001d0 __ssprint_r
01000b94 g     F .text	00000098 uxListRemove
01028f34 g     F .text	00000118 __register_exitproc
0101664c g     F .text	000000d0 strncmp
0102805c g     F .text	00000054 altera_avalon_mutex_unlock
01013464 g     F .text	0000013c virtqueue_disable_cb
01002878 g     F .text	000000ac xStreamBufferGenericCreate
0101e8b0 g     F .text	000001f8 __multiply
01027910 g     F .text	00000068 altera_avalon_jtag_uart_close
0102ad38 g       *ABS*	00000000 __ram_rwdata_start
010291dc g       *ABS*	00000000 __ram_rodata_start
0101671c g     F .text	000000ec strncpy
0182eb9c g     O .bss	00000028 __malloc_current_mallinfo
01005af4 g     F .text	00000078 xTaskNotifyStateClear
010041d8 g     F .text	000000cc vTaskResume
0101f0fc g     F .text	0000014c __d2b
01005f6c g     F .text	0000002c cleanup_system
01004844 g     F .text	000000d8 vTaskSwitchContext
0100cd14 g     F .text	00000098 remoteproc_get_io_with_da
01009788 g     F .text	00000148 rpmsg_rpc_init
01027440 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
01028db4 g     F .text	000000a4 alt_get_fd
01028394 g     F .text	00000158 alt_busy_sleep
01022984 g     F .text	00000054 _close_r
010131a0 g     F .text	000000a4 virtqueue_free
0101166c g     F .text	0000005c rpmsg_virtio_init_shm_pool
01005550 g     F .text	000000f4 xTaskNotifyWait
01012128 g     F .text	000003e0 rpmsg_init_vdev
01015878 g     F .text	0000007c memcmp
01027500 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0182ece4 g       *ABS*	00000000 __alt_stack_base
01027550 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0100ad3c g     F .text	0000006c elf_identify
01006038 g     F .text	0000003c metal_add_test_case
0101acd0 g     F .text	00000154 __swsetup_r
0102ae68 g     O .rwdata	00000024 zynqmp_r5_a53_proc_ops
01004070 g     F .text	000000fc vTaskSuspend
01024768 g     F .text	000008e8 .hidden __divdf3
01010e90 g     F .text	00000188 rpmsg_create_ept
0101cb8c g     F .text	00000118 __sfp
0101f360 g     F .text	00000078 __copybits
01004634 g     F .text	00000020 uxTaskGetNumberOfTasks
0102b328 g     O .rwdata	00000408 __malloc_av_
0101ccd8 g     F .text	00000004 __sinit_lock_release
0100839c g     F .text	000001b0 metal_io_block_write
010252a8 g     F .text	00000718 .hidden __muldf3
0101fd94 g     F .text	00000054 __sread
01028cac g     F .text	00000108 alt_find_file
01028528 g     F .text	000000a4 alt_dev_llist_insert
01026ed0 g     F .text	00000024 __malloc_lock
010270b4 g     F .text	000000b0 sbrk
01016808 g     F .text	000021d8 ___svfprintf_internal_r
01001790 g     F .text	0000009c xQueueTakeMutexRecursive
01006888 g     F .text	00000094 metal_register_generic_device
010090b0 g     F .text	000000bc metal_softirq_allocate
0101c8e0 g     F .text	0000005c _fflush_r
01000840 g     F .text	00000074 vEventGroupDelete
01006b30 g     F .text	000000c0 metal_dma_map
010229d8 g     F .text	000000c4 _calloc_r
01013d44 g     F .text	0000004c virtqueue_notification
01005644 g     F .text	000001ac xTaskGenericNotify
010120b8 g     F .text	00000070 rpmsg_virtio_get_buffer_size
0102e638 g       *ABS*	00000000 __bss_start
01015a3c g     F .text	00000128 memset
0101494c g     F .text	000000e0 main
0102e6c4 g     O .bss	00000004 alt_envp
0102e6a8 g     O .bss	00000004 __malloc_max_total_mem
010077e8 g     F .text	00000054 metal_machine_cache_flush
010274a0 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
01023058 g     F .text	00000018 __swbuf
010135ec g     F .text	00000124 virtqueue_dump
01008ba8 g     F .text	00000030 metal_default_log_handler
01000abc g     F .text	000000d8 vListInsert
0101fec8 g     F .text	00000008 __sclose
02000000 g       *ABS*	00000000 __alt_heap_limit
01022b8c g     F .text	00000014 fclose
01027fd8 g     F .text	00000044 altera_avalon_mutex_lock
0101b03c g     F .text	00001688 _dtoa_r
0101da1c g     F .text	0000080c _malloc_r
010231cc g     F .text	00000030 __ascii_wctomb
0100c7cc g     F .text	00000094 remoteproc_set_rsc_table
0102c99c g     O .rwdata	00000004 alt_errno
01003bcc g     F .text	000000f0 vTaskDelayUntil
0101581c g     F .text	00000020 _fiprintf_r
0101fd10 g     F .text	00000010 _init_signal
01006bf0 g     F .text	000000a0 metal_dma_unmap
0101d5fc g     F .text	000000c4 _fwalk
0100e7ac g     F .text	000000a0 remoteproc_allocate_id
01012e68 g     F .text	000000c4 virtqueue_create
010070d0 g     F .text	000000ec metal_sys_io_mem_map
01002164 g     F .text	000000e4 xQueueReceiveFromISR
01004fcc g     F .text	00000028 xTaskGetCurrentTaskHandle
01023d08 g     F .text	00000084 .hidden __divsi3
01001518 g     F .text	000000a8 xQueueGenericCreate
01013710 g     F .text	000000b4 virtqueue_get_desc_size
0101cd0c g     F .text	00000124 _malloc_trim_r
010291dc g       *ABS*	00000000 __CTOR_END__
01015e60 g     F .text	000000dc strcmp
010146f4 g     F .text	00000048 platform_cleanup
0100182c g     F .text	00000058 xQueueCreateCountingSemaphore
010291dc g       *ABS*	00000000 __flash_rodata_start
010291dc g       *ABS*	00000000 __DTOR_LIST__
01002a24 g     F .text	0000006c xStreamBufferSetTriggerLevel
01007dc8 g     F .text	000000e0 metal_finish_threads
0100cac4 g     F .text	000000ac remoteproc_stop
010057f0 g     F .text	000001e4 xTaskGenericNotifyFromISR
01025050 g     F .text	00000088 .hidden __nedf2
010273a0 g     F .text	00000038 alt_irq_init
01027050 g     F .text	00000064 alt_release_fd
01004488 g     F .text	00000158 xTaskResumeAll
01002304 g     F .text	00000054 uxQueueSpacesAvailable
0102abf4 g     O .rodata	00000100 .hidden __clz_tab
01004384 g     F .text	00000090 vTaskStartScheduler
0102e69c g     O .bss	00000004 _PathLocale
010088a4 g     F .text	000000cc metal_irq_register_controller
01010304 g     F .text	0000009c handle_trace_rsc
01028ee8 g     F .text	00000014 atexit
01022924 g     F .text	00000060 _write_r
010103c8 g     F .text	0000017c find_rsc
0101d83c g     F .text	00000018 setlocale
01002828 g     F .text	00000050 xQueueIsQueueFullFromISR
0102c974 g     O .rwdata	00000004 _impure_ptr
0102e6bc g     O .bss	00000004 alt_argc
01010b28 g     F .text	000000b0 rpmsg_send_offchannel_raw
0101c6c4 g     F .text	0000021c __sflush_r
010135a0 g     F .text	0000004c virtqueue_kick
0102862c g     F .text	00000060 _do_dtors
0101001c g     F .text	000000a0 handle_vendor_rsc
0101d828 g     F .text	00000008 __locale_cjk_lang
0100cb70 g     F .text	000000dc remoteproc_shutdown
0101ef8c g     F .text	00000064 __ulp
0101ccf4 g     F .text	00000018 __fp_unlock_all
01004cf4 g     F .text	00000028 vTaskMissedYield
0102c988 g     O .rwdata	00000008 alt_fs_list
0100fea8 g     F .text	00000174 handle_carve_out_rsc
010022c4 g     F .text	00000040 uxQueueMessagesWaiting
0102ad38  w    O .rwdata	0000002c metal_generic_bus
01004694 g     F .text	000001b0 xTaskIncrementTick
01000020 g       *ABS*	00000000 __ram_exceptions_start
0100f9d0 g     F .text	000000a8 rproc_virtio_init_vring
0100783c g     F .text	00000028 metal_machine_cache_invalidate
0101d854 g     F .text	0000000c localeconv
01007fe4 g     F .text	00000040 metal_finish
010069c0 g     F .text	000000e8 metal_generic_dev_dma_map
01005f00 g     F .text	0000006c init_system
0102685c g     F .text	00000050 alt_ic_isr_register
0101266c g     F .text	00000070 virtio_dev_name
01001404 g     F .text	00000114 xQueueGenericReset
01009dc4 g     F .text	0000015c _write
0102c9b8 g       *ABS*	00000000 _edata
0182ece4 g       *ABS*	00000000 _end
01022ba0 g     F .text	00000164 __fputwc
01000250 g       *ABS*	00000000 __ram_exceptions_end
0100854c g     F .text	000001c4 metal_io_block_set
01005e34 g     F .text	00000034 atomic_mutex_deinit
01027978 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
01007064 g     F .text	00000038 metal_sys_init
0100371c g     F .text	000000e8 xTaskCreate
01001370 g     F .text	00000020 vPortInitialiseBlocks
01014884 g     F .text	000000c8 app
01026934 g     F .text	0000008c alt_ic_irq_disable
0100f6b8 g     F .text	0000026c rproc_virtio_create_vdev
0101fdf0 g     F .text	0000007c __swrite
0102c980 g     O .rwdata	00000004 __malloc_trim_threshold
0101d81c g     F .text	0000000c __locale_msgcharset
0100baa4 g     F .text	00000104 elf_locate_rsc_table
01028efc g     F .text	00000038 exit
0101583c g     F .text	0000003c fiprintf
010189e8 g     F .text	00000018 _vfiprintf_r
0101d6c0 g     F .text	000000c4 _fwalk_reent
0101ed90 g     F .text	000001fc __mdiff
01023d8c g     F .text	00000074 .hidden __modsi3
01003cbc g     F .text	0000005c vTaskDelay
02000000 g       *ABS*	00000000 __alt_data_end
0101ccd0 g     F .text	00000004 __sfp_lock_release
01000000 g       *ABS*	00000000 __alt_mem_sdram
0100cc4c g     F .text	00000064 remoteproc_get_io_with_name
0101461c g     F .text	000000b4 platform_poll
0100916c g     F .text	00000138 metal_softirq_dispatch
01005230 g     F .text	00000140 vTaskPriorityDisinheritAfterTimeout
01009c84 g     F .text	00000140 _read
01008a64 g     F .text	000000cc metal_irq_register
01012508 g     F .text	00000088 rpmsg_deinit_vdev
0102671c g     F .text	00000034 _exit
01028268 g     F .text	0000012c alt_alarm_start
010076e0 g     F .text	00000090 metal_nios2_irq_init
0101d860 g     F .text	000001bc __smakebuf_r
010053c4 g     F .text	00000060 vTaskExitCritical
010165b4 g     F .text	00000098 strlen
01000c58 g     F .text	000000e0 pxPortInitialiseStack
0101fa90 g     F .text	0000006c _init_signal_r
01028990 g     F .text	00000154 open
010250d8 g     F .text	000000dc .hidden __gedf2
010144b0 g     F .text	0000016c platform_create_rpmsg_vdev
01015808 g     F .text	00000014 __assert
010065c4 g     F .text	000000a4 metal_bus_unregister
0102c984 g     O .rwdata	00000004 __wctomb
01005e00 g     F .text	00000034 atomic_mutex_init
01008c0c g     F .text	00000028 metal_get_log_handler
010213d8 g     F .text	00000018 __sprint_r
0102871c g     F .text	00000034 alt_icache_flush_all
01004b8c g     F .text	0000004c vTaskSetTimeOutState
0100ec28 g     F .text	00000084 remoteproc_remove_virtio
0102c9a0 g     O .rwdata	00000004 alt_priority_mask
01012f2c g     F .text	00000104 virtqueue_add_buffer
01005e9c g     F .text	00000034 atomic_mutex_release
010268ac g     F .text	00000088 alt_ic_irq_enable
0101abf8 g     F .text	0000001c __vfprintf_internal
01010e3c g     F .text	00000054 rpmsg_register_endpoint
01027fb4 g     F .text	00000024 altera_avalon_mutex_close
010231fc g     F .text	0000005c _wctomb_r
01002358 g     F .text	00000038 uxQueueMessagesWaitingFromISR
01002788 g     F .text	00000048 xQueueIsQueueEmptyFromISR
01002b18 g     F .text	00000040 xStreamBufferBytesAvailable
0100c980 g     F .text	000000b0 remoteproc_config
0100b914 g     F .text	00000110 elf_release
010259c0 g     F .text	000008fc .hidden __subdf3
0102ade4 g     O .rwdata	00000018 elf_ops
010146d0 g     F .text	00000024 platform_release_rpmsg_vdev
010100bc g     F .text	00000248 handle_vdev_rsc
0101e7c4 g     F .text	000000b0 __lo0bits
0100b4d4 g     F .text	00000440 elf_load
0102c9b0 g     O .rwdata	00000008 alt_alarm_list
01013358 g     F .text	000000d8 virtqueue_add_consumed_buffer
010285cc g     F .text	00000060 _do_ctors
0101fd20 g     F .text	00000014 __sigtramp
0100ca30 g     F .text	00000094 remoteproc_start
0100ada8 g     F .text	0000072c elf_load_header
01005424 g     F .text	00000044 uxTaskResetEventItemValue
0102310c g     F .text	000000c0 wcrtomb
010016a4 g     F .text	0000005c xQueueCreateMutex
01026560 g     F .text	000000d0 close
010059d4 g     F .text	00000120 vTaskNotifyGiveFromISR
0100f924 g     F .text	000000ac rproc_virtio_remove_vdev
01026cc0 g     F .text	00000084 alt_load
0100fbf8 g     F .text	000002b0 handle_rsc_table
010008f0 g     F .text	0000003c vEventGroupClearBitsCallback
01003318 g     F .text	00000084 xStreamBufferSendCompletedFromISR
01001b20 g     F .text	000000dc xQueueGiveFromISR
01022d28 g     F .text	00000080 fputwc
0101fce4 g     F .text	00000014 raise
01009f20 g     F .text	000000bc _close
0100ecac g     F .text	00000090 remoteproc_get_notification
0101ccd4 g     F .text	00000004 __sinit_lock_acquire
01006074 g     F .text	00000220 metal_tests_run
0101e538 g     F .text	00000120 __multadd
0101e510 g     F .text	00000028 _Bfree



Disassembly of section .entry:

01000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 1000000:	00820014 	movui	r2,2048
#endif

0:
    initi r2
 1000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 1000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 100000c:	00bffd16 	blt	zero,r2,1000004 <__alt_data_end+0xff000004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 1000010:	00404034 	movhi	at,256
    ori r1, r1, %lo(_start)
 1000014:	08409414 	ori	at,at,592
    jmp r1
 1000018:	0800683a 	jmp	at
 100001c:	00000000 	call	0 <__reset-0x1000000>

Disassembly of section .exceptions:

01000020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
 1000020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
 1000024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 1000028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
 100002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 1000030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 1000034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 1000038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
 100003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
 1000040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
 1000044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
 1000048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
 100004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 1000050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 1000054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 1000058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 100005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 1000060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 1000064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 1000068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 100006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
 1000070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 1000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 1000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 100007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 1000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 1000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 1000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 100008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 1000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 1000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 1000098:	df001c15 	stw	fp,112(sp)

0100009c <save_sp_to_pxCurrentTCB>:
 100009c:	060040f4 	movhi	et,259

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 10000a0:	c6399304 	addi	et,et,-6580
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 10000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 10000a8:	c6c00015 	stw	sp,0(et)

010000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
 10000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
 10000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
 10000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
 10000b8:	10002526 	beq	r2,zero,1000150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
 10000bc:	20002426 	beq	r4,zero,1000150 <soft_exceptions>

010000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
 10000c0:	100017c0 	call	100017c <alt_irq_handler>

010000c4 <restore_sp_from_pxCurrentTCB>:
 10000c4:	060040f4 	movhi	et,259

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 10000c8:	c6399304 	addi	et,et,-6580
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 10000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 10000d0:	c6c00017 	ldw	sp,0(et)

010000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
 10000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 10000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 10000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 10000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 10000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
 10000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
 10000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
 10000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
 10000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
 10000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 10000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 1000100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 1000104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 1000108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 100010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 1000110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 1000114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 1000118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 100011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 1000120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 1000124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 1000128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 100012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 1000130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 1000134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 1000138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 100013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 1000140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 1000144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 1000148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
 100014c:	ef80083a 	eret

01000150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
 1000150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
 1000154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
 1000158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
 100015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
 1000160:	c0000226 	beq	et,zero,100016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
 1000164:	003da03a 	break	0
  	br		restore_context			# its something else
 1000168:	003fda06 	br	10000d4 <__alt_data_end+0xff0000d4>

0100016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
 100016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
 1000170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
 1000174:	10048440 	call	1004844 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
 1000178:	003fd206 	br	10000c4 <__alt_data_end+0xff0000c4>

0100017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 100017c:	defff904 	addi	sp,sp,-28
 1000180:	dfc00615 	stw	ra,24(sp)
 1000184:	df000515 	stw	fp,20(sp)
 1000188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 100018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 1000190:	0005313a 	rdctl	r2,ipending
 1000194:	e0bffe15 	stw	r2,-8(fp)

  return active;
 1000198:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 100019c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 10001a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 10001a4:	00800044 	movi	r2,1
 10001a8:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 10001ac:	e0fffb17 	ldw	r3,-20(fp)
 10001b0:	e0bffc17 	ldw	r2,-16(fp)
 10001b4:	1884703a 	and	r2,r3,r2
 10001b8:	10001426 	beq	r2,zero,100020c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 10001bc:	008060f4 	movhi	r2,387
 10001c0:	10baf904 	addi	r2,r2,-5148
 10001c4:	e0fffd17 	ldw	r3,-12(fp)
 10001c8:	180690fa 	slli	r3,r3,3
 10001cc:	10c5883a 	add	r2,r2,r3
 10001d0:	10c00017 	ldw	r3,0(r2)
 10001d4:	008060f4 	movhi	r2,387
 10001d8:	10baf904 	addi	r2,r2,-5148
 10001dc:	e13ffd17 	ldw	r4,-12(fp)
 10001e0:	200890fa 	slli	r4,r4,3
 10001e4:	1105883a 	add	r2,r2,r4
 10001e8:	10800104 	addi	r2,r2,4
 10001ec:	10800017 	ldw	r2,0(r2)
 10001f0:	1009883a 	mov	r4,r2
 10001f4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 10001f8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 10001fc:	0005313a 	rdctl	r2,ipending
 1000200:	e0bfff15 	stw	r2,-4(fp)

  return active;
 1000204:	e0bfff17 	ldw	r2,-4(fp)
 1000208:	00000706 	br	1000228 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 100020c:	e0bffc17 	ldw	r2,-16(fp)
 1000210:	1085883a 	add	r2,r2,r2
 1000214:	e0bffc15 	stw	r2,-16(fp)
      i++;
 1000218:	e0bffd17 	ldw	r2,-12(fp)
 100021c:	10800044 	addi	r2,r2,1
 1000220:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 1000224:	003fe106 	br	10001ac <__alt_data_end+0xff0001ac>

    active = alt_irq_pending ();
 1000228:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 100022c:	e0bffb17 	ldw	r2,-20(fp)
 1000230:	103fdb1e 	bne	r2,zero,10001a0 <__alt_data_end+0xff0001a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 1000234:	0001883a 	nop
}
 1000238:	0001883a 	nop
 100023c:	e037883a 	mov	sp,fp
 1000240:	dfc00117 	ldw	ra,4(sp)
 1000244:	df000017 	ldw	fp,0(sp)
 1000248:	dec00204 	addi	sp,sp,8
 100024c:	f800283a 	ret

Disassembly of section .text:

01000250 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 1000250:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 1000254:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 1000258:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 100025c:	00bffd16 	blt	zero,r2,1000254 <__alt_data_end+0xff000254>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 1000260:	06c08034 	movhi	sp,512
    ori sp, sp, %lo(__alt_stack_pointer)
 1000264:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 1000268:	068040f4 	movhi	gp,259
    ori gp, gp, %lo(_gp)
 100026c:	d6925214 	ori	gp,gp,18760
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 1000270:	008040b4 	movhi	r2,258
    ori r2, r2, %lo(__bss_start)
 1000274:	10b98e14 	ori	r2,r2,58936

    movhi r3, %hi(__bss_end)
 1000278:	00c060b4 	movhi	r3,386
    ori r3, r3, %lo(__bss_end)
 100027c:	18fb3914 	ori	r3,r3,60644

    beq r2, r3, 1f
 1000280:	10c00326 	beq	r2,r3,1000290 <_start+0x40>

0:
    stw zero, (r2)
 1000284:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 1000288:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 100028c:	10fffd36 	bltu	r2,r3,1000284 <__alt_data_end+0xff000284>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 1000290:	1026cc00 	call	1026cc0 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 1000294:	1026e540 	call	1026e54 <alt_main>

01000298 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 1000298:	003fff06 	br	1000298 <__alt_data_end+0xff000298>

0100029c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
 100029c:	defffd04 	addi	sp,sp,-12
 10002a0:	dfc00215 	stw	ra,8(sp)
 10002a4:	df000115 	stw	fp,4(sp)
 10002a8:	df000104 	addi	fp,sp,4
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 10002ac:	01000604 	movi	r4,24
 10002b0:	10010b00 	call	10010b0 <pvPortMalloc>
 10002b4:	e0bfff15 	stw	r2,-4(fp)

		if( pxEventBits != NULL )
 10002b8:	e0bfff17 	ldw	r2,-4(fp)
 10002bc:	10000626 	beq	r2,zero,10002d8 <xEventGroupCreate+0x3c>
		{
			pxEventBits->uxEventBits = 0;
 10002c0:	e0bfff17 	ldw	r2,-4(fp)
 10002c4:	10000015 	stw	zero,0(r2)
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 10002c8:	e0bfff17 	ldw	r2,-4(fp)
 10002cc:	10800104 	addi	r2,r2,4
 10002d0:	1009883a 	mov	r4,r2
 10002d4:	100099c0 	call	100099c <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
 10002d8:	e0bfff17 	ldw	r2,-4(fp)
	}
 10002dc:	e037883a 	mov	sp,fp
 10002e0:	dfc00117 	ldw	ra,4(sp)
 10002e4:	df000017 	ldw	fp,0(sp)
 10002e8:	dec00204 	addi	sp,sp,8
 10002ec:	f800283a 	ret

010002f0 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
 10002f0:	defff504 	addi	sp,sp,-44
 10002f4:	dfc00a15 	stw	ra,40(sp)
 10002f8:	df000915 	stw	fp,36(sp)
 10002fc:	df000904 	addi	fp,sp,36
 1000300:	e13ffc15 	stw	r4,-16(fp)
 1000304:	e17ffd15 	stw	r5,-12(fp)
 1000308:	e1bffe15 	stw	r6,-8(fp)
 100030c:	e1ffff15 	stw	r7,-4(fp)
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
 1000310:	e0bffc17 	ldw	r2,-16(fp)
 1000314:	e0bff815 	stw	r2,-32(fp)
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
 1000318:	e03ff915 	stw	zero,-28(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
 100031c:	100445c0 	call	100445c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
 1000320:	e0bff817 	ldw	r2,-32(fp)
 1000324:	10800017 	ldw	r2,0(r2)
 1000328:	e0bffa15 	stw	r2,-24(fp)

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 100032c:	e17ffd17 	ldw	r5,-12(fp)
 1000330:	e13ffc17 	ldw	r4,-16(fp)
 1000334:	10006c00 	call	10006c0 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 1000338:	e0fffa17 	ldw	r3,-24(fp)
 100033c:	e0bffd17 	ldw	r2,-12(fp)
 1000340:	1886b03a 	or	r3,r3,r2
 1000344:	e0bffe17 	ldw	r2,-8(fp)
 1000348:	1886703a 	and	r3,r3,r2
 100034c:	e0bffe17 	ldw	r2,-8(fp)
 1000350:	18800d1e 	bne	r3,r2,1000388 <xEventGroupSync+0x98>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 1000354:	e0fffa17 	ldw	r3,-24(fp)
 1000358:	e0bffd17 	ldw	r2,-12(fp)
 100035c:	1884b03a 	or	r2,r3,r2
 1000360:	e0bff715 	stw	r2,-36(fp)

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 1000364:	e0bff817 	ldw	r2,-32(fp)
 1000368:	10c00017 	ldw	r3,0(r2)
 100036c:	e0bffe17 	ldw	r2,-8(fp)
 1000370:	0084303a 	nor	r2,zero,r2
 1000374:	1886703a 	and	r3,r3,r2
 1000378:	e0bff817 	ldw	r2,-32(fp)
 100037c:	10c00015 	stw	r3,0(r2)

			xTicksToWait = 0;
 1000380:	e03fff15 	stw	zero,-4(fp)
 1000384:	00001106 	br	10003cc <xEventGroupSync+0xdc>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
 1000388:	e0bfff17 	ldw	r2,-4(fp)
 100038c:	10000a26 	beq	r2,zero,10003b8 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 1000390:	e0bff817 	ldw	r2,-32(fp)
 1000394:	10c00104 	addi	r3,r2,4
 1000398:	e0bffe17 	ldw	r2,-8(fp)
 100039c:	10814034 	orhi	r2,r2,1280
 10003a0:	e1bfff17 	ldw	r6,-4(fp)
 10003a4:	100b883a 	mov	r5,r2
 10003a8:	1809883a 	mov	r4,r3
 10003ac:	100496c0 	call	100496c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
 10003b0:	e03ff715 	stw	zero,-36(fp)
 10003b4:	00000506 	br	10003cc <xEventGroupSync+0xdc>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
 10003b8:	e0bff817 	ldw	r2,-32(fp)
 10003bc:	10800017 	ldw	r2,0(r2)
 10003c0:	e0bff715 	stw	r2,-36(fp)
				xTimeoutOccurred = pdTRUE;
 10003c4:	00800044 	movi	r2,1
 10003c8:	e0bff915 	stw	r2,-28(fp)
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
 10003cc:	10044880 	call	1004488 <xTaskResumeAll>
 10003d0:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
 10003d4:	e0bfff17 	ldw	r2,-4(fp)
 10003d8:	10002026 	beq	r2,zero,100045c <xEventGroupSync+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
 10003dc:	e0bffb17 	ldw	r2,-20(fp)
 10003e0:	1000011e 	bne	r2,zero,10003e8 <xEventGroupSync+0xf8>
		{
			portYIELD_WITHIN_API();
 10003e4:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
 10003e8:	10054240 	call	1005424 <uxTaskResetEventItemValue>
 10003ec:	e0bff715 	stw	r2,-36(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 10003f0:	e0bff717 	ldw	r2,-36(fp)
 10003f4:	1080802c 	andhi	r2,r2,512
 10003f8:	1000131e 	bne	r2,zero,1000448 <xEventGroupSync+0x158>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
 10003fc:	10053700 	call	1005370 <vTaskEnterCritical>
			{
				uxReturn = pxEventBits->uxEventBits;
 1000400:	e0bff817 	ldw	r2,-32(fp)
 1000404:	10800017 	ldw	r2,0(r2)
 1000408:	e0bff715 	stw	r2,-36(fp)

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 100040c:	e0fff717 	ldw	r3,-36(fp)
 1000410:	e0bffe17 	ldw	r2,-8(fp)
 1000414:	1886703a 	and	r3,r3,r2
 1000418:	e0bffe17 	ldw	r2,-8(fp)
 100041c:	1880071e 	bne	r3,r2,100043c <xEventGroupSync+0x14c>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 1000420:	e0bff817 	ldw	r2,-32(fp)
 1000424:	10c00017 	ldw	r3,0(r2)
 1000428:	e0bffe17 	ldw	r2,-8(fp)
 100042c:	0084303a 	nor	r2,zero,r2
 1000430:	1886703a 	and	r3,r3,r2
 1000434:	e0bff817 	ldw	r2,-32(fp)
 1000438:	10c00015 	stw	r3,0(r2)
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 100043c:	10053c40 	call	10053c4 <vTaskExitCritical>

			xTimeoutOccurred = pdTRUE;
 1000440:	00800044 	movi	r2,1
 1000444:	e0bff915 	stw	r2,-28(fp)
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 1000448:	e0fff717 	ldw	r3,-36(fp)
 100044c:	00804034 	movhi	r2,256
 1000450:	10bfffc4 	addi	r2,r2,-1
 1000454:	1884703a 	and	r2,r3,r2
 1000458:	e0bff715 	stw	r2,-36(fp)
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
 100045c:	e0bff717 	ldw	r2,-36(fp)
}
 1000460:	e037883a 	mov	sp,fp
 1000464:	dfc00117 	ldw	ra,4(sp)
 1000468:	df000017 	ldw	fp,0(sp)
 100046c:	dec00204 	addi	sp,sp,8
 1000470:	f800283a 	ret

01000474 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
 1000474:	defff304 	addi	sp,sp,-52
 1000478:	dfc00c15 	stw	ra,48(sp)
 100047c:	df000b15 	stw	fp,44(sp)
 1000480:	df000b04 	addi	fp,sp,44
 1000484:	e13ffc15 	stw	r4,-16(fp)
 1000488:	e17ffd15 	stw	r5,-12(fp)
 100048c:	e1bffe15 	stw	r6,-8(fp)
 1000490:	e1ffff15 	stw	r7,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
 1000494:	e0bffc17 	ldw	r2,-16(fp)
 1000498:	e0bff715 	stw	r2,-36(fp)
EventBits_t uxReturn, uxControlBits = 0;
 100049c:	e03ff615 	stw	zero,-40(fp)
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
 10004a0:	e03ff815 	stw	zero,-32(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
 10004a4:	100445c0 	call	100445c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 10004a8:	e0bff717 	ldw	r2,-36(fp)
 10004ac:	10800017 	ldw	r2,0(r2)
 10004b0:	e0bff915 	stw	r2,-28(fp)

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 10004b4:	e1bfff17 	ldw	r6,-4(fp)
 10004b8:	e17ffd17 	ldw	r5,-12(fp)
 10004bc:	e13ff917 	ldw	r4,-28(fp)
 10004c0:	100092c0 	call	100092c <prvTestWaitCondition>
 10004c4:	e0bffa15 	stw	r2,-24(fp)

		if( xWaitConditionMet != pdFALSE )
 10004c8:	e0bffa17 	ldw	r2,-24(fp)
 10004cc:	10000d26 	beq	r2,zero,1000504 <xEventGroupWaitBits+0x90>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
 10004d0:	e0bff917 	ldw	r2,-28(fp)
 10004d4:	e0bff515 	stw	r2,-44(fp)
			xTicksToWait = ( TickType_t ) 0;
 10004d8:	e0000215 	stw	zero,8(fp)

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
 10004dc:	e0bffe17 	ldw	r2,-8(fp)
 10004e0:	10002226 	beq	r2,zero,100056c <xEventGroupWaitBits+0xf8>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 10004e4:	e0bff717 	ldw	r2,-36(fp)
 10004e8:	10c00017 	ldw	r3,0(r2)
 10004ec:	e0bffd17 	ldw	r2,-12(fp)
 10004f0:	0084303a 	nor	r2,zero,r2
 10004f4:	1886703a 	and	r3,r3,r2
 10004f8:	e0bff717 	ldw	r2,-36(fp)
 10004fc:	10c00015 	stw	r3,0(r2)
 1000500:	00001a06 	br	100056c <xEventGroupWaitBits+0xf8>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
 1000504:	e0800217 	ldw	r2,8(fp)
 1000508:	1000051e 	bne	r2,zero,1000520 <xEventGroupWaitBits+0xac>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
 100050c:	e0bff917 	ldw	r2,-28(fp)
 1000510:	e0bff515 	stw	r2,-44(fp)
			xTimeoutOccurred = pdTRUE;
 1000514:	00800044 	movi	r2,1
 1000518:	e0bff815 	stw	r2,-32(fp)
 100051c:	00001306 	br	100056c <xEventGroupWaitBits+0xf8>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
 1000520:	e0bffe17 	ldw	r2,-8(fp)
 1000524:	10000326 	beq	r2,zero,1000534 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 1000528:	e0bff617 	ldw	r2,-40(fp)
 100052c:	10804034 	orhi	r2,r2,256
 1000530:	e0bff615 	stw	r2,-40(fp)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
 1000534:	e0bfff17 	ldw	r2,-4(fp)
 1000538:	10000326 	beq	r2,zero,1000548 <xEventGroupWaitBits+0xd4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
 100053c:	e0bff617 	ldw	r2,-40(fp)
 1000540:	10810034 	orhi	r2,r2,1024
 1000544:	e0bff615 	stw	r2,-40(fp)
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 1000548:	e0bff717 	ldw	r2,-36(fp)
 100054c:	11000104 	addi	r4,r2,4
 1000550:	e0fffd17 	ldw	r3,-12(fp)
 1000554:	e0bff617 	ldw	r2,-40(fp)
 1000558:	1884b03a 	or	r2,r3,r2
 100055c:	e1800217 	ldw	r6,8(fp)
 1000560:	100b883a 	mov	r5,r2
 1000564:	100496c0 	call	100496c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
 1000568:	e03ff515 	stw	zero,-44(fp)

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
 100056c:	10044880 	call	1004488 <xTaskResumeAll>
 1000570:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
 1000574:	e0800217 	ldw	r2,8(fp)
 1000578:	10002226 	beq	r2,zero,1000604 <xEventGroupWaitBits+0x190>
	{
		if( xAlreadyYielded == pdFALSE )
 100057c:	e0bffb17 	ldw	r2,-20(fp)
 1000580:	1000011e 	bne	r2,zero,1000588 <xEventGroupWaitBits+0x114>
		{
			portYIELD_WITHIN_API();
 1000584:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
 1000588:	10054240 	call	1005424 <uxTaskResetEventItemValue>
 100058c:	e0bff515 	stw	r2,-44(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 1000590:	e0bff517 	ldw	r2,-44(fp)
 1000594:	1080802c 	andhi	r2,r2,512
 1000598:	1000151e 	bne	r2,zero,10005f0 <xEventGroupWaitBits+0x17c>
		{
			taskENTER_CRITICAL();
 100059c:	10053700 	call	1005370 <vTaskEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
 10005a0:	e0bff717 	ldw	r2,-36(fp)
 10005a4:	10800017 	ldw	r2,0(r2)
 10005a8:	e0bff515 	stw	r2,-44(fp)

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 10005ac:	e1bfff17 	ldw	r6,-4(fp)
 10005b0:	e17ffd17 	ldw	r5,-12(fp)
 10005b4:	e13ff517 	ldw	r4,-44(fp)
 10005b8:	100092c0 	call	100092c <prvTestWaitCondition>
 10005bc:	10000926 	beq	r2,zero,10005e4 <xEventGroupWaitBits+0x170>
				{
					if( xClearOnExit != pdFALSE )
 10005c0:	e0bffe17 	ldw	r2,-8(fp)
 10005c4:	10000726 	beq	r2,zero,10005e4 <xEventGroupWaitBits+0x170>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 10005c8:	e0bff717 	ldw	r2,-36(fp)
 10005cc:	10c00017 	ldw	r3,0(r2)
 10005d0:	e0bffd17 	ldw	r2,-12(fp)
 10005d4:	0084303a 	nor	r2,zero,r2
 10005d8:	1886703a 	and	r3,r3,r2
 10005dc:	e0bff717 	ldw	r2,-36(fp)
 10005e0:	10c00015 	stw	r3,0(r2)
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
 10005e4:	00800044 	movi	r2,1
 10005e8:	e0bff815 	stw	r2,-32(fp)
			}
			taskEXIT_CRITICAL();
 10005ec:	10053c40 	call	10053c4 <vTaskExitCritical>
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 10005f0:	e0fff517 	ldw	r3,-44(fp)
 10005f4:	00804034 	movhi	r2,256
 10005f8:	10bfffc4 	addi	r2,r2,-1
 10005fc:	1884703a 	and	r2,r3,r2
 1000600:	e0bff515 	stw	r2,-44(fp)
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
 1000604:	e0bff517 	ldw	r2,-44(fp)
}
 1000608:	e037883a 	mov	sp,fp
 100060c:	dfc00117 	ldw	ra,4(sp)
 1000610:	df000017 	ldw	fp,0(sp)
 1000614:	dec00204 	addi	sp,sp,8
 1000618:	f800283a 	ret

0100061c <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
 100061c:	defffa04 	addi	sp,sp,-24
 1000620:	dfc00515 	stw	ra,20(sp)
 1000624:	df000415 	stw	fp,16(sp)
 1000628:	df000404 	addi	fp,sp,16
 100062c:	e13ffe15 	stw	r4,-8(fp)
 1000630:	e17fff15 	stw	r5,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
 1000634:	e0bffe17 	ldw	r2,-8(fp)
 1000638:	e0bffc15 	stw	r2,-16(fp)
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
 100063c:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
 1000640:	e0bffc17 	ldw	r2,-16(fp)
 1000644:	10800017 	ldw	r2,0(r2)
 1000648:	e0bffd15 	stw	r2,-12(fp)

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 100064c:	e0bffc17 	ldw	r2,-16(fp)
 1000650:	10c00017 	ldw	r3,0(r2)
 1000654:	e0bfff17 	ldw	r2,-4(fp)
 1000658:	0084303a 	nor	r2,zero,r2
 100065c:	1886703a 	and	r3,r3,r2
 1000660:	e0bffc17 	ldw	r2,-16(fp)
 1000664:	10c00015 	stw	r3,0(r2)
	}
	taskEXIT_CRITICAL();
 1000668:	10053c40 	call	10053c4 <vTaskExitCritical>

	return uxReturn;
 100066c:	e0bffd17 	ldw	r2,-12(fp)
}
 1000670:	e037883a 	mov	sp,fp
 1000674:	dfc00117 	ldw	ra,4(sp)
 1000678:	df000017 	ldw	fp,0(sp)
 100067c:	dec00204 	addi	sp,sp,8
 1000680:	f800283a 	ret

01000684 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
 1000684:	defffb04 	addi	sp,sp,-20
 1000688:	df000415 	stw	fp,16(sp)
 100068c:	df000404 	addi	fp,sp,16
 1000690:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
 1000694:	e0bfff17 	ldw	r2,-4(fp)
 1000698:	e0bffc15 	stw	r2,-16(fp)
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 100069c:	e03ffd15 	stw	zero,-12(fp)
	{
		uxReturn = pxEventBits->uxEventBits;
 10006a0:	e0bffc17 	ldw	r2,-16(fp)
 10006a4:	10800017 	ldw	r2,0(r2)
 10006a8:	e0bffe15 	stw	r2,-8(fp)
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
 10006ac:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 10006b0:	e037883a 	mov	sp,fp
 10006b4:	df000017 	ldw	fp,0(sp)
 10006b8:	dec00104 	addi	sp,sp,4
 10006bc:	f800283a 	ret

010006c0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
 10006c0:	defff304 	addi	sp,sp,-52
 10006c4:	dfc00c15 	stw	ra,48(sp)
 10006c8:	df000b15 	stw	fp,44(sp)
 10006cc:	df000b04 	addi	fp,sp,44
 10006d0:	e13ffe15 	stw	r4,-8(fp)
 10006d4:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 10006d8:	e03ff615 	stw	zero,-40(fp)
EventGroup_t *pxEventBits = xEventGroup;
 10006dc:	e0bffe17 	ldw	r2,-8(fp)
 10006e0:	e0bff815 	stw	r2,-32(fp)
BaseType_t xMatchFound = pdFALSE;
 10006e4:	e03ff715 	stw	zero,-36(fp)
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
 10006e8:	e0bff817 	ldw	r2,-32(fp)
 10006ec:	10800104 	addi	r2,r2,4
 10006f0:	e0bff915 	stw	r2,-28(fp)
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 10006f4:	e0bff917 	ldw	r2,-28(fp)
 10006f8:	10800204 	addi	r2,r2,8
 10006fc:	e0bffa15 	stw	r2,-24(fp)
	vTaskSuspendAll();
 1000700:	100445c0 	call	100445c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
 1000704:	e0bff917 	ldw	r2,-28(fp)
 1000708:	10800317 	ldw	r2,12(r2)
 100070c:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
 1000710:	e0bff817 	ldw	r2,-32(fp)
 1000714:	10c00017 	ldw	r3,0(r2)
 1000718:	e0bfff17 	ldw	r2,-4(fp)
 100071c:	1886b03a 	or	r3,r3,r2
 1000720:	e0bff817 	ldw	r2,-32(fp)
 1000724:	10c00015 	stw	r3,0(r2)

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
 1000728:	00003306 	br	10007f8 <xEventGroupSetBits+0x138>
		{
			pxNext = listGET_NEXT( pxListItem );
 100072c:	e0bff517 	ldw	r2,-44(fp)
 1000730:	10800117 	ldw	r2,4(r2)
 1000734:	e0bffb15 	stw	r2,-20(fp)
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 1000738:	e0bff517 	ldw	r2,-44(fp)
 100073c:	10800017 	ldw	r2,0(r2)
 1000740:	e0bffc15 	stw	r2,-16(fp)
			xMatchFound = pdFALSE;
 1000744:	e03ff715 	stw	zero,-36(fp)

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 1000748:	e0bffc17 	ldw	r2,-16(fp)
 100074c:	10bfc02c 	andhi	r2,r2,65280
 1000750:	e0bffd15 	stw	r2,-12(fp)
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 1000754:	e0fffc17 	ldw	r3,-16(fp)
 1000758:	00804034 	movhi	r2,256
 100075c:	10bfffc4 	addi	r2,r2,-1
 1000760:	1884703a 	and	r2,r3,r2
 1000764:	e0bffc15 	stw	r2,-16(fp)

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 1000768:	e0bffd17 	ldw	r2,-12(fp)
 100076c:	1081002c 	andhi	r2,r2,1024
 1000770:	1000081e 	bne	r2,zero,1000794 <xEventGroupSetBits+0xd4>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 1000774:	e0bff817 	ldw	r2,-32(fp)
 1000778:	10c00017 	ldw	r3,0(r2)
 100077c:	e0bffc17 	ldw	r2,-16(fp)
 1000780:	1884703a 	and	r2,r3,r2
 1000784:	10000b26 	beq	r2,zero,10007b4 <xEventGroupSetBits+0xf4>
				{
					xMatchFound = pdTRUE;
 1000788:	00800044 	movi	r2,1
 100078c:	e0bff715 	stw	r2,-36(fp)
 1000790:	00000806 	br	10007b4 <xEventGroupSetBits+0xf4>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 1000794:	e0bff817 	ldw	r2,-32(fp)
 1000798:	10c00017 	ldw	r3,0(r2)
 100079c:	e0bffc17 	ldw	r2,-16(fp)
 10007a0:	1886703a 	and	r3,r3,r2
 10007a4:	e0bffc17 	ldw	r2,-16(fp)
 10007a8:	1880021e 	bne	r3,r2,10007b4 <xEventGroupSetBits+0xf4>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
 10007ac:	00800044 	movi	r2,1
 10007b0:	e0bff715 	stw	r2,-36(fp)
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
 10007b4:	e0bff717 	ldw	r2,-36(fp)
 10007b8:	10000d26 	beq	r2,zero,10007f0 <xEventGroupSetBits+0x130>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 10007bc:	e0bffd17 	ldw	r2,-12(fp)
 10007c0:	1080402c 	andhi	r2,r2,256
 10007c4:	10000426 	beq	r2,zero,10007d8 <xEventGroupSetBits+0x118>
				{
					uxBitsToClear |= uxBitsWaitedFor;
 10007c8:	e0fff617 	ldw	r3,-40(fp)
 10007cc:	e0bffc17 	ldw	r2,-16(fp)
 10007d0:	1884b03a 	or	r2,r3,r2
 10007d4:	e0bff615 	stw	r2,-40(fp)
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 10007d8:	e0bff817 	ldw	r2,-32(fp)
 10007dc:	10800017 	ldw	r2,0(r2)
 10007e0:	10808034 	orhi	r2,r2,512
 10007e4:	100b883a 	mov	r5,r2
 10007e8:	e13ff517 	ldw	r4,-44(fp)
 10007ec:	1004ac40 	call	1004ac4 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
 10007f0:	e0bffb17 	ldw	r2,-20(fp)
 10007f4:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
 10007f8:	e0fff517 	ldw	r3,-44(fp)
 10007fc:	e0bffa17 	ldw	r2,-24(fp)
 1000800:	18bfca1e 	bne	r3,r2,100072c <__alt_data_end+0xff00072c>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 1000804:	e0bff817 	ldw	r2,-32(fp)
 1000808:	10c00017 	ldw	r3,0(r2)
 100080c:	e0bff617 	ldw	r2,-40(fp)
 1000810:	0084303a 	nor	r2,zero,r2
 1000814:	1886703a 	and	r3,r3,r2
 1000818:	e0bff817 	ldw	r2,-32(fp)
 100081c:	10c00015 	stw	r3,0(r2)
	}
	( void ) xTaskResumeAll();
 1000820:	10044880 	call	1004488 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
 1000824:	e0bff817 	ldw	r2,-32(fp)
 1000828:	10800017 	ldw	r2,0(r2)
}
 100082c:	e037883a 	mov	sp,fp
 1000830:	dfc00117 	ldw	ra,4(sp)
 1000834:	df000017 	ldw	fp,0(sp)
 1000838:	dec00204 	addi	sp,sp,8
 100083c:	f800283a 	ret

01000840 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 1000840:	defffb04 	addi	sp,sp,-20
 1000844:	dfc00415 	stw	ra,16(sp)
 1000848:	df000315 	stw	fp,12(sp)
 100084c:	df000304 	addi	fp,sp,12
 1000850:	e13fff15 	stw	r4,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
 1000854:	e0bfff17 	ldw	r2,-4(fp)
 1000858:	e0bffd15 	stw	r2,-12(fp)
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 100085c:	e0bffd17 	ldw	r2,-12(fp)
 1000860:	10800104 	addi	r2,r2,4
 1000864:	e0bffe15 	stw	r2,-8(fp)

	vTaskSuspendAll();
 1000868:	100445c0 	call	100445c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 100086c:	00000506 	br	1000884 <vEventGroupDelete+0x44>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 1000870:	e0bffe17 	ldw	r2,-8(fp)
 1000874:	10800317 	ldw	r2,12(r2)
 1000878:	01408034 	movhi	r5,512
 100087c:	1009883a 	mov	r4,r2
 1000880:	1004ac40 	call	1004ac4 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 1000884:	e0bffe17 	ldw	r2,-8(fp)
 1000888:	10800017 	ldw	r2,0(r2)
 100088c:	103ff81e 	bne	r2,zero,1000870 <__alt_data_end+0xff000870>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
 1000890:	e13ffd17 	ldw	r4,-12(fp)
 1000894:	10012840 	call	1001284 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
 1000898:	10044880 	call	1004488 <xTaskResumeAll>
}
 100089c:	0001883a 	nop
 10008a0:	e037883a 	mov	sp,fp
 10008a4:	dfc00117 	ldw	ra,4(sp)
 10008a8:	df000017 	ldw	fp,0(sp)
 10008ac:	dec00204 	addi	sp,sp,8
 10008b0:	f800283a 	ret

010008b4 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
 10008b4:	defffc04 	addi	sp,sp,-16
 10008b8:	dfc00315 	stw	ra,12(sp)
 10008bc:	df000215 	stw	fp,8(sp)
 10008c0:	df000204 	addi	fp,sp,8
 10008c4:	e13ffe15 	stw	r4,-8(fp)
 10008c8:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 10008cc:	e17fff17 	ldw	r5,-4(fp)
 10008d0:	e13ffe17 	ldw	r4,-8(fp)
 10008d4:	10006c00 	call	10006c0 <xEventGroupSetBits>
}
 10008d8:	0001883a 	nop
 10008dc:	e037883a 	mov	sp,fp
 10008e0:	dfc00117 	ldw	ra,4(sp)
 10008e4:	df000017 	ldw	fp,0(sp)
 10008e8:	dec00204 	addi	sp,sp,8
 10008ec:	f800283a 	ret

010008f0 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
 10008f0:	defffc04 	addi	sp,sp,-16
 10008f4:	dfc00315 	stw	ra,12(sp)
 10008f8:	df000215 	stw	fp,8(sp)
 10008fc:	df000204 	addi	fp,sp,8
 1000900:	e13ffe15 	stw	r4,-8(fp)
 1000904:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 1000908:	e17fff17 	ldw	r5,-4(fp)
 100090c:	e13ffe17 	ldw	r4,-8(fp)
 1000910:	100061c0 	call	100061c <xEventGroupClearBits>
}
 1000914:	0001883a 	nop
 1000918:	e037883a 	mov	sp,fp
 100091c:	dfc00117 	ldw	ra,4(sp)
 1000920:	df000017 	ldw	fp,0(sp)
 1000924:	dec00204 	addi	sp,sp,8
 1000928:	f800283a 	ret

0100092c <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
 100092c:	defffb04 	addi	sp,sp,-20
 1000930:	df000415 	stw	fp,16(sp)
 1000934:	df000404 	addi	fp,sp,16
 1000938:	e13ffd15 	stw	r4,-12(fp)
 100093c:	e17ffe15 	stw	r5,-8(fp)
 1000940:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xWaitConditionMet = pdFALSE;
 1000944:	e03ffc15 	stw	zero,-16(fp)

	if( xWaitForAllBits == pdFALSE )
 1000948:	e0bfff17 	ldw	r2,-4(fp)
 100094c:	1000071e 	bne	r2,zero,100096c <prvTestWaitCondition+0x40>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 1000950:	e0fffd17 	ldw	r3,-12(fp)
 1000954:	e0bffe17 	ldw	r2,-8(fp)
 1000958:	1884703a 	and	r2,r3,r2
 100095c:	10000a26 	beq	r2,zero,1000988 <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
 1000960:	00800044 	movi	r2,1
 1000964:	e0bffc15 	stw	r2,-16(fp)
 1000968:	00000706 	br	1000988 <prvTestWaitCondition+0x5c>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 100096c:	e0fffd17 	ldw	r3,-12(fp)
 1000970:	e0bffe17 	ldw	r2,-8(fp)
 1000974:	1886703a 	and	r3,r3,r2
 1000978:	e0bffe17 	ldw	r2,-8(fp)
 100097c:	1880021e 	bne	r3,r2,1000988 <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
 1000980:	00800044 	movi	r2,1
 1000984:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
 1000988:	e0bffc17 	ldw	r2,-16(fp)
}
 100098c:	e037883a 	mov	sp,fp
 1000990:	df000017 	ldw	fp,0(sp)
 1000994:	dec00104 	addi	sp,sp,4
 1000998:	f800283a 	ret

0100099c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 100099c:	defffe04 	addi	sp,sp,-8
 10009a0:	df000115 	stw	fp,4(sp)
 10009a4:	df000104 	addi	fp,sp,4
 10009a8:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 10009ac:	e0bfff17 	ldw	r2,-4(fp)
 10009b0:	10c00204 	addi	r3,r2,8
 10009b4:	e0bfff17 	ldw	r2,-4(fp)
 10009b8:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 10009bc:	e0bfff17 	ldw	r2,-4(fp)
 10009c0:	00ffffc4 	movi	r3,-1
 10009c4:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 10009c8:	e0bfff17 	ldw	r2,-4(fp)
 10009cc:	10c00204 	addi	r3,r2,8
 10009d0:	e0bfff17 	ldw	r2,-4(fp)
 10009d4:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 10009d8:	e0bfff17 	ldw	r2,-4(fp)
 10009dc:	10c00204 	addi	r3,r2,8
 10009e0:	e0bfff17 	ldw	r2,-4(fp)
 10009e4:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 10009e8:	e0bfff17 	ldw	r2,-4(fp)
 10009ec:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 10009f0:	0001883a 	nop
 10009f4:	e037883a 	mov	sp,fp
 10009f8:	df000017 	ldw	fp,0(sp)
 10009fc:	dec00104 	addi	sp,sp,4
 1000a00:	f800283a 	ret

01000a04 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 1000a04:	defffe04 	addi	sp,sp,-8
 1000a08:	df000115 	stw	fp,4(sp)
 1000a0c:	df000104 	addi	fp,sp,4
 1000a10:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 1000a14:	e0bfff17 	ldw	r2,-4(fp)
 1000a18:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 1000a1c:	0001883a 	nop
 1000a20:	e037883a 	mov	sp,fp
 1000a24:	df000017 	ldw	fp,0(sp)
 1000a28:	dec00104 	addi	sp,sp,4
 1000a2c:	f800283a 	ret

01000a30 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1000a30:	defffc04 	addi	sp,sp,-16
 1000a34:	df000315 	stw	fp,12(sp)
 1000a38:	df000304 	addi	fp,sp,12
 1000a3c:	e13ffe15 	stw	r4,-8(fp)
 1000a40:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
 1000a44:	e0bffe17 	ldw	r2,-8(fp)
 1000a48:	10800117 	ldw	r2,4(r2)
 1000a4c:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 1000a50:	e0bfff17 	ldw	r2,-4(fp)
 1000a54:	e0fffd17 	ldw	r3,-12(fp)
 1000a58:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 1000a5c:	e0bffd17 	ldw	r2,-12(fp)
 1000a60:	10c00217 	ldw	r3,8(r2)
 1000a64:	e0bfff17 	ldw	r2,-4(fp)
 1000a68:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 1000a6c:	e0bffd17 	ldw	r2,-12(fp)
 1000a70:	10800217 	ldw	r2,8(r2)
 1000a74:	e0ffff17 	ldw	r3,-4(fp)
 1000a78:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
 1000a7c:	e0bffd17 	ldw	r2,-12(fp)
 1000a80:	e0ffff17 	ldw	r3,-4(fp)
 1000a84:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 1000a88:	e0bfff17 	ldw	r2,-4(fp)
 1000a8c:	e0fffe17 	ldw	r3,-8(fp)
 1000a90:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 1000a94:	e0bffe17 	ldw	r2,-8(fp)
 1000a98:	10800017 	ldw	r2,0(r2)
 1000a9c:	10c00044 	addi	r3,r2,1
 1000aa0:	e0bffe17 	ldw	r2,-8(fp)
 1000aa4:	10c00015 	stw	r3,0(r2)
}
 1000aa8:	0001883a 	nop
 1000aac:	e037883a 	mov	sp,fp
 1000ab0:	df000017 	ldw	fp,0(sp)
 1000ab4:	dec00104 	addi	sp,sp,4
 1000ab8:	f800283a 	ret

01000abc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1000abc:	defffb04 	addi	sp,sp,-20
 1000ac0:	df000415 	stw	fp,16(sp)
 1000ac4:	df000404 	addi	fp,sp,16
 1000ac8:	e13ffe15 	stw	r4,-8(fp)
 1000acc:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1000ad0:	e0bfff17 	ldw	r2,-4(fp)
 1000ad4:	10800017 	ldw	r2,0(r2)
 1000ad8:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1000adc:	e0bffd17 	ldw	r2,-12(fp)
 1000ae0:	10bfffd8 	cmpnei	r2,r2,-1
 1000ae4:	1000041e 	bne	r2,zero,1000af8 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1000ae8:	e0bffe17 	ldw	r2,-8(fp)
 1000aec:	10800417 	ldw	r2,16(r2)
 1000af0:	e0bffc15 	stw	r2,-16(fp)
 1000af4:	00000c06 	br	1000b28 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 1000af8:	e0bffe17 	ldw	r2,-8(fp)
 1000afc:	10800204 	addi	r2,r2,8
 1000b00:	e0bffc15 	stw	r2,-16(fp)
 1000b04:	00000306 	br	1000b14 <vListInsert+0x58>
 1000b08:	e0bffc17 	ldw	r2,-16(fp)
 1000b0c:	10800117 	ldw	r2,4(r2)
 1000b10:	e0bffc15 	stw	r2,-16(fp)
 1000b14:	e0bffc17 	ldw	r2,-16(fp)
 1000b18:	10800117 	ldw	r2,4(r2)
 1000b1c:	10800017 	ldw	r2,0(r2)
 1000b20:	e0fffd17 	ldw	r3,-12(fp)
 1000b24:	18bff82e 	bgeu	r3,r2,1000b08 <__alt_data_end+0xff000b08>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1000b28:	e0bffc17 	ldw	r2,-16(fp)
 1000b2c:	10c00117 	ldw	r3,4(r2)
 1000b30:	e0bfff17 	ldw	r2,-4(fp)
 1000b34:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1000b38:	e0bfff17 	ldw	r2,-4(fp)
 1000b3c:	10800117 	ldw	r2,4(r2)
 1000b40:	e0ffff17 	ldw	r3,-4(fp)
 1000b44:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
 1000b48:	e0bfff17 	ldw	r2,-4(fp)
 1000b4c:	e0fffc17 	ldw	r3,-16(fp)
 1000b50:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
 1000b54:	e0bffc17 	ldw	r2,-16(fp)
 1000b58:	e0ffff17 	ldw	r3,-4(fp)
 1000b5c:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 1000b60:	e0bfff17 	ldw	r2,-4(fp)
 1000b64:	e0fffe17 	ldw	r3,-8(fp)
 1000b68:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 1000b6c:	e0bffe17 	ldw	r2,-8(fp)
 1000b70:	10800017 	ldw	r2,0(r2)
 1000b74:	10c00044 	addi	r3,r2,1
 1000b78:	e0bffe17 	ldw	r2,-8(fp)
 1000b7c:	10c00015 	stw	r3,0(r2)
}
 1000b80:	0001883a 	nop
 1000b84:	e037883a 	mov	sp,fp
 1000b88:	df000017 	ldw	fp,0(sp)
 1000b8c:	dec00104 	addi	sp,sp,4
 1000b90:	f800283a 	ret

01000b94 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1000b94:	defffd04 	addi	sp,sp,-12
 1000b98:	df000215 	stw	fp,8(sp)
 1000b9c:	df000204 	addi	fp,sp,8
 1000ba0:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 1000ba4:	e0bfff17 	ldw	r2,-4(fp)
 1000ba8:	10800417 	ldw	r2,16(r2)
 1000bac:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1000bb0:	e0bfff17 	ldw	r2,-4(fp)
 1000bb4:	10800117 	ldw	r2,4(r2)
 1000bb8:	e0ffff17 	ldw	r3,-4(fp)
 1000bbc:	18c00217 	ldw	r3,8(r3)
 1000bc0:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1000bc4:	e0bfff17 	ldw	r2,-4(fp)
 1000bc8:	10800217 	ldw	r2,8(r2)
 1000bcc:	e0ffff17 	ldw	r3,-4(fp)
 1000bd0:	18c00117 	ldw	r3,4(r3)
 1000bd4:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1000bd8:	e0bffe17 	ldw	r2,-8(fp)
 1000bdc:	10c00117 	ldw	r3,4(r2)
 1000be0:	e0bfff17 	ldw	r2,-4(fp)
 1000be4:	1880041e 	bne	r3,r2,1000bf8 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 1000be8:	e0bfff17 	ldw	r2,-4(fp)
 1000bec:	10c00217 	ldw	r3,8(r2)
 1000bf0:	e0bffe17 	ldw	r2,-8(fp)
 1000bf4:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 1000bf8:	e0bfff17 	ldw	r2,-4(fp)
 1000bfc:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
 1000c00:	e0bffe17 	ldw	r2,-8(fp)
 1000c04:	10800017 	ldw	r2,0(r2)
 1000c08:	10ffffc4 	addi	r3,r2,-1
 1000c0c:	e0bffe17 	ldw	r2,-8(fp)
 1000c10:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
 1000c14:	e0bffe17 	ldw	r2,-8(fp)
 1000c18:	10800017 	ldw	r2,0(r2)
}
 1000c1c:	e037883a 	mov	sp,fp
 1000c20:	df000017 	ldw	fp,0(sp)
 1000c24:	dec00104 	addi	sp,sp,4
 1000c28:	f800283a 	ret

01000c2c <prvReadGp>:
void vPortSysTickHandler( void * context, alt_u32 id );

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 1000c2c:	defffe04 	addi	sp,sp,-8
 1000c30:	df000115 	stw	fp,4(sp)
 1000c34:	df000104 	addi	fp,sp,4
 1000c38:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 1000c3c:	e0bfff17 	ldw	r2,-4(fp)
 1000c40:	16800015 	stw	gp,0(r2)
}
 1000c44:	0001883a 	nop
 1000c48:	e037883a 	mov	sp,fp
 1000c4c:	df000017 	ldw	fp,0(sp)
 1000c50:	dec00104 	addi	sp,sp,4
 1000c54:	f800283a 	ret

01000c58 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 1000c58:	defff904 	addi	sp,sp,-28
 1000c5c:	dfc00615 	stw	ra,24(sp)
 1000c60:	df000515 	stw	fp,20(sp)
 1000c64:	df000504 	addi	fp,sp,20
 1000c68:	e13ffd15 	stw	r4,-12(fp)
 1000c6c:	e17ffe15 	stw	r5,-8(fp)
 1000c70:	e1bfff15 	stw	r6,-4(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 1000c74:	e0bffd17 	ldw	r2,-12(fp)
 1000c78:	10bfff04 	addi	r2,r2,-4
 1000c7c:	e0bffb15 	stw	r2,-20(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 1000c80:	e0bffc04 	addi	r2,fp,-16
 1000c84:	1009883a 	mov	r4,r2
 1000c88:	1000c2c0 	call	1000c2c <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 1000c8c:	e0fffd17 	ldw	r3,-12(fp)
 1000c90:	00b7abb4 	movhi	r2,57006
 1000c94:	10afbbc4 	addi	r2,r2,-16657
 1000c98:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 1000c9c:	e0bffd17 	ldw	r2,-12(fp)
 1000ca0:	10bfff04 	addi	r2,r2,-4
 1000ca4:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 1000ca8:	e0fffb17 	ldw	r3,-20(fp)
 1000cac:	e0bffd17 	ldw	r2,-12(fp)
 1000cb0:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 1000cb4:	e0bffd17 	ldw	r2,-12(fp)
 1000cb8:	10bfff04 	addi	r2,r2,-4
 1000cbc:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 1000cc0:	e0fffc17 	ldw	r3,-16(fp)
 1000cc4:	e0bffd17 	ldw	r2,-12(fp)
 1000cc8:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 1000ccc:	e0bffd17 	ldw	r2,-12(fp)
 1000cd0:	10bff704 	addi	r2,r2,-36
 1000cd4:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 1000cd8:	e0fffe17 	ldw	r3,-8(fp)
 1000cdc:	e0bffd17 	ldw	r2,-12(fp)
 1000ce0:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 1000ce4:	e0bffd17 	ldw	r2,-12(fp)
 1000ce8:	10bfff04 	addi	r2,r2,-4
 1000cec:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 1000cf0:	e0bffd17 	ldw	r2,-12(fp)
 1000cf4:	00c00044 	movi	r3,1
 1000cf8:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 1000cfc:	e0bffd17 	ldw	r2,-12(fp)
 1000d00:	10bff404 	addi	r2,r2,-48
 1000d04:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 1000d08:	e0ffff17 	ldw	r3,-4(fp)
 1000d0c:	e0bffd17 	ldw	r2,-12(fp)
 1000d10:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 1000d14:	e0bffd17 	ldw	r2,-12(fp)
 1000d18:	10bffb04 	addi	r2,r2,-20
 1000d1c:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 1000d20:	e0bffd17 	ldw	r2,-12(fp)
}
 1000d24:	e037883a 	mov	sp,fp
 1000d28:	dfc00117 	ldw	ra,4(sp)
 1000d2c:	df000017 	ldw	fp,0(sp)
 1000d30:	dec00204 	addi	sp,sp,8
 1000d34:	f800283a 	ret

01000d38 <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 1000d38:	defffe04 	addi	sp,sp,-8
 1000d3c:	dfc00115 	stw	ra,4(sp)
 1000d40:	df000015 	stw	fp,0(sp)
 1000d44:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 1000d48:	1000d900 	call	1000d90 <prvSetupTimerInterrupt>
 1000d4c:	00804034 	movhi	r2,256
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 1000d50:	10803104 	addi	r2,r2,196
 1000d54:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 1000d58:	0005883a 	mov	r2,zero
}
 1000d5c:	e037883a 	mov	sp,fp
 1000d60:	dfc00117 	ldw	ra,4(sp)
 1000d64:	df000017 	ldw	fp,0(sp)
 1000d68:	dec00204 	addi	sp,sp,8
 1000d6c:	f800283a 	ret

01000d70 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 1000d70:	deffff04 	addi	sp,sp,-4
 1000d74:	df000015 	stw	fp,0(sp)
 1000d78:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 1000d7c:	0001883a 	nop
 1000d80:	e037883a 	mov	sp,fp
 1000d84:	df000017 	ldw	fp,0(sp)
 1000d88:	dec00104 	addi	sp,sp,4
 1000d8c:	f800283a 	ret

01000d90 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 1000d90:	defffe04 	addi	sp,sp,-8
 1000d94:	dfc00115 	stw	ra,4(sp)
 1000d98:	df000015 	stw	fp,0(sp)
 1000d9c:	d839883a 	mov	fp,sp
	/* Try to register the interrupt handler. */
	if ( -EINVAL == alt_irq_register( TIMER_0_IRQ, 0x0, vPortSysTickHandler ) )
 1000da0:	01804034 	movhi	r6,256
 1000da4:	31838604 	addi	r6,r6,3608
 1000da8:	000b883a 	mov	r5,zero
 1000dac:	01000044 	movi	r4,1
 1000db0:	1000e600 	call	1000e60 <alt_irq_register>
 1000db4:	10bffa98 	cmpnei	r2,r2,-22
 1000db8:	1000021e 	bne	r2,zero,1000dc4 <prvSetupTimerInterrupt+0x34>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 1000dbc:	003da03a 	break	0
 1000dc0:	00000c06 	br	1000df4 <prvSetupTimerInterrupt+0x64>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 1000dc4:	00c00204 	movi	r3,8
 1000dc8:	00800904 	movi	r2,36
 1000dcc:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( TIMER_0_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 1000dd0:	00e1a814 	movui	r3,34464
 1000dd4:	00800a04 	movi	r2,40
 1000dd8:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( TIMER_0_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 1000ddc:	00c00044 	movi	r3,1
 1000de0:	00800b04 	movi	r2,44
 1000de4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );
 1000de8:	00c001c4 	movi	r3,7
 1000dec:	00800904 	movi	r2,36
 1000df0:	10c00035 	stwio	r3,0(r2)
	}

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 1000df4:	00ffff84 	movi	r3,-2
 1000df8:	00800804 	movi	r2,32
 1000dfc:	10c00035 	stwio	r3,0(r2)
}
 1000e00:	0001883a 	nop
 1000e04:	e037883a 	mov	sp,fp
 1000e08:	dfc00117 	ldw	ra,4(sp)
 1000e0c:	df000017 	ldw	fp,0(sp)
 1000e10:	dec00204 	addi	sp,sp,8
 1000e14:	f800283a 	ret

01000e18 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context, alt_u32 id )
{
 1000e18:	defffc04 	addi	sp,sp,-16
 1000e1c:	dfc00315 	stw	ra,12(sp)
 1000e20:	df000215 	stw	fp,8(sp)
 1000e24:	df000204 	addi	fp,sp,8
 1000e28:	e13ffe15 	stw	r4,-8(fp)
 1000e2c:	e17fff15 	stw	r5,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 1000e30:	10046940 	call	1004694 <xTaskIncrementTick>
 1000e34:	10000126 	beq	r2,zero,1000e3c <vPortSysTickHandler+0x24>
	{
        vTaskSwitchContext();
 1000e38:	10048440 	call	1004844 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 1000e3c:	00ffff84 	movi	r3,-2
 1000e40:	00800804 	movi	r2,32
 1000e44:	10c00035 	stwio	r3,0(r2)
}
 1000e48:	0001883a 	nop
 1000e4c:	e037883a 	mov	sp,fp
 1000e50:	dfc00117 	ldw	ra,4(sp)
 1000e54:	df000017 	ldw	fp,0(sp)
 1000e58:	dec00204 	addi	sp,sp,8
 1000e5c:	f800283a 	ret

01000e60 <alt_irq_register>:
#ifndef ALT_ENHANCED_INTERRUPT_API_PRESENT
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
#else
int alt_irq_register( alt_u32 id, void* context, alt_isr_func handler )
#endif
{
 1000e60:	defff104 	addi	sp,sp,-60
 1000e64:	df000e15 	stw	fp,56(sp)
 1000e68:	df000e04 	addi	fp,sp,56
 1000e6c:	e13ffd15 	stw	r4,-12(fp)
 1000e70:	e17ffe15 	stw	r5,-8(fp)
 1000e74:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;  
 1000e78:	00bffa84 	movi	r2,-22
 1000e7c:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
 1000e80:	e0bffd17 	ldw	r2,-12(fp)
 1000e84:	10800828 	cmpgeui	r2,r2,32
 1000e88:	10004c1e 	bne	r2,zero,1000fbc <alt_irq_register+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1000e8c:	0005303a 	rdctl	r2,status
 1000e90:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1000e94:	e0fff617 	ldw	r3,-40(fp)
 1000e98:	00bfff84 	movi	r2,-2
 1000e9c:	1884703a 	and	r2,r3,r2
 1000ea0:	1001703a 	wrctl	status,r2
  
  return context;
 1000ea4:	e0bff617 	ldw	r2,-40(fp)
	{
		status = alt_irq_disable_all ();
 1000ea8:	e0bff415 	stw	r2,-48(fp)
	
		alt_irq[id].handler = handler;
 1000eac:	008060f4 	movhi	r2,387
 1000eb0:	10baf904 	addi	r2,r2,-5148
 1000eb4:	e0fffd17 	ldw	r3,-12(fp)
 1000eb8:	180690fa 	slli	r3,r3,3
 1000ebc:	10c5883a 	add	r2,r2,r3
 1000ec0:	e0ffff17 	ldw	r3,-4(fp)
 1000ec4:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
 1000ec8:	008060f4 	movhi	r2,387
 1000ecc:	10baf904 	addi	r2,r2,-5148
 1000ed0:	e0fffd17 	ldw	r3,-12(fp)
 1000ed4:	180690fa 	slli	r3,r3,3
 1000ed8:	10c5883a 	add	r2,r2,r3
 1000edc:	10800104 	addi	r2,r2,4
 1000ee0:	e0fffe17 	ldw	r3,-8(fp)
 1000ee4:	10c00015 	stw	r3,0(r2)
	
		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 1000ee8:	e0bfff17 	ldw	r2,-4(fp)
 1000eec:	10001926 	beq	r2,zero,1000f54 <alt_irq_register+0xf4>
 1000ef0:	e0bffd17 	ldw	r2,-12(fp)
 1000ef4:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1000ef8:	0005303a 	rdctl	r2,status
 1000efc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1000f00:	e0fff717 	ldw	r3,-36(fp)
 1000f04:	00bfff84 	movi	r2,-2
 1000f08:	1884703a 	and	r2,r3,r2
 1000f0c:	1001703a 	wrctl	status,r2
  
  return context;
 1000f10:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1000f14:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 1000f18:	00c00044 	movi	r3,1
 1000f1c:	e0bff317 	ldw	r2,-52(fp)
 1000f20:	1884983a 	sll	r2,r3,r2
 1000f24:	1007883a 	mov	r3,r2
 1000f28:	d0a75c17 	ldw	r2,-25232(gp)
 1000f2c:	1884b03a 	or	r2,r3,r2
 1000f30:	d0a75c15 	stw	r2,-25232(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1000f34:	d0a75c17 	ldw	r2,-25232(gp)
 1000f38:	100170fa 	wrctl	ienable,r2
 1000f3c:	e0bff817 	ldw	r2,-32(fp)
 1000f40:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1000f44:	e0bff917 	ldw	r2,-28(fp)
 1000f48:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1000f4c:	0005883a 	mov	r2,zero
 1000f50:	00001906 	br	1000fb8 <alt_irq_register+0x158>
 1000f54:	e0bffd17 	ldw	r2,-12(fp)
 1000f58:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1000f5c:	0005303a 	rdctl	r2,status
 1000f60:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1000f64:	e0fffa17 	ldw	r3,-24(fp)
 1000f68:	00bfff84 	movi	r2,-2
 1000f6c:	1884703a 	and	r2,r3,r2
 1000f70:	1001703a 	wrctl	status,r2
  
  return context;
 1000f74:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1000f78:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
 1000f7c:	00c00044 	movi	r3,1
 1000f80:	e0bff517 	ldw	r2,-44(fp)
 1000f84:	1884983a 	sll	r2,r3,r2
 1000f88:	0084303a 	nor	r2,zero,r2
 1000f8c:	1007883a 	mov	r3,r2
 1000f90:	d0a75c17 	ldw	r2,-25232(gp)
 1000f94:	1884703a 	and	r2,r3,r2
 1000f98:	d0a75c15 	stw	r2,-25232(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1000f9c:	d0a75c17 	ldw	r2,-25232(gp)
 1000fa0:	100170fa 	wrctl	ienable,r2
 1000fa4:	e0bffb17 	ldw	r2,-20(fp)
 1000fa8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1000fac:	e0bffc17 	ldw	r2,-16(fp)
 1000fb0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1000fb4:	0005883a 	mov	r2,zero
 1000fb8:	e0bff215 	stw	r2,-56(fp)

		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 1000fbc:	e0bff217 	ldw	r2,-56(fp)
}
 1000fc0:	e037883a 	mov	sp,fp
 1000fc4:	df000017 	ldw	fp,0(sp)
 1000fc8:	dec00104 	addi	sp,sp,4
 1000fcc:	f800283a 	ret

01000fd0 <alt_iic_isr_register>:
 * @param flags
 * @return                 0 if successful, else error (-1)
 */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
 void *isr_context, void *flags)
{
 1000fd0:	defff604 	addi	sp,sp,-40
 1000fd4:	dfc00915 	stw	ra,36(sp)
 1000fd8:	df000815 	stw	fp,32(sp)
 1000fdc:	df000804 	addi	fp,sp,32
 1000fe0:	e13ffc15 	stw	r4,-16(fp)
 1000fe4:	e17ffd15 	stw	r5,-12(fp)
 1000fe8:	e1bffe15 	stw	r6,-8(fp)
 1000fec:	e1ffff15 	stw	r7,-4(fp)
 int rc = -EINVAL;
 1000ff0:	00bffa84 	movi	r2,-22
 1000ff4:	e0bff815 	stw	r2,-32(fp)
 int id = irq;             /* IRQ interpreted as the interrupt ID. */
 1000ff8:	e0bffd17 	ldw	r2,-12(fp)
 1000ffc:	e0bff915 	stw	r2,-28(fp)
 alt_irq_context status;

 if (id < ALT_NIRQ)
 1001000:	e0bff917 	ldw	r2,-28(fp)
 1001004:	10800808 	cmpgei	r2,r2,32
 1001008:	1000231e 	bne	r2,zero,1001098 <alt_iic_isr_register+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 100100c:	0005303a 	rdctl	r2,status
 1001010:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1001014:	e0fffb17 	ldw	r3,-20(fp)
 1001018:	00bfff84 	movi	r2,-2
 100101c:	1884703a 	and	r2,r3,r2
 1001020:	1001703a 	wrctl	status,r2
  
  return context;
 1001024:	e0bffb17 	ldw	r2,-20(fp)
    * interrupts are disabled while the handler tables are updated to ensure
    * that an interrupt doesn't occur while the tables are in an inconsistant
    * state.
    */

   status = alt_irq_disable_all();
 1001028:	e0bffa15 	stw	r2,-24(fp)

   alt_irq[id].handler = isr;
 100102c:	008060f4 	movhi	r2,387
 1001030:	10baf904 	addi	r2,r2,-5148
 1001034:	e0fff917 	ldw	r3,-28(fp)
 1001038:	180690fa 	slli	r3,r3,3
 100103c:	10c5883a 	add	r2,r2,r3
 1001040:	e0fffe17 	ldw	r3,-8(fp)
 1001044:	10c00015 	stw	r3,0(r2)
   alt_irq[id].context = isr_context;
 1001048:	008060f4 	movhi	r2,387
 100104c:	10baf904 	addi	r2,r2,-5148
 1001050:	e0fff917 	ldw	r3,-28(fp)
 1001054:	180690fa 	slli	r3,r3,3
 1001058:	10c5883a 	add	r2,r2,r3
 100105c:	10800104 	addi	r2,r2,4
 1001060:	e0ffff17 	ldw	r3,-4(fp)
 1001064:	10c00015 	stw	r3,0(r2)

   rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 1001068:	e0bffe17 	ldw	r2,-8(fp)
 100106c:	10000526 	beq	r2,zero,1001084 <alt_iic_isr_register+0xb4>
 1001070:	e0bff917 	ldw	r2,-28(fp)
 1001074:	100b883a 	mov	r5,r2
 1001078:	e13ffc17 	ldw	r4,-16(fp)
 100107c:	10268ac0 	call	10268ac <alt_ic_irq_enable>
 1001080:	00000406 	br	1001094 <alt_iic_isr_register+0xc4>
 1001084:	e0bff917 	ldw	r2,-28(fp)
 1001088:	100b883a 	mov	r5,r2
 100108c:	e13ffc17 	ldw	r4,-16(fp)
 1001090:	10269340 	call	1026934 <alt_ic_irq_disable>
 1001094:	e0bff815 	stw	r2,-32(fp)

 //  alt_irq_enable_all(status);
 }

 return rc;
 1001098:	e0bff817 	ldw	r2,-32(fp)
}
 100109c:	e037883a 	mov	sp,fp
 10010a0:	dfc00117 	ldw	ra,4(sp)
 10010a4:	df000017 	ldw	fp,0(sp)
 10010a8:	dec00204 	addi	sp,sp,8
 10010ac:	f800283a 	ret

010010b0 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 10010b0:	defff704 	addi	sp,sp,-36
 10010b4:	dfc00815 	stw	ra,32(sp)
 10010b8:	df000715 	stw	fp,28(sp)
 10010bc:	df000704 	addi	fp,sp,28
 10010c0:	e13fff15 	stw	r4,-4(fp)
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 10010c4:	e03ffb15 	stw	zero,-20(fp)

	vTaskSuspendAll();
 10010c8:	100445c0 	call	100445c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 10010cc:	d0a74017 	ldw	r2,-25344(gp)
 10010d0:	1000031e 	bne	r2,zero,10010e0 <pvPortMalloc+0x30>
		{
			prvHeapInit();
 10010d4:	10013900 	call	1001390 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
 10010d8:	00800044 	movi	r2,1
 10010dc:	d0a74015 	stw	r2,-25344(gp)
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 10010e0:	e0bfff17 	ldw	r2,-4(fp)
 10010e4:	10000d26 	beq	r2,zero,100111c <pvPortMalloc+0x6c>
		{
			xWantedSize += heapSTRUCT_SIZE;
 10010e8:	00800204 	movi	r2,8
 10010ec:	10bfffcc 	andi	r2,r2,65535
 10010f0:	e0ffff17 	ldw	r3,-4(fp)
 10010f4:	1885883a 	add	r2,r3,r2
 10010f8:	e0bfff15 	stw	r2,-4(fp)

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
 10010fc:	e0bfff17 	ldw	r2,-4(fp)
 1001100:	108000cc 	andi	r2,r2,3
 1001104:	10000526 	beq	r2,zero,100111c <pvPortMalloc+0x6c>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 1001108:	e0ffff17 	ldw	r3,-4(fp)
 100110c:	00bfff04 	movi	r2,-4
 1001110:	1884703a 	and	r2,r3,r2
 1001114:	10800104 	addi	r2,r2,4
 1001118:	e0bfff15 	stw	r2,-4(fp)
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 100111c:	e0bfff17 	ldw	r2,-4(fp)
 1001120:	10005126 	beq	r2,zero,1001268 <pvPortMalloc+0x1b8>
 1001124:	e0ffff17 	ldw	r3,-4(fp)
 1001128:	00802034 	movhi	r2,128
 100112c:	10bffec4 	addi	r2,r2,-5
 1001130:	10c04d36 	bltu	r2,r3,1001268 <pvPortMalloc+0x1b8>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 1001134:	d0a73c04 	addi	r2,gp,-25360
 1001138:	e0bffa15 	stw	r2,-24(fp)
			pxBlock = xStart.pxNextFreeBlock;
 100113c:	d0a73c17 	ldw	r2,-25360(gp)
 1001140:	e0bff915 	stw	r2,-28(fp)
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 1001144:	00000506 	br	100115c <pvPortMalloc+0xac>
			{
				pxPreviousBlock = pxBlock;
 1001148:	e0bff917 	ldw	r2,-28(fp)
 100114c:	e0bffa15 	stw	r2,-24(fp)
				pxBlock = pxBlock->pxNextFreeBlock;
 1001150:	e0bff917 	ldw	r2,-28(fp)
 1001154:	10800017 	ldw	r2,0(r2)
 1001158:	e0bff915 	stw	r2,-28(fp)
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 100115c:	e0bff917 	ldw	r2,-28(fp)
 1001160:	10c00117 	ldw	r3,4(r2)
 1001164:	e0bfff17 	ldw	r2,-4(fp)
 1001168:	1880032e 	bgeu	r3,r2,1001178 <pvPortMalloc+0xc8>
 100116c:	e0bff917 	ldw	r2,-28(fp)
 1001170:	10800017 	ldw	r2,0(r2)
 1001174:	103ff41e 	bne	r2,zero,1001148 <__alt_data_end+0xff001148>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 1001178:	e0fff917 	ldw	r3,-28(fp)
 100117c:	d0a73e04 	addi	r2,gp,-25352
 1001180:	18803926 	beq	r3,r2,1001268 <pvPortMalloc+0x1b8>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 1001184:	e0bffa17 	ldw	r2,-24(fp)
 1001188:	10c00017 	ldw	r3,0(r2)
 100118c:	00800204 	movi	r2,8
 1001190:	10bfffcc 	andi	r2,r2,65535
 1001194:	1885883a 	add	r2,r3,r2
 1001198:	e0bffb15 	stw	r2,-20(fp)

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 100119c:	e0bff917 	ldw	r2,-28(fp)
 10011a0:	10c00017 	ldw	r3,0(r2)
 10011a4:	e0bffa17 	ldw	r2,-24(fp)
 10011a8:	10c00015 	stw	r3,0(r2)

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 10011ac:	e0bff917 	ldw	r2,-28(fp)
 10011b0:	10c00117 	ldw	r3,4(r2)
 10011b4:	e0bfff17 	ldw	r2,-4(fp)
 10011b8:	1887c83a 	sub	r3,r3,r2
 10011bc:	00800204 	movi	r2,8
 10011c0:	10bfffcc 	andi	r2,r2,65535
 10011c4:	1085883a 	add	r2,r2,r2
 10011c8:	10c0222e 	bgeu	r2,r3,1001254 <pvPortMalloc+0x1a4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 10011cc:	e0fff917 	ldw	r3,-28(fp)
 10011d0:	e0bfff17 	ldw	r2,-4(fp)
 10011d4:	1885883a 	add	r2,r3,r2
 10011d8:	e0bffd15 	stw	r2,-12(fp)

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 10011dc:	e0bff917 	ldw	r2,-28(fp)
 10011e0:	10c00117 	ldw	r3,4(r2)
 10011e4:	e0bfff17 	ldw	r2,-4(fp)
 10011e8:	1887c83a 	sub	r3,r3,r2
 10011ec:	e0bffd17 	ldw	r2,-12(fp)
 10011f0:	10c00115 	stw	r3,4(r2)
					pxBlock->xBlockSize = xWantedSize;
 10011f4:	e0bff917 	ldw	r2,-28(fp)
 10011f8:	e0ffff17 	ldw	r3,-4(fp)
 10011fc:	10c00115 	stw	r3,4(r2)

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 1001200:	e0bffd17 	ldw	r2,-12(fp)
 1001204:	10800117 	ldw	r2,4(r2)
 1001208:	e0bffe15 	stw	r2,-8(fp)
 100120c:	d0a73c04 	addi	r2,gp,-25360
 1001210:	e0bffc15 	stw	r2,-16(fp)
 1001214:	00000306 	br	1001224 <pvPortMalloc+0x174>
 1001218:	e0bffc17 	ldw	r2,-16(fp)
 100121c:	10800017 	ldw	r2,0(r2)
 1001220:	e0bffc15 	stw	r2,-16(fp)
 1001224:	e0bffc17 	ldw	r2,-16(fp)
 1001228:	10800017 	ldw	r2,0(r2)
 100122c:	10c00117 	ldw	r3,4(r2)
 1001230:	e0bffe17 	ldw	r2,-8(fp)
 1001234:	18bff836 	bltu	r3,r2,1001218 <__alt_data_end+0xff001218>
 1001238:	e0bffc17 	ldw	r2,-16(fp)
 100123c:	10c00017 	ldw	r3,0(r2)
 1001240:	e0bffd17 	ldw	r2,-12(fp)
 1001244:	10c00015 	stw	r3,0(r2)
 1001248:	e0bffc17 	ldw	r2,-16(fp)
 100124c:	e0fffd17 	ldw	r3,-12(fp)
 1001250:	10c00015 	stw	r3,0(r2)
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 1001254:	d0e00117 	ldw	r3,-32764(gp)
 1001258:	e0bff917 	ldw	r2,-28(fp)
 100125c:	10800117 	ldw	r2,4(r2)
 1001260:	1885c83a 	sub	r2,r3,r2
 1001264:	d0a00115 	stw	r2,-32764(gp)
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 1001268:	10044880 	call	1004488 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 100126c:	e0bffb17 	ldw	r2,-20(fp)
}
 1001270:	e037883a 	mov	sp,fp
 1001274:	dfc00117 	ldw	ra,4(sp)
 1001278:	df000017 	ldw	fp,0(sp)
 100127c:	dec00204 	addi	sp,sp,8
 1001280:	f800283a 	ret

01001284 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 1001284:	defff904 	addi	sp,sp,-28
 1001288:	dfc00615 	stw	ra,24(sp)
 100128c:	df000515 	stw	fp,20(sp)
 1001290:	df000504 	addi	fp,sp,20
 1001294:	e13fff15 	stw	r4,-4(fp)
uint8_t *puc = ( uint8_t * ) pv;
 1001298:	e0bfff17 	ldw	r2,-4(fp)
 100129c:	e0bffc15 	stw	r2,-16(fp)
BlockLink_t *pxLink;

	if( pv != NULL )
 10012a0:	e0bfff17 	ldw	r2,-4(fp)
 10012a4:	10002426 	beq	r2,zero,1001338 <vPortFree+0xb4>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 10012a8:	00800204 	movi	r2,8
 10012ac:	10bfffcc 	andi	r2,r2,65535
 10012b0:	0085c83a 	sub	r2,zero,r2
 10012b4:	e0fffc17 	ldw	r3,-16(fp)
 10012b8:	1885883a 	add	r2,r3,r2
 10012bc:	e0bffc15 	stw	r2,-16(fp)

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
 10012c0:	e0bffc17 	ldw	r2,-16(fp)
 10012c4:	e0bffd15 	stw	r2,-12(fp)

		vTaskSuspendAll();
 10012c8:	100445c0 	call	100445c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 10012cc:	e0bffd17 	ldw	r2,-12(fp)
 10012d0:	10800117 	ldw	r2,4(r2)
 10012d4:	e0bffe15 	stw	r2,-8(fp)
 10012d8:	d0a73c04 	addi	r2,gp,-25360
 10012dc:	e0bffb15 	stw	r2,-20(fp)
 10012e0:	00000306 	br	10012f0 <vPortFree+0x6c>
 10012e4:	e0bffb17 	ldw	r2,-20(fp)
 10012e8:	10800017 	ldw	r2,0(r2)
 10012ec:	e0bffb15 	stw	r2,-20(fp)
 10012f0:	e0bffb17 	ldw	r2,-20(fp)
 10012f4:	10800017 	ldw	r2,0(r2)
 10012f8:	10c00117 	ldw	r3,4(r2)
 10012fc:	e0bffe17 	ldw	r2,-8(fp)
 1001300:	18bff836 	bltu	r3,r2,10012e4 <__alt_data_end+0xff0012e4>
 1001304:	e0bffb17 	ldw	r2,-20(fp)
 1001308:	10c00017 	ldw	r3,0(r2)
 100130c:	e0bffd17 	ldw	r2,-12(fp)
 1001310:	10c00015 	stw	r3,0(r2)
 1001314:	e0bffb17 	ldw	r2,-20(fp)
 1001318:	e0fffd17 	ldw	r3,-12(fp)
 100131c:	10c00015 	stw	r3,0(r2)
			xFreeBytesRemaining += pxLink->xBlockSize;
 1001320:	e0bffd17 	ldw	r2,-12(fp)
 1001324:	10c00117 	ldw	r3,4(r2)
 1001328:	d0a00117 	ldw	r2,-32764(gp)
 100132c:	1885883a 	add	r2,r3,r2
 1001330:	d0a00115 	stw	r2,-32764(gp)
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 1001334:	10044880 	call	1004488 <xTaskResumeAll>
	}
}
 1001338:	0001883a 	nop
 100133c:	e037883a 	mov	sp,fp
 1001340:	dfc00117 	ldw	ra,4(sp)
 1001344:	df000017 	ldw	fp,0(sp)
 1001348:	dec00204 	addi	sp,sp,8
 100134c:	f800283a 	ret

01001350 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 1001350:	deffff04 	addi	sp,sp,-4
 1001354:	df000015 	stw	fp,0(sp)
 1001358:	d839883a 	mov	fp,sp
	return xFreeBytesRemaining;
 100135c:	d0a00117 	ldw	r2,-32764(gp)
}
 1001360:	e037883a 	mov	sp,fp
 1001364:	df000017 	ldw	fp,0(sp)
 1001368:	dec00104 	addi	sp,sp,4
 100136c:	f800283a 	ret

01001370 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 1001370:	deffff04 	addi	sp,sp,-4
 1001374:	df000015 	stw	fp,0(sp)
 1001378:	d839883a 	mov	fp,sp
	/* This just exists to keep the linker quiet. */
}
 100137c:	0001883a 	nop
 1001380:	e037883a 	mov	sp,fp
 1001384:	df000017 	ldw	fp,0(sp)
 1001388:	dec00104 	addi	sp,sp,4
 100138c:	f800283a 	ret

01001390 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 1001390:	defffd04 	addi	sp,sp,-12
 1001394:	df000215 	stw	fp,8(sp)
 1001398:	df000204 	addi	fp,sp,8
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 100139c:	008040f4 	movhi	r2,259
 10013a0:	10b9b504 	addi	r2,r2,-6444
 10013a4:	00ffff04 	movi	r3,-4
 10013a8:	10c4703a 	and	r2,r2,r3
 10013ac:	e0bffe15 	stw	r2,-8(fp)

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 10013b0:	e0bffe17 	ldw	r2,-8(fp)
 10013b4:	d0a73c15 	stw	r2,-25360(gp)
	xStart.xBlockSize = ( size_t ) 0;
 10013b8:	d0273d15 	stw	zero,-25356(gp)

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 10013bc:	00802034 	movhi	r2,128
 10013c0:	10bfff04 	addi	r2,r2,-4
 10013c4:	d0a73f15 	stw	r2,-25348(gp)
	xEnd.pxNextFreeBlock = NULL;
 10013c8:	d0273e15 	stw	zero,-25352(gp)

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 10013cc:	e0bffe17 	ldw	r2,-8(fp)
 10013d0:	e0bfff15 	stw	r2,-4(fp)
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 10013d4:	e0ffff17 	ldw	r3,-4(fp)
 10013d8:	00802034 	movhi	r2,128
 10013dc:	10bfff04 	addi	r2,r2,-4
 10013e0:	18800115 	stw	r2,4(r3)
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 10013e4:	e0bfff17 	ldw	r2,-4(fp)
 10013e8:	d0e73e04 	addi	r3,gp,-25352
 10013ec:	10c00015 	stw	r3,0(r2)
}
 10013f0:	0001883a 	nop
 10013f4:	e037883a 	mov	sp,fp
 10013f8:	df000017 	ldw	fp,0(sp)
 10013fc:	dec00104 	addi	sp,sp,4
 1001400:	f800283a 	ret

01001404 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 1001404:	defffb04 	addi	sp,sp,-20
 1001408:	dfc00415 	stw	ra,16(sp)
 100140c:	df000315 	stw	fp,12(sp)
 1001410:	df000304 	addi	fp,sp,12
 1001414:	e13ffe15 	stw	r4,-8(fp)
 1001418:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = xQueue;
 100141c:	e0bffe17 	ldw	r2,-8(fp)
 1001420:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 1001424:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 1001428:	e0bffd17 	ldw	r2,-12(fp)
 100142c:	10c00017 	ldw	r3,0(r2)
 1001430:	e0bffd17 	ldw	r2,-12(fp)
 1001434:	11000f17 	ldw	r4,60(r2)
 1001438:	e0bffd17 	ldw	r2,-12(fp)
 100143c:	10801017 	ldw	r2,64(r2)
 1001440:	2085383a 	mul	r2,r4,r2
 1001444:	1887883a 	add	r3,r3,r2
 1001448:	e0bffd17 	ldw	r2,-12(fp)
 100144c:	10c00215 	stw	r3,8(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 1001450:	e0bffd17 	ldw	r2,-12(fp)
 1001454:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
 1001458:	e0bffd17 	ldw	r2,-12(fp)
 100145c:	10c00017 	ldw	r3,0(r2)
 1001460:	e0bffd17 	ldw	r2,-12(fp)
 1001464:	10c00115 	stw	r3,4(r2)
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 1001468:	e0bffd17 	ldw	r2,-12(fp)
 100146c:	10c00017 	ldw	r3,0(r2)
 1001470:	e0bffd17 	ldw	r2,-12(fp)
 1001474:	10800f17 	ldw	r2,60(r2)
 1001478:	113fffc4 	addi	r4,r2,-1
 100147c:	e0bffd17 	ldw	r2,-12(fp)
 1001480:	10801017 	ldw	r2,64(r2)
 1001484:	2085383a 	mul	r2,r4,r2
 1001488:	1887883a 	add	r3,r3,r2
 100148c:	e0bffd17 	ldw	r2,-12(fp)
 1001490:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
 1001494:	e0bffd17 	ldw	r2,-12(fp)
 1001498:	00ffffc4 	movi	r3,-1
 100149c:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
 10014a0:	e0bffd17 	ldw	r2,-12(fp)
 10014a4:	00ffffc4 	movi	r3,-1
 10014a8:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
 10014ac:	e0bfff17 	ldw	r2,-4(fp)
 10014b0:	10000a1e 	bne	r2,zero,10014dc <xQueueGenericReset+0xd8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 10014b4:	e0bffd17 	ldw	r2,-12(fp)
 10014b8:	10800417 	ldw	r2,16(r2)
 10014bc:	10000f26 	beq	r2,zero,10014fc <xQueueGenericReset+0xf8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 10014c0:	e0bffd17 	ldw	r2,-12(fp)
 10014c4:	10800404 	addi	r2,r2,16
 10014c8:	1009883a 	mov	r4,r2
 10014cc:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 10014d0:	10000a26 	beq	r2,zero,10014fc <xQueueGenericReset+0xf8>
				{
					queueYIELD_IF_USING_PREEMPTION();
 10014d4:	003b683a 	trap	0
 10014d8:	00000806 	br	10014fc <xQueueGenericReset+0xf8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 10014dc:	e0bffd17 	ldw	r2,-12(fp)
 10014e0:	10800404 	addi	r2,r2,16
 10014e4:	1009883a 	mov	r4,r2
 10014e8:	100099c0 	call	100099c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 10014ec:	e0bffd17 	ldw	r2,-12(fp)
 10014f0:	10800904 	addi	r2,r2,36
 10014f4:	1009883a 	mov	r4,r2
 10014f8:	100099c0 	call	100099c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 10014fc:	10053c40 	call	10053c4 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 1001500:	00800044 	movi	r2,1
}
 1001504:	e037883a 	mov	sp,fp
 1001508:	dfc00117 	ldw	ra,4(sp)
 100150c:	df000017 	ldw	fp,0(sp)
 1001510:	dec00204 	addi	sp,sp,8
 1001514:	f800283a 	ret

01001518 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 1001518:	defff704 	addi	sp,sp,-36
 100151c:	dfc00815 	stw	ra,32(sp)
 1001520:	df000715 	stw	fp,28(sp)
 1001524:	df000704 	addi	fp,sp,28
 1001528:	e13ffd15 	stw	r4,-12(fp)
 100152c:	e17ffe15 	stw	r5,-8(fp)
 1001530:	3005883a 	mov	r2,r6
 1001534:	e0bfff05 	stb	r2,-4(fp)
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
 1001538:	e0bffe17 	ldw	r2,-8(fp)
 100153c:	1000021e 	bne	r2,zero,1001548 <xQueueGenericCreate+0x30>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
 1001540:	e03ffa15 	stw	zero,-24(fp)
 1001544:	00000406 	br	1001558 <xQueueGenericCreate+0x40>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1001548:	e0fffd17 	ldw	r3,-12(fp)
 100154c:	e0bffe17 	ldw	r2,-8(fp)
 1001550:	1885383a 	mul	r2,r3,r2
 1001554:	e0bffa15 	stw	r2,-24(fp)
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 1001558:	e0bffa17 	ldw	r2,-24(fp)
 100155c:	10801204 	addi	r2,r2,72
 1001560:	1009883a 	mov	r4,r2
 1001564:	10010b00 	call	10010b0 <pvPortMalloc>
 1001568:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
 100156c:	e0bffb17 	ldw	r2,-20(fp)
 1001570:	10000d26 	beq	r2,zero,10015a8 <xQueueGenericCreate+0x90>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 1001574:	e0bffb17 	ldw	r2,-20(fp)
 1001578:	e0bffc15 	stw	r2,-16(fp)
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 100157c:	e0bffc17 	ldw	r2,-16(fp)
 1001580:	10801204 	addi	r2,r2,72
 1001584:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 1001588:	e0ffff03 	ldbu	r3,-4(fp)
 100158c:	e0bffb17 	ldw	r2,-20(fp)
 1001590:	d8800015 	stw	r2,0(sp)
 1001594:	180f883a 	mov	r7,r3
 1001598:	e1bffc17 	ldw	r6,-16(fp)
 100159c:	e17ffe17 	ldw	r5,-8(fp)
 10015a0:	e13ffd17 	ldw	r4,-12(fp)
 10015a4:	10015c00 	call	10015c0 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 10015a8:	e0bffb17 	ldw	r2,-20(fp)
	}
 10015ac:	e037883a 	mov	sp,fp
 10015b0:	dfc00117 	ldw	ra,4(sp)
 10015b4:	df000017 	ldw	fp,0(sp)
 10015b8:	dec00204 	addi	sp,sp,8
 10015bc:	f800283a 	ret

010015c0 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 10015c0:	defffa04 	addi	sp,sp,-24
 10015c4:	dfc00515 	stw	ra,20(sp)
 10015c8:	df000415 	stw	fp,16(sp)
 10015cc:	df000404 	addi	fp,sp,16
 10015d0:	e13ffc15 	stw	r4,-16(fp)
 10015d4:	e17ffd15 	stw	r5,-12(fp)
 10015d8:	e1bffe15 	stw	r6,-8(fp)
 10015dc:	3805883a 	mov	r2,r7
 10015e0:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 10015e4:	e0bffd17 	ldw	r2,-12(fp)
 10015e8:	1000041e 	bne	r2,zero,10015fc <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 10015ec:	e0800217 	ldw	r2,8(fp)
 10015f0:	e0c00217 	ldw	r3,8(fp)
 10015f4:	10c00015 	stw	r3,0(r2)
 10015f8:	00000306 	br	1001608 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 10015fc:	e0800217 	ldw	r2,8(fp)
 1001600:	e0fffe17 	ldw	r3,-8(fp)
 1001604:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 1001608:	e0800217 	ldw	r2,8(fp)
 100160c:	e0fffc17 	ldw	r3,-16(fp)
 1001610:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
 1001614:	e0800217 	ldw	r2,8(fp)
 1001618:	e0fffd17 	ldw	r3,-12(fp)
 100161c:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 1001620:	01400044 	movi	r5,1
 1001624:	e1000217 	ldw	r4,8(fp)
 1001628:	10014040 	call	1001404 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 100162c:	0001883a 	nop
 1001630:	e037883a 	mov	sp,fp
 1001634:	dfc00117 	ldw	ra,4(sp)
 1001638:	df000017 	ldw	fp,0(sp)
 100163c:	dec00204 	addi	sp,sp,8
 1001640:	f800283a 	ret

01001644 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 1001644:	defffd04 	addi	sp,sp,-12
 1001648:	dfc00215 	stw	ra,8(sp)
 100164c:	df000115 	stw	fp,4(sp)
 1001650:	df000104 	addi	fp,sp,4
 1001654:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
 1001658:	e0bfff17 	ldw	r2,-4(fp)
 100165c:	10000b26 	beq	r2,zero,100168c <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 1001660:	e0bfff17 	ldw	r2,-4(fp)
 1001664:	10000215 	stw	zero,8(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1001668:	e0bfff17 	ldw	r2,-4(fp)
 100166c:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 1001670:	e0bfff17 	ldw	r2,-4(fp)
 1001674:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 1001678:	000f883a 	mov	r7,zero
 100167c:	000d883a 	mov	r6,zero
 1001680:	000b883a 	mov	r5,zero
 1001684:	e13fff17 	ldw	r4,-4(fp)
 1001688:	10018840 	call	1001884 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 100168c:	0001883a 	nop
 1001690:	e037883a 	mov	sp,fp
 1001694:	dfc00117 	ldw	ra,4(sp)
 1001698:	df000017 	ldw	fp,0(sp)
 100169c:	dec00204 	addi	sp,sp,8
 10016a0:	f800283a 	ret

010016a4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 10016a4:	defffa04 	addi	sp,sp,-24
 10016a8:	dfc00515 	stw	ra,20(sp)
 10016ac:	df000415 	stw	fp,16(sp)
 10016b0:	df000404 	addi	fp,sp,16
 10016b4:	2005883a 	mov	r2,r4
 10016b8:	e0bfff05 	stb	r2,-4(fp)
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 10016bc:	00800044 	movi	r2,1
 10016c0:	e0bffc15 	stw	r2,-16(fp)
 10016c4:	e03ffd15 	stw	zero,-12(fp)

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 10016c8:	e0bfff03 	ldbu	r2,-4(fp)
 10016cc:	100d883a 	mov	r6,r2
 10016d0:	e17ffd17 	ldw	r5,-12(fp)
 10016d4:	e13ffc17 	ldw	r4,-16(fp)
 10016d8:	10015180 	call	1001518 <xQueueGenericCreate>
 10016dc:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 10016e0:	e13ffe17 	ldw	r4,-8(fp)
 10016e4:	10016440 	call	1001644 <prvInitialiseMutex>

		return xNewQueue;
 10016e8:	e0bffe17 	ldw	r2,-8(fp)
	}
 10016ec:	e037883a 	mov	sp,fp
 10016f0:	dfc00117 	ldw	ra,4(sp)
 10016f4:	df000017 	ldw	fp,0(sp)
 10016f8:	dec00204 	addi	sp,sp,8
 10016fc:	f800283a 	ret

01001700 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 1001700:	defffa04 	addi	sp,sp,-24
 1001704:	dfc00515 	stw	ra,20(sp)
 1001708:	df000415 	stw	fp,16(sp)
 100170c:	dc000315 	stw	r16,12(sp)
 1001710:	df000404 	addi	fp,sp,16
 1001714:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 1001718:	e0bffe17 	ldw	r2,-8(fp)
 100171c:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 1001720:	e0bffd17 	ldw	r2,-12(fp)
 1001724:	14000217 	ldw	r16,8(r2)
 1001728:	1004fcc0 	call	1004fcc <xTaskGetCurrentTaskHandle>
 100172c:	8080101e 	bne	r16,r2,1001770 <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 1001730:	e0bffd17 	ldw	r2,-12(fp)
 1001734:	10800317 	ldw	r2,12(r2)
 1001738:	10ffffc4 	addi	r3,r2,-1
 100173c:	e0bffd17 	ldw	r2,-12(fp)
 1001740:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 1001744:	e0bffd17 	ldw	r2,-12(fp)
 1001748:	10800317 	ldw	r2,12(r2)
 100174c:	1000051e 	bne	r2,zero,1001764 <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 1001750:	000f883a 	mov	r7,zero
 1001754:	000d883a 	mov	r6,zero
 1001758:	000b883a 	mov	r5,zero
 100175c:	e13ffd17 	ldw	r4,-12(fp)
 1001760:	10018840 	call	1001884 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 1001764:	00800044 	movi	r2,1
 1001768:	e0bffc15 	stw	r2,-16(fp)
 100176c:	00000106 	br	1001774 <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 1001770:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 1001774:	e0bffc17 	ldw	r2,-16(fp)
	}
 1001778:	e6ffff04 	addi	sp,fp,-4
 100177c:	dfc00217 	ldw	ra,8(sp)
 1001780:	df000117 	ldw	fp,4(sp)
 1001784:	dc000017 	ldw	r16,0(sp)
 1001788:	dec00304 	addi	sp,sp,12
 100178c:	f800283a 	ret

01001790 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 1001790:	defff904 	addi	sp,sp,-28
 1001794:	dfc00615 	stw	ra,24(sp)
 1001798:	df000515 	stw	fp,20(sp)
 100179c:	dc000415 	stw	r16,16(sp)
 10017a0:	df000504 	addi	fp,sp,20
 10017a4:	e13ffd15 	stw	r4,-12(fp)
 10017a8:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 10017ac:	e0bffd17 	ldw	r2,-12(fp)
 10017b0:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 10017b4:	e0bffc17 	ldw	r2,-16(fp)
 10017b8:	14000217 	ldw	r16,8(r2)
 10017bc:	1004fcc0 	call	1004fcc <xTaskGetCurrentTaskHandle>
 10017c0:	8080081e 	bne	r16,r2,10017e4 <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 10017c4:	e0bffc17 	ldw	r2,-16(fp)
 10017c8:	10800317 	ldw	r2,12(r2)
 10017cc:	10c00044 	addi	r3,r2,1
 10017d0:	e0bffc17 	ldw	r2,-16(fp)
 10017d4:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
 10017d8:	00800044 	movi	r2,1
 10017dc:	e0bffb15 	stw	r2,-20(fp)
 10017e0:	00000b06 	br	1001810 <xQueueTakeMutexRecursive+0x80>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 10017e4:	e17ffe17 	ldw	r5,-8(fp)
 10017e8:	e13ffc17 	ldw	r4,-16(fp)
 10017ec:	1001da40 	call	1001da4 <xQueueSemaphoreTake>
 10017f0:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
 10017f4:	e0bffb17 	ldw	r2,-20(fp)
 10017f8:	10000526 	beq	r2,zero,1001810 <xQueueTakeMutexRecursive+0x80>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 10017fc:	e0bffc17 	ldw	r2,-16(fp)
 1001800:	10800317 	ldw	r2,12(r2)
 1001804:	10c00044 	addi	r3,r2,1
 1001808:	e0bffc17 	ldw	r2,-16(fp)
 100180c:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 1001810:	e0bffb17 	ldw	r2,-20(fp)
	}
 1001814:	e6ffff04 	addi	sp,fp,-4
 1001818:	dfc00217 	ldw	ra,8(sp)
 100181c:	df000117 	ldw	fp,4(sp)
 1001820:	dc000017 	ldw	r16,0(sp)
 1001824:	dec00304 	addi	sp,sp,12
 1001828:	f800283a 	ret

0100182c <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 100182c:	defffb04 	addi	sp,sp,-20
 1001830:	dfc00415 	stw	ra,16(sp)
 1001834:	df000315 	stw	fp,12(sp)
 1001838:	df000304 	addi	fp,sp,12
 100183c:	e13ffe15 	stw	r4,-8(fp)
 1001840:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 1001844:	01800084 	movi	r6,2
 1001848:	000b883a 	mov	r5,zero
 100184c:	e13ffe17 	ldw	r4,-8(fp)
 1001850:	10015180 	call	1001518 <xQueueGenericCreate>
 1001854:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
 1001858:	e0bffd17 	ldw	r2,-12(fp)
 100185c:	10000326 	beq	r2,zero,100186c <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 1001860:	e0bffd17 	ldw	r2,-12(fp)
 1001864:	e0ffff17 	ldw	r3,-4(fp)
 1001868:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 100186c:	e0bffd17 	ldw	r2,-12(fp)
	}
 1001870:	e037883a 	mov	sp,fp
 1001874:	dfc00117 	ldw	ra,4(sp)
 1001878:	df000017 	ldw	fp,0(sp)
 100187c:	dec00204 	addi	sp,sp,8
 1001880:	f800283a 	ret

01001884 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 1001884:	defff504 	addi	sp,sp,-44
 1001888:	dfc00a15 	stw	ra,40(sp)
 100188c:	df000915 	stw	fp,36(sp)
 1001890:	df000904 	addi	fp,sp,36
 1001894:	e13ffc15 	stw	r4,-16(fp)
 1001898:	e17ffd15 	stw	r5,-12(fp)
 100189c:	e1bffe15 	stw	r6,-8(fp)
 10018a0:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 10018a4:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 10018a8:	e0bffc17 	ldw	r2,-16(fp)
 10018ac:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 10018b0:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 10018b4:	e0bff817 	ldw	r2,-32(fp)
 10018b8:	10c00e17 	ldw	r3,56(r2)
 10018bc:	e0bff817 	ldw	r2,-32(fp)
 10018c0:	10800f17 	ldw	r2,60(r2)
 10018c4:	18800336 	bltu	r3,r2,10018d4 <xQueueGenericSend+0x50>
 10018c8:	e0bfff17 	ldw	r2,-4(fp)
 10018cc:	10800098 	cmpnei	r2,r2,2
 10018d0:	1000151e 	bne	r2,zero,1001928 <xQueueGenericSend+0xa4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 10018d4:	e1bfff17 	ldw	r6,-4(fp)
 10018d8:	e17ffd17 	ldw	r5,-12(fp)
 10018dc:	e13ff817 	ldw	r4,-32(fp)
 10018e0:	100241c0 	call	100241c <prvCopyDataToQueue>
 10018e4:	e0bff915 	stw	r2,-28(fp)

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 10018e8:	e0bff817 	ldw	r2,-32(fp)
 10018ec:	10800917 	ldw	r2,36(r2)
 10018f0:	10000726 	beq	r2,zero,1001910 <xQueueGenericSend+0x8c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 10018f4:	e0bff817 	ldw	r2,-32(fp)
 10018f8:	10800904 	addi	r2,r2,36
 10018fc:	1009883a 	mov	r4,r2
 1001900:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 1001904:	10000526 	beq	r2,zero,100191c <xQueueGenericSend+0x98>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 1001908:	003b683a 	trap	0
 100190c:	00000306 	br	100191c <xQueueGenericSend+0x98>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 1001910:	e0bff917 	ldw	r2,-28(fp)
 1001914:	10000126 	beq	r2,zero,100191c <xQueueGenericSend+0x98>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 1001918:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 100191c:	10053c40 	call	10053c4 <vTaskExitCritical>
				return pdPASS;
 1001920:	00800044 	movi	r2,1
 1001924:	00003f06 	br	1001a24 <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 1001928:	e0bffe17 	ldw	r2,-8(fp)
 100192c:	1000031e 	bne	r2,zero,100193c <xQueueGenericSend+0xb8>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 1001930:	10053c40 	call	10053c4 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 1001934:	0005883a 	mov	r2,zero
 1001938:	00003a06 	br	1001a24 <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
 100193c:	e0bff717 	ldw	r2,-36(fp)
 1001940:	1000051e 	bne	r2,zero,1001958 <xQueueGenericSend+0xd4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 1001944:	e0bffa04 	addi	r2,fp,-24
 1001948:	1009883a 	mov	r4,r2
 100194c:	1004bd80 	call	1004bd8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 1001950:	00800044 	movi	r2,1
 1001954:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 1001958:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 100195c:	100445c0 	call	100445c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 1001960:	10053700 	call	1005370 <vTaskEnterCritical>
 1001964:	e0bff817 	ldw	r2,-32(fp)
 1001968:	10801103 	ldbu	r2,68(r2)
 100196c:	10803fcc 	andi	r2,r2,255
 1001970:	1080201c 	xori	r2,r2,128
 1001974:	10bfe004 	addi	r2,r2,-128
 1001978:	10bfffd8 	cmpnei	r2,r2,-1
 100197c:	1000021e 	bne	r2,zero,1001988 <xQueueGenericSend+0x104>
 1001980:	e0bff817 	ldw	r2,-32(fp)
 1001984:	10001105 	stb	zero,68(r2)
 1001988:	e0bff817 	ldw	r2,-32(fp)
 100198c:	10801143 	ldbu	r2,69(r2)
 1001990:	10803fcc 	andi	r2,r2,255
 1001994:	1080201c 	xori	r2,r2,128
 1001998:	10bfe004 	addi	r2,r2,-128
 100199c:	10bfffd8 	cmpnei	r2,r2,-1
 10019a0:	1000021e 	bne	r2,zero,10019ac <xQueueGenericSend+0x128>
 10019a4:	e0bff817 	ldw	r2,-32(fp)
 10019a8:	10001145 	stb	zero,69(r2)
 10019ac:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 10019b0:	e0fffe04 	addi	r3,fp,-8
 10019b4:	e0bffa04 	addi	r2,fp,-24
 10019b8:	180b883a 	mov	r5,r3
 10019bc:	1009883a 	mov	r4,r2
 10019c0:	1004c140 	call	1004c14 <xTaskCheckForTimeOut>
 10019c4:	1000131e 	bne	r2,zero,1001a14 <xQueueGenericSend+0x190>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 10019c8:	e13ff817 	ldw	r4,-32(fp)
 10019cc:	10027d00 	call	10027d0 <prvIsQueueFull>
 10019d0:	10000c26 	beq	r2,zero,1001a04 <xQueueGenericSend+0x180>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 10019d4:	e0bff817 	ldw	r2,-32(fp)
 10019d8:	10800404 	addi	r2,r2,16
 10019dc:	e0fffe17 	ldw	r3,-8(fp)
 10019e0:	180b883a 	mov	r5,r3
 10019e4:	1009883a 	mov	r4,r2
 10019e8:	100491c0 	call	100491c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 10019ec:	e13ff817 	ldw	r4,-32(fp)
 10019f0:	10026440 	call	1002644 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 10019f4:	10044880 	call	1004488 <xTaskResumeAll>
 10019f8:	103fad1e 	bne	r2,zero,10018b0 <__alt_data_end+0xff0018b0>
				{
					portYIELD_WITHIN_API();
 10019fc:	003b683a 	trap	0
 1001a00:	003fab06 	br	10018b0 <__alt_data_end+0xff0018b0>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 1001a04:	e13ff817 	ldw	r4,-32(fp)
 1001a08:	10026440 	call	1002644 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 1001a0c:	10044880 	call	1004488 <xTaskResumeAll>
 1001a10:	003fa706 	br	10018b0 <__alt_data_end+0xff0018b0>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 1001a14:	e13ff817 	ldw	r4,-32(fp)
 1001a18:	10026440 	call	1002644 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 1001a1c:	10044880 	call	1004488 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 1001a20:	0005883a 	mov	r2,zero
		}
	} /*lint -restore */
}
 1001a24:	e037883a 	mov	sp,fp
 1001a28:	dfc00117 	ldw	ra,4(sp)
 1001a2c:	df000017 	ldw	fp,0(sp)
 1001a30:	dec00204 	addi	sp,sp,8
 1001a34:	f800283a 	ret

01001a38 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 1001a38:	defff604 	addi	sp,sp,-40
 1001a3c:	dfc00915 	stw	ra,36(sp)
 1001a40:	df000815 	stw	fp,32(sp)
 1001a44:	df000804 	addi	fp,sp,32
 1001a48:	e13ffc15 	stw	r4,-16(fp)
 1001a4c:	e17ffd15 	stw	r5,-12(fp)
 1001a50:	e1bffe15 	stw	r6,-8(fp)
 1001a54:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 1001a58:	e0bffc17 	ldw	r2,-16(fp)
 1001a5c:	e0bff915 	stw	r2,-28(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1001a60:	e03ffa15 	stw	zero,-24(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1001a64:	e0bff917 	ldw	r2,-28(fp)
 1001a68:	10c00e17 	ldw	r3,56(r2)
 1001a6c:	e0bff917 	ldw	r2,-28(fp)
 1001a70:	10800f17 	ldw	r2,60(r2)
 1001a74:	18800336 	bltu	r3,r2,1001a84 <xQueueGenericSendFromISR+0x4c>
 1001a78:	e0bfff17 	ldw	r2,-4(fp)
 1001a7c:	10800098 	cmpnei	r2,r2,2
 1001a80:	1000201e 	bne	r2,zero,1001b04 <xQueueGenericSendFromISR+0xcc>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 1001a84:	e0bff917 	ldw	r2,-28(fp)
 1001a88:	10801143 	ldbu	r2,69(r2)
 1001a8c:	e0bffb05 	stb	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1001a90:	e1bfff17 	ldw	r6,-4(fp)
 1001a94:	e17ffd17 	ldw	r5,-12(fp)
 1001a98:	e13ff917 	ldw	r4,-28(fp)
 1001a9c:	100241c0 	call	100241c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 1001aa0:	e0bffb07 	ldb	r2,-20(fp)
 1001aa4:	10bfffd8 	cmpnei	r2,r2,-1
 1001aa8:	10000e1e 	bne	r2,zero,1001ae4 <xQueueGenericSendFromISR+0xac>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1001aac:	e0bff917 	ldw	r2,-28(fp)
 1001ab0:	10800917 	ldw	r2,36(r2)
 1001ab4:	10001026 	beq	r2,zero,1001af8 <xQueueGenericSendFromISR+0xc0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1001ab8:	e0bff917 	ldw	r2,-28(fp)
 1001abc:	10800904 	addi	r2,r2,36
 1001ac0:	1009883a 	mov	r4,r2
 1001ac4:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 1001ac8:	10000b26 	beq	r2,zero,1001af8 <xQueueGenericSendFromISR+0xc0>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 1001acc:	e0bffe17 	ldw	r2,-8(fp)
 1001ad0:	10000926 	beq	r2,zero,1001af8 <xQueueGenericSendFromISR+0xc0>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 1001ad4:	e0bffe17 	ldw	r2,-8(fp)
 1001ad8:	00c00044 	movi	r3,1
 1001adc:	10c00015 	stw	r3,0(r2)
 1001ae0:	00000506 	br	1001af8 <xQueueGenericSendFromISR+0xc0>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1001ae4:	e0bffb03 	ldbu	r2,-20(fp)
 1001ae8:	10800044 	addi	r2,r2,1
 1001aec:	1007883a 	mov	r3,r2
 1001af0:	e0bff917 	ldw	r2,-28(fp)
 1001af4:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 1001af8:	00800044 	movi	r2,1
 1001afc:	e0bff815 	stw	r2,-32(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
 1001b00:	00000106 	br	1001b08 <xQueueGenericSendFromISR+0xd0>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 1001b04:	e03ff815 	stw	zero,-32(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1001b08:	e0bff817 	ldw	r2,-32(fp)
}
 1001b0c:	e037883a 	mov	sp,fp
 1001b10:	dfc00117 	ldw	ra,4(sp)
 1001b14:	df000017 	ldw	fp,0(sp)
 1001b18:	dec00204 	addi	sp,sp,8
 1001b1c:	f800283a 	ret

01001b20 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 1001b20:	defff704 	addi	sp,sp,-36
 1001b24:	dfc00815 	stw	ra,32(sp)
 1001b28:	df000715 	stw	fp,28(sp)
 1001b2c:	df000704 	addi	fp,sp,28
 1001b30:	e13ffe15 	stw	r4,-8(fp)
 1001b34:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 1001b38:	e0bffe17 	ldw	r2,-8(fp)
 1001b3c:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1001b40:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1001b44:	e0bffa17 	ldw	r2,-24(fp)
 1001b48:	10800e17 	ldw	r2,56(r2)
 1001b4c:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 1001b50:	e0bffa17 	ldw	r2,-24(fp)
 1001b54:	10800f17 	ldw	r2,60(r2)
 1001b58:	e0fffc17 	ldw	r3,-16(fp)
 1001b5c:	1880202e 	bgeu	r3,r2,1001be0 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 1001b60:	e0bffa17 	ldw	r2,-24(fp)
 1001b64:	10801143 	ldbu	r2,69(r2)
 1001b68:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1001b6c:	e0bffc17 	ldw	r2,-16(fp)
 1001b70:	10c00044 	addi	r3,r2,1
 1001b74:	e0bffa17 	ldw	r2,-24(fp)
 1001b78:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 1001b7c:	e0bffd07 	ldb	r2,-12(fp)
 1001b80:	10bfffd8 	cmpnei	r2,r2,-1
 1001b84:	10000e1e 	bne	r2,zero,1001bc0 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1001b88:	e0bffa17 	ldw	r2,-24(fp)
 1001b8c:	10800917 	ldw	r2,36(r2)
 1001b90:	10001026 	beq	r2,zero,1001bd4 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1001b94:	e0bffa17 	ldw	r2,-24(fp)
 1001b98:	10800904 	addi	r2,r2,36
 1001b9c:	1009883a 	mov	r4,r2
 1001ba0:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 1001ba4:	10000b26 	beq	r2,zero,1001bd4 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 1001ba8:	e0bfff17 	ldw	r2,-4(fp)
 1001bac:	10000926 	beq	r2,zero,1001bd4 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 1001bb0:	e0bfff17 	ldw	r2,-4(fp)
 1001bb4:	00c00044 	movi	r3,1
 1001bb8:	10c00015 	stw	r3,0(r2)
 1001bbc:	00000506 	br	1001bd4 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1001bc0:	e0bffd03 	ldbu	r2,-12(fp)
 1001bc4:	10800044 	addi	r2,r2,1
 1001bc8:	1007883a 	mov	r3,r2
 1001bcc:	e0bffa17 	ldw	r2,-24(fp)
 1001bd0:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 1001bd4:	00800044 	movi	r2,1
 1001bd8:	e0bff915 	stw	r2,-28(fp)
 1001bdc:	00000106 	br	1001be4 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 1001be0:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1001be4:	e0bff917 	ldw	r2,-28(fp)
}
 1001be8:	e037883a 	mov	sp,fp
 1001bec:	dfc00117 	ldw	ra,4(sp)
 1001bf0:	df000017 	ldw	fp,0(sp)
 1001bf4:	dec00204 	addi	sp,sp,8
 1001bf8:	f800283a 	ret

01001bfc <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 1001bfc:	defff604 	addi	sp,sp,-40
 1001c00:	dfc00915 	stw	ra,36(sp)
 1001c04:	df000815 	stw	fp,32(sp)
 1001c08:	df000804 	addi	fp,sp,32
 1001c0c:	e13ffd15 	stw	r4,-12(fp)
 1001c10:	e17ffe15 	stw	r5,-8(fp)
 1001c14:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 1001c18:	e03ff815 	stw	zero,-32(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 1001c1c:	e0bffd17 	ldw	r2,-12(fp)
 1001c20:	e0bff915 	stw	r2,-28(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 1001c24:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1001c28:	e0bff917 	ldw	r2,-28(fp)
 1001c2c:	10800e17 	ldw	r2,56(r2)
 1001c30:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1001c34:	e0bffa17 	ldw	r2,-24(fp)
 1001c38:	10001326 	beq	r2,zero,1001c88 <xQueueReceive+0x8c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1001c3c:	e17ffe17 	ldw	r5,-8(fp)
 1001c40:	e13ff917 	ldw	r4,-28(fp)
 1001c44:	10025a80 	call	10025a8 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1001c48:	e0bffa17 	ldw	r2,-24(fp)
 1001c4c:	10ffffc4 	addi	r3,r2,-1
 1001c50:	e0bff917 	ldw	r2,-28(fp)
 1001c54:	10c00e15 	stw	r3,56(r2)

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1001c58:	e0bff917 	ldw	r2,-28(fp)
 1001c5c:	10800417 	ldw	r2,16(r2)
 1001c60:	10000626 	beq	r2,zero,1001c7c <xQueueReceive+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1001c64:	e0bff917 	ldw	r2,-28(fp)
 1001c68:	10800404 	addi	r2,r2,16
 1001c6c:	1009883a 	mov	r4,r2
 1001c70:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 1001c74:	10000126 	beq	r2,zero,1001c7c <xQueueReceive+0x80>
					{
						queueYIELD_IF_USING_PREEMPTION();
 1001c78:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 1001c7c:	10053c40 	call	10053c4 <vTaskExitCritical>
				return pdPASS;
 1001c80:	00800044 	movi	r2,1
 1001c84:	00004206 	br	1001d90 <xQueueReceive+0x194>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 1001c88:	e0bfff17 	ldw	r2,-4(fp)
 1001c8c:	1000031e 	bne	r2,zero,1001c9c <xQueueReceive+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 1001c90:	10053c40 	call	10053c4 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 1001c94:	0005883a 	mov	r2,zero
 1001c98:	00003d06 	br	1001d90 <xQueueReceive+0x194>
				}
				else if( xEntryTimeSet == pdFALSE )
 1001c9c:	e0bff817 	ldw	r2,-32(fp)
 1001ca0:	1000051e 	bne	r2,zero,1001cb8 <xQueueReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 1001ca4:	e0bffb04 	addi	r2,fp,-20
 1001ca8:	1009883a 	mov	r4,r2
 1001cac:	1004bd80 	call	1004bd8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 1001cb0:	00800044 	movi	r2,1
 1001cb4:	e0bff815 	stw	r2,-32(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 1001cb8:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 1001cbc:	100445c0 	call	100445c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 1001cc0:	10053700 	call	1005370 <vTaskEnterCritical>
 1001cc4:	e0bff917 	ldw	r2,-28(fp)
 1001cc8:	10801103 	ldbu	r2,68(r2)
 1001ccc:	10803fcc 	andi	r2,r2,255
 1001cd0:	1080201c 	xori	r2,r2,128
 1001cd4:	10bfe004 	addi	r2,r2,-128
 1001cd8:	10bfffd8 	cmpnei	r2,r2,-1
 1001cdc:	1000021e 	bne	r2,zero,1001ce8 <xQueueReceive+0xec>
 1001ce0:	e0bff917 	ldw	r2,-28(fp)
 1001ce4:	10001105 	stb	zero,68(r2)
 1001ce8:	e0bff917 	ldw	r2,-28(fp)
 1001cec:	10801143 	ldbu	r2,69(r2)
 1001cf0:	10803fcc 	andi	r2,r2,255
 1001cf4:	1080201c 	xori	r2,r2,128
 1001cf8:	10bfe004 	addi	r2,r2,-128
 1001cfc:	10bfffd8 	cmpnei	r2,r2,-1
 1001d00:	1000021e 	bne	r2,zero,1001d0c <xQueueReceive+0x110>
 1001d04:	e0bff917 	ldw	r2,-28(fp)
 1001d08:	10001145 	stb	zero,69(r2)
 1001d0c:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1001d10:	e0ffff04 	addi	r3,fp,-4
 1001d14:	e0bffb04 	addi	r2,fp,-20
 1001d18:	180b883a 	mov	r5,r3
 1001d1c:	1009883a 	mov	r4,r2
 1001d20:	1004c140 	call	1004c14 <xTaskCheckForTimeOut>
 1001d24:	1000131e 	bne	r2,zero,1001d74 <xQueueReceive+0x178>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1001d28:	e13ff917 	ldw	r4,-28(fp)
 1001d2c:	10027380 	call	1002738 <prvIsQueueEmpty>
 1001d30:	10000c26 	beq	r2,zero,1001d64 <xQueueReceive+0x168>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1001d34:	e0bff917 	ldw	r2,-28(fp)
 1001d38:	10800904 	addi	r2,r2,36
 1001d3c:	e0ffff17 	ldw	r3,-4(fp)
 1001d40:	180b883a 	mov	r5,r3
 1001d44:	1009883a 	mov	r4,r2
 1001d48:	100491c0 	call	100491c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 1001d4c:	e13ff917 	ldw	r4,-28(fp)
 1001d50:	10026440 	call	1002644 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 1001d54:	10044880 	call	1004488 <xTaskResumeAll>
 1001d58:	103fb21e 	bne	r2,zero,1001c24 <__alt_data_end+0xff001c24>
				{
					portYIELD_WITHIN_API();
 1001d5c:	003b683a 	trap	0
 1001d60:	003fb006 	br	1001c24 <__alt_data_end+0xff001c24>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 1001d64:	e13ff917 	ldw	r4,-28(fp)
 1001d68:	10026440 	call	1002644 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 1001d6c:	10044880 	call	1004488 <xTaskResumeAll>
 1001d70:	003fac06 	br	1001c24 <__alt_data_end+0xff001c24>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 1001d74:	e13ff917 	ldw	r4,-28(fp)
 1001d78:	10026440 	call	1002644 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 1001d7c:	10044880 	call	1004488 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1001d80:	e13ff917 	ldw	r4,-28(fp)
 1001d84:	10027380 	call	1002738 <prvIsQueueEmpty>
 1001d88:	103fa626 	beq	r2,zero,1001c24 <__alt_data_end+0xff001c24>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 1001d8c:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 1001d90:	e037883a 	mov	sp,fp
 1001d94:	dfc00117 	ldw	ra,4(sp)
 1001d98:	df000017 	ldw	fp,0(sp)
 1001d9c:	dec00204 	addi	sp,sp,8
 1001da0:	f800283a 	ret

01001da4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
 1001da4:	defff504 	addi	sp,sp,-44
 1001da8:	dfc00a15 	stw	ra,40(sp)
 1001dac:	df000915 	stw	fp,36(sp)
 1001db0:	df000904 	addi	fp,sp,36
 1001db4:	e13ffe15 	stw	r4,-8(fp)
 1001db8:	e17fff15 	stw	r5,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 1001dbc:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 1001dc0:	e0bffe17 	ldw	r2,-8(fp)
 1001dc4:	e0bff915 	stw	r2,-28(fp)

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
 1001dc8:	e03ff815 	stw	zero,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 1001dcc:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 1001dd0:	e0bff917 	ldw	r2,-28(fp)
 1001dd4:	10800e17 	ldw	r2,56(r2)
 1001dd8:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 1001ddc:	e0bffa17 	ldw	r2,-24(fp)
 1001de0:	10001726 	beq	r2,zero,1001e40 <xQueueSemaphoreTake+0x9c>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 1001de4:	e0bffa17 	ldw	r2,-24(fp)
 1001de8:	10ffffc4 	addi	r3,r2,-1
 1001dec:	e0bff917 	ldw	r2,-28(fp)
 1001df0:	10c00e15 	stw	r3,56(r2)

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1001df4:	e0bff917 	ldw	r2,-28(fp)
 1001df8:	10800017 	ldw	r2,0(r2)
 1001dfc:	1000041e 	bne	r2,zero,1001e10 <xQueueSemaphoreTake+0x6c>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 1001e00:	10054680 	call	1005468 <pvTaskIncrementMutexHeldCount>
 1001e04:	1007883a 	mov	r3,r2
 1001e08:	e0bff917 	ldw	r2,-28(fp)
 1001e0c:	10c00215 	stw	r3,8(r2)
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1001e10:	e0bff917 	ldw	r2,-28(fp)
 1001e14:	10800417 	ldw	r2,16(r2)
 1001e18:	10000626 	beq	r2,zero,1001e34 <xQueueSemaphoreTake+0x90>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1001e1c:	e0bff917 	ldw	r2,-28(fp)
 1001e20:	10800404 	addi	r2,r2,16
 1001e24:	1009883a 	mov	r4,r2
 1001e28:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 1001e2c:	10000126 	beq	r2,zero,1001e34 <xQueueSemaphoreTake+0x90>
					{
						queueYIELD_IF_USING_PREEMPTION();
 1001e30:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 1001e34:	10053c40 	call	10053c4 <vTaskExitCritical>
				return pdPASS;
 1001e38:	00800044 	movi	r2,1
 1001e3c:	00005806 	br	1001fa0 <xQueueSemaphoreTake+0x1fc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 1001e40:	e0bfff17 	ldw	r2,-4(fp)
 1001e44:	1000031e 	bne	r2,zero,1001e54 <xQueueSemaphoreTake+0xb0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
 1001e48:	10053c40 	call	10053c4 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 1001e4c:	0005883a 	mov	r2,zero
 1001e50:	00005306 	br	1001fa0 <xQueueSemaphoreTake+0x1fc>
				}
				else if( xEntryTimeSet == pdFALSE )
 1001e54:	e0bff717 	ldw	r2,-36(fp)
 1001e58:	1000051e 	bne	r2,zero,1001e70 <xQueueSemaphoreTake+0xcc>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 1001e5c:	e0bffc04 	addi	r2,fp,-16
 1001e60:	1009883a 	mov	r4,r2
 1001e64:	1004bd80 	call	1004bd8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 1001e68:	00800044 	movi	r2,1
 1001e6c:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 1001e70:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
 1001e74:	100445c0 	call	100445c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 1001e78:	10053700 	call	1005370 <vTaskEnterCritical>
 1001e7c:	e0bff917 	ldw	r2,-28(fp)
 1001e80:	10801103 	ldbu	r2,68(r2)
 1001e84:	10803fcc 	andi	r2,r2,255
 1001e88:	1080201c 	xori	r2,r2,128
 1001e8c:	10bfe004 	addi	r2,r2,-128
 1001e90:	10bfffd8 	cmpnei	r2,r2,-1
 1001e94:	1000021e 	bne	r2,zero,1001ea0 <xQueueSemaphoreTake+0xfc>
 1001e98:	e0bff917 	ldw	r2,-28(fp)
 1001e9c:	10001105 	stb	zero,68(r2)
 1001ea0:	e0bff917 	ldw	r2,-28(fp)
 1001ea4:	10801143 	ldbu	r2,69(r2)
 1001ea8:	10803fcc 	andi	r2,r2,255
 1001eac:	1080201c 	xori	r2,r2,128
 1001eb0:	10bfe004 	addi	r2,r2,-128
 1001eb4:	10bfffd8 	cmpnei	r2,r2,-1
 1001eb8:	1000021e 	bne	r2,zero,1001ec4 <xQueueSemaphoreTake+0x120>
 1001ebc:	e0bff917 	ldw	r2,-28(fp)
 1001ec0:	10001145 	stb	zero,69(r2)
 1001ec4:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1001ec8:	e0ffff04 	addi	r3,fp,-4
 1001ecc:	e0bffc04 	addi	r2,fp,-16
 1001ed0:	180b883a 	mov	r5,r3
 1001ed4:	1009883a 	mov	r4,r2
 1001ed8:	1004c140 	call	1004c14 <xTaskCheckForTimeOut>
 1001edc:	10001d1e 	bne	r2,zero,1001f54 <xQueueSemaphoreTake+0x1b0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1001ee0:	e13ff917 	ldw	r4,-28(fp)
 1001ee4:	10027380 	call	1002738 <prvIsQueueEmpty>
 1001ee8:	10001626 	beq	r2,zero,1001f44 <xQueueSemaphoreTake+0x1a0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1001eec:	e0bff917 	ldw	r2,-28(fp)
 1001ef0:	10800017 	ldw	r2,0(r2)
 1001ef4:	1000071e 	bne	r2,zero,1001f14 <xQueueSemaphoreTake+0x170>
					{
						taskENTER_CRITICAL();
 1001ef8:	10053700 	call	1005370 <vTaskEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 1001efc:	e0bff917 	ldw	r2,-28(fp)
 1001f00:	10800217 	ldw	r2,8(r2)
 1001f04:	1009883a 	mov	r4,r2
 1001f08:	1004ff40 	call	1004ff4 <xTaskPriorityInherit>
 1001f0c:	e0bff815 	stw	r2,-32(fp)
						}
						taskEXIT_CRITICAL();
 1001f10:	10053c40 	call	10053c4 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1001f14:	e0bff917 	ldw	r2,-28(fp)
 1001f18:	10800904 	addi	r2,r2,36
 1001f1c:	e0ffff17 	ldw	r3,-4(fp)
 1001f20:	180b883a 	mov	r5,r3
 1001f24:	1009883a 	mov	r4,r2
 1001f28:	100491c0 	call	100491c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 1001f2c:	e13ff917 	ldw	r4,-28(fp)
 1001f30:	10026440 	call	1002644 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 1001f34:	10044880 	call	1004488 <xTaskResumeAll>
 1001f38:	103fa41e 	bne	r2,zero,1001dcc <__alt_data_end+0xff001dcc>
				{
					portYIELD_WITHIN_API();
 1001f3c:	003b683a 	trap	0
 1001f40:	003fa206 	br	1001dcc <__alt_data_end+0xff001dcc>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
 1001f44:	e13ff917 	ldw	r4,-28(fp)
 1001f48:	10026440 	call	1002644 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 1001f4c:	10044880 	call	1004488 <xTaskResumeAll>
 1001f50:	003f9e06 	br	1001dcc <__alt_data_end+0xff001dcc>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
 1001f54:	e13ff917 	ldw	r4,-28(fp)
 1001f58:	10026440 	call	1002644 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 1001f5c:	10044880 	call	1004488 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1001f60:	e13ff917 	ldw	r4,-28(fp)
 1001f64:	10027380 	call	1002738 <prvIsQueueEmpty>
 1001f68:	103f9826 	beq	r2,zero,1001dcc <__alt_data_end+0xff001dcc>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
 1001f6c:	e0bff817 	ldw	r2,-32(fp)
 1001f70:	10000a26 	beq	r2,zero,1001f9c <xQueueSemaphoreTake+0x1f8>
					{
						taskENTER_CRITICAL();
 1001f74:	10053700 	call	1005370 <vTaskEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 1001f78:	e13ff917 	ldw	r4,-28(fp)
 1001f7c:	10023cc0 	call	10023cc <prvGetDisinheritPriorityAfterTimeout>
 1001f80:	e0bffb15 	stw	r2,-20(fp)
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 1001f84:	e0bff917 	ldw	r2,-28(fp)
 1001f88:	10800217 	ldw	r2,8(r2)
 1001f8c:	e17ffb17 	ldw	r5,-20(fp)
 1001f90:	1009883a 	mov	r4,r2
 1001f94:	10052300 	call	1005230 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
 1001f98:	10053c40 	call	10053c4 <vTaskExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 1001f9c:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 1001fa0:	e037883a 	mov	sp,fp
 1001fa4:	dfc00117 	ldw	ra,4(sp)
 1001fa8:	df000017 	ldw	fp,0(sp)
 1001fac:	dec00204 	addi	sp,sp,8
 1001fb0:	f800283a 	ret

01001fb4 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 1001fb4:	defff504 	addi	sp,sp,-44
 1001fb8:	dfc00a15 	stw	ra,40(sp)
 1001fbc:	df000915 	stw	fp,36(sp)
 1001fc0:	df000904 	addi	fp,sp,36
 1001fc4:	e13ffd15 	stw	r4,-12(fp)
 1001fc8:	e17ffe15 	stw	r5,-8(fp)
 1001fcc:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 1001fd0:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 1001fd4:	e0bffd17 	ldw	r2,-12(fp)
 1001fd8:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 1001fdc:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1001fe0:	e0bff817 	ldw	r2,-32(fp)
 1001fe4:	10800e17 	ldw	r2,56(r2)
 1001fe8:	e0bff915 	stw	r2,-28(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1001fec:	e0bff917 	ldw	r2,-28(fp)
 1001ff0:	10001526 	beq	r2,zero,1002048 <xQueuePeek+0x94>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1001ff4:	e0bff817 	ldw	r2,-32(fp)
 1001ff8:	10800317 	ldw	r2,12(r2)
 1001ffc:	e0bffa15 	stw	r2,-24(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1002000:	e17ffe17 	ldw	r5,-8(fp)
 1002004:	e13ff817 	ldw	r4,-32(fp)
 1002008:	10025a80 	call	10025a8 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 100200c:	e0bff817 	ldw	r2,-32(fp)
 1002010:	e0fffa17 	ldw	r3,-24(fp)
 1002014:	10c00315 	stw	r3,12(r2)

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1002018:	e0bff817 	ldw	r2,-32(fp)
 100201c:	10800917 	ldw	r2,36(r2)
 1002020:	10000626 	beq	r2,zero,100203c <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1002024:	e0bff817 	ldw	r2,-32(fp)
 1002028:	10800904 	addi	r2,r2,36
 100202c:	1009883a 	mov	r4,r2
 1002030:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 1002034:	10000126 	beq	r2,zero,100203c <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
 1002038:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 100203c:	10053c40 	call	10053c4 <vTaskExitCritical>
				return pdPASS;
 1002040:	00800044 	movi	r2,1
 1002044:	00004206 	br	1002150 <xQueuePeek+0x19c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 1002048:	e0bfff17 	ldw	r2,-4(fp)
 100204c:	1000031e 	bne	r2,zero,100205c <xQueuePeek+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 1002050:	10053c40 	call	10053c4 <vTaskExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 1002054:	0005883a 	mov	r2,zero
 1002058:	00003d06 	br	1002150 <xQueuePeek+0x19c>
				}
				else if( xEntryTimeSet == pdFALSE )
 100205c:	e0bff717 	ldw	r2,-36(fp)
 1002060:	1000051e 	bne	r2,zero,1002078 <xQueuePeek+0xc4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 1002064:	e0bffb04 	addi	r2,fp,-20
 1002068:	1009883a 	mov	r4,r2
 100206c:	1004bd80 	call	1004bd8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 1002070:	00800044 	movi	r2,1
 1002074:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 1002078:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 100207c:	100445c0 	call	100445c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 1002080:	10053700 	call	1005370 <vTaskEnterCritical>
 1002084:	e0bff817 	ldw	r2,-32(fp)
 1002088:	10801103 	ldbu	r2,68(r2)
 100208c:	10803fcc 	andi	r2,r2,255
 1002090:	1080201c 	xori	r2,r2,128
 1002094:	10bfe004 	addi	r2,r2,-128
 1002098:	10bfffd8 	cmpnei	r2,r2,-1
 100209c:	1000021e 	bne	r2,zero,10020a8 <xQueuePeek+0xf4>
 10020a0:	e0bff817 	ldw	r2,-32(fp)
 10020a4:	10001105 	stb	zero,68(r2)
 10020a8:	e0bff817 	ldw	r2,-32(fp)
 10020ac:	10801143 	ldbu	r2,69(r2)
 10020b0:	10803fcc 	andi	r2,r2,255
 10020b4:	1080201c 	xori	r2,r2,128
 10020b8:	10bfe004 	addi	r2,r2,-128
 10020bc:	10bfffd8 	cmpnei	r2,r2,-1
 10020c0:	1000021e 	bne	r2,zero,10020cc <xQueuePeek+0x118>
 10020c4:	e0bff817 	ldw	r2,-32(fp)
 10020c8:	10001145 	stb	zero,69(r2)
 10020cc:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 10020d0:	e0ffff04 	addi	r3,fp,-4
 10020d4:	e0bffb04 	addi	r2,fp,-20
 10020d8:	180b883a 	mov	r5,r3
 10020dc:	1009883a 	mov	r4,r2
 10020e0:	1004c140 	call	1004c14 <xTaskCheckForTimeOut>
 10020e4:	1000131e 	bne	r2,zero,1002134 <xQueuePeek+0x180>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 10020e8:	e13ff817 	ldw	r4,-32(fp)
 10020ec:	10027380 	call	1002738 <prvIsQueueEmpty>
 10020f0:	10000c26 	beq	r2,zero,1002124 <xQueuePeek+0x170>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 10020f4:	e0bff817 	ldw	r2,-32(fp)
 10020f8:	10800904 	addi	r2,r2,36
 10020fc:	e0ffff17 	ldw	r3,-4(fp)
 1002100:	180b883a 	mov	r5,r3
 1002104:	1009883a 	mov	r4,r2
 1002108:	100491c0 	call	100491c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 100210c:	e13ff817 	ldw	r4,-32(fp)
 1002110:	10026440 	call	1002644 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 1002114:	10044880 	call	1004488 <xTaskResumeAll>
 1002118:	103fb01e 	bne	r2,zero,1001fdc <__alt_data_end+0xff001fdc>
				{
					portYIELD_WITHIN_API();
 100211c:	003b683a 	trap	0
 1002120:	003fae06 	br	1001fdc <__alt_data_end+0xff001fdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
 1002124:	e13ff817 	ldw	r4,-32(fp)
 1002128:	10026440 	call	1002644 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 100212c:	10044880 	call	1004488 <xTaskResumeAll>
 1002130:	003faa06 	br	1001fdc <__alt_data_end+0xff001fdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
 1002134:	e13ff817 	ldw	r4,-32(fp)
 1002138:	10026440 	call	1002644 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 100213c:	10044880 	call	1004488 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1002140:	e13ff817 	ldw	r4,-32(fp)
 1002144:	10027380 	call	1002738 <prvIsQueueEmpty>
 1002148:	103fa426 	beq	r2,zero,1001fdc <__alt_data_end+0xff001fdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 100214c:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 1002150:	e037883a 	mov	sp,fp
 1002154:	dfc00117 	ldw	ra,4(sp)
 1002158:	df000017 	ldw	fp,0(sp)
 100215c:	dec00204 	addi	sp,sp,8
 1002160:	f800283a 	ret

01002164 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 1002164:	defff604 	addi	sp,sp,-40
 1002168:	dfc00915 	stw	ra,36(sp)
 100216c:	df000815 	stw	fp,32(sp)
 1002170:	df000804 	addi	fp,sp,32
 1002174:	e13ffd15 	stw	r4,-12(fp)
 1002178:	e17ffe15 	stw	r5,-8(fp)
 100217c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 1002180:	e0bffd17 	ldw	r2,-12(fp)
 1002184:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1002188:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 100218c:	e0bff917 	ldw	r2,-28(fp)
 1002190:	10800e17 	ldw	r2,56(r2)
 1002194:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1002198:	e0bffb17 	ldw	r2,-20(fp)
 100219c:	10002326 	beq	r2,zero,100222c <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
 10021a0:	e0bff917 	ldw	r2,-28(fp)
 10021a4:	10801103 	ldbu	r2,68(r2)
 10021a8:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 10021ac:	e17ffe17 	ldw	r5,-8(fp)
 10021b0:	e13ff917 	ldw	r4,-28(fp)
 10021b4:	10025a80 	call	10025a8 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 10021b8:	e0bffb17 	ldw	r2,-20(fp)
 10021bc:	10ffffc4 	addi	r3,r2,-1
 10021c0:	e0bff917 	ldw	r2,-28(fp)
 10021c4:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
 10021c8:	e0bffc07 	ldb	r2,-16(fp)
 10021cc:	10bfffd8 	cmpnei	r2,r2,-1
 10021d0:	10000e1e 	bne	r2,zero,100220c <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 10021d4:	e0bff917 	ldw	r2,-28(fp)
 10021d8:	10800417 	ldw	r2,16(r2)
 10021dc:	10001026 	beq	r2,zero,1002220 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 10021e0:	e0bff917 	ldw	r2,-28(fp)
 10021e4:	10800404 	addi	r2,r2,16
 10021e8:	1009883a 	mov	r4,r2
 10021ec:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 10021f0:	10000b26 	beq	r2,zero,1002220 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 10021f4:	e0bfff17 	ldw	r2,-4(fp)
 10021f8:	10000926 	beq	r2,zero,1002220 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 10021fc:	e0bfff17 	ldw	r2,-4(fp)
 1002200:	00c00044 	movi	r3,1
 1002204:	10c00015 	stw	r3,0(r2)
 1002208:	00000506 	br	1002220 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 100220c:	e0bffc03 	ldbu	r2,-16(fp)
 1002210:	10800044 	addi	r2,r2,1
 1002214:	1007883a 	mov	r3,r2
 1002218:	e0bff917 	ldw	r2,-28(fp)
 100221c:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
 1002220:	00800044 	movi	r2,1
 1002224:	e0bff815 	stw	r2,-32(fp)
 1002228:	00000106 	br	1002230 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
 100222c:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1002230:	e0bff817 	ldw	r2,-32(fp)
}
 1002234:	e037883a 	mov	sp,fp
 1002238:	dfc00117 	ldw	ra,4(sp)
 100223c:	df000017 	ldw	fp,0(sp)
 1002240:	dec00204 	addi	sp,sp,8
 1002244:	f800283a 	ret

01002248 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 1002248:	defff804 	addi	sp,sp,-32
 100224c:	dfc00715 	stw	ra,28(sp)
 1002250:	df000615 	stw	fp,24(sp)
 1002254:	df000604 	addi	fp,sp,24
 1002258:	e13ffe15 	stw	r4,-8(fp)
 100225c:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 1002260:	e0bffe17 	ldw	r2,-8(fp)
 1002264:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1002268:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 100226c:	e0bffb17 	ldw	r2,-20(fp)
 1002270:	10800e17 	ldw	r2,56(r2)
 1002274:	10000c26 	beq	r2,zero,10022a8 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1002278:	e0bffb17 	ldw	r2,-20(fp)
 100227c:	10800317 	ldw	r2,12(r2)
 1002280:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1002284:	e17fff17 	ldw	r5,-4(fp)
 1002288:	e13ffb17 	ldw	r4,-20(fp)
 100228c:	10025a80 	call	10025a8 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 1002290:	e0bffb17 	ldw	r2,-20(fp)
 1002294:	e0fffd17 	ldw	r3,-12(fp)
 1002298:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
 100229c:	00800044 	movi	r2,1
 10022a0:	e0bffa15 	stw	r2,-24(fp)
 10022a4:	00000106 	br	10022ac <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
 10022a8:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 10022ac:	e0bffa17 	ldw	r2,-24(fp)
}
 10022b0:	e037883a 	mov	sp,fp
 10022b4:	dfc00117 	ldw	ra,4(sp)
 10022b8:	df000017 	ldw	fp,0(sp)
 10022bc:	dec00204 	addi	sp,sp,8
 10022c0:	f800283a 	ret

010022c4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 10022c4:	defffc04 	addi	sp,sp,-16
 10022c8:	dfc00315 	stw	ra,12(sp)
 10022cc:	df000215 	stw	fp,8(sp)
 10022d0:	df000204 	addi	fp,sp,8
 10022d4:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 10022d8:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 10022dc:	e0bfff17 	ldw	r2,-4(fp)
 10022e0:	10800e17 	ldw	r2,56(r2)
 10022e4:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 10022e8:	10053c40 	call	10053c4 <vTaskExitCritical>

	return uxReturn;
 10022ec:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 10022f0:	e037883a 	mov	sp,fp
 10022f4:	dfc00117 	ldw	ra,4(sp)
 10022f8:	df000017 	ldw	fp,0(sp)
 10022fc:	dec00204 	addi	sp,sp,8
 1002300:	f800283a 	ret

01002304 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 1002304:	defffb04 	addi	sp,sp,-20
 1002308:	dfc00415 	stw	ra,16(sp)
 100230c:	df000315 	stw	fp,12(sp)
 1002310:	df000304 	addi	fp,sp,12
 1002314:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 1002318:	e0bfff17 	ldw	r2,-4(fp)
 100231c:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 1002320:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1002324:	e0bffd17 	ldw	r2,-12(fp)
 1002328:	10c00f17 	ldw	r3,60(r2)
 100232c:	e0bffd17 	ldw	r2,-12(fp)
 1002330:	10800e17 	ldw	r2,56(r2)
 1002334:	1885c83a 	sub	r2,r3,r2
 1002338:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 100233c:	10053c40 	call	10053c4 <vTaskExitCritical>

	return uxReturn;
 1002340:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1002344:	e037883a 	mov	sp,fp
 1002348:	dfc00117 	ldw	ra,4(sp)
 100234c:	df000017 	ldw	fp,0(sp)
 1002350:	dec00204 	addi	sp,sp,8
 1002354:	f800283a 	ret

01002358 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 1002358:	defffc04 	addi	sp,sp,-16
 100235c:	df000315 	stw	fp,12(sp)
 1002360:	df000304 	addi	fp,sp,12
 1002364:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 1002368:	e0bfff17 	ldw	r2,-4(fp)
 100236c:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
 1002370:	e0bffd17 	ldw	r2,-12(fp)
 1002374:	10800e17 	ldw	r2,56(r2)
 1002378:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
 100237c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1002380:	e037883a 	mov	sp,fp
 1002384:	df000017 	ldw	fp,0(sp)
 1002388:	dec00104 	addi	sp,sp,4
 100238c:	f800283a 	ret

01002390 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 1002390:	defffc04 	addi	sp,sp,-16
 1002394:	dfc00315 	stw	ra,12(sp)
 1002398:	df000215 	stw	fp,8(sp)
 100239c:	df000204 	addi	fp,sp,8
 10023a0:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = xQueue;
 10023a4:	e0bfff17 	ldw	r2,-4(fp)
 10023a8:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
 10023ac:	e13ffe17 	ldw	r4,-8(fp)
 10023b0:	10012840 	call	1001284 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 10023b4:	0001883a 	nop
 10023b8:	e037883a 	mov	sp,fp
 10023bc:	dfc00117 	ldw	ra,4(sp)
 10023c0:	df000017 	ldw	fp,0(sp)
 10023c4:	dec00204 	addi	sp,sp,8
 10023c8:	f800283a 	ret

010023cc <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 10023cc:	defffd04 	addi	sp,sp,-12
 10023d0:	df000215 	stw	fp,8(sp)
 10023d4:	df000204 	addi	fp,sp,8
 10023d8:	e13fff15 	stw	r4,-4(fp)
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 10023dc:	e0bfff17 	ldw	r2,-4(fp)
 10023e0:	10800917 	ldw	r2,36(r2)
 10023e4:	10000726 	beq	r2,zero,1002404 <prvGetDisinheritPriorityAfterTimeout+0x38>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 10023e8:	e0bfff17 	ldw	r2,-4(fp)
 10023ec:	10800c17 	ldw	r2,48(r2)
 10023f0:	10800017 	ldw	r2,0(r2)
 10023f4:	00c00144 	movi	r3,5
 10023f8:	1885c83a 	sub	r2,r3,r2
 10023fc:	e0bffe15 	stw	r2,-8(fp)
 1002400:	00000106 	br	1002408 <prvGetDisinheritPriorityAfterTimeout+0x3c>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 1002404:	e03ffe15 	stw	zero,-8(fp)
		}

		return uxHighestPriorityOfWaitingTasks;
 1002408:	e0bffe17 	ldw	r2,-8(fp)
	}
 100240c:	e037883a 	mov	sp,fp
 1002410:	df000017 	ldw	fp,0(sp)
 1002414:	dec00104 	addi	sp,sp,4
 1002418:	f800283a 	ret

0100241c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 100241c:	defff904 	addi	sp,sp,-28
 1002420:	dfc00615 	stw	ra,24(sp)
 1002424:	df000515 	stw	fp,20(sp)
 1002428:	df000504 	addi	fp,sp,20
 100242c:	e13ffd15 	stw	r4,-12(fp)
 1002430:	e17ffe15 	stw	r5,-8(fp)
 1002434:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
 1002438:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 100243c:	e0bffd17 	ldw	r2,-12(fp)
 1002440:	10800e17 	ldw	r2,56(r2)
 1002444:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 1002448:	e0bffd17 	ldw	r2,-12(fp)
 100244c:	10801017 	ldw	r2,64(r2)
 1002450:	10000b1e 	bne	r2,zero,1002480 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1002454:	e0bffd17 	ldw	r2,-12(fp)
 1002458:	10800017 	ldw	r2,0(r2)
 100245c:	1000481e 	bne	r2,zero,1002580 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 1002460:	e0bffd17 	ldw	r2,-12(fp)
 1002464:	10800217 	ldw	r2,8(r2)
 1002468:	1009883a 	mov	r4,r2
 100246c:	10051340 	call	1005134 <xTaskPriorityDisinherit>
 1002470:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 1002474:	e0bffd17 	ldw	r2,-12(fp)
 1002478:	10000215 	stw	zero,8(r2)
 100247c:	00004006 	br	1002580 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 1002480:	e0bfff17 	ldw	r2,-4(fp)
 1002484:	1000191e 	bne	r2,zero,10024ec <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 1002488:	e0bffd17 	ldw	r2,-12(fp)
 100248c:	10c00117 	ldw	r3,4(r2)
 1002490:	e0bffd17 	ldw	r2,-12(fp)
 1002494:	10801017 	ldw	r2,64(r2)
 1002498:	100d883a 	mov	r6,r2
 100249c:	e17ffe17 	ldw	r5,-8(fp)
 10024a0:	1809883a 	mov	r4,r3
 10024a4:	10158f40 	call	10158f4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 10024a8:	e0bffd17 	ldw	r2,-12(fp)
 10024ac:	10c00117 	ldw	r3,4(r2)
 10024b0:	e0bffd17 	ldw	r2,-12(fp)
 10024b4:	10801017 	ldw	r2,64(r2)
 10024b8:	1887883a 	add	r3,r3,r2
 10024bc:	e0bffd17 	ldw	r2,-12(fp)
 10024c0:	10c00115 	stw	r3,4(r2)
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 10024c4:	e0bffd17 	ldw	r2,-12(fp)
 10024c8:	10c00117 	ldw	r3,4(r2)
 10024cc:	e0bffd17 	ldw	r2,-12(fp)
 10024d0:	10800217 	ldw	r2,8(r2)
 10024d4:	18802a36 	bltu	r3,r2,1002580 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 10024d8:	e0bffd17 	ldw	r2,-12(fp)
 10024dc:	10c00017 	ldw	r3,0(r2)
 10024e0:	e0bffd17 	ldw	r2,-12(fp)
 10024e4:	10c00115 	stw	r3,4(r2)
 10024e8:	00002506 	br	1002580 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 10024ec:	e0bffd17 	ldw	r2,-12(fp)
 10024f0:	10c00317 	ldw	r3,12(r2)
 10024f4:	e0bffd17 	ldw	r2,-12(fp)
 10024f8:	10801017 	ldw	r2,64(r2)
 10024fc:	100d883a 	mov	r6,r2
 1002500:	e17ffe17 	ldw	r5,-8(fp)
 1002504:	1809883a 	mov	r4,r3
 1002508:	10158f40 	call	10158f4 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 100250c:	e0bffd17 	ldw	r2,-12(fp)
 1002510:	10c00317 	ldw	r3,12(r2)
 1002514:	e0bffd17 	ldw	r2,-12(fp)
 1002518:	10801017 	ldw	r2,64(r2)
 100251c:	0085c83a 	sub	r2,zero,r2
 1002520:	1887883a 	add	r3,r3,r2
 1002524:	e0bffd17 	ldw	r2,-12(fp)
 1002528:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 100252c:	e0bffd17 	ldw	r2,-12(fp)
 1002530:	10c00317 	ldw	r3,12(r2)
 1002534:	e0bffd17 	ldw	r2,-12(fp)
 1002538:	10800017 	ldw	r2,0(r2)
 100253c:	1880082e 	bgeu	r3,r2,1002560 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 1002540:	e0bffd17 	ldw	r2,-12(fp)
 1002544:	10c00217 	ldw	r3,8(r2)
 1002548:	e0bffd17 	ldw	r2,-12(fp)
 100254c:	10801017 	ldw	r2,64(r2)
 1002550:	0085c83a 	sub	r2,zero,r2
 1002554:	1887883a 	add	r3,r3,r2
 1002558:	e0bffd17 	ldw	r2,-12(fp)
 100255c:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 1002560:	e0bfff17 	ldw	r2,-4(fp)
 1002564:	10800098 	cmpnei	r2,r2,2
 1002568:	1000051e 	bne	r2,zero,1002580 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 100256c:	e0bffc17 	ldw	r2,-16(fp)
 1002570:	10000326 	beq	r2,zero,1002580 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 1002574:	e0bffc17 	ldw	r2,-16(fp)
 1002578:	10bfffc4 	addi	r2,r2,-1
 100257c:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1002580:	e0bffc17 	ldw	r2,-16(fp)
 1002584:	10c00044 	addi	r3,r2,1
 1002588:	e0bffd17 	ldw	r2,-12(fp)
 100258c:	10c00e15 	stw	r3,56(r2)

	return xReturn;
 1002590:	e0bffb17 	ldw	r2,-20(fp)
}
 1002594:	e037883a 	mov	sp,fp
 1002598:	dfc00117 	ldw	ra,4(sp)
 100259c:	df000017 	ldw	fp,0(sp)
 10025a0:	dec00204 	addi	sp,sp,8
 10025a4:	f800283a 	ret

010025a8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 10025a8:	defffc04 	addi	sp,sp,-16
 10025ac:	dfc00315 	stw	ra,12(sp)
 10025b0:	df000215 	stw	fp,8(sp)
 10025b4:	df000204 	addi	fp,sp,8
 10025b8:	e13ffe15 	stw	r4,-8(fp)
 10025bc:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 10025c0:	e0bffe17 	ldw	r2,-8(fp)
 10025c4:	10801017 	ldw	r2,64(r2)
 10025c8:	10001826 	beq	r2,zero,100262c <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 10025cc:	e0bffe17 	ldw	r2,-8(fp)
 10025d0:	10c00317 	ldw	r3,12(r2)
 10025d4:	e0bffe17 	ldw	r2,-8(fp)
 10025d8:	10801017 	ldw	r2,64(r2)
 10025dc:	1887883a 	add	r3,r3,r2
 10025e0:	e0bffe17 	ldw	r2,-8(fp)
 10025e4:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 10025e8:	e0bffe17 	ldw	r2,-8(fp)
 10025ec:	10c00317 	ldw	r3,12(r2)
 10025f0:	e0bffe17 	ldw	r2,-8(fp)
 10025f4:	10800217 	ldw	r2,8(r2)
 10025f8:	18800436 	bltu	r3,r2,100260c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 10025fc:	e0bffe17 	ldw	r2,-8(fp)
 1002600:	10c00017 	ldw	r3,0(r2)
 1002604:	e0bffe17 	ldw	r2,-8(fp)
 1002608:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 100260c:	e0bffe17 	ldw	r2,-8(fp)
 1002610:	10c00317 	ldw	r3,12(r2)
 1002614:	e0bffe17 	ldw	r2,-8(fp)
 1002618:	10801017 	ldw	r2,64(r2)
 100261c:	100d883a 	mov	r6,r2
 1002620:	180b883a 	mov	r5,r3
 1002624:	e13fff17 	ldw	r4,-4(fp)
 1002628:	10158f40 	call	10158f4 <memcpy>
	}
}
 100262c:	0001883a 	nop
 1002630:	e037883a 	mov	sp,fp
 1002634:	dfc00117 	ldw	ra,4(sp)
 1002638:	df000017 	ldw	fp,0(sp)
 100263c:	dec00204 	addi	sp,sp,8
 1002640:	f800283a 	ret

01002644 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 1002644:	defffc04 	addi	sp,sp,-16
 1002648:	dfc00315 	stw	ra,12(sp)
 100264c:	df000215 	stw	fp,8(sp)
 1002650:	df000204 	addi	fp,sp,8
 1002654:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 1002658:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 100265c:	e0bfff17 	ldw	r2,-4(fp)
 1002660:	10801143 	ldbu	r2,69(r2)
 1002664:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 1002668:	00000c06 	br	100269c <prvUnlockQueue+0x58>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 100266c:	e0bfff17 	ldw	r2,-4(fp)
 1002670:	10800917 	ldw	r2,36(r2)
 1002674:	10000c26 	beq	r2,zero,10026a8 <prvUnlockQueue+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1002678:	e0bfff17 	ldw	r2,-4(fp)
 100267c:	10800904 	addi	r2,r2,36
 1002680:	1009883a 	mov	r4,r2
 1002684:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 1002688:	10000126 	beq	r2,zero,1002690 <prvUnlockQueue+0x4c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 100268c:	1004cf40 	call	1004cf4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 1002690:	e0bffe03 	ldbu	r2,-8(fp)
 1002694:	10bfffc4 	addi	r2,r2,-1
 1002698:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 100269c:	e0bffe07 	ldb	r2,-8(fp)
 10026a0:	00bff216 	blt	zero,r2,100266c <__alt_data_end+0xff00266c>
 10026a4:	00000106 	br	10026ac <prvUnlockQueue+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 10026a8:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 10026ac:	e0bfff17 	ldw	r2,-4(fp)
 10026b0:	00ffffc4 	movi	r3,-1
 10026b4:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
 10026b8:	10053c40 	call	10053c4 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 10026bc:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 10026c0:	e0bfff17 	ldw	r2,-4(fp)
 10026c4:	10801103 	ldbu	r2,68(r2)
 10026c8:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
 10026cc:	00000c06 	br	1002700 <prvUnlockQueue+0xbc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 10026d0:	e0bfff17 	ldw	r2,-4(fp)
 10026d4:	10800417 	ldw	r2,16(r2)
 10026d8:	10000c26 	beq	r2,zero,100270c <prvUnlockQueue+0xc8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 10026dc:	e0bfff17 	ldw	r2,-4(fp)
 10026e0:	10800404 	addi	r2,r2,16
 10026e4:	1009883a 	mov	r4,r2
 10026e8:	10049d00 	call	10049d0 <xTaskRemoveFromEventList>
 10026ec:	10000126 	beq	r2,zero,10026f4 <prvUnlockQueue+0xb0>
				{
					vTaskMissedYield();
 10026f0:	1004cf40 	call	1004cf4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 10026f4:	e0bffe43 	ldbu	r2,-7(fp)
 10026f8:	10bfffc4 	addi	r2,r2,-1
 10026fc:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
 1002700:	e0bffe47 	ldb	r2,-7(fp)
 1002704:	00bff216 	blt	zero,r2,10026d0 <__alt_data_end+0xff0026d0>
 1002708:	00000106 	br	1002710 <prvUnlockQueue+0xcc>

				--cRxLock;
			}
			else
			{
				break;
 100270c:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 1002710:	e0bfff17 	ldw	r2,-4(fp)
 1002714:	00ffffc4 	movi	r3,-1
 1002718:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
 100271c:	10053c40 	call	10053c4 <vTaskExitCritical>
}
 1002720:	0001883a 	nop
 1002724:	e037883a 	mov	sp,fp
 1002728:	dfc00117 	ldw	ra,4(sp)
 100272c:	df000017 	ldw	fp,0(sp)
 1002730:	dec00204 	addi	sp,sp,8
 1002734:	f800283a 	ret

01002738 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 1002738:	defffc04 	addi	sp,sp,-16
 100273c:	dfc00315 	stw	ra,12(sp)
 1002740:	df000215 	stw	fp,8(sp)
 1002744:	df000204 	addi	fp,sp,8
 1002748:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 100274c:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 1002750:	e0bfff17 	ldw	r2,-4(fp)
 1002754:	10800e17 	ldw	r2,56(r2)
 1002758:	1000031e 	bne	r2,zero,1002768 <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
 100275c:	00800044 	movi	r2,1
 1002760:	e0bffe15 	stw	r2,-8(fp)
 1002764:	00000106 	br	100276c <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
 1002768:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 100276c:	10053c40 	call	10053c4 <vTaskExitCritical>

	return xReturn;
 1002770:	e0bffe17 	ldw	r2,-8(fp)
}
 1002774:	e037883a 	mov	sp,fp
 1002778:	dfc00117 	ldw	ra,4(sp)
 100277c:	df000017 	ldw	fp,0(sp)
 1002780:	dec00204 	addi	sp,sp,8
 1002784:	f800283a 	ret

01002788 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 1002788:	defffc04 	addi	sp,sp,-16
 100278c:	df000315 	stw	fp,12(sp)
 1002790:	df000304 	addi	fp,sp,12
 1002794:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 1002798:	e0bfff17 	ldw	r2,-4(fp)
 100279c:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 10027a0:	e0bffe17 	ldw	r2,-8(fp)
 10027a4:	10800e17 	ldw	r2,56(r2)
 10027a8:	1000031e 	bne	r2,zero,10027b8 <xQueueIsQueueEmptyFromISR+0x30>
	{
		xReturn = pdTRUE;
 10027ac:	00800044 	movi	r2,1
 10027b0:	e0bffd15 	stw	r2,-12(fp)
 10027b4:	00000106 	br	10027bc <xQueueIsQueueEmptyFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
 10027b8:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 10027bc:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 10027c0:	e037883a 	mov	sp,fp
 10027c4:	df000017 	ldw	fp,0(sp)
 10027c8:	dec00104 	addi	sp,sp,4
 10027cc:	f800283a 	ret

010027d0 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 10027d0:	defffc04 	addi	sp,sp,-16
 10027d4:	dfc00315 	stw	ra,12(sp)
 10027d8:	df000215 	stw	fp,8(sp)
 10027dc:	df000204 	addi	fp,sp,8
 10027e0:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 10027e4:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 10027e8:	e0bfff17 	ldw	r2,-4(fp)
 10027ec:	10c00e17 	ldw	r3,56(r2)
 10027f0:	e0bfff17 	ldw	r2,-4(fp)
 10027f4:	10800f17 	ldw	r2,60(r2)
 10027f8:	1880031e 	bne	r3,r2,1002808 <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
 10027fc:	00800044 	movi	r2,1
 1002800:	e0bffe15 	stw	r2,-8(fp)
 1002804:	00000106 	br	100280c <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
 1002808:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 100280c:	10053c40 	call	10053c4 <vTaskExitCritical>

	return xReturn;
 1002810:	e0bffe17 	ldw	r2,-8(fp)
}
 1002814:	e037883a 	mov	sp,fp
 1002818:	dfc00117 	ldw	ra,4(sp)
 100281c:	df000017 	ldw	fp,0(sp)
 1002820:	dec00204 	addi	sp,sp,8
 1002824:	f800283a 	ret

01002828 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 1002828:	defffc04 	addi	sp,sp,-16
 100282c:	df000315 	stw	fp,12(sp)
 1002830:	df000304 	addi	fp,sp,12
 1002834:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 1002838:	e0bfff17 	ldw	r2,-4(fp)
 100283c:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1002840:	e0bffe17 	ldw	r2,-8(fp)
 1002844:	10c00e17 	ldw	r3,56(r2)
 1002848:	e0bffe17 	ldw	r2,-8(fp)
 100284c:	10800f17 	ldw	r2,60(r2)
 1002850:	1880031e 	bne	r3,r2,1002860 <xQueueIsQueueFullFromISR+0x38>
	{
		xReturn = pdTRUE;
 1002854:	00800044 	movi	r2,1
 1002858:	e0bffd15 	stw	r2,-12(fp)
 100285c:	00000106 	br	1002864 <xQueueIsQueueFullFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
 1002860:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 1002864:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 1002868:	e037883a 	mov	sp,fp
 100286c:	df000017 	ldw	fp,0(sp)
 1002870:	dec00104 	addi	sp,sp,4
 1002874:	f800283a 	ret

01002878 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
 1002878:	defff804 	addi	sp,sp,-32
 100287c:	dfc00715 	stw	ra,28(sp)
 1002880:	df000615 	stw	fp,24(sp)
 1002884:	df000604 	addi	fp,sp,24
 1002888:	e13ffd15 	stw	r4,-12(fp)
 100288c:	e17ffe15 	stw	r5,-8(fp)
 1002890:	e1bfff15 	stw	r6,-4(fp)

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
 1002894:	e0bfff17 	ldw	r2,-4(fp)
 1002898:	10800058 	cmpnei	r2,r2,1
 100289c:	1000031e 	bne	r2,zero,10028ac <xStreamBufferGenericCreate+0x34>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 10028a0:	00800044 	movi	r2,1
 10028a4:	e0bffb05 	stb	r2,-20(fp)
 10028a8:	00000106 	br	10028b0 <xStreamBufferGenericCreate+0x38>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
 10028ac:	e03ffb05 	stb	zero,-20(fp)
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
 10028b0:	e0bffe17 	ldw	r2,-8(fp)
 10028b4:	1000021e 	bne	r2,zero,10028c0 <xStreamBufferGenericCreate+0x48>
		{
			xTriggerLevelBytes = ( size_t ) 1;
 10028b8:	00800044 	movi	r2,1
 10028bc:	e0bffe15 	stw	r2,-8(fp)
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
 10028c0:	e0bffd17 	ldw	r2,-12(fp)
 10028c4:	10800044 	addi	r2,r2,1
 10028c8:	e0bffd15 	stw	r2,-12(fp)
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 10028cc:	e0bffd17 	ldw	r2,-12(fp)
 10028d0:	10800804 	addi	r2,r2,32
 10028d4:	1009883a 	mov	r4,r2
 10028d8:	10010b00 	call	10010b0 <pvPortMalloc>
 10028dc:	e0bffc15 	stw	r2,-16(fp)

		if( pucAllocatedMemory != NULL )
 10028e0:	e0bffc17 	ldw	r2,-16(fp)
 10028e4:	10000926 	beq	r2,zero,100290c <xStreamBufferGenericCreate+0x94>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 10028e8:	e0bffc17 	ldw	r2,-16(fp)
 10028ec:	10c00804 	addi	r3,r2,32
 10028f0:	e0bffb03 	ldbu	r2,-20(fp)
 10028f4:	d8800015 	stw	r2,0(sp)
 10028f8:	e1fffe17 	ldw	r7,-8(fp)
 10028fc:	e1bffd17 	ldw	r6,-12(fp)
 1002900:	180b883a 	mov	r5,r3
 1002904:	e13ffc17 	ldw	r4,-16(fp)
 1002908:	100369c0 	call	100369c <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 100290c:	e0bffc17 	ldw	r2,-16(fp)
	}
 1002910:	e037883a 	mov	sp,fp
 1002914:	dfc00117 	ldw	ra,4(sp)
 1002918:	df000017 	ldw	fp,0(sp)
 100291c:	dec00204 	addi	sp,sp,8
 1002920:	f800283a 	ret

01002924 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
 1002924:	defffc04 	addi	sp,sp,-16
 1002928:	dfc00315 	stw	ra,12(sp)
 100292c:	df000215 	stw	fp,8(sp)
 1002930:	df000204 	addi	fp,sp,8
 1002934:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 1002938:	e0bfff17 	ldw	r2,-4(fp)
 100293c:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 1002940:	e0bffe17 	ldw	r2,-8(fp)
 1002944:	10800703 	ldbu	r2,28(r2)
 1002948:	10803fcc 	andi	r2,r2,255
 100294c:	1080008c 	andi	r2,r2,2
 1002950:	1000031e 	bne	r2,zero,1002960 <vStreamBufferDelete+0x3c>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 1002954:	e13ffe17 	ldw	r4,-8(fp)
 1002958:	10012840 	call	1001284 <vPortFree>
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
	}
}
 100295c:	00000406 	br	1002970 <vStreamBufferDelete+0x4c>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 1002960:	01800804 	movi	r6,32
 1002964:	000b883a 	mov	r5,zero
 1002968:	e13ffe17 	ldw	r4,-8(fp)
 100296c:	1015a3c0 	call	1015a3c <memset>
	}
}
 1002970:	0001883a 	nop
 1002974:	e037883a 	mov	sp,fp
 1002978:	dfc00117 	ldw	ra,4(sp)
 100297c:	df000017 	ldw	fp,0(sp)
 1002980:	dec00204 	addi	sp,sp,8
 1002984:	f800283a 	ret

01002988 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
 1002988:	defffa04 	addi	sp,sp,-24
 100298c:	dfc00515 	stw	ra,20(sp)
 1002990:	df000415 	stw	fp,16(sp)
 1002994:	df000404 	addi	fp,sp,16
 1002998:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 100299c:	e0bfff17 	ldw	r2,-4(fp)
 10029a0:	e0bffe15 	stw	r2,-8(fp)
BaseType_t xReturn = pdFAIL;
 10029a4:	e03ffd15 	stw	zero,-12(fp)
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
 10029a8:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
 10029ac:	e0bffe17 	ldw	r2,-8(fp)
 10029b0:	10800417 	ldw	r2,16(r2)
 10029b4:	1000141e 	bne	r2,zero,1002a08 <xStreamBufferReset+0x80>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
 10029b8:	e0bffe17 	ldw	r2,-8(fp)
 10029bc:	10800517 	ldw	r2,20(r2)
 10029c0:	1000111e 	bne	r2,zero,1002a08 <xStreamBufferReset+0x80>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
 10029c4:	e0bffe17 	ldw	r2,-8(fp)
 10029c8:	10c00617 	ldw	r3,24(r2)
 10029cc:	e0bffe17 	ldw	r2,-8(fp)
 10029d0:	11000217 	ldw	r4,8(r2)
 10029d4:	e0bffe17 	ldw	r2,-8(fp)
 10029d8:	11400317 	ldw	r5,12(r2)
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
 10029dc:	e0bffe17 	ldw	r2,-8(fp)
 10029e0:	10800703 	ldbu	r2,28(r2)
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
 10029e4:	10803fcc 	andi	r2,r2,255
 10029e8:	d8800015 	stw	r2,0(sp)
 10029ec:	280f883a 	mov	r7,r5
 10029f0:	200d883a 	mov	r6,r4
 10029f4:	180b883a 	mov	r5,r3
 10029f8:	e13ffe17 	ldw	r4,-8(fp)
 10029fc:	100369c0 	call	100369c <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
 1002a00:	00800044 	movi	r2,1
 1002a04:	e0bffd15 	stw	r2,-12(fp)

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
 1002a08:	10053c40 	call	10053c4 <vTaskExitCritical>

	return xReturn;
 1002a0c:	e0bffd17 	ldw	r2,-12(fp)
}
 1002a10:	e037883a 	mov	sp,fp
 1002a14:	dfc00117 	ldw	ra,4(sp)
 1002a18:	df000017 	ldw	fp,0(sp)
 1002a1c:	dec00204 	addi	sp,sp,8
 1002a20:	f800283a 	ret

01002a24 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
 1002a24:	defffb04 	addi	sp,sp,-20
 1002a28:	df000415 	stw	fp,16(sp)
 1002a2c:	df000404 	addi	fp,sp,16
 1002a30:	e13ffe15 	stw	r4,-8(fp)
 1002a34:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1002a38:	e0bffe17 	ldw	r2,-8(fp)
 1002a3c:	e0bffd15 	stw	r2,-12(fp)
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
 1002a40:	e0bfff17 	ldw	r2,-4(fp)
 1002a44:	1000021e 	bne	r2,zero,1002a50 <xStreamBufferSetTriggerLevel+0x2c>
	{
		xTriggerLevel = ( size_t ) 1;
 1002a48:	00800044 	movi	r2,1
 1002a4c:	e0bfff15 	stw	r2,-4(fp)
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
 1002a50:	e0bffd17 	ldw	r2,-12(fp)
 1002a54:	10c00217 	ldw	r3,8(r2)
 1002a58:	e0bfff17 	ldw	r2,-4(fp)
 1002a5c:	18800636 	bltu	r3,r2,1002a78 <xStreamBufferSetTriggerLevel+0x54>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 1002a60:	e0bffd17 	ldw	r2,-12(fp)
 1002a64:	e0ffff17 	ldw	r3,-4(fp)
 1002a68:	10c00315 	stw	r3,12(r2)
		xReturn = pdPASS;
 1002a6c:	00800044 	movi	r2,1
 1002a70:	e0bffc15 	stw	r2,-16(fp)
 1002a74:	00000106 	br	1002a7c <xStreamBufferSetTriggerLevel+0x58>
	}
	else
	{
		xReturn = pdFALSE;
 1002a78:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
 1002a7c:	e0bffc17 	ldw	r2,-16(fp)
}
 1002a80:	e037883a 	mov	sp,fp
 1002a84:	df000017 	ldw	fp,0(sp)
 1002a88:	dec00104 	addi	sp,sp,4
 1002a8c:	f800283a 	ret

01002a90 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 1002a90:	defffc04 	addi	sp,sp,-16
 1002a94:	df000315 	stw	fp,12(sp)
 1002a98:	df000304 	addi	fp,sp,12
 1002a9c:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1002aa0:	e0bfff17 	ldw	r2,-4(fp)
 1002aa4:	e0bffe15 	stw	r2,-8(fp)
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 1002aa8:	e0bffe17 	ldw	r2,-8(fp)
 1002aac:	10c00217 	ldw	r3,8(r2)
 1002ab0:	e0bffe17 	ldw	r2,-8(fp)
 1002ab4:	10800017 	ldw	r2,0(r2)
 1002ab8:	1885883a 	add	r2,r3,r2
 1002abc:	e0bffd15 	stw	r2,-12(fp)
	xSpace -= pxStreamBuffer->xHead;
 1002ac0:	e0bffe17 	ldw	r2,-8(fp)
 1002ac4:	10800117 	ldw	r2,4(r2)
 1002ac8:	e0fffd17 	ldw	r3,-12(fp)
 1002acc:	1885c83a 	sub	r2,r3,r2
 1002ad0:	e0bffd15 	stw	r2,-12(fp)
	xSpace -= ( size_t ) 1;
 1002ad4:	e0bffd17 	ldw	r2,-12(fp)
 1002ad8:	10bfffc4 	addi	r2,r2,-1
 1002adc:	e0bffd15 	stw	r2,-12(fp)

	if( xSpace >= pxStreamBuffer->xLength )
 1002ae0:	e0bffe17 	ldw	r2,-8(fp)
 1002ae4:	10800217 	ldw	r2,8(r2)
 1002ae8:	e0fffd17 	ldw	r3,-12(fp)
 1002aec:	18800536 	bltu	r3,r2,1002b04 <xStreamBufferSpacesAvailable+0x74>
	{
		xSpace -= pxStreamBuffer->xLength;
 1002af0:	e0bffe17 	ldw	r2,-8(fp)
 1002af4:	10800217 	ldw	r2,8(r2)
 1002af8:	e0fffd17 	ldw	r3,-12(fp)
 1002afc:	1885c83a 	sub	r2,r3,r2
 1002b00:	e0bffd15 	stw	r2,-12(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
 1002b04:	e0bffd17 	ldw	r2,-12(fp)
}
 1002b08:	e037883a 	mov	sp,fp
 1002b0c:	df000017 	ldw	fp,0(sp)
 1002b10:	dec00104 	addi	sp,sp,4
 1002b14:	f800283a 	ret

01002b18 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
 1002b18:	defffb04 	addi	sp,sp,-20
 1002b1c:	dfc00415 	stw	ra,16(sp)
 1002b20:	df000315 	stw	fp,12(sp)
 1002b24:	df000304 	addi	fp,sp,12
 1002b28:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1002b2c:	e0bfff17 	ldw	r2,-4(fp)
 1002b30:	e0bffd15 	stw	r2,-12(fp)
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
 1002b34:	e13ffd17 	ldw	r4,-12(fp)
 1002b38:	10036280 	call	1003628 <prvBytesInBuffer>
 1002b3c:	e0bffe15 	stw	r2,-8(fp)
	return xReturn;
 1002b40:	e0bffe17 	ldw	r2,-8(fp)
}
 1002b44:	e037883a 	mov	sp,fp
 1002b48:	dfc00117 	ldw	ra,4(sp)
 1002b4c:	df000017 	ldw	fp,0(sp)
 1002b50:	dec00204 	addi	sp,sp,8
 1002b54:	f800283a 	ret

01002b58 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
 1002b58:	defff304 	addi	sp,sp,-52
 1002b5c:	dfc00c15 	stw	ra,48(sp)
 1002b60:	df000b15 	stw	fp,44(sp)
 1002b64:	df000b04 	addi	fp,sp,44
 1002b68:	e13ffc15 	stw	r4,-16(fp)
 1002b6c:	e17ffd15 	stw	r5,-12(fp)
 1002b70:	e1bffe15 	stw	r6,-8(fp)
 1002b74:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1002b78:	e0bffc17 	ldw	r2,-16(fp)
 1002b7c:	e0bff815 	stw	r2,-32(fp)
size_t xReturn, xSpace = 0;
 1002b80:	e03ff615 	stw	zero,-40(fp)
size_t xRequiredSpace = xDataLengthBytes;
 1002b84:	e0bffe17 	ldw	r2,-8(fp)
 1002b88:	e0bff715 	stw	r2,-36(fp)

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1002b8c:	e0bff817 	ldw	r2,-32(fp)
 1002b90:	10800703 	ldbu	r2,28(r2)
 1002b94:	10803fcc 	andi	r2,r2,255
 1002b98:	1080004c 	andi	r2,r2,1
 1002b9c:	10000326 	beq	r2,zero,1002bac <xStreamBufferSend+0x54>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 1002ba0:	e0bff717 	ldw	r2,-36(fp)
 1002ba4:	10800104 	addi	r2,r2,4
 1002ba8:	e0bff715 	stw	r2,-36(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
 1002bac:	e0bfff17 	ldw	r2,-4(fp)
 1002bb0:	10002226 	beq	r2,zero,1002c3c <xStreamBufferSend+0xe4>
	{
		vTaskSetTimeOutState( &xTimeOut );
 1002bb4:	e0bffa04 	addi	r2,fp,-24
 1002bb8:	1009883a 	mov	r4,r2
 1002bbc:	1004b8c0 	call	1004b8c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
 1002bc0:	10053700 	call	1005370 <vTaskEnterCritical>
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 1002bc4:	e13ff817 	ldw	r4,-32(fp)
 1002bc8:	1002a900 	call	1002a90 <xStreamBufferSpacesAvailable>
 1002bcc:	e0bff615 	stw	r2,-40(fp)

				if( xSpace < xRequiredSpace )
 1002bd0:	e0fff617 	ldw	r3,-40(fp)
 1002bd4:	e0bff717 	ldw	r2,-36(fp)
 1002bd8:	1880072e 	bgeu	r3,r2,1002bf8 <xStreamBufferSend+0xa0>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
 1002bdc:	0009883a 	mov	r4,zero
 1002be0:	1005af40 	call	1005af4 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 1002be4:	1004fcc0 	call	1004fcc <xTaskGetCurrentTaskHandle>
 1002be8:	1007883a 	mov	r3,r2
 1002bec:	e0bff817 	ldw	r2,-32(fp)
 1002bf0:	10c00515 	stw	r3,20(r2)
 1002bf4:	00000206 	br	1002c00 <xStreamBufferSend+0xa8>
				}
				else
				{
					taskEXIT_CRITICAL();
 1002bf8:	10053c40 	call	10053c4 <vTaskExitCritical>
					break;
 1002bfc:	00000f06 	br	1002c3c <xStreamBufferSend+0xe4>
				}
			}
			taskEXIT_CRITICAL();
 1002c00:	10053c40 	call	10053c4 <vTaskExitCritical>

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 1002c04:	e0bfff17 	ldw	r2,-4(fp)
 1002c08:	100f883a 	mov	r7,r2
 1002c0c:	000d883a 	mov	r6,zero
 1002c10:	000b883a 	mov	r5,zero
 1002c14:	0009883a 	mov	r4,zero
 1002c18:	10055500 	call	1005550 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
 1002c1c:	e0bff817 	ldw	r2,-32(fp)
 1002c20:	10000515 	stw	zero,20(r2)

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 1002c24:	e0ffff04 	addi	r3,fp,-4
 1002c28:	e0bffa04 	addi	r2,fp,-24
 1002c2c:	180b883a 	mov	r5,r3
 1002c30:	1009883a 	mov	r4,r2
 1002c34:	1004c140 	call	1004c14 <xTaskCheckForTimeOut>
 1002c38:	103fe126 	beq	r2,zero,1002bc0 <__alt_data_end+0xff002bc0>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
 1002c3c:	e0bff617 	ldw	r2,-40(fp)
 1002c40:	1000031e 	bne	r2,zero,1002c50 <xStreamBufferSend+0xf8>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 1002c44:	e13ff817 	ldw	r4,-32(fp)
 1002c48:	1002a900 	call	1002a90 <xStreamBufferSpacesAvailable>
 1002c4c:	e0bff615 	stw	r2,-40(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 1002c50:	e0bff717 	ldw	r2,-36(fp)
 1002c54:	d8800015 	stw	r2,0(sp)
 1002c58:	e1fff617 	ldw	r7,-40(fp)
 1002c5c:	e1bffe17 	ldw	r6,-8(fp)
 1002c60:	e17ffd17 	ldw	r5,-12(fp)
 1002c64:	e13ff817 	ldw	r4,-32(fp)
 1002c68:	1002dd00 	call	1002dd0 <prvWriteMessageToBuffer>
 1002c6c:	e0bff915 	stw	r2,-28(fp)

	if( xReturn > ( size_t ) 0 )
 1002c70:	e0bff917 	ldw	r2,-28(fp)
 1002c74:	10001426 	beq	r2,zero,1002cc8 <xStreamBufferSend+0x170>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 1002c78:	e13ff817 	ldw	r4,-32(fp)
 1002c7c:	10036280 	call	1003628 <prvBytesInBuffer>
 1002c80:	1007883a 	mov	r3,r2
 1002c84:	e0bff817 	ldw	r2,-32(fp)
 1002c88:	10800317 	ldw	r2,12(r2)
 1002c8c:	18800e36 	bltu	r3,r2,1002cc8 <xStreamBufferSend+0x170>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
 1002c90:	100445c0 	call	100445c <vTaskSuspendAll>
 1002c94:	e0bff817 	ldw	r2,-32(fp)
 1002c98:	10800417 	ldw	r2,16(r2)
 1002c9c:	10000926 	beq	r2,zero,1002cc4 <xStreamBufferSend+0x16c>
 1002ca0:	e0bff817 	ldw	r2,-32(fp)
 1002ca4:	10800417 	ldw	r2,16(r2)
 1002ca8:	000f883a 	mov	r7,zero
 1002cac:	000d883a 	mov	r6,zero
 1002cb0:	000b883a 	mov	r5,zero
 1002cb4:	1009883a 	mov	r4,r2
 1002cb8:	10056440 	call	1005644 <xTaskGenericNotify>
 1002cbc:	e0bff817 	ldw	r2,-32(fp)
 1002cc0:	10000415 	stw	zero,16(r2)
 1002cc4:	10044880 	call	1004488 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
 1002cc8:	e0bff917 	ldw	r2,-28(fp)
}
 1002ccc:	e037883a 	mov	sp,fp
 1002cd0:	dfc00117 	ldw	ra,4(sp)
 1002cd4:	df000017 	ldw	fp,0(sp)
 1002cd8:	dec00204 	addi	sp,sp,8
 1002cdc:	f800283a 	ret

01002ce0 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
 1002ce0:	defff404 	addi	sp,sp,-48
 1002ce4:	dfc00b15 	stw	ra,44(sp)
 1002ce8:	df000a15 	stw	fp,40(sp)
 1002cec:	df000a04 	addi	fp,sp,40
 1002cf0:	e13ffc15 	stw	r4,-16(fp)
 1002cf4:	e17ffd15 	stw	r5,-12(fp)
 1002cf8:	e1bffe15 	stw	r6,-8(fp)
 1002cfc:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1002d00:	e0bffc17 	ldw	r2,-16(fp)
 1002d04:	e0bff815 	stw	r2,-32(fp)
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
 1002d08:	e0bffe17 	ldw	r2,-8(fp)
 1002d0c:	e0bff715 	stw	r2,-36(fp)

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1002d10:	e0bff817 	ldw	r2,-32(fp)
 1002d14:	10800703 	ldbu	r2,28(r2)
 1002d18:	10803fcc 	andi	r2,r2,255
 1002d1c:	1080004c 	andi	r2,r2,1
 1002d20:	10000326 	beq	r2,zero,1002d30 <xStreamBufferSendFromISR+0x50>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 1002d24:	e0bff717 	ldw	r2,-36(fp)
 1002d28:	10800104 	addi	r2,r2,4
 1002d2c:	e0bff715 	stw	r2,-36(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 1002d30:	e13ff817 	ldw	r4,-32(fp)
 1002d34:	1002a900 	call	1002a90 <xStreamBufferSpacesAvailable>
 1002d38:	e0bff915 	stw	r2,-28(fp)
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 1002d3c:	e0bff717 	ldw	r2,-36(fp)
 1002d40:	d8800015 	stw	r2,0(sp)
 1002d44:	e1fff917 	ldw	r7,-28(fp)
 1002d48:	e1bffe17 	ldw	r6,-8(fp)
 1002d4c:	e17ffd17 	ldw	r5,-12(fp)
 1002d50:	e13ff817 	ldw	r4,-32(fp)
 1002d54:	1002dd00 	call	1002dd0 <prvWriteMessageToBuffer>
 1002d58:	e0bffa15 	stw	r2,-24(fp)

	if( xReturn > ( size_t ) 0 )
 1002d5c:	e0bffa17 	ldw	r2,-24(fp)
 1002d60:	10001526 	beq	r2,zero,1002db8 <xStreamBufferSendFromISR+0xd8>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 1002d64:	e13ff817 	ldw	r4,-32(fp)
 1002d68:	10036280 	call	1003628 <prvBytesInBuffer>
 1002d6c:	1007883a 	mov	r3,r2
 1002d70:	e0bff817 	ldw	r2,-32(fp)
 1002d74:	10800317 	ldw	r2,12(r2)
 1002d78:	18800f36 	bltu	r3,r2,1002db8 <xStreamBufferSendFromISR+0xd8>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 1002d7c:	e03ffb15 	stw	zero,-20(fp)
 1002d80:	e0bff817 	ldw	r2,-32(fp)
 1002d84:	10800417 	ldw	r2,16(r2)
 1002d88:	10000b26 	beq	r2,zero,1002db8 <xStreamBufferSendFromISR+0xd8>
 1002d8c:	e0bff817 	ldw	r2,-32(fp)
 1002d90:	10c00417 	ldw	r3,16(r2)
 1002d94:	e0bfff17 	ldw	r2,-4(fp)
 1002d98:	d8800015 	stw	r2,0(sp)
 1002d9c:	000f883a 	mov	r7,zero
 1002da0:	000d883a 	mov	r6,zero
 1002da4:	000b883a 	mov	r5,zero
 1002da8:	1809883a 	mov	r4,r3
 1002dac:	10057f00 	call	10057f0 <xTaskGenericNotifyFromISR>
 1002db0:	e0bff817 	ldw	r2,-32(fp)
 1002db4:	10000415 	stw	zero,16(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
 1002db8:	e0bffa17 	ldw	r2,-24(fp)
}
 1002dbc:	e037883a 	mov	sp,fp
 1002dc0:	dfc00117 	ldw	ra,4(sp)
 1002dc4:	df000017 	ldw	fp,0(sp)
 1002dc8:	dec00204 	addi	sp,sp,8
 1002dcc:	f800283a 	ret

01002dd0 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
 1002dd0:	defff804 	addi	sp,sp,-32
 1002dd4:	dfc00715 	stw	ra,28(sp)
 1002dd8:	df000615 	stw	fp,24(sp)
 1002ddc:	df000604 	addi	fp,sp,24
 1002de0:	e13ffc15 	stw	r4,-16(fp)
 1002de4:	e17ffd15 	stw	r5,-12(fp)
 1002de8:	e1bffe15 	stw	r6,-8(fp)
 1002dec:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
 1002df0:	e0bfff17 	ldw	r2,-4(fp)
 1002df4:	1000021e 	bne	r2,zero,1002e00 <prvWriteMessageToBuffer+0x30>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
 1002df8:	e03ffa15 	stw	zero,-24(fp)
 1002dfc:	00001906 	br	1002e64 <prvWriteMessageToBuffer+0x94>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
 1002e00:	e0bffc17 	ldw	r2,-16(fp)
 1002e04:	10800703 	ldbu	r2,28(r2)
 1002e08:	10803fcc 	andi	r2,r2,255
 1002e0c:	1080004c 	andi	r2,r2,1
 1002e10:	1000081e 	bne	r2,zero,1002e34 <prvWriteMessageToBuffer+0x64>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
 1002e14:	00800044 	movi	r2,1
 1002e18:	e0bffa15 	stw	r2,-24(fp)
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 1002e1c:	e0fffe17 	ldw	r3,-8(fp)
 1002e20:	e0bfff17 	ldw	r2,-4(fp)
 1002e24:	1880012e 	bgeu	r3,r2,1002e2c <prvWriteMessageToBuffer+0x5c>
 1002e28:	1805883a 	mov	r2,r3
 1002e2c:	e0bffe15 	stw	r2,-8(fp)
 1002e30:	00000c06 	br	1002e64 <prvWriteMessageToBuffer+0x94>
	}
	else if( xSpace >= xRequiredSpace )
 1002e34:	e0ffff17 	ldw	r3,-4(fp)
 1002e38:	e0800217 	ldw	r2,8(fp)
 1002e3c:	18800836 	bltu	r3,r2,1002e60 <prvWriteMessageToBuffer+0x90>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
 1002e40:	00800044 	movi	r2,1
 1002e44:	e0bffa15 	stw	r2,-24(fp)
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
 1002e48:	e0bffe04 	addi	r2,fp,-8
 1002e4c:	01800104 	movi	r6,4
 1002e50:	100b883a 	mov	r5,r2
 1002e54:	e13ffc17 	ldw	r4,-16(fp)
 1002e58:	10034200 	call	1003420 <prvWriteBytesToBuffer>
 1002e5c:	00000106 	br	1002e64 <prvWriteMessageToBuffer+0x94>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
 1002e60:	e03ffa15 	stw	zero,-24(fp)
	}

	if( xShouldWrite != pdFALSE )
 1002e64:	e0bffa17 	ldw	r2,-24(fp)
 1002e68:	10000726 	beq	r2,zero,1002e88 <prvWriteMessageToBuffer+0xb8>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
 1002e6c:	e0bffe17 	ldw	r2,-8(fp)
 1002e70:	100d883a 	mov	r6,r2
 1002e74:	e17ffd17 	ldw	r5,-12(fp)
 1002e78:	e13ffc17 	ldw	r4,-16(fp)
 1002e7c:	10034200 	call	1003420 <prvWriteBytesToBuffer>
 1002e80:	e0bffb15 	stw	r2,-20(fp)
 1002e84:	00000106 	br	1002e8c <prvWriteMessageToBuffer+0xbc>
	}
	else
	{
		xReturn = 0;
 1002e88:	e03ffb15 	stw	zero,-20(fp)
	}

	return xReturn;
 1002e8c:	e0bffb17 	ldw	r2,-20(fp)
}
 1002e90:	e037883a 	mov	sp,fp
 1002e94:	dfc00117 	ldw	ra,4(sp)
 1002e98:	df000017 	ldw	fp,0(sp)
 1002e9c:	dec00204 	addi	sp,sp,8
 1002ea0:	f800283a 	ret

01002ea4 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
 1002ea4:	defff504 	addi	sp,sp,-44
 1002ea8:	dfc00a15 	stw	ra,40(sp)
 1002eac:	df000915 	stw	fp,36(sp)
 1002eb0:	df000904 	addi	fp,sp,36
 1002eb4:	e13ffc15 	stw	r4,-16(fp)
 1002eb8:	e17ffd15 	stw	r5,-12(fp)
 1002ebc:	e1bffe15 	stw	r6,-8(fp)
 1002ec0:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1002ec4:	e0bffc17 	ldw	r2,-16(fp)
 1002ec8:	e0bffb15 	stw	r2,-20(fp)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 1002ecc:	e03ff815 	stw	zero,-32(fp)
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1002ed0:	e0bffb17 	ldw	r2,-20(fp)
 1002ed4:	10800703 	ldbu	r2,28(r2)
 1002ed8:	10803fcc 	andi	r2,r2,255
 1002edc:	1080004c 	andi	r2,r2,1
 1002ee0:	10000326 	beq	r2,zero,1002ef0 <xStreamBufferReceive+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 1002ee4:	00800104 	movi	r2,4
 1002ee8:	e0bffa15 	stw	r2,-24(fp)
 1002eec:	00000106 	br	1002ef4 <xStreamBufferReceive+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
 1002ef0:	e03ffa15 	stw	zero,-24(fp)
	}

	if( xTicksToWait != ( TickType_t ) 0 )
 1002ef4:	e0bfff17 	ldw	r2,-4(fp)
 1002ef8:	10001c26 	beq	r2,zero,1002f6c <xStreamBufferReceive+0xc8>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
 1002efc:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 1002f00:	e13ffb17 	ldw	r4,-20(fp)
 1002f04:	10036280 	call	1003628 <prvBytesInBuffer>
 1002f08:	e0bff915 	stw	r2,-28(fp)
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
 1002f0c:	e0bff917 	ldw	r2,-28(fp)
 1002f10:	e0fffa17 	ldw	r3,-24(fp)
 1002f14:	18800636 	bltu	r3,r2,1002f30 <xStreamBufferReceive+0x8c>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
 1002f18:	0009883a 	mov	r4,zero
 1002f1c:	1005af40 	call	1005af4 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 1002f20:	1004fcc0 	call	1004fcc <xTaskGetCurrentTaskHandle>
 1002f24:	1007883a 	mov	r3,r2
 1002f28:	e0bffb17 	ldw	r2,-20(fp)
 1002f2c:	10c00415 	stw	r3,16(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 1002f30:	10053c40 	call	10053c4 <vTaskExitCritical>

		if( xBytesAvailable <= xBytesToStoreMessageLength )
 1002f34:	e0bff917 	ldw	r2,-28(fp)
 1002f38:	e0fffa17 	ldw	r3,-24(fp)
 1002f3c:	18800e36 	bltu	r3,r2,1002f78 <xStreamBufferReceive+0xd4>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 1002f40:	e1ffff17 	ldw	r7,-4(fp)
 1002f44:	000d883a 	mov	r6,zero
 1002f48:	000b883a 	mov	r5,zero
 1002f4c:	0009883a 	mov	r4,zero
 1002f50:	10055500 	call	1005550 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
 1002f54:	e0bffb17 	ldw	r2,-20(fp)
 1002f58:	10000415 	stw	zero,16(r2)

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 1002f5c:	e13ffb17 	ldw	r4,-20(fp)
 1002f60:	10036280 	call	1003628 <prvBytesInBuffer>
 1002f64:	e0bff915 	stw	r2,-28(fp)
 1002f68:	00000306 	br	1002f78 <xStreamBufferReceive+0xd4>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 1002f6c:	e13ffb17 	ldw	r4,-20(fp)
 1002f70:	10036280 	call	1003628 <prvBytesInBuffer>
 1002f74:	e0bff915 	stw	r2,-28(fp)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
 1002f78:	e0bff917 	ldw	r2,-28(fp)
 1002f7c:	e0fffa17 	ldw	r3,-24(fp)
 1002f80:	1880182e 	bgeu	r3,r2,1002fe4 <xStreamBufferReceive+0x140>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
 1002f84:	e0bffa17 	ldw	r2,-24(fp)
 1002f88:	d8800015 	stw	r2,0(sp)
 1002f8c:	e1fff917 	ldw	r7,-28(fp)
 1002f90:	e1bffe17 	ldw	r6,-8(fp)
 1002f94:	e17ffd17 	ldw	r5,-12(fp)
 1002f98:	e13ffb17 	ldw	r4,-20(fp)
 1002f9c:	10031880 	call	1003188 <prvReadMessageFromBuffer>
 1002fa0:	e0bff815 	stw	r2,-32(fp)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
 1002fa4:	e0bff817 	ldw	r2,-32(fp)
 1002fa8:	10000e26 	beq	r2,zero,1002fe4 <xStreamBufferReceive+0x140>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
 1002fac:	100445c0 	call	100445c <vTaskSuspendAll>
 1002fb0:	e0bffb17 	ldw	r2,-20(fp)
 1002fb4:	10800517 	ldw	r2,20(r2)
 1002fb8:	10000926 	beq	r2,zero,1002fe0 <xStreamBufferReceive+0x13c>
 1002fbc:	e0bffb17 	ldw	r2,-20(fp)
 1002fc0:	10800517 	ldw	r2,20(r2)
 1002fc4:	000f883a 	mov	r7,zero
 1002fc8:	000d883a 	mov	r6,zero
 1002fcc:	000b883a 	mov	r5,zero
 1002fd0:	1009883a 	mov	r4,r2
 1002fd4:	10056440 	call	1005644 <xTaskGenericNotify>
 1002fd8:	e0bffb17 	ldw	r2,-20(fp)
 1002fdc:	10000515 	stw	zero,20(r2)
 1002fe0:	10044880 	call	1004488 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
 1002fe4:	e0bff817 	ldw	r2,-32(fp)
}
 1002fe8:	e037883a 	mov	sp,fp
 1002fec:	dfc00117 	ldw	ra,4(sp)
 1002ff0:	df000017 	ldw	fp,0(sp)
 1002ff4:	dec00204 	addi	sp,sp,8
 1002ff8:	f800283a 	ret

01002ffc <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
 1002ffc:	defff804 	addi	sp,sp,-32
 1003000:	dfc00715 	stw	ra,28(sp)
 1003004:	df000615 	stw	fp,24(sp)
 1003008:	df000604 	addi	fp,sp,24
 100300c:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1003010:	e0bfff17 	ldw	r2,-4(fp)
 1003014:	e0bffb15 	stw	r2,-20(fp)
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 1003018:	e0bffb17 	ldw	r2,-20(fp)
 100301c:	10800703 	ldbu	r2,28(r2)
 1003020:	10803fcc 	andi	r2,r2,255
 1003024:	1080004c 	andi	r2,r2,1
 1003028:	10001726 	beq	r2,zero,1003088 <xStreamBufferNextMessageLengthBytes+0x8c>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 100302c:	e13ffb17 	ldw	r4,-20(fp)
 1003030:	10036280 	call	1003628 <prvBytesInBuffer>
 1003034:	e0bffc15 	stw	r2,-16(fp)
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 1003038:	e0bffc17 	ldw	r2,-16(fp)
 100303c:	10800170 	cmpltui	r2,r2,5
 1003040:	10000f1e 	bne	r2,zero,1003080 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
 1003044:	e0bffb17 	ldw	r2,-20(fp)
 1003048:	10800017 	ldw	r2,0(r2)
 100304c:	e0bffd15 	stw	r2,-12(fp)
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
 1003050:	e0bffe04 	addi	r2,fp,-8
 1003054:	e1fffc17 	ldw	r7,-16(fp)
 1003058:	01800104 	movi	r6,4
 100305c:	100b883a 	mov	r5,r2
 1003060:	e13ffb17 	ldw	r4,-20(fp)
 1003064:	10035140 	call	1003514 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
 1003068:	e0bffe17 	ldw	r2,-8(fp)
 100306c:	e0bffa15 	stw	r2,-24(fp)
			pxStreamBuffer->xTail = xOriginalTail;
 1003070:	e0bffb17 	ldw	r2,-20(fp)
 1003074:	e0fffd17 	ldw	r3,-12(fp)
 1003078:	10c00015 	stw	r3,0(r2)
 100307c:	00000306 	br	100308c <xStreamBufferNextMessageLengthBytes+0x90>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
 1003080:	e03ffa15 	stw	zero,-24(fp)
 1003084:	00000106 	br	100308c <xStreamBufferNextMessageLengthBytes+0x90>
		}
	}
	else
	{
		xReturn = 0;
 1003088:	e03ffa15 	stw	zero,-24(fp)
	}

	return xReturn;
 100308c:	e0bffa17 	ldw	r2,-24(fp)
}
 1003090:	e037883a 	mov	sp,fp
 1003094:	dfc00117 	ldw	ra,4(sp)
 1003098:	df000017 	ldw	fp,0(sp)
 100309c:	dec00204 	addi	sp,sp,8
 10030a0:	f800283a 	ret

010030a4 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
 10030a4:	defff404 	addi	sp,sp,-48
 10030a8:	dfc00b15 	stw	ra,44(sp)
 10030ac:	df000a15 	stw	fp,40(sp)
 10030b0:	df000a04 	addi	fp,sp,40
 10030b4:	e13ffc15 	stw	r4,-16(fp)
 10030b8:	e17ffd15 	stw	r5,-12(fp)
 10030bc:	e1bffe15 	stw	r6,-8(fp)
 10030c0:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 10030c4:	e0bffc17 	ldw	r2,-16(fp)
 10030c8:	e0bff915 	stw	r2,-28(fp)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 10030cc:	e03ff715 	stw	zero,-36(fp)
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 10030d0:	e0bff917 	ldw	r2,-28(fp)
 10030d4:	10800703 	ldbu	r2,28(r2)
 10030d8:	10803fcc 	andi	r2,r2,255
 10030dc:	1080004c 	andi	r2,r2,1
 10030e0:	10000326 	beq	r2,zero,10030f0 <xStreamBufferReceiveFromISR+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 10030e4:	00800104 	movi	r2,4
 10030e8:	e0bff815 	stw	r2,-32(fp)
 10030ec:	00000106 	br	10030f4 <xStreamBufferReceiveFromISR+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
 10030f0:	e03ff815 	stw	zero,-32(fp)
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 10030f4:	e13ff917 	ldw	r4,-28(fp)
 10030f8:	10036280 	call	1003628 <prvBytesInBuffer>
 10030fc:	e0bffa15 	stw	r2,-24(fp)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
 1003100:	e0bffa17 	ldw	r2,-24(fp)
 1003104:	e0fff817 	ldw	r3,-32(fp)
 1003108:	1880192e 	bgeu	r3,r2,1003170 <xStreamBufferReceiveFromISR+0xcc>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
 100310c:	e0bff817 	ldw	r2,-32(fp)
 1003110:	d8800015 	stw	r2,0(sp)
 1003114:	e1fffa17 	ldw	r7,-24(fp)
 1003118:	e1bffe17 	ldw	r6,-8(fp)
 100311c:	e17ffd17 	ldw	r5,-12(fp)
 1003120:	e13ff917 	ldw	r4,-28(fp)
 1003124:	10031880 	call	1003188 <prvReadMessageFromBuffer>
 1003128:	e0bff715 	stw	r2,-36(fp)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
 100312c:	e0bff717 	ldw	r2,-36(fp)
 1003130:	10000f26 	beq	r2,zero,1003170 <xStreamBufferReceiveFromISR+0xcc>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 1003134:	e03ffb15 	stw	zero,-20(fp)
 1003138:	e0bff917 	ldw	r2,-28(fp)
 100313c:	10800517 	ldw	r2,20(r2)
 1003140:	10000b26 	beq	r2,zero,1003170 <xStreamBufferReceiveFromISR+0xcc>
 1003144:	e0bff917 	ldw	r2,-28(fp)
 1003148:	10c00517 	ldw	r3,20(r2)
 100314c:	e0bfff17 	ldw	r2,-4(fp)
 1003150:	d8800015 	stw	r2,0(sp)
 1003154:	000f883a 	mov	r7,zero
 1003158:	000d883a 	mov	r6,zero
 100315c:	000b883a 	mov	r5,zero
 1003160:	1809883a 	mov	r4,r3
 1003164:	10057f00 	call	10057f0 <xTaskGenericNotifyFromISR>
 1003168:	e0bff917 	ldw	r2,-28(fp)
 100316c:	10000515 	stw	zero,20(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
 1003170:	e0bff717 	ldw	r2,-36(fp)
}
 1003174:	e037883a 	mov	sp,fp
 1003178:	dfc00117 	ldw	ra,4(sp)
 100317c:	df000017 	ldw	fp,0(sp)
 1003180:	dec00204 	addi	sp,sp,8
 1003184:	f800283a 	ret

01003188 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
 1003188:	defff604 	addi	sp,sp,-40
 100318c:	dfc00915 	stw	ra,36(sp)
 1003190:	df000815 	stw	fp,32(sp)
 1003194:	df000804 	addi	fp,sp,32
 1003198:	e13ffc15 	stw	r4,-16(fp)
 100319c:	e17ffd15 	stw	r5,-12(fp)
 10031a0:	e1bffe15 	stw	r6,-8(fp)
 10031a4:	e1ffff15 	stw	r7,-4(fp)
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
 10031a8:	e0800217 	ldw	r2,8(fp)
 10031ac:	10001726 	beq	r2,zero,100320c <prvReadMessageFromBuffer+0x84>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
 10031b0:	e0bffc17 	ldw	r2,-16(fp)
 10031b4:	10800017 	ldw	r2,0(r2)
 10031b8:	e0bff915 	stw	r2,-28(fp)
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
 10031bc:	e0bffb04 	addi	r2,fp,-20
 10031c0:	e1ffff17 	ldw	r7,-4(fp)
 10031c4:	e1800217 	ldw	r6,8(fp)
 10031c8:	100b883a 	mov	r5,r2
 10031cc:	e13ffc17 	ldw	r4,-16(fp)
 10031d0:	10035140 	call	1003514 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
 10031d4:	e0bffb17 	ldw	r2,-20(fp)
 10031d8:	e0bff815 	stw	r2,-32(fp)

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
 10031dc:	e0ffff17 	ldw	r3,-4(fp)
 10031e0:	e0800217 	ldw	r2,8(fp)
 10031e4:	1885c83a 	sub	r2,r3,r2
 10031e8:	e0bfff15 	stw	r2,-4(fp)

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
 10031ec:	e0bff817 	ldw	r2,-32(fp)
 10031f0:	e0fffe17 	ldw	r3,-8(fp)
 10031f4:	1880072e 	bgeu	r3,r2,1003214 <prvReadMessageFromBuffer+0x8c>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
 10031f8:	e0bffc17 	ldw	r2,-16(fp)
 10031fc:	e0fff917 	ldw	r3,-28(fp)
 1003200:	10c00015 	stw	r3,0(r2)
			xNextMessageLength = 0;
 1003204:	e03ff815 	stw	zero,-32(fp)
 1003208:	00000206 	br	1003214 <prvReadMessageFromBuffer+0x8c>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
 100320c:	e0bffe17 	ldw	r2,-8(fp)
 1003210:	e0bff815 	stw	r2,-32(fp)
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 1003214:	e1ffff17 	ldw	r7,-4(fp)
 1003218:	e1bff817 	ldw	r6,-32(fp)
 100321c:	e17ffd17 	ldw	r5,-12(fp)
 1003220:	e13ffc17 	ldw	r4,-16(fp)
 1003224:	10035140 	call	1003514 <prvReadBytesFromBuffer>
 1003228:	e0bffa15 	stw	r2,-24(fp)

	return xReceivedLength;
 100322c:	e0bffa17 	ldw	r2,-24(fp)
}
 1003230:	e037883a 	mov	sp,fp
 1003234:	dfc00117 	ldw	ra,4(sp)
 1003238:	df000017 	ldw	fp,0(sp)
 100323c:	dec00204 	addi	sp,sp,8
 1003240:	f800283a 	ret

01003244 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
 1003244:	defffb04 	addi	sp,sp,-20
 1003248:	df000415 	stw	fp,16(sp)
 100324c:	df000404 	addi	fp,sp,16
 1003250:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1003254:	e0bfff17 	ldw	r2,-4(fp)
 1003258:	e0bffd15 	stw	r2,-12(fp)
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
 100325c:	e0bffd17 	ldw	r2,-12(fp)
 1003260:	10800017 	ldw	r2,0(r2)
 1003264:	e0bffe15 	stw	r2,-8(fp)
	if( pxStreamBuffer->xHead == xTail )
 1003268:	e0bffd17 	ldw	r2,-12(fp)
 100326c:	10c00117 	ldw	r3,4(r2)
 1003270:	e0bffe17 	ldw	r2,-8(fp)
 1003274:	1880031e 	bne	r3,r2,1003284 <xStreamBufferIsEmpty+0x40>
	{
		xReturn = pdTRUE;
 1003278:	00800044 	movi	r2,1
 100327c:	e0bffc15 	stw	r2,-16(fp)
 1003280:	00000106 	br	1003288 <xStreamBufferIsEmpty+0x44>
	}
	else
	{
		xReturn = pdFALSE;
 1003284:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
 1003288:	e0bffc17 	ldw	r2,-16(fp)
}
 100328c:	e037883a 	mov	sp,fp
 1003290:	df000017 	ldw	fp,0(sp)
 1003294:	dec00104 	addi	sp,sp,4
 1003298:	f800283a 	ret

0100329c <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
 100329c:	defffa04 	addi	sp,sp,-24
 10032a0:	dfc00515 	stw	ra,20(sp)
 10032a4:	df000415 	stw	fp,16(sp)
 10032a8:	df000404 	addi	fp,sp,16
 10032ac:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 10032b0:	e0bfff17 	ldw	r2,-4(fp)
 10032b4:	e0bffe15 	stw	r2,-8(fp)

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 10032b8:	e0bffe17 	ldw	r2,-8(fp)
 10032bc:	10800703 	ldbu	r2,28(r2)
 10032c0:	10803fcc 	andi	r2,r2,255
 10032c4:	1080004c 	andi	r2,r2,1
 10032c8:	10000326 	beq	r2,zero,10032d8 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 10032cc:	00800104 	movi	r2,4
 10032d0:	e0bffd15 	stw	r2,-12(fp)
 10032d4:	00000106 	br	10032dc <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
 10032d8:	e03ffd15 	stw	zero,-12(fp)
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 10032dc:	e13fff17 	ldw	r4,-4(fp)
 10032e0:	1002a900 	call	1002a90 <xStreamBufferSpacesAvailable>
 10032e4:	1007883a 	mov	r3,r2
 10032e8:	e0bffd17 	ldw	r2,-12(fp)
 10032ec:	10c00336 	bltu	r2,r3,10032fc <xStreamBufferIsFull+0x60>
	{
		xReturn = pdTRUE;
 10032f0:	00800044 	movi	r2,1
 10032f4:	e0bffc15 	stw	r2,-16(fp)
 10032f8:	00000106 	br	1003300 <xStreamBufferIsFull+0x64>
	}
	else
	{
		xReturn = pdFALSE;
 10032fc:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
 1003300:	e0bffc17 	ldw	r2,-16(fp)
}
 1003304:	e037883a 	mov	sp,fp
 1003308:	dfc00117 	ldw	ra,4(sp)
 100330c:	df000017 	ldw	fp,0(sp)
 1003310:	dec00204 	addi	sp,sp,8
 1003314:	f800283a 	ret

01003318 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
 1003318:	defff804 	addi	sp,sp,-32
 100331c:	dfc00715 	stw	ra,28(sp)
 1003320:	df000615 	stw	fp,24(sp)
 1003324:	df000604 	addi	fp,sp,24
 1003328:	e13ffe15 	stw	r4,-8(fp)
 100332c:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 1003330:	e0bffe17 	ldw	r2,-8(fp)
 1003334:	e0bffc15 	stw	r2,-16(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 1003338:	e03ffd15 	stw	zero,-12(fp)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 100333c:	e0bffc17 	ldw	r2,-16(fp)
 1003340:	10800417 	ldw	r2,16(r2)
 1003344:	10000e26 	beq	r2,zero,1003380 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 1003348:	e0bffc17 	ldw	r2,-16(fp)
 100334c:	10c00417 	ldw	r3,16(r2)
 1003350:	e0bfff17 	ldw	r2,-4(fp)
 1003354:	d8800015 	stw	r2,0(sp)
 1003358:	000f883a 	mov	r7,zero
 100335c:	000d883a 	mov	r6,zero
 1003360:	000b883a 	mov	r5,zero
 1003364:	1809883a 	mov	r4,r3
 1003368:	10057f00 	call	10057f0 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 100336c:	e0bffc17 	ldw	r2,-16(fp)
 1003370:	10000415 	stw	zero,16(r2)
			xReturn = pdTRUE;
 1003374:	00800044 	movi	r2,1
 1003378:	e0bffb15 	stw	r2,-20(fp)
 100337c:	00000106 	br	1003384 <xStreamBufferSendCompletedFromISR+0x6c>
		}
		else
		{
			xReturn = pdFALSE;
 1003380:	e03ffb15 	stw	zero,-20(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1003384:	e0bffb17 	ldw	r2,-20(fp)
}
 1003388:	e037883a 	mov	sp,fp
 100338c:	dfc00117 	ldw	ra,4(sp)
 1003390:	df000017 	ldw	fp,0(sp)
 1003394:	dec00204 	addi	sp,sp,8
 1003398:	f800283a 	ret

0100339c <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
 100339c:	defff804 	addi	sp,sp,-32
 10033a0:	dfc00715 	stw	ra,28(sp)
 10033a4:	df000615 	stw	fp,24(sp)
 10033a8:	df000604 	addi	fp,sp,24
 10033ac:	e13ffe15 	stw	r4,-8(fp)
 10033b0:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 10033b4:	e0bffe17 	ldw	r2,-8(fp)
 10033b8:	e0bffc15 	stw	r2,-16(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
 10033bc:	e03ffd15 	stw	zero,-12(fp)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 10033c0:	e0bffc17 	ldw	r2,-16(fp)
 10033c4:	10800517 	ldw	r2,20(r2)
 10033c8:	10000e26 	beq	r2,zero,1003404 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 10033cc:	e0bffc17 	ldw	r2,-16(fp)
 10033d0:	10c00517 	ldw	r3,20(r2)
 10033d4:	e0bfff17 	ldw	r2,-4(fp)
 10033d8:	d8800015 	stw	r2,0(sp)
 10033dc:	000f883a 	mov	r7,zero
 10033e0:	000d883a 	mov	r6,zero
 10033e4:	000b883a 	mov	r5,zero
 10033e8:	1809883a 	mov	r4,r3
 10033ec:	10057f00 	call	10057f0 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 10033f0:	e0bffc17 	ldw	r2,-16(fp)
 10033f4:	10000515 	stw	zero,20(r2)
			xReturn = pdTRUE;
 10033f8:	00800044 	movi	r2,1
 10033fc:	e0bffb15 	stw	r2,-20(fp)
 1003400:	00000106 	br	1003408 <xStreamBufferReceiveCompletedFromISR+0x6c>
		}
		else
		{
			xReturn = pdFALSE;
 1003404:	e03ffb15 	stw	zero,-20(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1003408:	e0bffb17 	ldw	r2,-20(fp)
}
 100340c:	e037883a 	mov	sp,fp
 1003410:	dfc00117 	ldw	ra,4(sp)
 1003414:	df000017 	ldw	fp,0(sp)
 1003418:	dec00204 	addi	sp,sp,8
 100341c:	f800283a 	ret

01003420 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
 1003420:	defff904 	addi	sp,sp,-28
 1003424:	dfc00615 	stw	ra,24(sp)
 1003428:	df000515 	stw	fp,20(sp)
 100342c:	df000504 	addi	fp,sp,20
 1003430:	e13ffd15 	stw	r4,-12(fp)
 1003434:	e17ffe15 	stw	r5,-8(fp)
 1003438:	e1bfff15 	stw	r6,-4(fp)
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
 100343c:	e0bffd17 	ldw	r2,-12(fp)
 1003440:	10800117 	ldw	r2,4(r2)
 1003444:	e0bffb15 	stw	r2,-20(fp)

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
 1003448:	e0bffd17 	ldw	r2,-12(fp)
 100344c:	10c00217 	ldw	r3,8(r2)
 1003450:	e0bffb17 	ldw	r2,-20(fp)
 1003454:	1885c83a 	sub	r2,r3,r2
 1003458:	e0ffff17 	ldw	r3,-4(fp)
 100345c:	1880012e 	bgeu	r3,r2,1003464 <prvWriteBytesToBuffer+0x44>
 1003460:	1805883a 	mov	r2,r3
 1003464:	e0bffc15 	stw	r2,-16(fp)

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 1003468:	e0bffd17 	ldw	r2,-12(fp)
 100346c:	10c00617 	ldw	r3,24(r2)
 1003470:	e0bffb17 	ldw	r2,-20(fp)
 1003474:	1885883a 	add	r2,r3,r2
 1003478:	e1bffc17 	ldw	r6,-16(fp)
 100347c:	e17ffe17 	ldw	r5,-8(fp)
 1003480:	1009883a 	mov	r4,r2
 1003484:	10158f40 	call	10158f4 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
 1003488:	e0bfff17 	ldw	r2,-4(fp)
 100348c:	e0fffc17 	ldw	r3,-16(fp)
 1003490:	18800a2e 	bgeu	r3,r2,10034bc <prvWriteBytesToBuffer+0x9c>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 1003494:	e0bffd17 	ldw	r2,-12(fp)
 1003498:	11000617 	ldw	r4,24(r2)
 100349c:	e0fffe17 	ldw	r3,-8(fp)
 10034a0:	e0bffc17 	ldw	r2,-16(fp)
 10034a4:	188b883a 	add	r5,r3,r2
 10034a8:	e0ffff17 	ldw	r3,-4(fp)
 10034ac:	e0bffc17 	ldw	r2,-16(fp)
 10034b0:	1885c83a 	sub	r2,r3,r2
 10034b4:	100d883a 	mov	r6,r2
 10034b8:	10158f40 	call	10158f4 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
 10034bc:	e0fffb17 	ldw	r3,-20(fp)
 10034c0:	e0bfff17 	ldw	r2,-4(fp)
 10034c4:	1885883a 	add	r2,r3,r2
 10034c8:	e0bffb15 	stw	r2,-20(fp)
	if( xNextHead >= pxStreamBuffer->xLength )
 10034cc:	e0bffd17 	ldw	r2,-12(fp)
 10034d0:	10800217 	ldw	r2,8(r2)
 10034d4:	e0fffb17 	ldw	r3,-20(fp)
 10034d8:	18800536 	bltu	r3,r2,10034f0 <prvWriteBytesToBuffer+0xd0>
	{
		xNextHead -= pxStreamBuffer->xLength;
 10034dc:	e0bffd17 	ldw	r2,-12(fp)
 10034e0:	10800217 	ldw	r2,8(r2)
 10034e4:	e0fffb17 	ldw	r3,-20(fp)
 10034e8:	1885c83a 	sub	r2,r3,r2
 10034ec:	e0bffb15 	stw	r2,-20(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
 10034f0:	e0bffd17 	ldw	r2,-12(fp)
 10034f4:	e0fffb17 	ldw	r3,-20(fp)
 10034f8:	10c00115 	stw	r3,4(r2)

	return xCount;
 10034fc:	e0bfff17 	ldw	r2,-4(fp)
}
 1003500:	e037883a 	mov	sp,fp
 1003504:	dfc00117 	ldw	ra,4(sp)
 1003508:	df000017 	ldw	fp,0(sp)
 100350c:	dec00204 	addi	sp,sp,8
 1003510:	f800283a 	ret

01003514 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
 1003514:	defff704 	addi	sp,sp,-36
 1003518:	dfc00815 	stw	ra,32(sp)
 100351c:	df000715 	stw	fp,28(sp)
 1003520:	df000704 	addi	fp,sp,28
 1003524:	e13ffc15 	stw	r4,-16(fp)
 1003528:	e17ffd15 	stw	r5,-12(fp)
 100352c:	e1bffe15 	stw	r6,-8(fp)
 1003530:	e1ffff15 	stw	r7,-4(fp)
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
 1003534:	e0ffff17 	ldw	r3,-4(fp)
 1003538:	e0bffe17 	ldw	r2,-8(fp)
 100353c:	1880012e 	bgeu	r3,r2,1003544 <prvReadBytesFromBuffer+0x30>
 1003540:	1805883a 	mov	r2,r3
 1003544:	e0bffa15 	stw	r2,-24(fp)

	if( xCount > ( size_t ) 0 )
 1003548:	e0bffa17 	ldw	r2,-24(fp)
 100354c:	10003026 	beq	r2,zero,1003610 <prvReadBytesFromBuffer+0xfc>
	{
		xNextTail = pxStreamBuffer->xTail;
 1003550:	e0bffc17 	ldw	r2,-16(fp)
 1003554:	10800017 	ldw	r2,0(r2)
 1003558:	e0bff915 	stw	r2,-28(fp)

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
 100355c:	e0bffc17 	ldw	r2,-16(fp)
 1003560:	10c00217 	ldw	r3,8(r2)
 1003564:	e0bff917 	ldw	r2,-28(fp)
 1003568:	1885c83a 	sub	r2,r3,r2
 100356c:	e0fffa17 	ldw	r3,-24(fp)
 1003570:	1880012e 	bgeu	r3,r2,1003578 <prvReadBytesFromBuffer+0x64>
 1003574:	1805883a 	mov	r2,r3
 1003578:	e0bffb15 	stw	r2,-20(fp)

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 100357c:	e0bffc17 	ldw	r2,-16(fp)
 1003580:	10c00617 	ldw	r3,24(r2)
 1003584:	e0bff917 	ldw	r2,-28(fp)
 1003588:	1885883a 	add	r2,r3,r2
 100358c:	e1bffb17 	ldw	r6,-20(fp)
 1003590:	100b883a 	mov	r5,r2
 1003594:	e13ffd17 	ldw	r4,-12(fp)
 1003598:	10158f40 	call	10158f4 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
 100359c:	e0bffa17 	ldw	r2,-24(fp)
 10035a0:	e0fffb17 	ldw	r3,-20(fp)
 10035a4:	18800a2e 	bgeu	r3,r2,10035d0 <prvReadBytesFromBuffer+0xbc>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 10035a8:	e0fffd17 	ldw	r3,-12(fp)
 10035ac:	e0bffb17 	ldw	r2,-20(fp)
 10035b0:	1889883a 	add	r4,r3,r2
 10035b4:	e0bffc17 	ldw	r2,-16(fp)
 10035b8:	11400617 	ldw	r5,24(r2)
 10035bc:	e0fffa17 	ldw	r3,-24(fp)
 10035c0:	e0bffb17 	ldw	r2,-20(fp)
 10035c4:	1885c83a 	sub	r2,r3,r2
 10035c8:	100d883a 	mov	r6,r2
 10035cc:	10158f40 	call	10158f4 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
 10035d0:	e0fff917 	ldw	r3,-28(fp)
 10035d4:	e0bffa17 	ldw	r2,-24(fp)
 10035d8:	1885883a 	add	r2,r3,r2
 10035dc:	e0bff915 	stw	r2,-28(fp)

		if( xNextTail >= pxStreamBuffer->xLength )
 10035e0:	e0bffc17 	ldw	r2,-16(fp)
 10035e4:	10800217 	ldw	r2,8(r2)
 10035e8:	e0fff917 	ldw	r3,-28(fp)
 10035ec:	18800536 	bltu	r3,r2,1003604 <prvReadBytesFromBuffer+0xf0>
		{
			xNextTail -= pxStreamBuffer->xLength;
 10035f0:	e0bffc17 	ldw	r2,-16(fp)
 10035f4:	10800217 	ldw	r2,8(r2)
 10035f8:	e0fff917 	ldw	r3,-28(fp)
 10035fc:	1885c83a 	sub	r2,r3,r2
 1003600:	e0bff915 	stw	r2,-28(fp)
		}

		pxStreamBuffer->xTail = xNextTail;
 1003604:	e0bffc17 	ldw	r2,-16(fp)
 1003608:	e0fff917 	ldw	r3,-28(fp)
 100360c:	10c00015 	stw	r3,0(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
 1003610:	e0bffa17 	ldw	r2,-24(fp)
}
 1003614:	e037883a 	mov	sp,fp
 1003618:	dfc00117 	ldw	ra,4(sp)
 100361c:	df000017 	ldw	fp,0(sp)
 1003620:	dec00204 	addi	sp,sp,8
 1003624:	f800283a 	ret

01003628 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
 1003628:	defffd04 	addi	sp,sp,-12
 100362c:	df000215 	stw	fp,8(sp)
 1003630:	df000204 	addi	fp,sp,8
 1003634:	e13fff15 	stw	r4,-4(fp)
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 1003638:	e0bfff17 	ldw	r2,-4(fp)
 100363c:	10c00217 	ldw	r3,8(r2)
 1003640:	e0bfff17 	ldw	r2,-4(fp)
 1003644:	10800117 	ldw	r2,4(r2)
 1003648:	1885883a 	add	r2,r3,r2
 100364c:	e0bffe15 	stw	r2,-8(fp)
	xCount -= pxStreamBuffer->xTail;
 1003650:	e0bfff17 	ldw	r2,-4(fp)
 1003654:	10800017 	ldw	r2,0(r2)
 1003658:	e0fffe17 	ldw	r3,-8(fp)
 100365c:	1885c83a 	sub	r2,r3,r2
 1003660:	e0bffe15 	stw	r2,-8(fp)
	if ( xCount >= pxStreamBuffer->xLength )
 1003664:	e0bfff17 	ldw	r2,-4(fp)
 1003668:	10800217 	ldw	r2,8(r2)
 100366c:	e0fffe17 	ldw	r3,-8(fp)
 1003670:	18800536 	bltu	r3,r2,1003688 <prvBytesInBuffer+0x60>
	{
		xCount -= pxStreamBuffer->xLength;
 1003674:	e0bfff17 	ldw	r2,-4(fp)
 1003678:	10800217 	ldw	r2,8(r2)
 100367c:	e0fffe17 	ldw	r3,-8(fp)
 1003680:	1885c83a 	sub	r2,r3,r2
 1003684:	e0bffe15 	stw	r2,-8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
 1003688:	e0bffe17 	ldw	r2,-8(fp)
}
 100368c:	e037883a 	mov	sp,fp
 1003690:	df000017 	ldw	fp,0(sp)
 1003694:	dec00104 	addi	sp,sp,4
 1003698:	f800283a 	ret

0100369c <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
 100369c:	defff904 	addi	sp,sp,-28
 10036a0:	dfc00615 	stw	ra,24(sp)
 10036a4:	df000515 	stw	fp,20(sp)
 10036a8:	df000504 	addi	fp,sp,20
 10036ac:	e13ffb15 	stw	r4,-20(fp)
 10036b0:	e17ffc15 	stw	r5,-16(fp)
 10036b4:	e1bffd15 	stw	r6,-12(fp)
 10036b8:	e1fffe15 	stw	r7,-8(fp)
 10036bc:	e0800217 	ldw	r2,8(fp)
 10036c0:	e0bfff05 	stb	r2,-4(fp)
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 10036c4:	01800804 	movi	r6,32
 10036c8:	000b883a 	mov	r5,zero
 10036cc:	e13ffb17 	ldw	r4,-20(fp)
 10036d0:	1015a3c0 	call	1015a3c <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
 10036d4:	e0bffb17 	ldw	r2,-20(fp)
 10036d8:	e0fffc17 	ldw	r3,-16(fp)
 10036dc:	10c00615 	stw	r3,24(r2)
	pxStreamBuffer->xLength = xBufferSizeBytes;
 10036e0:	e0bffb17 	ldw	r2,-20(fp)
 10036e4:	e0fffd17 	ldw	r3,-12(fp)
 10036e8:	10c00215 	stw	r3,8(r2)
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 10036ec:	e0bffb17 	ldw	r2,-20(fp)
 10036f0:	e0fffe17 	ldw	r3,-8(fp)
 10036f4:	10c00315 	stw	r3,12(r2)
	pxStreamBuffer->ucFlags = ucFlags;
 10036f8:	e0bffb17 	ldw	r2,-20(fp)
 10036fc:	e0ffff03 	ldbu	r3,-4(fp)
 1003700:	10c00705 	stb	r3,28(r2)
}
 1003704:	0001883a 	nop
 1003708:	e037883a 	mov	sp,fp
 100370c:	dfc00117 	ldw	ra,4(sp)
 1003710:	df000017 	ldw	fp,0(sp)
 1003714:	dec00204 	addi	sp,sp,8
 1003718:	f800283a 	ret

0100371c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 100371c:	defff304 	addi	sp,sp,-52
 1003720:	dfc00c15 	stw	ra,48(sp)
 1003724:	df000b15 	stw	fp,44(sp)
 1003728:	df000b04 	addi	fp,sp,44
 100372c:	e13ffc15 	stw	r4,-16(fp)
 1003730:	e17ffd15 	stw	r5,-12(fp)
 1003734:	3005883a 	mov	r2,r6
 1003738:	e1ffff15 	stw	r7,-4(fp)
 100373c:	e0bffe0d 	sth	r2,-8(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 1003740:	e0bffe0b 	ldhu	r2,-8(fp)
 1003744:	1085883a 	add	r2,r2,r2
 1003748:	1085883a 	add	r2,r2,r2
 100374c:	1009883a 	mov	r4,r2
 1003750:	10010b00 	call	10010b0 <pvPortMalloc>
 1003754:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
 1003758:	e0bffb17 	ldw	r2,-20(fp)
 100375c:	10000c26 	beq	r2,zero,1003790 <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 1003760:	01001404 	movi	r4,80
 1003764:	10010b00 	call	10010b0 <pvPortMalloc>
 1003768:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
 100376c:	e0bff917 	ldw	r2,-28(fp)
 1003770:	10000426 	beq	r2,zero,1003784 <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 1003774:	e0bff917 	ldw	r2,-28(fp)
 1003778:	e0fffb17 	ldw	r3,-20(fp)
 100377c:	10c00c15 	stw	r3,48(r2)
 1003780:	00000406 	br	1003794 <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 1003784:	e13ffb17 	ldw	r4,-20(fp)
 1003788:	10012840 	call	1001284 <vPortFree>
 100378c:	00000106 	br	1003794 <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
 1003790:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 1003794:	e0bff917 	ldw	r2,-28(fp)
 1003798:	10001226 	beq	r2,zero,10037e4 <xTaskCreate+0xc8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 100379c:	e0fffe0b 	ldhu	r3,-8(fp)
 10037a0:	d8000315 	stw	zero,12(sp)
 10037a4:	e0bff917 	ldw	r2,-28(fp)
 10037a8:	d8800215 	stw	r2,8(sp)
 10037ac:	e0800317 	ldw	r2,12(fp)
 10037b0:	d8800115 	stw	r2,4(sp)
 10037b4:	e0800217 	ldw	r2,8(fp)
 10037b8:	d8800015 	stw	r2,0(sp)
 10037bc:	e1ffff17 	ldw	r7,-4(fp)
 10037c0:	180d883a 	mov	r6,r3
 10037c4:	e17ffd17 	ldw	r5,-12(fp)
 10037c8:	e13ffc17 	ldw	r4,-16(fp)
 10037cc:	10038040 	call	1003804 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 10037d0:	e13ff917 	ldw	r4,-28(fp)
 10037d4:	10039e80 	call	10039e8 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 10037d8:	00800044 	movi	r2,1
 10037dc:	e0bffa15 	stw	r2,-24(fp)
 10037e0:	00000206 	br	10037ec <xTaskCreate+0xd0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 10037e4:	00bfffc4 	movi	r2,-1
 10037e8:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
 10037ec:	e0bffa17 	ldw	r2,-24(fp)
	}
 10037f0:	e037883a 	mov	sp,fp
 10037f4:	dfc00117 	ldw	ra,4(sp)
 10037f8:	df000017 	ldw	fp,0(sp)
 10037fc:	dec00204 	addi	sp,sp,8
 1003800:	f800283a 	ret

01003804 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 1003804:	defff804 	addi	sp,sp,-32
 1003808:	dfc00715 	stw	ra,28(sp)
 100380c:	df000615 	stw	fp,24(sp)
 1003810:	df000604 	addi	fp,sp,24
 1003814:	e13ffc15 	stw	r4,-16(fp)
 1003818:	e17ffd15 	stw	r5,-12(fp)
 100381c:	e1bffe15 	stw	r6,-8(fp)
 1003820:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 1003824:	e0800417 	ldw	r2,16(fp)
 1003828:	10c00c17 	ldw	r3,48(r2)
 100382c:	e0bffe17 	ldw	r2,-8(fp)
 1003830:	1085883a 	add	r2,r2,r2
 1003834:	1085883a 	add	r2,r2,r2
 1003838:	100d883a 	mov	r6,r2
 100383c:	01402944 	movi	r5,165
 1003840:	1809883a 	mov	r4,r3
 1003844:	1015a3c0 	call	1015a3c <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 1003848:	e0800417 	ldw	r2,16(fp)
 100384c:	10c00c17 	ldw	r3,48(r2)
 1003850:	e13ffe17 	ldw	r4,-8(fp)
 1003854:	00900034 	movhi	r2,16384
 1003858:	10bfffc4 	addi	r2,r2,-1
 100385c:	2085883a 	add	r2,r4,r2
 1003860:	1085883a 	add	r2,r2,r2
 1003864:	1085883a 	add	r2,r2,r2
 1003868:	1885883a 	add	r2,r3,r2
 100386c:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 1003870:	e0fffb17 	ldw	r3,-20(fp)
 1003874:	00bfff04 	movi	r2,-4
 1003878:	1884703a 	and	r2,r3,r2
 100387c:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 1003880:	e0bffd17 	ldw	r2,-12(fp)
 1003884:	10001e26 	beq	r2,zero,1003900 <prvInitialiseNewTask+0xfc>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 1003888:	e03ffa15 	stw	zero,-24(fp)
 100388c:	00001406 	br	10038e0 <prvInitialiseNewTask+0xdc>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 1003890:	e0fffd17 	ldw	r3,-12(fp)
 1003894:	e0bffa17 	ldw	r2,-24(fp)
 1003898:	1885883a 	add	r2,r3,r2
 100389c:	10c00003 	ldbu	r3,0(r2)
 10038a0:	e1000417 	ldw	r4,16(fp)
 10038a4:	e0bffa17 	ldw	r2,-24(fp)
 10038a8:	2085883a 	add	r2,r4,r2
 10038ac:	10800d04 	addi	r2,r2,52
 10038b0:	10c00005 	stb	r3,0(r2)

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 10038b4:	e0fffd17 	ldw	r3,-12(fp)
 10038b8:	e0bffa17 	ldw	r2,-24(fp)
 10038bc:	1885883a 	add	r2,r3,r2
 10038c0:	10800003 	ldbu	r2,0(r2)
 10038c4:	10803fcc 	andi	r2,r2,255
 10038c8:	1080201c 	xori	r2,r2,128
 10038cc:	10bfe004 	addi	r2,r2,-128
 10038d0:	10000726 	beq	r2,zero,10038f0 <prvInitialiseNewTask+0xec>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 10038d4:	e0bffa17 	ldw	r2,-24(fp)
 10038d8:	10800044 	addi	r2,r2,1
 10038dc:	e0bffa15 	stw	r2,-24(fp)
 10038e0:	e0bffa17 	ldw	r2,-24(fp)
 10038e4:	10800230 	cmpltui	r2,r2,8
 10038e8:	103fe91e 	bne	r2,zero,1003890 <__alt_data_end+0xff003890>
 10038ec:	00000106 	br	10038f4 <prvInitialiseNewTask+0xf0>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
 10038f0:	0001883a 	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 10038f4:	e0800417 	ldw	r2,16(fp)
 10038f8:	10000ec5 	stb	zero,59(r2)
 10038fc:	00000206 	br	1003908 <prvInitialiseNewTask+0x104>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 1003900:	e0800417 	ldw	r2,16(fp)
 1003904:	10000d05 	stb	zero,52(r2)
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1003908:	e0800217 	ldw	r2,8(fp)
 100390c:	10800170 	cmpltui	r2,r2,5
 1003910:	1000021e 	bne	r2,zero,100391c <prvInitialiseNewTask+0x118>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1003914:	00800104 	movi	r2,4
 1003918:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 100391c:	e0800417 	ldw	r2,16(fp)
 1003920:	e0c00217 	ldw	r3,8(fp)
 1003924:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 1003928:	e0800417 	ldw	r2,16(fp)
 100392c:	e0c00217 	ldw	r3,8(fp)
 1003930:	10c01015 	stw	r3,64(r2)
		pxNewTCB->uxMutexesHeld = 0;
 1003934:	e0800417 	ldw	r2,16(fp)
 1003938:	10001115 	stw	zero,68(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 100393c:	e0800417 	ldw	r2,16(fp)
 1003940:	10800104 	addi	r2,r2,4
 1003944:	1009883a 	mov	r4,r2
 1003948:	1000a040 	call	1000a04 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 100394c:	e0800417 	ldw	r2,16(fp)
 1003950:	10800604 	addi	r2,r2,24
 1003954:	1009883a 	mov	r4,r2
 1003958:	1000a040 	call	1000a04 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 100395c:	e0800417 	ldw	r2,16(fp)
 1003960:	e0c00417 	ldw	r3,16(fp)
 1003964:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1003968:	00c00144 	movi	r3,5
 100396c:	e0800217 	ldw	r2,8(fp)
 1003970:	1887c83a 	sub	r3,r3,r2
 1003974:	e0800417 	ldw	r2,16(fp)
 1003978:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 100397c:	e0800417 	ldw	r2,16(fp)
 1003980:	e0c00417 	ldw	r3,16(fp)
 1003984:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 1003988:	e0800417 	ldw	r2,16(fp)
 100398c:	10000f15 	stw	zero,60(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 1003990:	e0800417 	ldw	r2,16(fp)
 1003994:	10001215 	stw	zero,72(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1003998:	e0800417 	ldw	r2,16(fp)
 100399c:	10001305 	stb	zero,76(r2)
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 10039a0:	e1bfff17 	ldw	r6,-4(fp)
 10039a4:	e17ffc17 	ldw	r5,-16(fp)
 10039a8:	e13ffb17 	ldw	r4,-20(fp)
 10039ac:	1000c580 	call	1000c58 <pxPortInitialiseStack>
 10039b0:	1007883a 	mov	r3,r2
 10039b4:	e0800417 	ldw	r2,16(fp)
 10039b8:	10c00015 	stw	r3,0(r2)
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 10039bc:	e0800317 	ldw	r2,12(fp)
 10039c0:	10000326 	beq	r2,zero,10039d0 <prvInitialiseNewTask+0x1cc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 10039c4:	e0800317 	ldw	r2,12(fp)
 10039c8:	e0c00417 	ldw	r3,16(fp)
 10039cc:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 10039d0:	0001883a 	nop
 10039d4:	e037883a 	mov	sp,fp
 10039d8:	dfc00117 	ldw	ra,4(sp)
 10039dc:	df000017 	ldw	fp,0(sp)
 10039e0:	dec00204 	addi	sp,sp,8
 10039e4:	f800283a 	ret

010039e8 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 10039e8:	defffd04 	addi	sp,sp,-12
 10039ec:	dfc00215 	stw	ra,8(sp)
 10039f0:	df000115 	stw	fp,4(sp)
 10039f4:	df000104 	addi	fp,sp,4
 10039f8:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 10039fc:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 1003a00:	d0a74517 	ldw	r2,-25324(gp)
 1003a04:	10800044 	addi	r2,r2,1
 1003a08:	d0a74515 	stw	r2,-25324(gp)
		if( pxCurrentTCB == NULL )
 1003a0c:	d0a74117 	ldw	r2,-25340(gp)
 1003a10:	1000071e 	bne	r2,zero,1003a30 <prvAddNewTaskToReadyList+0x48>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 1003a14:	e0bfff17 	ldw	r2,-4(fp)
 1003a18:	d0a74115 	stw	r2,-25340(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 1003a1c:	d0a74517 	ldw	r2,-25324(gp)
 1003a20:	10800058 	cmpnei	r2,r2,1
 1003a24:	10000b1e 	bne	r2,zero,1003a54 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 1003a28:	1004d380 	call	1004d38 <prvInitialiseTaskLists>
 1003a2c:	00000906 	br	1003a54 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 1003a30:	d0a74817 	ldw	r2,-25312(gp)
 1003a34:	1000071e 	bne	r2,zero,1003a54 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 1003a38:	d0a74117 	ldw	r2,-25340(gp)
 1003a3c:	10800b17 	ldw	r2,44(r2)
 1003a40:	e0ffff17 	ldw	r3,-4(fp)
 1003a44:	18c00b17 	ldw	r3,44(r3)
 1003a48:	18800236 	bltu	r3,r2,1003a54 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
 1003a4c:	e0bfff17 	ldw	r2,-4(fp)
 1003a50:	d0a74115 	stw	r2,-25340(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 1003a54:	d0a74c17 	ldw	r2,-25296(gp)
 1003a58:	10800044 	addi	r2,r2,1
 1003a5c:	d0a74c15 	stw	r2,-25296(gp)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 1003a60:	e0bfff17 	ldw	r2,-4(fp)
 1003a64:	10800b17 	ldw	r2,44(r2)
 1003a68:	d0e74717 	ldw	r3,-25316(gp)
 1003a6c:	1880032e 	bgeu	r3,r2,1003a7c <prvAddNewTaskToReadyList+0x94>
 1003a70:	e0bfff17 	ldw	r2,-4(fp)
 1003a74:	10800b17 	ldw	r2,44(r2)
 1003a78:	d0a74715 	stw	r2,-25316(gp)
 1003a7c:	e0bfff17 	ldw	r2,-4(fp)
 1003a80:	10800b17 	ldw	r2,44(r2)
 1003a84:	10c00524 	muli	r3,r2,20
 1003a88:	008060f4 	movhi	r2,387
 1003a8c:	10b9b404 	addi	r2,r2,-6448
 1003a90:	1887883a 	add	r3,r3,r2
 1003a94:	e0bfff17 	ldw	r2,-4(fp)
 1003a98:	10800104 	addi	r2,r2,4
 1003a9c:	100b883a 	mov	r5,r2
 1003aa0:	1809883a 	mov	r4,r3
 1003aa4:	1000a300 	call	1000a30 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 1003aa8:	10053c40 	call	10053c4 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
 1003aac:	d0a74817 	ldw	r2,-25312(gp)
 1003ab0:	10000626 	beq	r2,zero,1003acc <prvAddNewTaskToReadyList+0xe4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 1003ab4:	d0a74117 	ldw	r2,-25340(gp)
 1003ab8:	10c00b17 	ldw	r3,44(r2)
 1003abc:	e0bfff17 	ldw	r2,-4(fp)
 1003ac0:	10800b17 	ldw	r2,44(r2)
 1003ac4:	1880012e 	bgeu	r3,r2,1003acc <prvAddNewTaskToReadyList+0xe4>
		{
			taskYIELD_IF_USING_PREEMPTION();
 1003ac8:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 1003acc:	0001883a 	nop
 1003ad0:	e037883a 	mov	sp,fp
 1003ad4:	dfc00117 	ldw	ra,4(sp)
 1003ad8:	df000017 	ldw	fp,0(sp)
 1003adc:	dec00204 	addi	sp,sp,8
 1003ae0:	f800283a 	ret

01003ae4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 1003ae4:	defffc04 	addi	sp,sp,-16
 1003ae8:	dfc00315 	stw	ra,12(sp)
 1003aec:	df000215 	stw	fp,8(sp)
 1003af0:	df000204 	addi	fp,sp,8
 1003af4:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 1003af8:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 1003afc:	e0bfff17 	ldw	r2,-4(fp)
 1003b00:	1000021e 	bne	r2,zero,1003b0c <vTaskDelete+0x28>
 1003b04:	d0a74117 	ldw	r2,-25340(gp)
 1003b08:	00000106 	br	1003b10 <vTaskDelete+0x2c>
 1003b0c:	e0bfff17 	ldw	r2,-4(fp)
 1003b10:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1003b14:	e0bffe17 	ldw	r2,-8(fp)
 1003b18:	10800104 	addi	r2,r2,4
 1003b1c:	1009883a 	mov	r4,r2
 1003b20:	1000b940 	call	1000b94 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1003b24:	e0bffe17 	ldw	r2,-8(fp)
 1003b28:	10800a17 	ldw	r2,40(r2)
 1003b2c:	10000426 	beq	r2,zero,1003b40 <vTaskDelete+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1003b30:	e0bffe17 	ldw	r2,-8(fp)
 1003b34:	10800604 	addi	r2,r2,24
 1003b38:	1009883a 	mov	r4,r2
 1003b3c:	1000b940 	call	1000b94 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
 1003b40:	d0a74c17 	ldw	r2,-25296(gp)
 1003b44:	10800044 	addi	r2,r2,1
 1003b48:	d0a74c15 	stw	r2,-25296(gp)

			if( pxTCB == pxCurrentTCB )
 1003b4c:	d0a74117 	ldw	r2,-25340(gp)
 1003b50:	e0fffe17 	ldw	r3,-8(fp)
 1003b54:	18800a1e 	bne	r3,r2,1003b80 <vTaskDelete+0x9c>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 1003b58:	e0bffe17 	ldw	r2,-8(fp)
 1003b5c:	10800104 	addi	r2,r2,4
 1003b60:	100b883a 	mov	r5,r2
 1003b64:	010060f4 	movhi	r4,387
 1003b68:	2139dc04 	addi	r4,r4,-6288
 1003b6c:	1000a300 	call	1000a30 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
 1003b70:	d0a74417 	ldw	r2,-25328(gp)
 1003b74:	10800044 	addi	r2,r2,1
 1003b78:	d0a74415 	stw	r2,-25328(gp)
 1003b7c:	00000606 	br	1003b98 <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
 1003b80:	d0a74517 	ldw	r2,-25324(gp)
 1003b84:	10bfffc4 	addi	r2,r2,-1
 1003b88:	d0a74515 	stw	r2,-25324(gp)
				prvDeleteTCB( pxTCB );
 1003b8c:	e13ffe17 	ldw	r4,-8(fp)
 1003b90:	1004f340 	call	1004f34 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
 1003b94:	1004f780 	call	1004f78 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 1003b98:	10053c40 	call	10053c4 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 1003b9c:	d0a74817 	ldw	r2,-25312(gp)
 1003ba0:	10000426 	beq	r2,zero,1003bb4 <vTaskDelete+0xd0>
		{
			if( pxTCB == pxCurrentTCB )
 1003ba4:	d0a74117 	ldw	r2,-25340(gp)
 1003ba8:	e0fffe17 	ldw	r3,-8(fp)
 1003bac:	1880011e 	bne	r3,r2,1003bb4 <vTaskDelete+0xd0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 1003bb0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 1003bb4:	0001883a 	nop
 1003bb8:	e037883a 	mov	sp,fp
 1003bbc:	dfc00117 	ldw	ra,4(sp)
 1003bc0:	df000017 	ldw	fp,0(sp)
 1003bc4:	dec00204 	addi	sp,sp,8
 1003bc8:	f800283a 	ret

01003bcc <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 1003bcc:	defff804 	addi	sp,sp,-32
 1003bd0:	dfc00715 	stw	ra,28(sp)
 1003bd4:	df000615 	stw	fp,24(sp)
 1003bd8:	df000604 	addi	fp,sp,24
 1003bdc:	e13ffe15 	stw	r4,-8(fp)
 1003be0:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 1003be4:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 1003be8:	100445c0 	call	100445c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 1003bec:	d0a74617 	ldw	r2,-25320(gp)
 1003bf0:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1003bf4:	e0bffe17 	ldw	r2,-8(fp)
 1003bf8:	10c00017 	ldw	r3,0(r2)
 1003bfc:	e0bfff17 	ldw	r2,-4(fp)
 1003c00:	1885883a 	add	r2,r3,r2
 1003c04:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
 1003c08:	e0bffe17 	ldw	r2,-8(fp)
 1003c0c:	10800017 	ldw	r2,0(r2)
 1003c10:	e0fffb17 	ldw	r3,-20(fp)
 1003c14:	18800a2e 	bgeu	r3,r2,1003c40 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1003c18:	e0bffe17 	ldw	r2,-8(fp)
 1003c1c:	10800017 	ldw	r2,0(r2)
 1003c20:	e0fffc17 	ldw	r3,-16(fp)
 1003c24:	18800f2e 	bgeu	r3,r2,1003c64 <vTaskDelayUntil+0x98>
 1003c28:	e0bffc17 	ldw	r2,-16(fp)
 1003c2c:	e0fffb17 	ldw	r3,-20(fp)
 1003c30:	18800c2e 	bgeu	r3,r2,1003c64 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 1003c34:	00800044 	movi	r2,1
 1003c38:	e0bffa15 	stw	r2,-24(fp)
 1003c3c:	00000906 	br	1003c64 <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1003c40:	e0bffe17 	ldw	r2,-8(fp)
 1003c44:	10800017 	ldw	r2,0(r2)
 1003c48:	e0fffc17 	ldw	r3,-16(fp)
 1003c4c:	18800336 	bltu	r3,r2,1003c5c <vTaskDelayUntil+0x90>
 1003c50:	e0bffc17 	ldw	r2,-16(fp)
 1003c54:	e0fffb17 	ldw	r3,-20(fp)
 1003c58:	1880022e 	bgeu	r3,r2,1003c64 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 1003c5c:	00800044 	movi	r2,1
 1003c60:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 1003c64:	e0bffe17 	ldw	r2,-8(fp)
 1003c68:	e0fffc17 	ldw	r3,-16(fp)
 1003c6c:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
 1003c70:	e0bffa17 	ldw	r2,-24(fp)
 1003c74:	10000626 	beq	r2,zero,1003c90 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 1003c78:	e0fffc17 	ldw	r3,-16(fp)
 1003c7c:	e0bffb17 	ldw	r2,-20(fp)
 1003c80:	1885c83a 	sub	r2,r3,r2
 1003c84:	000b883a 	mov	r5,zero
 1003c88:	1009883a 	mov	r4,r2
 1003c8c:	1005b6c0 	call	1005b6c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 1003c90:	10044880 	call	1004488 <xTaskResumeAll>
 1003c94:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 1003c98:	e0bffd17 	ldw	r2,-12(fp)
 1003c9c:	1000011e 	bne	r2,zero,1003ca4 <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
 1003ca0:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1003ca4:	0001883a 	nop
 1003ca8:	e037883a 	mov	sp,fp
 1003cac:	dfc00117 	ldw	ra,4(sp)
 1003cb0:	df000017 	ldw	fp,0(sp)
 1003cb4:	dec00204 	addi	sp,sp,8
 1003cb8:	f800283a 	ret

01003cbc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 1003cbc:	defffc04 	addi	sp,sp,-16
 1003cc0:	dfc00315 	stw	ra,12(sp)
 1003cc4:	df000215 	stw	fp,8(sp)
 1003cc8:	df000204 	addi	fp,sp,8
 1003ccc:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
 1003cd0:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 1003cd4:	e0bfff17 	ldw	r2,-4(fp)
 1003cd8:	10000626 	beq	r2,zero,1003cf4 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 1003cdc:	100445c0 	call	100445c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 1003ce0:	000b883a 	mov	r5,zero
 1003ce4:	e13fff17 	ldw	r4,-4(fp)
 1003ce8:	1005b6c0 	call	1005b6c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 1003cec:	10044880 	call	1004488 <xTaskResumeAll>
 1003cf0:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 1003cf4:	e0bffe17 	ldw	r2,-8(fp)
 1003cf8:	1000011e 	bne	r2,zero,1003d00 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
 1003cfc:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1003d00:	0001883a 	nop
 1003d04:	e037883a 	mov	sp,fp
 1003d08:	dfc00117 	ldw	ra,4(sp)
 1003d0c:	df000017 	ldw	fp,0(sp)
 1003d10:	dec00204 	addi	sp,sp,8
 1003d14:	f800283a 	ret

01003d18 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
 1003d18:	defff804 	addi	sp,sp,-32
 1003d1c:	dfc00715 	stw	ra,28(sp)
 1003d20:	df000615 	stw	fp,24(sp)
 1003d24:	df000604 	addi	fp,sp,24
 1003d28:	e13fff15 	stw	r4,-4(fp)
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
 1003d2c:	e0bfff17 	ldw	r2,-4(fp)
 1003d30:	e0bffb15 	stw	r2,-20(fp)

		configASSERT( pxTCB );

		if( pxTCB == pxCurrentTCB )
 1003d34:	d0a74117 	ldw	r2,-25340(gp)
 1003d38:	e0fffb17 	ldw	r3,-20(fp)
 1003d3c:	1880021e 	bne	r3,r2,1003d48 <eTaskGetState+0x30>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
 1003d40:	e03ffa15 	stw	zero,-24(fp)
 1003d44:	00003206 	br	1003e10 <eTaskGetState+0xf8>
		}
		else
		{
			taskENTER_CRITICAL();
 1003d48:	10053700 	call	1005370 <vTaskEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 1003d4c:	e0bffb17 	ldw	r2,-20(fp)
 1003d50:	10800517 	ldw	r2,20(r2)
 1003d54:	e0bffc15 	stw	r2,-16(fp)
				pxDelayedList = pxDelayedTaskList;
 1003d58:	d0a74217 	ldw	r2,-25336(gp)
 1003d5c:	e0bffd15 	stw	r2,-12(fp)
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 1003d60:	d0a74317 	ldw	r2,-25332(gp)
 1003d64:	e0bffe15 	stw	r2,-8(fp)
			}
			taskEXIT_CRITICAL();
 1003d68:	10053c40 	call	10053c4 <vTaskExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 1003d6c:	e0fffc17 	ldw	r3,-16(fp)
 1003d70:	e0bffd17 	ldw	r2,-12(fp)
 1003d74:	18800326 	beq	r3,r2,1003d84 <eTaskGetState+0x6c>
 1003d78:	e0fffc17 	ldw	r3,-16(fp)
 1003d7c:	e0bffe17 	ldw	r2,-8(fp)
 1003d80:	1880031e 	bne	r3,r2,1003d90 <eTaskGetState+0x78>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
 1003d84:	00800084 	movi	r2,2
 1003d88:	e0bffa15 	stw	r2,-24(fp)
 1003d8c:	00002006 	br	1003e10 <eTaskGetState+0xf8>
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
 1003d90:	e0fffc17 	ldw	r3,-16(fp)
 1003d94:	008060f4 	movhi	r2,387
 1003d98:	10b9e104 	addi	r2,r2,-6268
 1003d9c:	1880111e 	bne	r3,r2,1003de4 <eTaskGetState+0xcc>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 1003da0:	e0bffb17 	ldw	r2,-20(fp)
 1003da4:	10800a17 	ldw	r2,40(r2)
 1003da8:	10000b1e 	bne	r2,zero,1003dd8 <eTaskGetState+0xc0>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 1003dac:	e0bffb17 	ldw	r2,-20(fp)
 1003db0:	10801303 	ldbu	r2,76(r2)
 1003db4:	10803fcc 	andi	r2,r2,255
 1003db8:	10800058 	cmpnei	r2,r2,1
 1003dbc:	1000031e 	bne	r2,zero,1003dcc <eTaskGetState+0xb4>
							{
								eReturn = eBlocked;
 1003dc0:	00800084 	movi	r2,2
 1003dc4:	e0bffa15 	stw	r2,-24(fp)
 1003dc8:	00001106 	br	1003e10 <eTaskGetState+0xf8>
							}
							else
							{
								eReturn = eSuspended;
 1003dcc:	008000c4 	movi	r2,3
 1003dd0:	e0bffa15 	stw	r2,-24(fp)
 1003dd4:	00000e06 	br	1003e10 <eTaskGetState+0xf8>
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
 1003dd8:	00800084 	movi	r2,2
 1003ddc:	e0bffa15 	stw	r2,-24(fp)
 1003de0:	00000b06 	br	1003e10 <eTaskGetState+0xf8>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 1003de4:	e0fffc17 	ldw	r3,-16(fp)
 1003de8:	008060f4 	movhi	r2,387
 1003dec:	10b9dc04 	addi	r2,r2,-6288
 1003df0:	18800226 	beq	r3,r2,1003dfc <eTaskGetState+0xe4>
 1003df4:	e0bffc17 	ldw	r2,-16(fp)
 1003df8:	1000031e 	bne	r2,zero,1003e08 <eTaskGetState+0xf0>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
 1003dfc:	00800104 	movi	r2,4
 1003e00:	e0bffa15 	stw	r2,-24(fp)
 1003e04:	00000206 	br	1003e10 <eTaskGetState+0xf8>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
 1003e08:	00800044 	movi	r2,1
 1003e0c:	e0bffa15 	stw	r2,-24(fp)
			}
		}

		return eReturn;
 1003e10:	e0bffa17 	ldw	r2,-24(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1003e14:	e037883a 	mov	sp,fp
 1003e18:	dfc00117 	ldw	ra,4(sp)
 1003e1c:	df000017 	ldw	fp,0(sp)
 1003e20:	dec00204 	addi	sp,sp,8
 1003e24:	f800283a 	ret

01003e28 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
 1003e28:	defffb04 	addi	sp,sp,-20
 1003e2c:	dfc00415 	stw	ra,16(sp)
 1003e30:	df000315 	stw	fp,12(sp)
 1003e34:	df000304 	addi	fp,sp,12
 1003e38:	e13fff15 	stw	r4,-4(fp)
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 1003e3c:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 1003e40:	e0bfff17 	ldw	r2,-4(fp)
 1003e44:	1000021e 	bne	r2,zero,1003e50 <uxTaskPriorityGet+0x28>
 1003e48:	d0a74117 	ldw	r2,-25340(gp)
 1003e4c:	00000106 	br	1003e54 <uxTaskPriorityGet+0x2c>
 1003e50:	e0bfff17 	ldw	r2,-4(fp)
 1003e54:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 1003e58:	e0bffd17 	ldw	r2,-12(fp)
 1003e5c:	10800b17 	ldw	r2,44(r2)
 1003e60:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
 1003e64:	10053c40 	call	10053c4 <vTaskExitCritical>

		return uxReturn;
 1003e68:	e0bffe17 	ldw	r2,-8(fp)
	}
 1003e6c:	e037883a 	mov	sp,fp
 1003e70:	dfc00117 	ldw	ra,4(sp)
 1003e74:	df000017 	ldw	fp,0(sp)
 1003e78:	dec00204 	addi	sp,sp,8
 1003e7c:	f800283a 	ret

01003e80 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
 1003e80:	defffb04 	addi	sp,sp,-20
 1003e84:	df000415 	stw	fp,16(sp)
 1003e88:	df000404 	addi	fp,sp,16
 1003e8c:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1003e90:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 1003e94:	e0bfff17 	ldw	r2,-4(fp)
 1003e98:	1000021e 	bne	r2,zero,1003ea4 <uxTaskPriorityGetFromISR+0x24>
 1003e9c:	d0a74117 	ldw	r2,-25340(gp)
 1003ea0:	00000106 	br	1003ea8 <uxTaskPriorityGetFromISR+0x28>
 1003ea4:	e0bfff17 	ldw	r2,-4(fp)
 1003ea8:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 1003eac:	e0bffd17 	ldw	r2,-12(fp)
 1003eb0:	10800b17 	ldw	r2,44(r2)
 1003eb4:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
 1003eb8:	e0bffe17 	ldw	r2,-8(fp)
	}
 1003ebc:	e037883a 	mov	sp,fp
 1003ec0:	df000017 	ldw	fp,0(sp)
 1003ec4:	dec00104 	addi	sp,sp,4
 1003ec8:	f800283a 	ret

01003ecc <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 1003ecc:	defff804 	addi	sp,sp,-32
 1003ed0:	dfc00715 	stw	ra,28(sp)
 1003ed4:	df000615 	stw	fp,24(sp)
 1003ed8:	df000604 	addi	fp,sp,24
 1003edc:	e13ffe15 	stw	r4,-8(fp)
 1003ee0:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 1003ee4:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1003ee8:	e0bfff17 	ldw	r2,-4(fp)
 1003eec:	10800170 	cmpltui	r2,r2,5
 1003ef0:	1000021e 	bne	r2,zero,1003efc <vTaskPrioritySet+0x30>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1003ef4:	00800104 	movi	r2,4
 1003ef8:	e0bfff15 	stw	r2,-4(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 1003efc:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 1003f00:	e0bffe17 	ldw	r2,-8(fp)
 1003f04:	1000021e 	bne	r2,zero,1003f10 <vTaskPrioritySet+0x44>
 1003f08:	d0a74117 	ldw	r2,-25340(gp)
 1003f0c:	00000106 	br	1003f14 <vTaskPrioritySet+0x48>
 1003f10:	e0bffe17 	ldw	r2,-8(fp)
 1003f14:	e0bffb15 	stw	r2,-20(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 1003f18:	e0bffb17 	ldw	r2,-20(fp)
 1003f1c:	10801017 	ldw	r2,64(r2)
 1003f20:	e0bffc15 	stw	r2,-16(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 1003f24:	e0fffc17 	ldw	r3,-16(fp)
 1003f28:	e0bfff17 	ldw	r2,-4(fp)
 1003f2c:	18804926 	beq	r3,r2,1004054 <vTaskPrioritySet+0x188>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 1003f30:	e0bfff17 	ldw	r2,-4(fp)
 1003f34:	e0fffc17 	ldw	r3,-16(fp)
 1003f38:	18800a2e 	bgeu	r3,r2,1003f64 <vTaskPrioritySet+0x98>
				{
					if( pxTCB != pxCurrentTCB )
 1003f3c:	d0a74117 	ldw	r2,-25340(gp)
 1003f40:	e0fffb17 	ldw	r3,-20(fp)
 1003f44:	18800c26 	beq	r3,r2,1003f78 <vTaskPrioritySet+0xac>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1003f48:	d0a74117 	ldw	r2,-25340(gp)
 1003f4c:	10800b17 	ldw	r2,44(r2)
 1003f50:	e0ffff17 	ldw	r3,-4(fp)
 1003f54:	18800836 	bltu	r3,r2,1003f78 <vTaskPrioritySet+0xac>
						{
							xYieldRequired = pdTRUE;
 1003f58:	00800044 	movi	r2,1
 1003f5c:	e0bffa15 	stw	r2,-24(fp)
 1003f60:	00000506 	br	1003f78 <vTaskPrioritySet+0xac>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 1003f64:	d0a74117 	ldw	r2,-25340(gp)
 1003f68:	e0fffb17 	ldw	r3,-20(fp)
 1003f6c:	1880021e 	bne	r3,r2,1003f78 <vTaskPrioritySet+0xac>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
 1003f70:	00800044 	movi	r2,1
 1003f74:	e0bffa15 	stw	r2,-24(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1003f78:	e0bffb17 	ldw	r2,-20(fp)
 1003f7c:	10800b17 	ldw	r2,44(r2)
 1003f80:	e0bffd15 	stw	r2,-12(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1003f84:	e0bffb17 	ldw	r2,-20(fp)
 1003f88:	10c01017 	ldw	r3,64(r2)
 1003f8c:	e0bffb17 	ldw	r2,-20(fp)
 1003f90:	10800b17 	ldw	r2,44(r2)
 1003f94:	1880031e 	bne	r3,r2,1003fa4 <vTaskPrioritySet+0xd8>
					{
						pxTCB->uxPriority = uxNewPriority;
 1003f98:	e0bffb17 	ldw	r2,-20(fp)
 1003f9c:	e0ffff17 	ldw	r3,-4(fp)
 1003fa0:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 1003fa4:	e0bffb17 	ldw	r2,-20(fp)
 1003fa8:	e0ffff17 	ldw	r3,-4(fp)
 1003fac:	10c01015 	stw	r3,64(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1003fb0:	e0bffb17 	ldw	r2,-20(fp)
 1003fb4:	10800617 	ldw	r2,24(r2)
 1003fb8:	10000516 	blt	r2,zero,1003fd0 <vTaskPrioritySet+0x104>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1003fbc:	00c00144 	movi	r3,5
 1003fc0:	e0bfff17 	ldw	r2,-4(fp)
 1003fc4:	1887c83a 	sub	r3,r3,r2
 1003fc8:	e0bffb17 	ldw	r2,-20(fp)
 1003fcc:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 1003fd0:	e0bffb17 	ldw	r2,-20(fp)
 1003fd4:	10c00517 	ldw	r3,20(r2)
 1003fd8:	e0bffd17 	ldw	r2,-12(fp)
 1003fdc:	11000524 	muli	r4,r2,20
 1003fe0:	008060f4 	movhi	r2,387
 1003fe4:	10b9b404 	addi	r2,r2,-6448
 1003fe8:	2085883a 	add	r2,r4,r2
 1003fec:	1880161e 	bne	r3,r2,1004048 <vTaskPrioritySet+0x17c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1003ff0:	e0bffb17 	ldw	r2,-20(fp)
 1003ff4:	10800104 	addi	r2,r2,4
 1003ff8:	1009883a 	mov	r4,r2
 1003ffc:	1000b940 	call	1000b94 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 1004000:	e0bffb17 	ldw	r2,-20(fp)
 1004004:	10800b17 	ldw	r2,44(r2)
 1004008:	d0e74717 	ldw	r3,-25316(gp)
 100400c:	1880032e 	bgeu	r3,r2,100401c <vTaskPrioritySet+0x150>
 1004010:	e0bffb17 	ldw	r2,-20(fp)
 1004014:	10800b17 	ldw	r2,44(r2)
 1004018:	d0a74715 	stw	r2,-25316(gp)
 100401c:	e0bffb17 	ldw	r2,-20(fp)
 1004020:	10800b17 	ldw	r2,44(r2)
 1004024:	10c00524 	muli	r3,r2,20
 1004028:	008060f4 	movhi	r2,387
 100402c:	10b9b404 	addi	r2,r2,-6448
 1004030:	1887883a 	add	r3,r3,r2
 1004034:	e0bffb17 	ldw	r2,-20(fp)
 1004038:	10800104 	addi	r2,r2,4
 100403c:	100b883a 	mov	r5,r2
 1004040:	1809883a 	mov	r4,r3
 1004044:	1000a300 	call	1000a30 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
 1004048:	e0bffa17 	ldw	r2,-24(fp)
 100404c:	10000126 	beq	r2,zero,1004054 <vTaskPrioritySet+0x188>
				{
					taskYIELD_IF_USING_PREEMPTION();
 1004050:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 1004054:	10053c40 	call	10053c4 <vTaskExitCritical>
	}
 1004058:	0001883a 	nop
 100405c:	e037883a 	mov	sp,fp
 1004060:	dfc00117 	ldw	ra,4(sp)
 1004064:	df000017 	ldw	fp,0(sp)
 1004068:	dec00204 	addi	sp,sp,8
 100406c:	f800283a 	ret

01004070 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 1004070:	defffc04 	addi	sp,sp,-16
 1004074:	dfc00315 	stw	ra,12(sp)
 1004078:	df000215 	stw	fp,8(sp)
 100407c:	df000204 	addi	fp,sp,8
 1004080:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 1004084:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1004088:	e0bfff17 	ldw	r2,-4(fp)
 100408c:	1000021e 	bne	r2,zero,1004098 <vTaskSuspend+0x28>
 1004090:	d0a74117 	ldw	r2,-25340(gp)
 1004094:	00000106 	br	100409c <vTaskSuspend+0x2c>
 1004098:	e0bfff17 	ldw	r2,-4(fp)
 100409c:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 10040a0:	e0bffe17 	ldw	r2,-8(fp)
 10040a4:	10800104 	addi	r2,r2,4
 10040a8:	1009883a 	mov	r4,r2
 10040ac:	1000b940 	call	1000b94 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 10040b0:	e0bffe17 	ldw	r2,-8(fp)
 10040b4:	10800a17 	ldw	r2,40(r2)
 10040b8:	10000426 	beq	r2,zero,10040cc <vTaskSuspend+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 10040bc:	e0bffe17 	ldw	r2,-8(fp)
 10040c0:	10800604 	addi	r2,r2,24
 10040c4:	1009883a 	mov	r4,r2
 10040c8:	1000b940 	call	1000b94 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 10040cc:	e0bffe17 	ldw	r2,-8(fp)
 10040d0:	10800104 	addi	r2,r2,4
 10040d4:	100b883a 	mov	r5,r2
 10040d8:	010060f4 	movhi	r4,387
 10040dc:	2139e104 	addi	r4,r4,-6268
 10040e0:	1000a300 	call	1000a30 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 10040e4:	e0bffe17 	ldw	r2,-8(fp)
 10040e8:	10801303 	ldbu	r2,76(r2)
 10040ec:	10803fcc 	andi	r2,r2,255
 10040f0:	10800058 	cmpnei	r2,r2,1
 10040f4:	1000021e 	bne	r2,zero,1004100 <vTaskSuspend+0x90>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 10040f8:	e0bffe17 	ldw	r2,-8(fp)
 10040fc:	10001305 	stb	zero,76(r2)
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
 1004100:	10053c40 	call	10053c4 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
 1004104:	d0a74817 	ldw	r2,-25312(gp)
 1004108:	10000326 	beq	r2,zero,1004118 <vTaskSuspend+0xa8>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 100410c:	10053700 	call	1005370 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 1004110:	1004f780 	call	1004f78 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 1004114:	10053c40 	call	10053c4 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 1004118:	d0a74117 	ldw	r2,-25340(gp)
 100411c:	e0fffe17 	ldw	r3,-8(fp)
 1004120:	18800c1e 	bne	r3,r2,1004154 <vTaskSuspend+0xe4>
		{
			if( xSchedulerRunning != pdFALSE )
 1004124:	d0a74817 	ldw	r2,-25312(gp)
 1004128:	10000226 	beq	r2,zero,1004134 <vTaskSuspend+0xc4>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 100412c:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1004130:	00000806 	br	1004154 <vTaskSuspend+0xe4>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 1004134:	008060f4 	movhi	r2,387
 1004138:	10b9e104 	addi	r2,r2,-6268
 100413c:	10c00017 	ldw	r3,0(r2)
 1004140:	d0a74517 	ldw	r2,-25324(gp)
 1004144:	1880021e 	bne	r3,r2,1004150 <vTaskSuspend+0xe0>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 1004148:	d0274115 	stw	zero,-25340(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 100414c:	00000106 	br	1004154 <vTaskSuspend+0xe4>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 1004150:	10048440 	call	1004844 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1004154:	0001883a 	nop
 1004158:	e037883a 	mov	sp,fp
 100415c:	dfc00117 	ldw	ra,4(sp)
 1004160:	df000017 	ldw	fp,0(sp)
 1004164:	dec00204 	addi	sp,sp,8
 1004168:	f800283a 	ret

0100416c <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
 100416c:	defffc04 	addi	sp,sp,-16
 1004170:	df000315 	stw	fp,12(sp)
 1004174:	df000304 	addi	fp,sp,12
 1004178:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
 100417c:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = xTask;
 1004180:	e0bfff17 	ldw	r2,-4(fp)
 1004184:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1004188:	e0bffe17 	ldw	r2,-8(fp)
 100418c:	10c00517 	ldw	r3,20(r2)
 1004190:	008060f4 	movhi	r2,387
 1004194:	10b9e104 	addi	r2,r2,-6268
 1004198:	18800a1e 	bne	r3,r2,10041c4 <prvTaskIsTaskSuspended+0x58>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 100419c:	e0bffe17 	ldw	r2,-8(fp)
 10041a0:	10c00a17 	ldw	r3,40(r2)
 10041a4:	008060f4 	movhi	r2,387
 10041a8:	10b9d704 	addi	r2,r2,-6308
 10041ac:	18800526 	beq	r3,r2,10041c4 <prvTaskIsTaskSuspended+0x58>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 10041b0:	e0bffe17 	ldw	r2,-8(fp)
 10041b4:	10800a17 	ldw	r2,40(r2)
 10041b8:	1000021e 	bne	r2,zero,10041c4 <prvTaskIsTaskSuspended+0x58>
				{
					xReturn = pdTRUE;
 10041bc:	00800044 	movi	r2,1
 10041c0:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 10041c4:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 10041c8:	e037883a 	mov	sp,fp
 10041cc:	df000017 	ldw	fp,0(sp)
 10041d0:	dec00104 	addi	sp,sp,4
 10041d4:	f800283a 	ret

010041d8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 10041d8:	defffc04 	addi	sp,sp,-16
 10041dc:	dfc00315 	stw	ra,12(sp)
 10041e0:	df000215 	stw	fp,8(sp)
 10041e4:	df000204 	addi	fp,sp,8
 10041e8:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = xTaskToResume;
 10041ec:	e0bfff17 	ldw	r2,-4(fp)
 10041f0:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 10041f4:	d0a74117 	ldw	r2,-25340(gp)
 10041f8:	e0fffe17 	ldw	r3,-8(fp)
 10041fc:	18802326 	beq	r3,r2,100428c <vTaskResume+0xb4>
 1004200:	e0bffe17 	ldw	r2,-8(fp)
 1004204:	10002126 	beq	r2,zero,100428c <vTaskResume+0xb4>
		{
			taskENTER_CRITICAL();
 1004208:	10053700 	call	1005370 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 100420c:	e13ffe17 	ldw	r4,-8(fp)
 1004210:	100416c0 	call	100416c <prvTaskIsTaskSuspended>
 1004214:	10001c26 	beq	r2,zero,1004288 <vTaskResume+0xb0>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1004218:	e0bffe17 	ldw	r2,-8(fp)
 100421c:	10800104 	addi	r2,r2,4
 1004220:	1009883a 	mov	r4,r2
 1004224:	1000b940 	call	1000b94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1004228:	e0bffe17 	ldw	r2,-8(fp)
 100422c:	10800b17 	ldw	r2,44(r2)
 1004230:	d0e74717 	ldw	r3,-25316(gp)
 1004234:	1880032e 	bgeu	r3,r2,1004244 <vTaskResume+0x6c>
 1004238:	e0bffe17 	ldw	r2,-8(fp)
 100423c:	10800b17 	ldw	r2,44(r2)
 1004240:	d0a74715 	stw	r2,-25316(gp)
 1004244:	e0bffe17 	ldw	r2,-8(fp)
 1004248:	10800b17 	ldw	r2,44(r2)
 100424c:	10c00524 	muli	r3,r2,20
 1004250:	008060f4 	movhi	r2,387
 1004254:	10b9b404 	addi	r2,r2,-6448
 1004258:	1887883a 	add	r3,r3,r2
 100425c:	e0bffe17 	ldw	r2,-8(fp)
 1004260:	10800104 	addi	r2,r2,4
 1004264:	100b883a 	mov	r5,r2
 1004268:	1809883a 	mov	r4,r3
 100426c:	1000a300 	call	1000a30 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1004270:	e0bffe17 	ldw	r2,-8(fp)
 1004274:	10c00b17 	ldw	r3,44(r2)
 1004278:	d0a74117 	ldw	r2,-25340(gp)
 100427c:	10800b17 	ldw	r2,44(r2)
 1004280:	18800136 	bltu	r3,r2,1004288 <vTaskResume+0xb0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 1004284:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 1004288:	10053c40 	call	10053c4 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 100428c:	0001883a 	nop
 1004290:	e037883a 	mov	sp,fp
 1004294:	dfc00117 	ldw	ra,4(sp)
 1004298:	df000017 	ldw	fp,0(sp)
 100429c:	dec00204 	addi	sp,sp,8
 10042a0:	f800283a 	ret

010042a4 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 10042a4:	defffa04 	addi	sp,sp,-24
 10042a8:	dfc00515 	stw	ra,20(sp)
 10042ac:	df000415 	stw	fp,16(sp)
 10042b0:	df000404 	addi	fp,sp,16
 10042b4:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
 10042b8:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = xTaskToResume;
 10042bc:	e0bfff17 	ldw	r2,-4(fp)
 10042c0:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 10042c4:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 10042c8:	e13ffd17 	ldw	r4,-12(fp)
 10042cc:	100416c0 	call	100416c <prvTaskIsTaskSuspended>
 10042d0:	10002626 	beq	r2,zero,100436c <xTaskResumeFromISR+0xc8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 10042d4:	d0a74f17 	ldw	r2,-25284(gp)
 10042d8:	10001e1e 	bne	r2,zero,1004354 <xTaskResumeFromISR+0xb0>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 10042dc:	e0bffd17 	ldw	r2,-12(fp)
 10042e0:	10c00b17 	ldw	r3,44(r2)
 10042e4:	d0a74117 	ldw	r2,-25340(gp)
 10042e8:	10800b17 	ldw	r2,44(r2)
 10042ec:	18800236 	bltu	r3,r2,10042f8 <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
 10042f0:	00800044 	movi	r2,1
 10042f4:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 10042f8:	e0bffd17 	ldw	r2,-12(fp)
 10042fc:	10800104 	addi	r2,r2,4
 1004300:	1009883a 	mov	r4,r2
 1004304:	1000b940 	call	1000b94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1004308:	e0bffd17 	ldw	r2,-12(fp)
 100430c:	10800b17 	ldw	r2,44(r2)
 1004310:	d0e74717 	ldw	r3,-25316(gp)
 1004314:	1880032e 	bgeu	r3,r2,1004324 <xTaskResumeFromISR+0x80>
 1004318:	e0bffd17 	ldw	r2,-12(fp)
 100431c:	10800b17 	ldw	r2,44(r2)
 1004320:	d0a74715 	stw	r2,-25316(gp)
 1004324:	e0bffd17 	ldw	r2,-12(fp)
 1004328:	10800b17 	ldw	r2,44(r2)
 100432c:	10c00524 	muli	r3,r2,20
 1004330:	008060f4 	movhi	r2,387
 1004334:	10b9b404 	addi	r2,r2,-6448
 1004338:	1887883a 	add	r3,r3,r2
 100433c:	e0bffd17 	ldw	r2,-12(fp)
 1004340:	10800104 	addi	r2,r2,4
 1004344:	100b883a 	mov	r5,r2
 1004348:	1809883a 	mov	r4,r3
 100434c:	1000a300 	call	1000a30 <vListInsertEnd>
 1004350:	00000606 	br	100436c <xTaskResumeFromISR+0xc8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1004354:	e0bffd17 	ldw	r2,-12(fp)
 1004358:	10800604 	addi	r2,r2,24
 100435c:	100b883a 	mov	r5,r2
 1004360:	010060f4 	movhi	r4,387
 1004364:	2139d704 	addi	r4,r4,-6308
 1004368:	1000a300 	call	1000a30 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
 100436c:	e0bffc17 	ldw	r2,-16(fp)
	}
 1004370:	e037883a 	mov	sp,fp
 1004374:	dfc00117 	ldw	ra,4(sp)
 1004378:	df000017 	ldw	fp,0(sp)
 100437c:	dec00204 	addi	sp,sp,8
 1004380:	f800283a 	ret

01004384 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 1004384:	defffa04 	addi	sp,sp,-24
 1004388:	dfc00515 	stw	ra,20(sp)
 100438c:	df000415 	stw	fp,16(sp)
 1004390:	df000404 	addi	fp,sp,16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 1004394:	d0a74e04 	addi	r2,gp,-25288
 1004398:	d8800115 	stw	r2,4(sp)
 100439c:	d8000015 	stw	zero,0(sp)
 10043a0:	000f883a 	mov	r7,zero
 10043a4:	01810004 	movi	r6,1024
 10043a8:	014040f4 	movhi	r5,259
 10043ac:	29647704 	addi	r5,r5,-28196
 10043b0:	01004034 	movhi	r4,256
 10043b4:	21134704 	addi	r4,r4,19740
 10043b8:	100371c0 	call	100371c <xTaskCreate>
 10043bc:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 10043c0:	e0bffe17 	ldw	r2,-8(fp)
 10043c4:	10800058 	cmpnei	r2,r2,1
 10043c8:	10000c1e 	bne	r2,zero,10043fc <vTaskStartScheduler+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10043cc:	0005303a 	rdctl	r2,status
 10043d0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10043d4:	e0ffff17 	ldw	r3,-4(fp)
 10043d8:	00bfff84 	movi	r2,-2
 10043dc:	1884703a 	and	r2,r3,r2
 10043e0:	1001703a 	wrctl	status,r2
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 10043e4:	00bfffc4 	movi	r2,-1
 10043e8:	d0a74d15 	stw	r2,-25292(gp)
		xSchedulerRunning = pdTRUE;
 10043ec:	00800044 	movi	r2,1
 10043f0:	d0a74815 	stw	r2,-25312(gp)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 10043f4:	d0274615 	stw	zero,-25320(gp)

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 10043f8:	1000d380 	call	1000d38 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 10043fc:	0001883a 	nop
 1004400:	e037883a 	mov	sp,fp
 1004404:	dfc00117 	ldw	ra,4(sp)
 1004408:	df000017 	ldw	fp,0(sp)
 100440c:	dec00204 	addi	sp,sp,8
 1004410:	f800283a 	ret

01004414 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 1004414:	defffd04 	addi	sp,sp,-12
 1004418:	dfc00215 	stw	ra,8(sp)
 100441c:	df000115 	stw	fp,4(sp)
 1004420:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1004424:	0005303a 	rdctl	r2,status
 1004428:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 100442c:	e0ffff17 	ldw	r3,-4(fp)
 1004430:	00bfff84 	movi	r2,-2
 1004434:	1884703a 	and	r2,r3,r2
 1004438:	1001703a 	wrctl	status,r2
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
 100443c:	d0274815 	stw	zero,-25312(gp)
	vPortEndScheduler();
 1004440:	1000d700 	call	1000d70 <vPortEndScheduler>
}
 1004444:	0001883a 	nop
 1004448:	e037883a 	mov	sp,fp
 100444c:	dfc00117 	ldw	ra,4(sp)
 1004450:	df000017 	ldw	fp,0(sp)
 1004454:	dec00204 	addi	sp,sp,8
 1004458:	f800283a 	ret

0100445c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 100445c:	deffff04 	addi	sp,sp,-4
 1004460:	df000015 	stw	fp,0(sp)
 1004464:	d839883a 	mov	fp,sp
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 1004468:	d0a74f17 	ldw	r2,-25284(gp)
 100446c:	10800044 	addi	r2,r2,1
 1004470:	d0a74f15 	stw	r2,-25284(gp)
	portMEMORY_BARRIER();
}
 1004474:	0001883a 	nop
 1004478:	e037883a 	mov	sp,fp
 100447c:	df000017 	ldw	fp,0(sp)
 1004480:	dec00104 	addi	sp,sp,4
 1004484:	f800283a 	ret

01004488 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 1004488:	defffb04 	addi	sp,sp,-20
 100448c:	dfc00415 	stw	ra,16(sp)
 1004490:	df000315 	stw	fp,12(sp)
 1004494:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
 1004498:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
 100449c:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 10044a0:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
 10044a4:	d0a74f17 	ldw	r2,-25284(gp)
 10044a8:	10bfffc4 	addi	r2,r2,-1
 10044ac:	d0a74f15 	stw	r2,-25284(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 10044b0:	d0a74f17 	ldw	r2,-25284(gp)
 10044b4:	1000431e 	bne	r2,zero,10045c4 <xTaskResumeAll+0x13c>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 10044b8:	d0a74517 	ldw	r2,-25324(gp)
 10044bc:	10004126 	beq	r2,zero,10045c4 <xTaskResumeAll+0x13c>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 10044c0:	00002606 	br	100455c <xTaskResumeAll+0xd4>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 10044c4:	008060f4 	movhi	r2,387
 10044c8:	10b9d704 	addi	r2,r2,-6308
 10044cc:	10800317 	ldw	r2,12(r2)
 10044d0:	10800317 	ldw	r2,12(r2)
 10044d4:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 10044d8:	e0bffd17 	ldw	r2,-12(fp)
 10044dc:	10800604 	addi	r2,r2,24
 10044e0:	1009883a 	mov	r4,r2
 10044e4:	1000b940 	call	1000b94 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 10044e8:	e0bffd17 	ldw	r2,-12(fp)
 10044ec:	10800104 	addi	r2,r2,4
 10044f0:	1009883a 	mov	r4,r2
 10044f4:	1000b940 	call	1000b94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 10044f8:	e0bffd17 	ldw	r2,-12(fp)
 10044fc:	10800b17 	ldw	r2,44(r2)
 1004500:	d0e74717 	ldw	r3,-25316(gp)
 1004504:	1880032e 	bgeu	r3,r2,1004514 <xTaskResumeAll+0x8c>
 1004508:	e0bffd17 	ldw	r2,-12(fp)
 100450c:	10800b17 	ldw	r2,44(r2)
 1004510:	d0a74715 	stw	r2,-25316(gp)
 1004514:	e0bffd17 	ldw	r2,-12(fp)
 1004518:	10800b17 	ldw	r2,44(r2)
 100451c:	10c00524 	muli	r3,r2,20
 1004520:	008060f4 	movhi	r2,387
 1004524:	10b9b404 	addi	r2,r2,-6448
 1004528:	1887883a 	add	r3,r3,r2
 100452c:	e0bffd17 	ldw	r2,-12(fp)
 1004530:	10800104 	addi	r2,r2,4
 1004534:	100b883a 	mov	r5,r2
 1004538:	1809883a 	mov	r4,r3
 100453c:	1000a300 	call	1000a30 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1004540:	e0bffd17 	ldw	r2,-12(fp)
 1004544:	10c00b17 	ldw	r3,44(r2)
 1004548:	d0a74117 	ldw	r2,-25340(gp)
 100454c:	10800b17 	ldw	r2,44(r2)
 1004550:	18800236 	bltu	r3,r2,100455c <xTaskResumeAll+0xd4>
					{
						xYieldPending = pdTRUE;
 1004554:	00800044 	movi	r2,1
 1004558:	d0a74a15 	stw	r2,-25304(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 100455c:	008060f4 	movhi	r2,387
 1004560:	10b9d704 	addi	r2,r2,-6308
 1004564:	10800017 	ldw	r2,0(r2)
 1004568:	103fd61e 	bne	r2,zero,10044c4 <__alt_data_end+0xff0044c4>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 100456c:	e0bffd17 	ldw	r2,-12(fp)
 1004570:	10000126 	beq	r2,zero,1004578 <xTaskResumeAll+0xf0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 1004574:	1004f780 	call	1004f78 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 1004578:	d0a74917 	ldw	r2,-25308(gp)
 100457c:	e0bfff15 	stw	r2,-4(fp)

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 1004580:	e0bfff17 	ldw	r2,-4(fp)
 1004584:	10000a26 	beq	r2,zero,10045b0 <xTaskResumeAll+0x128>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 1004588:	10046940 	call	1004694 <xTaskIncrementTick>
 100458c:	10000226 	beq	r2,zero,1004598 <xTaskResumeAll+0x110>
							{
								xYieldPending = pdTRUE;
 1004590:	00800044 	movi	r2,1
 1004594:	d0a74a15 	stw	r2,-25304(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 1004598:	e0bfff17 	ldw	r2,-4(fp)
 100459c:	10bfffc4 	addi	r2,r2,-1
 10045a0:	e0bfff15 	stw	r2,-4(fp)
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 10045a4:	e0bfff17 	ldw	r2,-4(fp)
 10045a8:	103ff71e 	bne	r2,zero,1004588 <__alt_data_end+0xff004588>

						uxPendedTicks = 0;
 10045ac:	d0274915 	stw	zero,-25308(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 10045b0:	d0a74a17 	ldw	r2,-25304(gp)
 10045b4:	10000326 	beq	r2,zero,10045c4 <xTaskResumeAll+0x13c>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 10045b8:	00800044 	movi	r2,1
 10045bc:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 10045c0:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 10045c4:	10053c40 	call	10053c4 <vTaskExitCritical>

	return xAlreadyYielded;
 10045c8:	e0bffe17 	ldw	r2,-8(fp)
}
 10045cc:	e037883a 	mov	sp,fp
 10045d0:	dfc00117 	ldw	ra,4(sp)
 10045d4:	df000017 	ldw	fp,0(sp)
 10045d8:	dec00204 	addi	sp,sp,8
 10045dc:	f800283a 	ret

010045e0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 10045e0:	defffe04 	addi	sp,sp,-8
 10045e4:	df000115 	stw	fp,4(sp)
 10045e8:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 10045ec:	d0a74617 	ldw	r2,-25320(gp)
 10045f0:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 10045f4:	e0bfff17 	ldw	r2,-4(fp)
}
 10045f8:	e037883a 	mov	sp,fp
 10045fc:	df000017 	ldw	fp,0(sp)
 1004600:	dec00104 	addi	sp,sp,4
 1004604:	f800283a 	ret

01004608 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 1004608:	defffd04 	addi	sp,sp,-12
 100460c:	df000215 	stw	fp,8(sp)
 1004610:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 1004614:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
 1004618:	d0a74617 	ldw	r2,-25320(gp)
 100461c:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1004620:	e0bfff17 	ldw	r2,-4(fp)
}
 1004624:	e037883a 	mov	sp,fp
 1004628:	df000017 	ldw	fp,0(sp)
 100462c:	dec00104 	addi	sp,sp,4
 1004630:	f800283a 	ret

01004634 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 1004634:	deffff04 	addi	sp,sp,-4
 1004638:	df000015 	stw	fp,0(sp)
 100463c:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 1004640:	d0a74517 	ldw	r2,-25324(gp)
}
 1004644:	e037883a 	mov	sp,fp
 1004648:	df000017 	ldw	fp,0(sp)
 100464c:	dec00104 	addi	sp,sp,4
 1004650:	f800283a 	ret

01004654 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 1004654:	defffd04 	addi	sp,sp,-12
 1004658:	df000215 	stw	fp,8(sp)
 100465c:	df000204 	addi	fp,sp,8
 1004660:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 1004664:	e0bfff17 	ldw	r2,-4(fp)
 1004668:	1000021e 	bne	r2,zero,1004674 <pcTaskGetName+0x20>
 100466c:	d0a74117 	ldw	r2,-25340(gp)
 1004670:	00000106 	br	1004678 <pcTaskGetName+0x24>
 1004674:	e0bfff17 	ldw	r2,-4(fp)
 1004678:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
 100467c:	e0bffe17 	ldw	r2,-8(fp)
 1004680:	10800d04 	addi	r2,r2,52
}
 1004684:	e037883a 	mov	sp,fp
 1004688:	df000017 	ldw	fp,0(sp)
 100468c:	dec00104 	addi	sp,sp,4
 1004690:	f800283a 	ret

01004694 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 1004694:	defff904 	addi	sp,sp,-28
 1004698:	dfc00615 	stw	ra,24(sp)
 100469c:	df000515 	stw	fp,20(sp)
 10046a0:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 10046a4:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 10046a8:	d0a74f17 	ldw	r2,-25284(gp)
 10046ac:	1000581e 	bne	r2,zero,1004810 <xTaskIncrementTick+0x17c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 10046b0:	d0a74617 	ldw	r2,-25320(gp)
 10046b4:	10800044 	addi	r2,r2,1
 10046b8:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 10046bc:	e0bffc17 	ldw	r2,-16(fp)
 10046c0:	d0a74615 	stw	r2,-25320(gp)

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 10046c4:	e0bffc17 	ldw	r2,-16(fp)
 10046c8:	10000a1e 	bne	r2,zero,10046f4 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
 10046cc:	d0a74217 	ldw	r2,-25336(gp)
 10046d0:	e0bffd15 	stw	r2,-12(fp)
 10046d4:	d0a74317 	ldw	r2,-25332(gp)
 10046d8:	d0a74215 	stw	r2,-25336(gp)
 10046dc:	e0bffd17 	ldw	r2,-12(fp)
 10046e0:	d0a74315 	stw	r2,-25332(gp)
 10046e4:	d0a74b17 	ldw	r2,-25300(gp)
 10046e8:	10800044 	addi	r2,r2,1
 10046ec:	d0a74b15 	stw	r2,-25300(gp)
 10046f0:	1004f780 	call	1004f78 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 10046f4:	d0a74d17 	ldw	r2,-25292(gp)
 10046f8:	e0fffc17 	ldw	r3,-16(fp)
 10046fc:	18803836 	bltu	r3,r2,10047e0 <xTaskIncrementTick+0x14c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1004700:	d0a74217 	ldw	r2,-25336(gp)
 1004704:	10800017 	ldw	r2,0(r2)
 1004708:	1000031e 	bne	r2,zero,1004718 <xTaskIncrementTick+0x84>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 100470c:	00bfffc4 	movi	r2,-1
 1004710:	d0a74d15 	stw	r2,-25292(gp)
					break;
 1004714:	00003206 	br	10047e0 <xTaskIncrementTick+0x14c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1004718:	d0a74217 	ldw	r2,-25336(gp)
 100471c:	10800317 	ldw	r2,12(r2)
 1004720:	10800317 	ldw	r2,12(r2)
 1004724:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1004728:	e0bffe17 	ldw	r2,-8(fp)
 100472c:	10800117 	ldw	r2,4(r2)
 1004730:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
 1004734:	e0fffc17 	ldw	r3,-16(fp)
 1004738:	e0bfff17 	ldw	r2,-4(fp)
 100473c:	1880032e 	bgeu	r3,r2,100474c <xTaskIncrementTick+0xb8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 1004740:	e0bfff17 	ldw	r2,-4(fp)
 1004744:	d0a74d15 	stw	r2,-25292(gp)
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 1004748:	00002506 	br	10047e0 <xTaskIncrementTick+0x14c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 100474c:	e0bffe17 	ldw	r2,-8(fp)
 1004750:	10800104 	addi	r2,r2,4
 1004754:	1009883a 	mov	r4,r2
 1004758:	1000b940 	call	1000b94 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 100475c:	e0bffe17 	ldw	r2,-8(fp)
 1004760:	10800a17 	ldw	r2,40(r2)
 1004764:	10000426 	beq	r2,zero,1004778 <xTaskIncrementTick+0xe4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1004768:	e0bffe17 	ldw	r2,-8(fp)
 100476c:	10800604 	addi	r2,r2,24
 1004770:	1009883a 	mov	r4,r2
 1004774:	1000b940 	call	1000b94 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 1004778:	e0bffe17 	ldw	r2,-8(fp)
 100477c:	10800b17 	ldw	r2,44(r2)
 1004780:	d0e74717 	ldw	r3,-25316(gp)
 1004784:	1880032e 	bgeu	r3,r2,1004794 <xTaskIncrementTick+0x100>
 1004788:	e0bffe17 	ldw	r2,-8(fp)
 100478c:	10800b17 	ldw	r2,44(r2)
 1004790:	d0a74715 	stw	r2,-25316(gp)
 1004794:	e0bffe17 	ldw	r2,-8(fp)
 1004798:	10800b17 	ldw	r2,44(r2)
 100479c:	10c00524 	muli	r3,r2,20
 10047a0:	008060f4 	movhi	r2,387
 10047a4:	10b9b404 	addi	r2,r2,-6448
 10047a8:	1887883a 	add	r3,r3,r2
 10047ac:	e0bffe17 	ldw	r2,-8(fp)
 10047b0:	10800104 	addi	r2,r2,4
 10047b4:	100b883a 	mov	r5,r2
 10047b8:	1809883a 	mov	r4,r3
 10047bc:	1000a300 	call	1000a30 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 10047c0:	e0bffe17 	ldw	r2,-8(fp)
 10047c4:	10c00b17 	ldw	r3,44(r2)
 10047c8:	d0a74117 	ldw	r2,-25340(gp)
 10047cc:	10800b17 	ldw	r2,44(r2)
 10047d0:	18bfcb36 	bltu	r3,r2,1004700 <__alt_data_end+0xff004700>
						{
							xSwitchRequired = pdTRUE;
 10047d4:	00800044 	movi	r2,1
 10047d8:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
 10047dc:	003fc806 	br	1004700 <__alt_data_end+0xff004700>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 10047e0:	d0a74117 	ldw	r2,-25340(gp)
 10047e4:	10c00b17 	ldw	r3,44(r2)
 10047e8:	008060f4 	movhi	r2,387
 10047ec:	10b9b404 	addi	r2,r2,-6448
 10047f0:	18c00524 	muli	r3,r3,20
 10047f4:	10c5883a 	add	r2,r2,r3
 10047f8:	10800017 	ldw	r2,0(r2)
 10047fc:	108000b0 	cmpltui	r2,r2,2
 1004800:	1000061e 	bne	r2,zero,100481c <xTaskIncrementTick+0x188>
			{
				xSwitchRequired = pdTRUE;
 1004804:	00800044 	movi	r2,1
 1004808:	e0bffb15 	stw	r2,-20(fp)
 100480c:	00000306 	br	100481c <xTaskIncrementTick+0x188>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 1004810:	d0a74917 	ldw	r2,-25308(gp)
 1004814:	10800044 	addi	r2,r2,1
 1004818:	d0a74915 	stw	r2,-25308(gp)
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 100481c:	d0a74a17 	ldw	r2,-25304(gp)
 1004820:	10000226 	beq	r2,zero,100482c <xTaskIncrementTick+0x198>
		{
			xSwitchRequired = pdTRUE;
 1004824:	00800044 	movi	r2,1
 1004828:	e0bffb15 	stw	r2,-20(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 100482c:	e0bffb17 	ldw	r2,-20(fp)
}
 1004830:	e037883a 	mov	sp,fp
 1004834:	dfc00117 	ldw	ra,4(sp)
 1004838:	df000017 	ldw	fp,0(sp)
 100483c:	dec00204 	addi	sp,sp,8
 1004840:	f800283a 	ret

01004844 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 1004844:	defffd04 	addi	sp,sp,-12
 1004848:	df000215 	stw	fp,8(sp)
 100484c:	df000204 	addi	fp,sp,8
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 1004850:	d0a74f17 	ldw	r2,-25284(gp)
 1004854:	10000326 	beq	r2,zero,1004864 <vTaskSwitchContext+0x20>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 1004858:	00800044 	movi	r2,1
 100485c:	d0a74a15 	stw	r2,-25304(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 1004860:	00002906 	br	1004908 <vTaskSwitchContext+0xc4>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 1004864:	d0274a15 	stw	zero,-25304(gp)
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1004868:	d0a74717 	ldw	r2,-25316(gp)
 100486c:	e0bffe15 	stw	r2,-8(fp)
 1004870:	00000306 	br	1004880 <vTaskSwitchContext+0x3c>
 1004874:	e0bffe17 	ldw	r2,-8(fp)
 1004878:	10bfffc4 	addi	r2,r2,-1
 100487c:	e0bffe15 	stw	r2,-8(fp)
 1004880:	008060f4 	movhi	r2,387
 1004884:	10b9b404 	addi	r2,r2,-6448
 1004888:	e0fffe17 	ldw	r3,-8(fp)
 100488c:	18c00524 	muli	r3,r3,20
 1004890:	10c5883a 	add	r2,r2,r3
 1004894:	10800017 	ldw	r2,0(r2)
 1004898:	103ff626 	beq	r2,zero,1004874 <__alt_data_end+0xff004874>
 100489c:	e0bffe17 	ldw	r2,-8(fp)
 10048a0:	10c00524 	muli	r3,r2,20
 10048a4:	008060f4 	movhi	r2,387
 10048a8:	10b9b404 	addi	r2,r2,-6448
 10048ac:	1885883a 	add	r2,r3,r2
 10048b0:	e0bfff15 	stw	r2,-4(fp)
 10048b4:	e0bfff17 	ldw	r2,-4(fp)
 10048b8:	10800117 	ldw	r2,4(r2)
 10048bc:	10c00117 	ldw	r3,4(r2)
 10048c0:	e0bfff17 	ldw	r2,-4(fp)
 10048c4:	10c00115 	stw	r3,4(r2)
 10048c8:	e0bfff17 	ldw	r2,-4(fp)
 10048cc:	10c00117 	ldw	r3,4(r2)
 10048d0:	e0bfff17 	ldw	r2,-4(fp)
 10048d4:	10800204 	addi	r2,r2,8
 10048d8:	1880051e 	bne	r3,r2,10048f0 <vTaskSwitchContext+0xac>
 10048dc:	e0bfff17 	ldw	r2,-4(fp)
 10048e0:	10800117 	ldw	r2,4(r2)
 10048e4:	10c00117 	ldw	r3,4(r2)
 10048e8:	e0bfff17 	ldw	r2,-4(fp)
 10048ec:	10c00115 	stw	r3,4(r2)
 10048f0:	e0bfff17 	ldw	r2,-4(fp)
 10048f4:	10800117 	ldw	r2,4(r2)
 10048f8:	10800317 	ldw	r2,12(r2)
 10048fc:	d0a74115 	stw	r2,-25340(gp)
 1004900:	e0bffe17 	ldw	r2,-8(fp)
 1004904:	d0a74715 	stw	r2,-25316(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 1004908:	0001883a 	nop
 100490c:	e037883a 	mov	sp,fp
 1004910:	df000017 	ldw	fp,0(sp)
 1004914:	dec00104 	addi	sp,sp,4
 1004918:	f800283a 	ret

0100491c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 100491c:	defffc04 	addi	sp,sp,-16
 1004920:	dfc00315 	stw	ra,12(sp)
 1004924:	df000215 	stw	fp,8(sp)
 1004928:	df000204 	addi	fp,sp,8
 100492c:	e13ffe15 	stw	r4,-8(fp)
 1004930:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1004934:	d0a74117 	ldw	r2,-25340(gp)
 1004938:	10800604 	addi	r2,r2,24
 100493c:	100b883a 	mov	r5,r2
 1004940:	e13ffe17 	ldw	r4,-8(fp)
 1004944:	1000abc0 	call	1000abc <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1004948:	01400044 	movi	r5,1
 100494c:	e13fff17 	ldw	r4,-4(fp)
 1004950:	1005b6c0 	call	1005b6c <prvAddCurrentTaskToDelayedList>
}
 1004954:	0001883a 	nop
 1004958:	e037883a 	mov	sp,fp
 100495c:	dfc00117 	ldw	ra,4(sp)
 1004960:	df000017 	ldw	fp,0(sp)
 1004964:	dec00204 	addi	sp,sp,8
 1004968:	f800283a 	ret

0100496c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 100496c:	defffb04 	addi	sp,sp,-20
 1004970:	dfc00415 	stw	ra,16(sp)
 1004974:	df000315 	stw	fp,12(sp)
 1004978:	df000304 	addi	fp,sp,12
 100497c:	e13ffd15 	stw	r4,-12(fp)
 1004980:	e17ffe15 	stw	r5,-8(fp)
 1004984:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 1004988:	d0a74117 	ldw	r2,-25340(gp)
 100498c:	e0fffe17 	ldw	r3,-8(fp)
 1004990:	18e00034 	orhi	r3,r3,32768
 1004994:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1004998:	d0a74117 	ldw	r2,-25340(gp)
 100499c:	10800604 	addi	r2,r2,24
 10049a0:	100b883a 	mov	r5,r2
 10049a4:	e13ffd17 	ldw	r4,-12(fp)
 10049a8:	1000a300 	call	1000a30 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 10049ac:	01400044 	movi	r5,1
 10049b0:	e13fff17 	ldw	r4,-4(fp)
 10049b4:	1005b6c0 	call	1005b6c <prvAddCurrentTaskToDelayedList>
}
 10049b8:	0001883a 	nop
 10049bc:	e037883a 	mov	sp,fp
 10049c0:	dfc00117 	ldw	ra,4(sp)
 10049c4:	df000017 	ldw	fp,0(sp)
 10049c8:	dec00204 	addi	sp,sp,8
 10049cc:	f800283a 	ret

010049d0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 10049d0:	defffb04 	addi	sp,sp,-20
 10049d4:	dfc00415 	stw	ra,16(sp)
 10049d8:	df000315 	stw	fp,12(sp)
 10049dc:	df000304 	addi	fp,sp,12
 10049e0:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 10049e4:	e0bfff17 	ldw	r2,-4(fp)
 10049e8:	10800317 	ldw	r2,12(r2)
 10049ec:	10800317 	ldw	r2,12(r2)
 10049f0:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 10049f4:	e0bffe17 	ldw	r2,-8(fp)
 10049f8:	10800604 	addi	r2,r2,24
 10049fc:	1009883a 	mov	r4,r2
 1004a00:	1000b940 	call	1000b94 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1004a04:	d0a74f17 	ldw	r2,-25284(gp)
 1004a08:	1000171e 	bne	r2,zero,1004a68 <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 1004a0c:	e0bffe17 	ldw	r2,-8(fp)
 1004a10:	10800104 	addi	r2,r2,4
 1004a14:	1009883a 	mov	r4,r2
 1004a18:	1000b940 	call	1000b94 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 1004a1c:	e0bffe17 	ldw	r2,-8(fp)
 1004a20:	10800b17 	ldw	r2,44(r2)
 1004a24:	d0e74717 	ldw	r3,-25316(gp)
 1004a28:	1880032e 	bgeu	r3,r2,1004a38 <xTaskRemoveFromEventList+0x68>
 1004a2c:	e0bffe17 	ldw	r2,-8(fp)
 1004a30:	10800b17 	ldw	r2,44(r2)
 1004a34:	d0a74715 	stw	r2,-25316(gp)
 1004a38:	e0bffe17 	ldw	r2,-8(fp)
 1004a3c:	10800b17 	ldw	r2,44(r2)
 1004a40:	10c00524 	muli	r3,r2,20
 1004a44:	008060f4 	movhi	r2,387
 1004a48:	10b9b404 	addi	r2,r2,-6448
 1004a4c:	1887883a 	add	r3,r3,r2
 1004a50:	e0bffe17 	ldw	r2,-8(fp)
 1004a54:	10800104 	addi	r2,r2,4
 1004a58:	100b883a 	mov	r5,r2
 1004a5c:	1809883a 	mov	r4,r3
 1004a60:	1000a300 	call	1000a30 <vListInsertEnd>
 1004a64:	00000606 	br	1004a80 <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 1004a68:	e0bffe17 	ldw	r2,-8(fp)
 1004a6c:	10800604 	addi	r2,r2,24
 1004a70:	100b883a 	mov	r5,r2
 1004a74:	010060f4 	movhi	r4,387
 1004a78:	2139d704 	addi	r4,r4,-6308
 1004a7c:	1000a300 	call	1000a30 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 1004a80:	e0bffe17 	ldw	r2,-8(fp)
 1004a84:	10800b17 	ldw	r2,44(r2)
 1004a88:	d0e74117 	ldw	r3,-25340(gp)
 1004a8c:	18c00b17 	ldw	r3,44(r3)
 1004a90:	1880052e 	bgeu	r3,r2,1004aa8 <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 1004a94:	00800044 	movi	r2,1
 1004a98:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 1004a9c:	00800044 	movi	r2,1
 1004aa0:	d0a74a15 	stw	r2,-25304(gp)
 1004aa4:	00000106 	br	1004aac <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
 1004aa8:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 1004aac:	e0bffd17 	ldw	r2,-12(fp)
}
 1004ab0:	e037883a 	mov	sp,fp
 1004ab4:	dfc00117 	ldw	ra,4(sp)
 1004ab8:	df000017 	ldw	fp,0(sp)
 1004abc:	dec00204 	addi	sp,sp,8
 1004ac0:	f800283a 	ret

01004ac4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 1004ac4:	defffb04 	addi	sp,sp,-20
 1004ac8:	dfc00415 	stw	ra,16(sp)
 1004acc:	df000315 	stw	fp,12(sp)
 1004ad0:	df000304 	addi	fp,sp,12
 1004ad4:	e13ffe15 	stw	r4,-8(fp)
 1004ad8:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 1004adc:	e0bfff17 	ldw	r2,-4(fp)
 1004ae0:	10e00034 	orhi	r3,r2,32768
 1004ae4:	e0bffe17 	ldw	r2,-8(fp)
 1004ae8:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1004aec:	e0bffe17 	ldw	r2,-8(fp)
 1004af0:	10800317 	ldw	r2,12(r2)
 1004af4:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 1004af8:	e13ffe17 	ldw	r4,-8(fp)
 1004afc:	1000b940 	call	1000b94 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 1004b00:	e0bffd17 	ldw	r2,-12(fp)
 1004b04:	10800104 	addi	r2,r2,4
 1004b08:	1009883a 	mov	r4,r2
 1004b0c:	1000b940 	call	1000b94 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 1004b10:	e0bffd17 	ldw	r2,-12(fp)
 1004b14:	10800b17 	ldw	r2,44(r2)
 1004b18:	d0e74717 	ldw	r3,-25316(gp)
 1004b1c:	1880032e 	bgeu	r3,r2,1004b2c <vTaskRemoveFromUnorderedEventList+0x68>
 1004b20:	e0bffd17 	ldw	r2,-12(fp)
 1004b24:	10800b17 	ldw	r2,44(r2)
 1004b28:	d0a74715 	stw	r2,-25316(gp)
 1004b2c:	e0bffd17 	ldw	r2,-12(fp)
 1004b30:	10800b17 	ldw	r2,44(r2)
 1004b34:	10c00524 	muli	r3,r2,20
 1004b38:	008060f4 	movhi	r2,387
 1004b3c:	10b9b404 	addi	r2,r2,-6448
 1004b40:	1887883a 	add	r3,r3,r2
 1004b44:	e0bffd17 	ldw	r2,-12(fp)
 1004b48:	10800104 	addi	r2,r2,4
 1004b4c:	100b883a 	mov	r5,r2
 1004b50:	1809883a 	mov	r4,r3
 1004b54:	1000a300 	call	1000a30 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 1004b58:	e0bffd17 	ldw	r2,-12(fp)
 1004b5c:	10800b17 	ldw	r2,44(r2)
 1004b60:	d0e74117 	ldw	r3,-25340(gp)
 1004b64:	18c00b17 	ldw	r3,44(r3)
 1004b68:	1880022e 	bgeu	r3,r2,1004b74 <vTaskRemoveFromUnorderedEventList+0xb0>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
 1004b6c:	00800044 	movi	r2,1
 1004b70:	d0a74a15 	stw	r2,-25304(gp)
	}
}
 1004b74:	0001883a 	nop
 1004b78:	e037883a 	mov	sp,fp
 1004b7c:	dfc00117 	ldw	ra,4(sp)
 1004b80:	df000017 	ldw	fp,0(sp)
 1004b84:	dec00204 	addi	sp,sp,8
 1004b88:	f800283a 	ret

01004b8c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 1004b8c:	defffd04 	addi	sp,sp,-12
 1004b90:	dfc00215 	stw	ra,8(sp)
 1004b94:	df000115 	stw	fp,4(sp)
 1004b98:	df000104 	addi	fp,sp,4
 1004b9c:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
 1004ba0:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
 1004ba4:	d0e74b17 	ldw	r3,-25300(gp)
 1004ba8:	e0bfff17 	ldw	r2,-4(fp)
 1004bac:	10c00015 	stw	r3,0(r2)
		pxTimeOut->xTimeOnEntering = xTickCount;
 1004bb0:	d0e74617 	ldw	r3,-25320(gp)
 1004bb4:	e0bfff17 	ldw	r2,-4(fp)
 1004bb8:	10c00115 	stw	r3,4(r2)
	}
	taskEXIT_CRITICAL();
 1004bbc:	10053c40 	call	10053c4 <vTaskExitCritical>
}
 1004bc0:	0001883a 	nop
 1004bc4:	e037883a 	mov	sp,fp
 1004bc8:	dfc00117 	ldw	ra,4(sp)
 1004bcc:	df000017 	ldw	fp,0(sp)
 1004bd0:	dec00204 	addi	sp,sp,8
 1004bd4:	f800283a 	ret

01004bd8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 1004bd8:	defffe04 	addi	sp,sp,-8
 1004bdc:	df000115 	stw	fp,4(sp)
 1004be0:	df000104 	addi	fp,sp,4
 1004be4:	e13fff15 	stw	r4,-4(fp)
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 1004be8:	d0e74b17 	ldw	r3,-25300(gp)
 1004bec:	e0bfff17 	ldw	r2,-4(fp)
 1004bf0:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
 1004bf4:	d0e74617 	ldw	r3,-25320(gp)
 1004bf8:	e0bfff17 	ldw	r2,-4(fp)
 1004bfc:	10c00115 	stw	r3,4(r2)
}
 1004c00:	0001883a 	nop
 1004c04:	e037883a 	mov	sp,fp
 1004c08:	df000017 	ldw	fp,0(sp)
 1004c0c:	dec00104 	addi	sp,sp,4
 1004c10:	f800283a 	ret

01004c14 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 1004c14:	defff904 	addi	sp,sp,-28
 1004c18:	dfc00615 	stw	ra,24(sp)
 1004c1c:	df000515 	stw	fp,20(sp)
 1004c20:	df000504 	addi	fp,sp,20
 1004c24:	e13ffe15 	stw	r4,-8(fp)
 1004c28:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 1004c2c:	10053700 	call	1005370 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 1004c30:	d0a74617 	ldw	r2,-25320(gp)
 1004c34:	e0bffc15 	stw	r2,-16(fp)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 1004c38:	e0bffe17 	ldw	r2,-8(fp)
 1004c3c:	10800117 	ldw	r2,4(r2)
 1004c40:	e0fffc17 	ldw	r3,-16(fp)
 1004c44:	1885c83a 	sub	r2,r3,r2
 1004c48:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 1004c4c:	e0bfff17 	ldw	r2,-4(fp)
 1004c50:	10800017 	ldw	r2,0(r2)
 1004c54:	10bfffd8 	cmpnei	r2,r2,-1
 1004c58:	1000021e 	bne	r2,zero,1004c64 <xTaskCheckForTimeOut+0x50>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 1004c5c:	e03ffb15 	stw	zero,-20(fp)
 1004c60:	00001d06 	br	1004cd8 <xTaskCheckForTimeOut+0xc4>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 1004c64:	e0bffe17 	ldw	r2,-8(fp)
 1004c68:	10c00017 	ldw	r3,0(r2)
 1004c6c:	d0a74b17 	ldw	r2,-25300(gp)
 1004c70:	18800726 	beq	r3,r2,1004c90 <xTaskCheckForTimeOut+0x7c>
 1004c74:	e0bffe17 	ldw	r2,-8(fp)
 1004c78:	10800117 	ldw	r2,4(r2)
 1004c7c:	e0fffc17 	ldw	r3,-16(fp)
 1004c80:	18800336 	bltu	r3,r2,1004c90 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 1004c84:	00800044 	movi	r2,1
 1004c88:	e0bffb15 	stw	r2,-20(fp)
 1004c8c:	00001206 	br	1004cd8 <xTaskCheckForTimeOut+0xc4>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 1004c90:	e0bfff17 	ldw	r2,-4(fp)
 1004c94:	10800017 	ldw	r2,0(r2)
 1004c98:	e0fffd17 	ldw	r3,-12(fp)
 1004c9c:	18800a2e 	bgeu	r3,r2,1004cc8 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 1004ca0:	e0bfff17 	ldw	r2,-4(fp)
 1004ca4:	10c00017 	ldw	r3,0(r2)
 1004ca8:	e0bffd17 	ldw	r2,-12(fp)
 1004cac:	1887c83a 	sub	r3,r3,r2
 1004cb0:	e0bfff17 	ldw	r2,-4(fp)
 1004cb4:	10c00015 	stw	r3,0(r2)
			vTaskInternalSetTimeOutState( pxTimeOut );
 1004cb8:	e13ffe17 	ldw	r4,-8(fp)
 1004cbc:	1004bd80 	call	1004bd8 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 1004cc0:	e03ffb15 	stw	zero,-20(fp)
 1004cc4:	00000406 	br	1004cd8 <xTaskCheckForTimeOut+0xc4>
		}
		else
		{
			*pxTicksToWait = 0;
 1004cc8:	e0bfff17 	ldw	r2,-4(fp)
 1004ccc:	10000015 	stw	zero,0(r2)
			xReturn = pdTRUE;
 1004cd0:	00800044 	movi	r2,1
 1004cd4:	e0bffb15 	stw	r2,-20(fp)
		}
	}
	taskEXIT_CRITICAL();
 1004cd8:	10053c40 	call	10053c4 <vTaskExitCritical>

	return xReturn;
 1004cdc:	e0bffb17 	ldw	r2,-20(fp)
}
 1004ce0:	e037883a 	mov	sp,fp
 1004ce4:	dfc00117 	ldw	ra,4(sp)
 1004ce8:	df000017 	ldw	fp,0(sp)
 1004cec:	dec00204 	addi	sp,sp,8
 1004cf0:	f800283a 	ret

01004cf4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 1004cf4:	deffff04 	addi	sp,sp,-4
 1004cf8:	df000015 	stw	fp,0(sp)
 1004cfc:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
 1004d00:	00800044 	movi	r2,1
 1004d04:	d0a74a15 	stw	r2,-25304(gp)
}
 1004d08:	0001883a 	nop
 1004d0c:	e037883a 	mov	sp,fp
 1004d10:	df000017 	ldw	fp,0(sp)
 1004d14:	dec00104 	addi	sp,sp,4
 1004d18:	f800283a 	ret

01004d1c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 1004d1c:	defffd04 	addi	sp,sp,-12
 1004d20:	dfc00215 	stw	ra,8(sp)
 1004d24:	df000115 	stw	fp,4(sp)
 1004d28:	df000104 	addi	fp,sp,4
 1004d2c:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 1004d30:	1004df00 	call	1004df0 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 1004d34:	003ffe06 	br	1004d30 <__alt_data_end+0xff004d30>

01004d38 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 1004d38:	defffd04 	addi	sp,sp,-12
 1004d3c:	dfc00215 	stw	ra,8(sp)
 1004d40:	df000115 	stw	fp,4(sp)
 1004d44:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 1004d48:	e03fff15 	stw	zero,-4(fp)
 1004d4c:	00000a06 	br	1004d78 <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 1004d50:	e0bfff17 	ldw	r2,-4(fp)
 1004d54:	10c00524 	muli	r3,r2,20
 1004d58:	008060f4 	movhi	r2,387
 1004d5c:	10b9b404 	addi	r2,r2,-6448
 1004d60:	1885883a 	add	r2,r3,r2
 1004d64:	1009883a 	mov	r4,r2
 1004d68:	100099c0 	call	100099c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 1004d6c:	e0bfff17 	ldw	r2,-4(fp)
 1004d70:	10800044 	addi	r2,r2,1
 1004d74:	e0bfff15 	stw	r2,-4(fp)
 1004d78:	e0bfff17 	ldw	r2,-4(fp)
 1004d7c:	10800170 	cmpltui	r2,r2,5
 1004d80:	103ff31e 	bne	r2,zero,1004d50 <__alt_data_end+0xff004d50>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 1004d84:	010060f4 	movhi	r4,387
 1004d88:	2139cd04 	addi	r4,r4,-6348
 1004d8c:	100099c0 	call	100099c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 1004d90:	010060f4 	movhi	r4,387
 1004d94:	2139d204 	addi	r4,r4,-6328
 1004d98:	100099c0 	call	100099c <vListInitialise>
	vListInitialise( &xPendingReadyList );
 1004d9c:	010060f4 	movhi	r4,387
 1004da0:	2139d704 	addi	r4,r4,-6308
 1004da4:	100099c0 	call	100099c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 1004da8:	010060f4 	movhi	r4,387
 1004dac:	2139dc04 	addi	r4,r4,-6288
 1004db0:	100099c0 	call	100099c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 1004db4:	010060f4 	movhi	r4,387
 1004db8:	2139e104 	addi	r4,r4,-6268
 1004dbc:	100099c0 	call	100099c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 1004dc0:	008060f4 	movhi	r2,387
 1004dc4:	10b9cd04 	addi	r2,r2,-6348
 1004dc8:	d0a74215 	stw	r2,-25336(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 1004dcc:	008060f4 	movhi	r2,387
 1004dd0:	10b9d204 	addi	r2,r2,-6328
 1004dd4:	d0a74315 	stw	r2,-25332(gp)
}
 1004dd8:	0001883a 	nop
 1004ddc:	e037883a 	mov	sp,fp
 1004de0:	dfc00117 	ldw	ra,4(sp)
 1004de4:	df000017 	ldw	fp,0(sp)
 1004de8:	dec00204 	addi	sp,sp,8
 1004dec:	f800283a 	ret

01004df0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 1004df0:	defffd04 	addi	sp,sp,-12
 1004df4:	dfc00215 	stw	ra,8(sp)
 1004df8:	df000115 	stw	fp,4(sp)
 1004dfc:	df000104 	addi	fp,sp,4
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 1004e00:	00001306 	br	1004e50 <prvCheckTasksWaitingTermination+0x60>
		{
			taskENTER_CRITICAL();
 1004e04:	10053700 	call	1005370 <vTaskEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1004e08:	008060f4 	movhi	r2,387
 1004e0c:	10b9dc04 	addi	r2,r2,-6288
 1004e10:	10800317 	ldw	r2,12(r2)
 1004e14:	10800317 	ldw	r2,12(r2)
 1004e18:	e0bfff15 	stw	r2,-4(fp)
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1004e1c:	e0bfff17 	ldw	r2,-4(fp)
 1004e20:	10800104 	addi	r2,r2,4
 1004e24:	1009883a 	mov	r4,r2
 1004e28:	1000b940 	call	1000b94 <uxListRemove>
				--uxCurrentNumberOfTasks;
 1004e2c:	d0a74517 	ldw	r2,-25324(gp)
 1004e30:	10bfffc4 	addi	r2,r2,-1
 1004e34:	d0a74515 	stw	r2,-25324(gp)
				--uxDeletedTasksWaitingCleanUp;
 1004e38:	d0a74417 	ldw	r2,-25328(gp)
 1004e3c:	10bfffc4 	addi	r2,r2,-1
 1004e40:	d0a74415 	stw	r2,-25328(gp)
			}
			taskEXIT_CRITICAL();
 1004e44:	10053c40 	call	10053c4 <vTaskExitCritical>

			prvDeleteTCB( pxTCB );
 1004e48:	e13fff17 	ldw	r4,-4(fp)
 1004e4c:	1004f340 	call	1004f34 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 1004e50:	d0a74417 	ldw	r2,-25328(gp)
 1004e54:	103feb1e 	bne	r2,zero,1004e04 <__alt_data_end+0xff004e04>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 1004e58:	0001883a 	nop
 1004e5c:	e037883a 	mov	sp,fp
 1004e60:	dfc00117 	ldw	ra,4(sp)
 1004e64:	df000017 	ldw	fp,0(sp)
 1004e68:	dec00204 	addi	sp,sp,8
 1004e6c:	f800283a 	ret

01004e70 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
 1004e70:	defffd04 	addi	sp,sp,-12
 1004e74:	df000215 	stw	fp,8(sp)
 1004e78:	df000204 	addi	fp,sp,8
 1004e7c:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
 1004e80:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 1004e84:	00000606 	br	1004ea0 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
 1004e88:	e0bfff17 	ldw	r2,-4(fp)
 1004e8c:	10800044 	addi	r2,r2,1
 1004e90:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
 1004e94:	e0bffe17 	ldw	r2,-8(fp)
 1004e98:	10800044 	addi	r2,r2,1
 1004e9c:	e0bffe15 	stw	r2,-8(fp)

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 1004ea0:	e0bfff17 	ldw	r2,-4(fp)
 1004ea4:	10800003 	ldbu	r2,0(r2)
 1004ea8:	10803fcc 	andi	r2,r2,255
 1004eac:	10802960 	cmpeqi	r2,r2,165
 1004eb0:	103ff51e 	bne	r2,zero,1004e88 <__alt_data_end+0xff004e88>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 1004eb4:	e0bffe17 	ldw	r2,-8(fp)
 1004eb8:	1004d0ba 	srli	r2,r2,2
 1004ebc:	e0bffe15 	stw	r2,-8(fp)

		return ( configSTACK_DEPTH_TYPE ) ulCount;
 1004ec0:	e0bffe17 	ldw	r2,-8(fp)
	}
 1004ec4:	e037883a 	mov	sp,fp
 1004ec8:	df000017 	ldw	fp,0(sp)
 1004ecc:	dec00104 	addi	sp,sp,4
 1004ed0:	f800283a 	ret

01004ed4 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
 1004ed4:	defffa04 	addi	sp,sp,-24
 1004ed8:	dfc00515 	stw	ra,20(sp)
 1004edc:	df000415 	stw	fp,16(sp)
 1004ee0:	df000404 	addi	fp,sp,16
 1004ee4:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
 1004ee8:	e0bfff17 	ldw	r2,-4(fp)
 1004eec:	1000021e 	bne	r2,zero,1004ef8 <uxTaskGetStackHighWaterMark+0x24>
 1004ef0:	d0a74117 	ldw	r2,-25340(gp)
 1004ef4:	00000106 	br	1004efc <uxTaskGetStackHighWaterMark+0x28>
 1004ef8:	e0bfff17 	ldw	r2,-4(fp)
 1004efc:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 1004f00:	e0bffc17 	ldw	r2,-16(fp)
 1004f04:	10800c17 	ldw	r2,48(r2)
 1004f08:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 1004f0c:	e13ffd17 	ldw	r4,-12(fp)
 1004f10:	1004e700 	call	1004e70 <prvTaskCheckFreeStackSpace>
 1004f14:	10bfffcc 	andi	r2,r2,65535
 1004f18:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
 1004f1c:	e0bffe17 	ldw	r2,-8(fp)
	}
 1004f20:	e037883a 	mov	sp,fp
 1004f24:	dfc00117 	ldw	ra,4(sp)
 1004f28:	df000017 	ldw	fp,0(sp)
 1004f2c:	dec00204 	addi	sp,sp,8
 1004f30:	f800283a 	ret

01004f34 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 1004f34:	defffd04 	addi	sp,sp,-12
 1004f38:	dfc00215 	stw	ra,8(sp)
 1004f3c:	df000115 	stw	fp,4(sp)
 1004f40:	df000104 	addi	fp,sp,4
 1004f44:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 1004f48:	e0bfff17 	ldw	r2,-4(fp)
 1004f4c:	10800c17 	ldw	r2,48(r2)
 1004f50:	1009883a 	mov	r4,r2
 1004f54:	10012840 	call	1001284 <vPortFree>
			vPortFree( pxTCB );
 1004f58:	e13fff17 	ldw	r4,-4(fp)
 1004f5c:	10012840 	call	1001284 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 1004f60:	0001883a 	nop
 1004f64:	e037883a 	mov	sp,fp
 1004f68:	dfc00117 	ldw	ra,4(sp)
 1004f6c:	df000017 	ldw	fp,0(sp)
 1004f70:	dec00204 	addi	sp,sp,8
 1004f74:	f800283a 	ret

01004f78 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 1004f78:	defffe04 	addi	sp,sp,-8
 1004f7c:	df000115 	stw	fp,4(sp)
 1004f80:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1004f84:	d0a74217 	ldw	r2,-25336(gp)
 1004f88:	10800017 	ldw	r2,0(r2)
 1004f8c:	1000031e 	bne	r2,zero,1004f9c <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 1004f90:	00bfffc4 	movi	r2,-1
 1004f94:	d0a74d15 	stw	r2,-25292(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 1004f98:	00000706 	br	1004fb8 <prvResetNextTaskUnblockTime+0x40>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1004f9c:	d0a74217 	ldw	r2,-25336(gp)
 1004fa0:	10800317 	ldw	r2,12(r2)
 1004fa4:	10800317 	ldw	r2,12(r2)
 1004fa8:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 1004fac:	e0bfff17 	ldw	r2,-4(fp)
 1004fb0:	10800117 	ldw	r2,4(r2)
 1004fb4:	d0a74d15 	stw	r2,-25292(gp)
	}
}
 1004fb8:	0001883a 	nop
 1004fbc:	e037883a 	mov	sp,fp
 1004fc0:	df000017 	ldw	fp,0(sp)
 1004fc4:	dec00104 	addi	sp,sp,4
 1004fc8:	f800283a 	ret

01004fcc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 1004fcc:	defffe04 	addi	sp,sp,-8
 1004fd0:	df000115 	stw	fp,4(sp)
 1004fd4:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 1004fd8:	d0a74117 	ldw	r2,-25340(gp)
 1004fdc:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
 1004fe0:	e0bfff17 	ldw	r2,-4(fp)
	}
 1004fe4:	e037883a 	mov	sp,fp
 1004fe8:	df000017 	ldw	fp,0(sp)
 1004fec:	dec00104 	addi	sp,sp,4
 1004ff0:	f800283a 	ret

01004ff4 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 1004ff4:	defffb04 	addi	sp,sp,-20
 1004ff8:	dfc00415 	stw	ra,16(sp)
 1004ffc:	df000315 	stw	fp,12(sp)
 1005000:	df000304 	addi	fp,sp,12
 1005004:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 1005008:	e0bfff17 	ldw	r2,-4(fp)
 100500c:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 1005010:	e03ffd15 	stw	zero,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
 1005014:	e0bfff17 	ldw	r2,-4(fp)
 1005018:	10004026 	beq	r2,zero,100511c <xTaskPriorityInherit+0x128>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 100501c:	e0bffe17 	ldw	r2,-8(fp)
 1005020:	10c00b17 	ldw	r3,44(r2)
 1005024:	d0a74117 	ldw	r2,-25340(gp)
 1005028:	10800b17 	ldw	r2,44(r2)
 100502c:	1880342e 	bgeu	r3,r2,1005100 <xTaskPriorityInherit+0x10c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1005030:	e0bffe17 	ldw	r2,-8(fp)
 1005034:	10800617 	ldw	r2,24(r2)
 1005038:	10000616 	blt	r2,zero,1005054 <xTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 100503c:	d0a74117 	ldw	r2,-25340(gp)
 1005040:	10800b17 	ldw	r2,44(r2)
 1005044:	00c00144 	movi	r3,5
 1005048:	1887c83a 	sub	r3,r3,r2
 100504c:	e0bffe17 	ldw	r2,-8(fp)
 1005050:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 1005054:	e0bffe17 	ldw	r2,-8(fp)
 1005058:	10c00517 	ldw	r3,20(r2)
 100505c:	e0bffe17 	ldw	r2,-8(fp)
 1005060:	10800b17 	ldw	r2,44(r2)
 1005064:	11000524 	muli	r4,r2,20
 1005068:	008060f4 	movhi	r2,387
 100506c:	10b9b404 	addi	r2,r2,-6448
 1005070:	2085883a 	add	r2,r4,r2
 1005074:	18801b1e 	bne	r3,r2,10050e4 <xTaskPriorityInherit+0xf0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1005078:	e0bffe17 	ldw	r2,-8(fp)
 100507c:	10800104 	addi	r2,r2,4
 1005080:	1009883a 	mov	r4,r2
 1005084:	1000b940 	call	1000b94 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 1005088:	d0a74117 	ldw	r2,-25340(gp)
 100508c:	10c00b17 	ldw	r3,44(r2)
 1005090:	e0bffe17 	ldw	r2,-8(fp)
 1005094:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxMutexHolderTCB );
 1005098:	e0bffe17 	ldw	r2,-8(fp)
 100509c:	10800b17 	ldw	r2,44(r2)
 10050a0:	d0e74717 	ldw	r3,-25316(gp)
 10050a4:	1880032e 	bgeu	r3,r2,10050b4 <xTaskPriorityInherit+0xc0>
 10050a8:	e0bffe17 	ldw	r2,-8(fp)
 10050ac:	10800b17 	ldw	r2,44(r2)
 10050b0:	d0a74715 	stw	r2,-25316(gp)
 10050b4:	e0bffe17 	ldw	r2,-8(fp)
 10050b8:	10800b17 	ldw	r2,44(r2)
 10050bc:	10c00524 	muli	r3,r2,20
 10050c0:	008060f4 	movhi	r2,387
 10050c4:	10b9b404 	addi	r2,r2,-6448
 10050c8:	1887883a 	add	r3,r3,r2
 10050cc:	e0bffe17 	ldw	r2,-8(fp)
 10050d0:	10800104 	addi	r2,r2,4
 10050d4:	100b883a 	mov	r5,r2
 10050d8:	1809883a 	mov	r4,r3
 10050dc:	1000a300 	call	1000a30 <vListInsertEnd>
 10050e0:	00000406 	br	10050f4 <xTaskPriorityInherit+0x100>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 10050e4:	d0a74117 	ldw	r2,-25340(gp)
 10050e8:	10c00b17 	ldw	r3,44(r2)
 10050ec:	e0bffe17 	ldw	r2,-8(fp)
 10050f0:	10c00b15 	stw	r3,44(r2)
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
 10050f4:	00800044 	movi	r2,1
 10050f8:	e0bffd15 	stw	r2,-12(fp)
 10050fc:	00000706 	br	100511c <xTaskPriorityInherit+0x128>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 1005100:	e0bffe17 	ldw	r2,-8(fp)
 1005104:	10c01017 	ldw	r3,64(r2)
 1005108:	d0a74117 	ldw	r2,-25340(gp)
 100510c:	10800b17 	ldw	r2,44(r2)
 1005110:	1880022e 	bgeu	r3,r2,100511c <xTaskPriorityInherit+0x128>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
 1005114:	00800044 	movi	r2,1
 1005118:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 100511c:	e0bffd17 	ldw	r2,-12(fp)
	}
 1005120:	e037883a 	mov	sp,fp
 1005124:	dfc00117 	ldw	ra,4(sp)
 1005128:	df000017 	ldw	fp,0(sp)
 100512c:	dec00204 	addi	sp,sp,8
 1005130:	f800283a 	ret

01005134 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 1005134:	defffb04 	addi	sp,sp,-20
 1005138:	dfc00415 	stw	ra,16(sp)
 100513c:	df000315 	stw	fp,12(sp)
 1005140:	df000304 	addi	fp,sp,12
 1005144:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 1005148:	e0bfff17 	ldw	r2,-4(fp)
 100514c:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 1005150:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
 1005154:	e0bfff17 	ldw	r2,-4(fp)
 1005158:	10002f26 	beq	r2,zero,1005218 <xTaskPriorityDisinherit+0xe4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 100515c:	e0bffe17 	ldw	r2,-8(fp)
 1005160:	10801117 	ldw	r2,68(r2)
 1005164:	10ffffc4 	addi	r3,r2,-1
 1005168:	e0bffe17 	ldw	r2,-8(fp)
 100516c:	10c01115 	stw	r3,68(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 1005170:	e0bffe17 	ldw	r2,-8(fp)
 1005174:	10c00b17 	ldw	r3,44(r2)
 1005178:	e0bffe17 	ldw	r2,-8(fp)
 100517c:	10801017 	ldw	r2,64(r2)
 1005180:	18802526 	beq	r3,r2,1005218 <xTaskPriorityDisinherit+0xe4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 1005184:	e0bffe17 	ldw	r2,-8(fp)
 1005188:	10801117 	ldw	r2,68(r2)
 100518c:	1000221e 	bne	r2,zero,1005218 <xTaskPriorityDisinherit+0xe4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1005190:	e0bffe17 	ldw	r2,-8(fp)
 1005194:	10800104 	addi	r2,r2,4
 1005198:	1009883a 	mov	r4,r2
 100519c:	1000b940 	call	1000b94 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 10051a0:	e0bffe17 	ldw	r2,-8(fp)
 10051a4:	10c01017 	ldw	r3,64(r2)
 10051a8:	e0bffe17 	ldw	r2,-8(fp)
 10051ac:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 10051b0:	e0bffe17 	ldw	r2,-8(fp)
 10051b4:	10800b17 	ldw	r2,44(r2)
 10051b8:	00c00144 	movi	r3,5
 10051bc:	1887c83a 	sub	r3,r3,r2
 10051c0:	e0bffe17 	ldw	r2,-8(fp)
 10051c4:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
 10051c8:	e0bffe17 	ldw	r2,-8(fp)
 10051cc:	10800b17 	ldw	r2,44(r2)
 10051d0:	d0e74717 	ldw	r3,-25316(gp)
 10051d4:	1880032e 	bgeu	r3,r2,10051e4 <xTaskPriorityDisinherit+0xb0>
 10051d8:	e0bffe17 	ldw	r2,-8(fp)
 10051dc:	10800b17 	ldw	r2,44(r2)
 10051e0:	d0a74715 	stw	r2,-25316(gp)
 10051e4:	e0bffe17 	ldw	r2,-8(fp)
 10051e8:	10800b17 	ldw	r2,44(r2)
 10051ec:	10c00524 	muli	r3,r2,20
 10051f0:	008060f4 	movhi	r2,387
 10051f4:	10b9b404 	addi	r2,r2,-6448
 10051f8:	1887883a 	add	r3,r3,r2
 10051fc:	e0bffe17 	ldw	r2,-8(fp)
 1005200:	10800104 	addi	r2,r2,4
 1005204:	100b883a 	mov	r5,r2
 1005208:	1809883a 	mov	r4,r3
 100520c:	1000a300 	call	1000a30 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 1005210:	00800044 	movi	r2,1
 1005214:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 1005218:	e0bffd17 	ldw	r2,-12(fp)
	}
 100521c:	e037883a 	mov	sp,fp
 1005220:	dfc00117 	ldw	ra,4(sp)
 1005224:	df000017 	ldw	fp,0(sp)
 1005228:	dec00204 	addi	sp,sp,8
 100522c:	f800283a 	ret

01005230 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
 1005230:	defff804 	addi	sp,sp,-32
 1005234:	dfc00715 	stw	ra,28(sp)
 1005238:	df000615 	stw	fp,24(sp)
 100523c:	df000604 	addi	fp,sp,24
 1005240:	e13ffe15 	stw	r4,-8(fp)
 1005244:	e17fff15 	stw	r5,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 1005248:	e0bffe17 	ldw	r2,-8(fp)
 100524c:	e0bffb15 	stw	r2,-20(fp)
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 1005250:	00800044 	movi	r2,1
 1005254:	e0bffc15 	stw	r2,-16(fp)

		if( pxMutexHolder != NULL )
 1005258:	e0bffe17 	ldw	r2,-8(fp)
 100525c:	10003e26 	beq	r2,zero,1005358 <vTaskPriorityDisinheritAfterTimeout+0x128>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 1005260:	e0bffb17 	ldw	r2,-20(fp)
 1005264:	10c01017 	ldw	r3,64(r2)
 1005268:	e0bfff17 	ldw	r2,-4(fp)
 100526c:	1880032e 	bgeu	r3,r2,100527c <vTaskPriorityDisinheritAfterTimeout+0x4c>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 1005270:	e0bfff17 	ldw	r2,-4(fp)
 1005274:	e0bffa15 	stw	r2,-24(fp)
 1005278:	00000306 	br	1005288 <vTaskPriorityDisinheritAfterTimeout+0x58>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
 100527c:	e0bffb17 	ldw	r2,-20(fp)
 1005280:	10801017 	ldw	r2,64(r2)
 1005284:	e0bffa15 	stw	r2,-24(fp)
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
 1005288:	e0bffb17 	ldw	r2,-20(fp)
 100528c:	10c00b17 	ldw	r3,44(r2)
 1005290:	e0bffa17 	ldw	r2,-24(fp)
 1005294:	18803026 	beq	r3,r2,1005358 <vTaskPriorityDisinheritAfterTimeout+0x128>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 1005298:	e0bffb17 	ldw	r2,-20(fp)
 100529c:	10c01117 	ldw	r3,68(r2)
 10052a0:	e0bffc17 	ldw	r2,-16(fp)
 10052a4:	18802c1e 	bne	r3,r2,1005358 <vTaskPriorityDisinheritAfterTimeout+0x128>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 10052a8:	e0bffb17 	ldw	r2,-20(fp)
 10052ac:	10800b17 	ldw	r2,44(r2)
 10052b0:	e0bffd15 	stw	r2,-12(fp)
					pxTCB->uxPriority = uxPriorityToUse;
 10052b4:	e0bffb17 	ldw	r2,-20(fp)
 10052b8:	e0fffa17 	ldw	r3,-24(fp)
 10052bc:	10c00b15 	stw	r3,44(r2)

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 10052c0:	e0bffb17 	ldw	r2,-20(fp)
 10052c4:	10800617 	ldw	r2,24(r2)
 10052c8:	10000516 	blt	r2,zero,10052e0 <vTaskPriorityDisinheritAfterTimeout+0xb0>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 10052cc:	00c00144 	movi	r3,5
 10052d0:	e0bffa17 	ldw	r2,-24(fp)
 10052d4:	1887c83a 	sub	r3,r3,r2
 10052d8:	e0bffb17 	ldw	r2,-20(fp)
 10052dc:	10c00615 	stw	r3,24(r2)
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 10052e0:	e0bffb17 	ldw	r2,-20(fp)
 10052e4:	10c00517 	ldw	r3,20(r2)
 10052e8:	e0bffd17 	ldw	r2,-12(fp)
 10052ec:	11000524 	muli	r4,r2,20
 10052f0:	008060f4 	movhi	r2,387
 10052f4:	10b9b404 	addi	r2,r2,-6448
 10052f8:	2085883a 	add	r2,r4,r2
 10052fc:	1880161e 	bne	r3,r2,1005358 <vTaskPriorityDisinheritAfterTimeout+0x128>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1005300:	e0bffb17 	ldw	r2,-20(fp)
 1005304:	10800104 	addi	r2,r2,4
 1005308:	1009883a 	mov	r4,r2
 100530c:	1000b940 	call	1000b94 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
 1005310:	e0bffb17 	ldw	r2,-20(fp)
 1005314:	10800b17 	ldw	r2,44(r2)
 1005318:	d0e74717 	ldw	r3,-25316(gp)
 100531c:	1880032e 	bgeu	r3,r2,100532c <vTaskPriorityDisinheritAfterTimeout+0xfc>
 1005320:	e0bffb17 	ldw	r2,-20(fp)
 1005324:	10800b17 	ldw	r2,44(r2)
 1005328:	d0a74715 	stw	r2,-25316(gp)
 100532c:	e0bffb17 	ldw	r2,-20(fp)
 1005330:	10800b17 	ldw	r2,44(r2)
 1005334:	10c00524 	muli	r3,r2,20
 1005338:	008060f4 	movhi	r2,387
 100533c:	10b9b404 	addi	r2,r2,-6448
 1005340:	1887883a 	add	r3,r3,r2
 1005344:	e0bffb17 	ldw	r2,-20(fp)
 1005348:	10800104 	addi	r2,r2,4
 100534c:	100b883a 	mov	r5,r2
 1005350:	1809883a 	mov	r4,r3
 1005354:	1000a300 	call	1000a30 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1005358:	0001883a 	nop
 100535c:	e037883a 	mov	sp,fp
 1005360:	dfc00117 	ldw	ra,4(sp)
 1005364:	df000017 	ldw	fp,0(sp)
 1005368:	dec00204 	addi	sp,sp,8
 100536c:	f800283a 	ret

01005370 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
 1005370:	defffe04 	addi	sp,sp,-8
 1005374:	df000115 	stw	fp,4(sp)
 1005378:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 100537c:	0005303a 	rdctl	r2,status
 1005380:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1005384:	e0ffff17 	ldw	r3,-4(fp)
 1005388:	00bfff84 	movi	r2,-2
 100538c:	1884703a 	and	r2,r3,r2
 1005390:	1001703a 	wrctl	status,r2
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
 1005394:	d0a74817 	ldw	r2,-25312(gp)
 1005398:	10000526 	beq	r2,zero,10053b0 <vTaskEnterCritical+0x40>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
 100539c:	d0a74117 	ldw	r2,-25340(gp)
 10053a0:	10c00f17 	ldw	r3,60(r2)
 10053a4:	18c00044 	addi	r3,r3,1
 10053a8:	10c00f15 	stw	r3,60(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
 10053ac:	d0a74117 	ldw	r2,-25340(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 10053b0:	0001883a 	nop
 10053b4:	e037883a 	mov	sp,fp
 10053b8:	df000017 	ldw	fp,0(sp)
 10053bc:	dec00104 	addi	sp,sp,4
 10053c0:	f800283a 	ret

010053c4 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
 10053c4:	defffe04 	addi	sp,sp,-8
 10053c8:	df000115 	stw	fp,4(sp)
 10053cc:	df000104 	addi	fp,sp,4
		if( xSchedulerRunning != pdFALSE )
 10053d0:	d0a74817 	ldw	r2,-25312(gp)
 10053d4:	10000e26 	beq	r2,zero,1005410 <vTaskExitCritical+0x4c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
 10053d8:	d0a74117 	ldw	r2,-25340(gp)
 10053dc:	10800f17 	ldw	r2,60(r2)
 10053e0:	10000b26 	beq	r2,zero,1005410 <vTaskExitCritical+0x4c>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
 10053e4:	d0a74117 	ldw	r2,-25340(gp)
 10053e8:	10c00f17 	ldw	r3,60(r2)
 10053ec:	18ffffc4 	addi	r3,r3,-1
 10053f0:	10c00f15 	stw	r3,60(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
 10053f4:	d0a74117 	ldw	r2,-25340(gp)
 10053f8:	10800f17 	ldw	r2,60(r2)
 10053fc:	1000041e 	bne	r2,zero,1005410 <vTaskExitCritical+0x4c>
 1005400:	00800044 	movi	r2,1
 1005404:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1005408:	e0bfff17 	ldw	r2,-4(fp)
 100540c:	1001703a 	wrctl	status,r2
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1005410:	0001883a 	nop
 1005414:	e037883a 	mov	sp,fp
 1005418:	df000017 	ldw	fp,0(sp)
 100541c:	dec00104 	addi	sp,sp,4
 1005420:	f800283a 	ret

01005424 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 1005424:	defffe04 	addi	sp,sp,-8
 1005428:	df000115 	stw	fp,4(sp)
 100542c:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 1005430:	d0a74117 	ldw	r2,-25340(gp)
 1005434:	10800617 	ldw	r2,24(r2)
 1005438:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 100543c:	d0a74117 	ldw	r2,-25340(gp)
 1005440:	d0e74117 	ldw	r3,-25340(gp)
 1005444:	18c00b17 	ldw	r3,44(r3)
 1005448:	01000144 	movi	r4,5
 100544c:	20c7c83a 	sub	r3,r4,r3
 1005450:	10c00615 	stw	r3,24(r2)

	return uxReturn;
 1005454:	e0bfff17 	ldw	r2,-4(fp)
}
 1005458:	e037883a 	mov	sp,fp
 100545c:	df000017 	ldw	fp,0(sp)
 1005460:	dec00104 	addi	sp,sp,4
 1005464:	f800283a 	ret

01005468 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
 1005468:	deffff04 	addi	sp,sp,-4
 100546c:	df000015 	stw	fp,0(sp)
 1005470:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 1005474:	d0a74117 	ldw	r2,-25340(gp)
 1005478:	10000426 	beq	r2,zero,100548c <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 100547c:	d0a74117 	ldw	r2,-25340(gp)
 1005480:	10c01117 	ldw	r3,68(r2)
 1005484:	18c00044 	addi	r3,r3,1
 1005488:	10c01115 	stw	r3,68(r2)
		}

		return pxCurrentTCB;
 100548c:	d0a74117 	ldw	r2,-25340(gp)
	}
 1005490:	e037883a 	mov	sp,fp
 1005494:	df000017 	ldw	fp,0(sp)
 1005498:	dec00104 	addi	sp,sp,4
 100549c:	f800283a 	ret

010054a0 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 10054a0:	defffb04 	addi	sp,sp,-20
 10054a4:	dfc00415 	stw	ra,16(sp)
 10054a8:	df000315 	stw	fp,12(sp)
 10054ac:	df000304 	addi	fp,sp,12
 10054b0:	e13ffe15 	stw	r4,-8(fp)
 10054b4:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 10054b8:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 10054bc:	d0a74117 	ldw	r2,-25340(gp)
 10054c0:	10801217 	ldw	r2,72(r2)
 10054c4:	1000091e 	bne	r2,zero,10054ec <ulTaskNotifyTake+0x4c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 10054c8:	d0a74117 	ldw	r2,-25340(gp)
 10054cc:	00c00044 	movi	r3,1
 10054d0:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 10054d4:	e0bfff17 	ldw	r2,-4(fp)
 10054d8:	10000426 	beq	r2,zero,10054ec <ulTaskNotifyTake+0x4c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 10054dc:	01400044 	movi	r5,1
 10054e0:	e13fff17 	ldw	r4,-4(fp)
 10054e4:	1005b6c0 	call	1005b6c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 10054e8:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 10054ec:	10053c40 	call	10053c4 <vTaskExitCritical>

		taskENTER_CRITICAL();
 10054f0:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 10054f4:	d0a74117 	ldw	r2,-25340(gp)
 10054f8:	10801217 	ldw	r2,72(r2)
 10054fc:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
 1005500:	e0bffd17 	ldw	r2,-12(fp)
 1005504:	10000926 	beq	r2,zero,100552c <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
 1005508:	e0bffe17 	ldw	r2,-8(fp)
 100550c:	10000326 	beq	r2,zero,100551c <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 1005510:	d0a74117 	ldw	r2,-25340(gp)
 1005514:	10001215 	stw	zero,72(r2)
 1005518:	00000406 	br	100552c <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 100551c:	d0a74117 	ldw	r2,-25340(gp)
 1005520:	e0fffd17 	ldw	r3,-12(fp)
 1005524:	18ffffc4 	addi	r3,r3,-1
 1005528:	10c01215 	stw	r3,72(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 100552c:	d0a74117 	ldw	r2,-25340(gp)
 1005530:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
 1005534:	10053c40 	call	10053c4 <vTaskExitCritical>

		return ulReturn;
 1005538:	e0bffd17 	ldw	r2,-12(fp)
	}
 100553c:	e037883a 	mov	sp,fp
 1005540:	dfc00117 	ldw	ra,4(sp)
 1005544:	df000017 	ldw	fp,0(sp)
 1005548:	dec00204 	addi	sp,sp,8
 100554c:	f800283a 	ret

01005550 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 1005550:	defff904 	addi	sp,sp,-28
 1005554:	dfc00615 	stw	ra,24(sp)
 1005558:	df000515 	stw	fp,20(sp)
 100555c:	df000504 	addi	fp,sp,20
 1005560:	e13ffc15 	stw	r4,-16(fp)
 1005564:	e17ffd15 	stw	r5,-12(fp)
 1005568:	e1bffe15 	stw	r6,-8(fp)
 100556c:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 1005570:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 1005574:	d0a74117 	ldw	r2,-25340(gp)
 1005578:	10801303 	ldbu	r2,76(r2)
 100557c:	10803fcc 	andi	r2,r2,255
 1005580:	108000a0 	cmpeqi	r2,r2,2
 1005584:	10000f1e 	bne	r2,zero,10055c4 <xTaskNotifyWait+0x74>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 1005588:	d0a74117 	ldw	r2,-25340(gp)
 100558c:	11001217 	ldw	r4,72(r2)
 1005590:	e0fffc17 	ldw	r3,-16(fp)
 1005594:	00c6303a 	nor	r3,zero,r3
 1005598:	20c6703a 	and	r3,r4,r3
 100559c:	10c01215 	stw	r3,72(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 10055a0:	d0a74117 	ldw	r2,-25340(gp)
 10055a4:	00c00044 	movi	r3,1
 10055a8:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 10055ac:	e0bfff17 	ldw	r2,-4(fp)
 10055b0:	10000426 	beq	r2,zero,10055c4 <xTaskNotifyWait+0x74>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 10055b4:	01400044 	movi	r5,1
 10055b8:	e13fff17 	ldw	r4,-4(fp)
 10055bc:	1005b6c0 	call	1005b6c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 10055c0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 10055c4:	10053c40 	call	10053c4 <vTaskExitCritical>

		taskENTER_CRITICAL();
 10055c8:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 10055cc:	e0bffe17 	ldw	r2,-8(fp)
 10055d0:	10000426 	beq	r2,zero,10055e4 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 10055d4:	d0a74117 	ldw	r2,-25340(gp)
 10055d8:	10c01217 	ldw	r3,72(r2)
 10055dc:	e0bffe17 	ldw	r2,-8(fp)
 10055e0:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 10055e4:	d0a74117 	ldw	r2,-25340(gp)
 10055e8:	10801303 	ldbu	r2,76(r2)
 10055ec:	10803fcc 	andi	r2,r2,255
 10055f0:	108000a0 	cmpeqi	r2,r2,2
 10055f4:	1000021e 	bne	r2,zero,1005600 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 10055f8:	e03ffb15 	stw	zero,-20(fp)
 10055fc:	00000806 	br	1005620 <xTaskNotifyWait+0xd0>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 1005600:	d0a74117 	ldw	r2,-25340(gp)
 1005604:	11001217 	ldw	r4,72(r2)
 1005608:	e0fffd17 	ldw	r3,-12(fp)
 100560c:	00c6303a 	nor	r3,zero,r3
 1005610:	20c6703a 	and	r3,r4,r3
 1005614:	10c01215 	stw	r3,72(r2)
				xReturn = pdTRUE;
 1005618:	00800044 	movi	r2,1
 100561c:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1005620:	d0a74117 	ldw	r2,-25340(gp)
 1005624:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
 1005628:	10053c40 	call	10053c4 <vTaskExitCritical>

		return xReturn;
 100562c:	e0bffb17 	ldw	r2,-20(fp)
	}
 1005630:	e037883a 	mov	sp,fp
 1005634:	dfc00117 	ldw	ra,4(sp)
 1005638:	df000017 	ldw	fp,0(sp)
 100563c:	dec00204 	addi	sp,sp,8
 1005640:	f800283a 	ret

01005644 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 1005644:	defff704 	addi	sp,sp,-36
 1005648:	dfc00815 	stw	ra,32(sp)
 100564c:	df000715 	stw	fp,28(sp)
 1005650:	df000704 	addi	fp,sp,28
 1005654:	e13ffc15 	stw	r4,-16(fp)
 1005658:	e17ffd15 	stw	r5,-12(fp)
 100565c:	e1bffe15 	stw	r6,-8(fp)
 1005660:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 1005664:	00800044 	movi	r2,1
 1005668:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
 100566c:	e0bffc17 	ldw	r2,-16(fp)
 1005670:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
 1005674:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 1005678:	e0bfff17 	ldw	r2,-4(fp)
 100567c:	10000426 	beq	r2,zero,1005690 <xTaskGenericNotify+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 1005680:	e0bffa17 	ldw	r2,-24(fp)
 1005684:	10c01217 	ldw	r3,72(r2)
 1005688:	e0bfff17 	ldw	r2,-4(fp)
 100568c:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 1005690:	e0bffa17 	ldw	r2,-24(fp)
 1005694:	10801303 	ldbu	r2,76(r2)
 1005698:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 100569c:	e0bffa17 	ldw	r2,-24(fp)
 10056a0:	00c00084 	movi	r3,2
 10056a4:	10c01305 	stb	r3,76(r2)

			switch( eAction )
 10056a8:	e0bffe17 	ldw	r2,-8(fp)
 10056ac:	10800168 	cmpgeui	r2,r2,5
 10056b0:	1000261e 	bne	r2,zero,100574c <xTaskGenericNotify+0x108>
 10056b4:	e0bffe17 	ldw	r2,-8(fp)
 10056b8:	100690ba 	slli	r3,r2,2
 10056bc:	00804034 	movhi	r2,256
 10056c0:	1095b404 	addi	r2,r2,22224
 10056c4:	1885883a 	add	r2,r3,r2
 10056c8:	10800017 	ldw	r2,0(r2)
 10056cc:	1000683a 	jmp	r2
 10056d0:	01005754 	movui	r4,349
 10056d4:	010056e4 	muli	r4,zero,347
 10056d8:	01005700 	call	100570 <__reset-0xeffa90>
 10056dc:	01005718 	cmpnei	r4,zero,348
 10056e0:	01005728 	cmpgeui	r4,zero,348
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 10056e4:	e0bffa17 	ldw	r2,-24(fp)
 10056e8:	10c01217 	ldw	r3,72(r2)
 10056ec:	e0bffd17 	ldw	r2,-12(fp)
 10056f0:	1886b03a 	or	r3,r3,r2
 10056f4:	e0bffa17 	ldw	r2,-24(fp)
 10056f8:	10c01215 	stw	r3,72(r2)
					break;
 10056fc:	00001606 	br	1005758 <xTaskGenericNotify+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 1005700:	e0bffa17 	ldw	r2,-24(fp)
 1005704:	10801217 	ldw	r2,72(r2)
 1005708:	10c00044 	addi	r3,r2,1
 100570c:	e0bffa17 	ldw	r2,-24(fp)
 1005710:	10c01215 	stw	r3,72(r2)
					break;
 1005714:	00001006 	br	1005758 <xTaskGenericNotify+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 1005718:	e0bffa17 	ldw	r2,-24(fp)
 100571c:	e0fffd17 	ldw	r3,-12(fp)
 1005720:	10c01215 	stw	r3,72(r2)
					break;
 1005724:	00000c06 	br	1005758 <xTaskGenericNotify+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 1005728:	e0bffb03 	ldbu	r2,-20(fp)
 100572c:	108000a0 	cmpeqi	r2,r2,2
 1005730:	1000041e 	bne	r2,zero,1005744 <xTaskGenericNotify+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 1005734:	e0bffa17 	ldw	r2,-24(fp)
 1005738:	e0fffd17 	ldw	r3,-12(fp)
 100573c:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 1005740:	00000506 	br	1005758 <xTaskGenericNotify+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 1005744:	e03ff915 	stw	zero,-28(fp)
					}
					break;
 1005748:	00000306 	br	1005758 <xTaskGenericNotify+0x114>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
 100574c:	0001883a 	nop
 1005750:	00000106 	br	1005758 <xTaskGenericNotify+0x114>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
 1005754:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1005758:	e0bffb03 	ldbu	r2,-20(fp)
 100575c:	10800058 	cmpnei	r2,r2,1
 1005760:	10001c1e 	bne	r2,zero,10057d4 <xTaskGenericNotify+0x190>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1005764:	e0bffa17 	ldw	r2,-24(fp)
 1005768:	10800104 	addi	r2,r2,4
 100576c:	1009883a 	mov	r4,r2
 1005770:	1000b940 	call	1000b94 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 1005774:	e0bffa17 	ldw	r2,-24(fp)
 1005778:	10800b17 	ldw	r2,44(r2)
 100577c:	d0e74717 	ldw	r3,-25316(gp)
 1005780:	1880032e 	bgeu	r3,r2,1005790 <xTaskGenericNotify+0x14c>
 1005784:	e0bffa17 	ldw	r2,-24(fp)
 1005788:	10800b17 	ldw	r2,44(r2)
 100578c:	d0a74715 	stw	r2,-25316(gp)
 1005790:	e0bffa17 	ldw	r2,-24(fp)
 1005794:	10800b17 	ldw	r2,44(r2)
 1005798:	10c00524 	muli	r3,r2,20
 100579c:	008060f4 	movhi	r2,387
 10057a0:	10b9b404 	addi	r2,r2,-6448
 10057a4:	1887883a 	add	r3,r3,r2
 10057a8:	e0bffa17 	ldw	r2,-24(fp)
 10057ac:	10800104 	addi	r2,r2,4
 10057b0:	100b883a 	mov	r5,r2
 10057b4:	1809883a 	mov	r4,r3
 10057b8:	1000a300 	call	1000a30 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 10057bc:	e0bffa17 	ldw	r2,-24(fp)
 10057c0:	10800b17 	ldw	r2,44(r2)
 10057c4:	d0e74117 	ldw	r3,-25340(gp)
 10057c8:	18c00b17 	ldw	r3,44(r3)
 10057cc:	1880012e 	bgeu	r3,r2,10057d4 <xTaskGenericNotify+0x190>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 10057d0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 10057d4:	10053c40 	call	10053c4 <vTaskExitCritical>

		return xReturn;
 10057d8:	e0bff917 	ldw	r2,-28(fp)
	}
 10057dc:	e037883a 	mov	sp,fp
 10057e0:	dfc00117 	ldw	ra,4(sp)
 10057e4:	df000017 	ldw	fp,0(sp)
 10057e8:	dec00204 	addi	sp,sp,8
 10057ec:	f800283a 	ret

010057f0 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 10057f0:	defff604 	addi	sp,sp,-40
 10057f4:	dfc00915 	stw	ra,36(sp)
 10057f8:	df000815 	stw	fp,32(sp)
 10057fc:	df000804 	addi	fp,sp,32
 1005800:	e13ffc15 	stw	r4,-16(fp)
 1005804:	e17ffd15 	stw	r5,-12(fp)
 1005808:	e1bffe15 	stw	r6,-8(fp)
 100580c:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
 1005810:	00800044 	movi	r2,1
 1005814:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 1005818:	e0bffc17 	ldw	r2,-16(fp)
 100581c:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1005820:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
 1005824:	e0bfff17 	ldw	r2,-4(fp)
 1005828:	10000426 	beq	r2,zero,100583c <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 100582c:	e0bff917 	ldw	r2,-28(fp)
 1005830:	10c01217 	ldw	r3,72(r2)
 1005834:	e0bfff17 	ldw	r2,-4(fp)
 1005838:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 100583c:	e0bff917 	ldw	r2,-28(fp)
 1005840:	10801303 	ldbu	r2,76(r2)
 1005844:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 1005848:	e0bff917 	ldw	r2,-28(fp)
 100584c:	00c00084 	movi	r3,2
 1005850:	10c01305 	stb	r3,76(r2)

			switch( eAction )
 1005854:	e0bffe17 	ldw	r2,-8(fp)
 1005858:	10800168 	cmpgeui	r2,r2,5
 100585c:	1000261e 	bne	r2,zero,10058f8 <xTaskGenericNotifyFromISR+0x108>
 1005860:	e0bffe17 	ldw	r2,-8(fp)
 1005864:	100690ba 	slli	r3,r2,2
 1005868:	00804034 	movhi	r2,256
 100586c:	10961f04 	addi	r2,r2,22652
 1005870:	1885883a 	add	r2,r3,r2
 1005874:	10800017 	ldw	r2,0(r2)
 1005878:	1000683a 	jmp	r2
 100587c:	01005900 	call	100590 <__reset-0xeffa70>
 1005880:	01005890 	cmplti	r4,zero,354
 1005884:	010058ac 	andhi	r4,zero,354
 1005888:	010058c4 	movi	r4,355
 100588c:	010058d4 	movui	r4,355
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 1005890:	e0bff917 	ldw	r2,-28(fp)
 1005894:	10c01217 	ldw	r3,72(r2)
 1005898:	e0bffd17 	ldw	r2,-12(fp)
 100589c:	1886b03a 	or	r3,r3,r2
 10058a0:	e0bff917 	ldw	r2,-28(fp)
 10058a4:	10c01215 	stw	r3,72(r2)
					break;
 10058a8:	00001606 	br	1005904 <xTaskGenericNotifyFromISR+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 10058ac:	e0bff917 	ldw	r2,-28(fp)
 10058b0:	10801217 	ldw	r2,72(r2)
 10058b4:	10c00044 	addi	r3,r2,1
 10058b8:	e0bff917 	ldw	r2,-28(fp)
 10058bc:	10c01215 	stw	r3,72(r2)
					break;
 10058c0:	00001006 	br	1005904 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 10058c4:	e0bff917 	ldw	r2,-28(fp)
 10058c8:	e0fffd17 	ldw	r3,-12(fp)
 10058cc:	10c01215 	stw	r3,72(r2)
					break;
 10058d0:	00000c06 	br	1005904 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 10058d4:	e0bffb03 	ldbu	r2,-20(fp)
 10058d8:	108000a0 	cmpeqi	r2,r2,2
 10058dc:	1000041e 	bne	r2,zero,10058f0 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 10058e0:	e0bff917 	ldw	r2,-28(fp)
 10058e4:	e0fffd17 	ldw	r3,-12(fp)
 10058e8:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 10058ec:	00000506 	br	1005904 <xTaskGenericNotifyFromISR+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 10058f0:	e03ff815 	stw	zero,-32(fp)
					}
					break;
 10058f4:	00000306 	br	1005904 <xTaskGenericNotifyFromISR+0x114>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
 10058f8:	0001883a 	nop
 10058fc:	00000106 	br	1005904 <xTaskGenericNotifyFromISR+0x114>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
 1005900:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1005904:	e0bffb03 	ldbu	r2,-20(fp)
 1005908:	10800058 	cmpnei	r2,r2,1
 100590c:	10002b1e 	bne	r2,zero,10059bc <xTaskGenericNotifyFromISR+0x1cc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1005910:	d0a74f17 	ldw	r2,-25284(gp)
 1005914:	1000171e 	bne	r2,zero,1005974 <xTaskGenericNotifyFromISR+0x184>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1005918:	e0bff917 	ldw	r2,-28(fp)
 100591c:	10800104 	addi	r2,r2,4
 1005920:	1009883a 	mov	r4,r2
 1005924:	1000b940 	call	1000b94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1005928:	e0bff917 	ldw	r2,-28(fp)
 100592c:	10800b17 	ldw	r2,44(r2)
 1005930:	d0e74717 	ldw	r3,-25316(gp)
 1005934:	1880032e 	bgeu	r3,r2,1005944 <xTaskGenericNotifyFromISR+0x154>
 1005938:	e0bff917 	ldw	r2,-28(fp)
 100593c:	10800b17 	ldw	r2,44(r2)
 1005940:	d0a74715 	stw	r2,-25316(gp)
 1005944:	e0bff917 	ldw	r2,-28(fp)
 1005948:	10800b17 	ldw	r2,44(r2)
 100594c:	10c00524 	muli	r3,r2,20
 1005950:	008060f4 	movhi	r2,387
 1005954:	10b9b404 	addi	r2,r2,-6448
 1005958:	1887883a 	add	r3,r3,r2
 100595c:	e0bff917 	ldw	r2,-28(fp)
 1005960:	10800104 	addi	r2,r2,4
 1005964:	100b883a 	mov	r5,r2
 1005968:	1809883a 	mov	r4,r3
 100596c:	1000a300 	call	1000a30 <vListInsertEnd>
 1005970:	00000606 	br	100598c <xTaskGenericNotifyFromISR+0x19c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1005974:	e0bff917 	ldw	r2,-28(fp)
 1005978:	10800604 	addi	r2,r2,24
 100597c:	100b883a 	mov	r5,r2
 1005980:	010060f4 	movhi	r4,387
 1005984:	2139d704 	addi	r4,r4,-6308
 1005988:	1000a300 	call	1000a30 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 100598c:	e0bff917 	ldw	r2,-28(fp)
 1005990:	10800b17 	ldw	r2,44(r2)
 1005994:	d0e74117 	ldw	r3,-25340(gp)
 1005998:	18c00b17 	ldw	r3,44(r3)
 100599c:	1880072e 	bgeu	r3,r2,10059bc <xTaskGenericNotifyFromISR+0x1cc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 10059a0:	e0800217 	ldw	r2,8(fp)
 10059a4:	10000326 	beq	r2,zero,10059b4 <xTaskGenericNotifyFromISR+0x1c4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 10059a8:	e0800217 	ldw	r2,8(fp)
 10059ac:	00c00044 	movi	r3,1
 10059b0:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 10059b4:	00800044 	movi	r2,1
 10059b8:	d0a74a15 	stw	r2,-25304(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
 10059bc:	e0bff817 	ldw	r2,-32(fp)
	}
 10059c0:	e037883a 	mov	sp,fp
 10059c4:	dfc00117 	ldw	ra,4(sp)
 10059c8:	df000017 	ldw	fp,0(sp)
 10059cc:	dec00204 	addi	sp,sp,8
 10059d0:	f800283a 	ret

010059d4 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 10059d4:	defff904 	addi	sp,sp,-28
 10059d8:	dfc00615 	stw	ra,24(sp)
 10059dc:	df000515 	stw	fp,20(sp)
 10059e0:	df000504 	addi	fp,sp,20
 10059e4:	e13ffe15 	stw	r4,-8(fp)
 10059e8:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 10059ec:	e0bffe17 	ldw	r2,-8(fp)
 10059f0:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 10059f4:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 10059f8:	e0bffb17 	ldw	r2,-20(fp)
 10059fc:	10801303 	ldbu	r2,76(r2)
 1005a00:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 1005a04:	e0bffb17 	ldw	r2,-20(fp)
 1005a08:	00c00084 	movi	r3,2
 1005a0c:	10c01305 	stb	r3,76(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 1005a10:	e0bffb17 	ldw	r2,-20(fp)
 1005a14:	10801217 	ldw	r2,72(r2)
 1005a18:	10c00044 	addi	r3,r2,1
 1005a1c:	e0bffb17 	ldw	r2,-20(fp)
 1005a20:	10c01215 	stw	r3,72(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1005a24:	e0bffd03 	ldbu	r2,-12(fp)
 1005a28:	10800058 	cmpnei	r2,r2,1
 1005a2c:	10002b1e 	bne	r2,zero,1005adc <vTaskNotifyGiveFromISR+0x108>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1005a30:	d0a74f17 	ldw	r2,-25284(gp)
 1005a34:	1000171e 	bne	r2,zero,1005a94 <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1005a38:	e0bffb17 	ldw	r2,-20(fp)
 1005a3c:	10800104 	addi	r2,r2,4
 1005a40:	1009883a 	mov	r4,r2
 1005a44:	1000b940 	call	1000b94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1005a48:	e0bffb17 	ldw	r2,-20(fp)
 1005a4c:	10800b17 	ldw	r2,44(r2)
 1005a50:	d0e74717 	ldw	r3,-25316(gp)
 1005a54:	1880032e 	bgeu	r3,r2,1005a64 <vTaskNotifyGiveFromISR+0x90>
 1005a58:	e0bffb17 	ldw	r2,-20(fp)
 1005a5c:	10800b17 	ldw	r2,44(r2)
 1005a60:	d0a74715 	stw	r2,-25316(gp)
 1005a64:	e0bffb17 	ldw	r2,-20(fp)
 1005a68:	10800b17 	ldw	r2,44(r2)
 1005a6c:	10c00524 	muli	r3,r2,20
 1005a70:	008060f4 	movhi	r2,387
 1005a74:	10b9b404 	addi	r2,r2,-6448
 1005a78:	1887883a 	add	r3,r3,r2
 1005a7c:	e0bffb17 	ldw	r2,-20(fp)
 1005a80:	10800104 	addi	r2,r2,4
 1005a84:	100b883a 	mov	r5,r2
 1005a88:	1809883a 	mov	r4,r3
 1005a8c:	1000a300 	call	1000a30 <vListInsertEnd>
 1005a90:	00000606 	br	1005aac <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1005a94:	e0bffb17 	ldw	r2,-20(fp)
 1005a98:	10800604 	addi	r2,r2,24
 1005a9c:	100b883a 	mov	r5,r2
 1005aa0:	010060f4 	movhi	r4,387
 1005aa4:	2139d704 	addi	r4,r4,-6308
 1005aa8:	1000a300 	call	1000a30 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 1005aac:	e0bffb17 	ldw	r2,-20(fp)
 1005ab0:	10800b17 	ldw	r2,44(r2)
 1005ab4:	d0e74117 	ldw	r3,-25340(gp)
 1005ab8:	18c00b17 	ldw	r3,44(r3)
 1005abc:	1880072e 	bgeu	r3,r2,1005adc <vTaskNotifyGiveFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 1005ac0:	e0bfff17 	ldw	r2,-4(fp)
 1005ac4:	10000326 	beq	r2,zero,1005ad4 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 1005ac8:	e0bfff17 	ldw	r2,-4(fp)
 1005acc:	00c00044 	movi	r3,1
 1005ad0:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 1005ad4:	00800044 	movi	r2,1
 1005ad8:	d0a74a15 	stw	r2,-25304(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 1005adc:	0001883a 	nop
 1005ae0:	e037883a 	mov	sp,fp
 1005ae4:	dfc00117 	ldw	ra,4(sp)
 1005ae8:	df000017 	ldw	fp,0(sp)
 1005aec:	dec00204 	addi	sp,sp,8
 1005af0:	f800283a 	ret

01005af4 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
 1005af4:	defffb04 	addi	sp,sp,-20
 1005af8:	dfc00415 	stw	ra,16(sp)
 1005afc:	df000315 	stw	fp,12(sp)
 1005b00:	df000304 	addi	fp,sp,12
 1005b04:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 1005b08:	e0bfff17 	ldw	r2,-4(fp)
 1005b0c:	1000021e 	bne	r2,zero,1005b18 <xTaskNotifyStateClear+0x24>
 1005b10:	d0a74117 	ldw	r2,-25340(gp)
 1005b14:	00000106 	br	1005b1c <xTaskNotifyStateClear+0x28>
 1005b18:	e0bfff17 	ldw	r2,-4(fp)
 1005b1c:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
 1005b20:	10053700 	call	1005370 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 1005b24:	e0bffe17 	ldw	r2,-8(fp)
 1005b28:	10801303 	ldbu	r2,76(r2)
 1005b2c:	10803fcc 	andi	r2,r2,255
 1005b30:	10800098 	cmpnei	r2,r2,2
 1005b34:	1000051e 	bne	r2,zero,1005b4c <xTaskNotifyStateClear+0x58>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1005b38:	e0bffe17 	ldw	r2,-8(fp)
 1005b3c:	10001305 	stb	zero,76(r2)
				xReturn = pdPASS;
 1005b40:	00800044 	movi	r2,1
 1005b44:	e0bffd15 	stw	r2,-12(fp)
 1005b48:	00000106 	br	1005b50 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
 1005b4c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
 1005b50:	10053c40 	call	10053c4 <vTaskExitCritical>

		return xReturn;
 1005b54:	e0bffd17 	ldw	r2,-12(fp)
	}
 1005b58:	e037883a 	mov	sp,fp
 1005b5c:	dfc00117 	ldw	ra,4(sp)
 1005b60:	df000017 	ldw	fp,0(sp)
 1005b64:	dec00204 	addi	sp,sp,8
 1005b68:	f800283a 	ret

01005b6c <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 1005b6c:	defffa04 	addi	sp,sp,-24
 1005b70:	dfc00515 	stw	ra,20(sp)
 1005b74:	df000415 	stw	fp,16(sp)
 1005b78:	df000404 	addi	fp,sp,16
 1005b7c:	e13ffe15 	stw	r4,-8(fp)
 1005b80:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 1005b84:	d0a74617 	ldw	r2,-25320(gp)
 1005b88:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1005b8c:	d0a74117 	ldw	r2,-25340(gp)
 1005b90:	10800104 	addi	r2,r2,4
 1005b94:	1009883a 	mov	r4,r2
 1005b98:	1000b940 	call	1000b94 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 1005b9c:	e0bffe17 	ldw	r2,-8(fp)
 1005ba0:	10bfffd8 	cmpnei	r2,r2,-1
 1005ba4:	1000091e 	bne	r2,zero,1005bcc <prvAddCurrentTaskToDelayedList+0x60>
 1005ba8:	e0bfff17 	ldw	r2,-4(fp)
 1005bac:	10000726 	beq	r2,zero,1005bcc <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 1005bb0:	d0a74117 	ldw	r2,-25340(gp)
 1005bb4:	10800104 	addi	r2,r2,4
 1005bb8:	100b883a 	mov	r5,r2
 1005bbc:	010060f4 	movhi	r4,387
 1005bc0:	2139e104 	addi	r4,r4,-6268
 1005bc4:	1000a300 	call	1000a30 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 1005bc8:	00001c06 	br	1005c3c <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 1005bcc:	e0fffc17 	ldw	r3,-16(fp)
 1005bd0:	e0bffe17 	ldw	r2,-8(fp)
 1005bd4:	1885883a 	add	r2,r3,r2
 1005bd8:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 1005bdc:	d0a74117 	ldw	r2,-25340(gp)
 1005be0:	e0fffd17 	ldw	r3,-12(fp)
 1005be4:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
 1005be8:	e0fffd17 	ldw	r3,-12(fp)
 1005bec:	e0bffc17 	ldw	r2,-16(fp)
 1005bf0:	1880072e 	bgeu	r3,r2,1005c10 <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 1005bf4:	d0e74317 	ldw	r3,-25332(gp)
 1005bf8:	d0a74117 	ldw	r2,-25340(gp)
 1005bfc:	10800104 	addi	r2,r2,4
 1005c00:	100b883a 	mov	r5,r2
 1005c04:	1809883a 	mov	r4,r3
 1005c08:	1000abc0 	call	1000abc <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 1005c0c:	00000b06 	br	1005c3c <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 1005c10:	d0e74217 	ldw	r3,-25336(gp)
 1005c14:	d0a74117 	ldw	r2,-25340(gp)
 1005c18:	10800104 	addi	r2,r2,4
 1005c1c:	100b883a 	mov	r5,r2
 1005c20:	1809883a 	mov	r4,r3
 1005c24:	1000abc0 	call	1000abc <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 1005c28:	d0a74d17 	ldw	r2,-25292(gp)
 1005c2c:	e0fffd17 	ldw	r3,-12(fp)
 1005c30:	1880022e 	bgeu	r3,r2,1005c3c <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
 1005c34:	e0bffd17 	ldw	r2,-12(fp)
 1005c38:	d0a74d15 	stw	r2,-25292(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 1005c3c:	0001883a 	nop
 1005c40:	e037883a 	mov	sp,fp
 1005c44:	dfc00117 	ldw	ra,4(sp)
 1005c48:	df000017 	ldw	fp,0(sp)
 1005c4c:	dec00204 	addi	sp,sp,8
 1005c50:	f800283a 	ret

01005c54 <__metal_mutex_init>:
 * static singleton mutex
 */
#define METAL_MUTEX_DEFINE(m) metal_mutex_t m = METAL_MUTEX_INIT(m)

static inline void __metal_mutex_init(metal_mutex_t *mutex)
{
 1005c54:	defffe04 	addi	sp,sp,-8
 1005c58:	df000115 	stw	fp,4(sp)
 1005c5c:	df000104 	addi	fp,sp,4
 1005c60:	e13fff15 	stw	r4,-4(fp)
	atomic_store(&mutex->v, 0);
 1005c64:	e0bfff17 	ldw	r2,-4(fp)
 1005c68:	10000015 	stw	zero,0(r2)
 1005c6c:	0001b03a 	sync
}
 1005c70:	0001883a 	nop
 1005c74:	e037883a 	mov	sp,fp
 1005c78:	df000017 	ldw	fp,0(sp)
 1005c7c:	dec00104 	addi	sp,sp,4
 1005c80:	f800283a 	ret

01005c84 <__metal_mutex_deinit>:

static inline void __metal_mutex_deinit(metal_mutex_t *mutex)
{
 1005c84:	defffe04 	addi	sp,sp,-8
 1005c88:	df000115 	stw	fp,4(sp)
 1005c8c:	df000104 	addi	fp,sp,4
 1005c90:	e13fff15 	stw	r4,-4(fp)
	(void)mutex;
}
 1005c94:	0001883a 	nop
 1005c98:	e037883a 	mov	sp,fp
 1005c9c:	df000017 	ldw	fp,0(sp)
 1005ca0:	dec00104 	addi	sp,sp,4
 1005ca4:	f800283a 	ret

01005ca8 <__metal_mutex_acquire>:
{
	return 1 - atomic_flag_test_and_set(&mutex->v);
}

static inline void __metal_mutex_acquire(metal_mutex_t *mutex)
{
 1005ca8:	defffb04 	addi	sp,sp,-20
 1005cac:	df000415 	stw	fp,16(sp)
 1005cb0:	df000404 	addi	fp,sp,16
 1005cb4:	e13fff15 	stw	r4,-4(fp)
	while (atomic_flag_test_and_set(&mutex->v)) {
 1005cb8:	0001883a 	nop
 1005cbc:	e0bfff17 	ldw	r2,-4(fp)
 1005cc0:	e0bffc15 	stw	r2,-16(fp)
 1005cc4:	e0bffc17 	ldw	r2,-16(fp)
 1005cc8:	10800017 	ldw	r2,0(r2)
 1005ccc:	e0bffd15 	stw	r2,-12(fp)
 1005cd0:	00800044 	movi	r2,1
 1005cd4:	e0bffe15 	stw	r2,-8(fp)
 1005cd8:	e0bfff17 	ldw	r2,-4(fp)
 1005cdc:	e0fffe17 	ldw	r3,-8(fp)
 1005ce0:	10c00015 	stw	r3,0(r2)
 1005ce4:	e0bffd17 	ldw	r2,-12(fp)
 1005ce8:	103ff41e 	bne	r2,zero,1005cbc <__alt_data_end+0xff005cbc>
		;
	}
}
 1005cec:	0001883a 	nop
 1005cf0:	e037883a 	mov	sp,fp
 1005cf4:	df000017 	ldw	fp,0(sp)
 1005cf8:	dec00104 	addi	sp,sp,4
 1005cfc:	f800283a 	ret

01005d00 <__metal_mutex_release>:

static inline void __metal_mutex_release(metal_mutex_t *mutex)
{
 1005d00:	defffe04 	addi	sp,sp,-8
 1005d04:	df000115 	stw	fp,4(sp)
 1005d08:	df000104 	addi	fp,sp,4
 1005d0c:	e13fff15 	stw	r4,-4(fp)
	atomic_flag_clear(&mutex->v);
 1005d10:	e0bfff17 	ldw	r2,-4(fp)
 1005d14:	0001b03a 	sync
 1005d18:	10000015 	stw	zero,0(r2)
}
 1005d1c:	0001883a 	nop
 1005d20:	e037883a 	mov	sp,fp
 1005d24:	df000017 	ldw	fp,0(sp)
 1005d28:	dec00104 	addi	sp,sp,4
 1005d2c:	f800283a 	ret

01005d30 <metal_mutex_init>:
/**
 * @brief	Initialize a libmetal mutex.
 * @param[in]	mutex	Mutex to initialize.
 */
static inline void metal_mutex_init(metal_mutex_t *mutex)
{
 1005d30:	defffd04 	addi	sp,sp,-12
 1005d34:	dfc00215 	stw	ra,8(sp)
 1005d38:	df000115 	stw	fp,4(sp)
 1005d3c:	df000104 	addi	fp,sp,4
 1005d40:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_init(mutex);
 1005d44:	e13fff17 	ldw	r4,-4(fp)
 1005d48:	1005c540 	call	1005c54 <__metal_mutex_init>
}
 1005d4c:	0001883a 	nop
 1005d50:	e037883a 	mov	sp,fp
 1005d54:	dfc00117 	ldw	ra,4(sp)
 1005d58:	df000017 	ldw	fp,0(sp)
 1005d5c:	dec00204 	addi	sp,sp,8
 1005d60:	f800283a 	ret

01005d64 <metal_mutex_deinit>:
/**
 * @brief	Deinitialize a libmetal mutex.
 * @param[in]	mutex	Mutex to deinitialize.
 */
static inline void metal_mutex_deinit(metal_mutex_t *mutex)
{
 1005d64:	defffd04 	addi	sp,sp,-12
 1005d68:	dfc00215 	stw	ra,8(sp)
 1005d6c:	df000115 	stw	fp,4(sp)
 1005d70:	df000104 	addi	fp,sp,4
 1005d74:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_deinit(mutex);
 1005d78:	e13fff17 	ldw	r4,-4(fp)
 1005d7c:	1005c840 	call	1005c84 <__metal_mutex_deinit>
}
 1005d80:	0001883a 	nop
 1005d84:	e037883a 	mov	sp,fp
 1005d88:	dfc00117 	ldw	ra,4(sp)
 1005d8c:	df000017 	ldw	fp,0(sp)
 1005d90:	dec00204 	addi	sp,sp,8
 1005d94:	f800283a 	ret

01005d98 <metal_mutex_acquire>:
/**
 * @brief	Acquire a mutex 
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
 1005d98:	defffd04 	addi	sp,sp,-12
 1005d9c:	dfc00215 	stw	ra,8(sp)
 1005da0:	df000115 	stw	fp,4(sp)
 1005da4:	df000104 	addi	fp,sp,4
 1005da8:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_acquire(mutex);
 1005dac:	e13fff17 	ldw	r4,-4(fp)
 1005db0:	1005ca80 	call	1005ca8 <__metal_mutex_acquire>
}
 1005db4:	0001883a 	nop
 1005db8:	e037883a 	mov	sp,fp
 1005dbc:	dfc00117 	ldw	ra,4(sp)
 1005dc0:	df000017 	ldw	fp,0(sp)
 1005dc4:	dec00204 	addi	sp,sp,8
 1005dc8:	f800283a 	ret

01005dcc <metal_mutex_release>:
 * @brief	Release a previously acquired mutex.
 * @param[in]	mutex	Mutex to mutex.
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
 1005dcc:	defffd04 	addi	sp,sp,-12
 1005dd0:	dfc00215 	stw	ra,8(sp)
 1005dd4:	df000115 	stw	fp,4(sp)
 1005dd8:	df000104 	addi	fp,sp,4
 1005ddc:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_release(mutex);
 1005de0:	e13fff17 	ldw	r4,-4(fp)
 1005de4:	1005d000 	call	1005d00 <__metal_mutex_release>
}
 1005de8:	0001883a 	nop
 1005dec:	e037883a 	mov	sp,fp
 1005df0:	dfc00117 	ldw	ra,4(sp)
 1005df4:	df000017 	ldw	fp,0(sp)
 1005df8:	dec00204 	addi	sp,sp,8
 1005dfc:	f800283a 	ret

01005e00 <atomic_mutex_init>:
#include <mutex.h>

metal_mutex_t *atomic_mutex;

void atomic_mutex_init(void)
{
 1005e00:	defffe04 	addi	sp,sp,-8
 1005e04:	dfc00115 	stw	ra,4(sp)
 1005e08:	df000015 	stw	fp,0(sp)
 1005e0c:	d839883a 	mov	fp,sp
	metal_mutex_init(atomic_mutex);
 1005e10:	d0a75017 	ldw	r2,-25280(gp)
 1005e14:	1009883a 	mov	r4,r2
 1005e18:	1005d300 	call	1005d30 <metal_mutex_init>
}
 1005e1c:	0001883a 	nop
 1005e20:	e037883a 	mov	sp,fp
 1005e24:	dfc00117 	ldw	ra,4(sp)
 1005e28:	df000017 	ldw	fp,0(sp)
 1005e2c:	dec00204 	addi	sp,sp,8
 1005e30:	f800283a 	ret

01005e34 <atomic_mutex_deinit>:

void atomic_mutex_deinit(void)
{
 1005e34:	defffe04 	addi	sp,sp,-8
 1005e38:	dfc00115 	stw	ra,4(sp)
 1005e3c:	df000015 	stw	fp,0(sp)
 1005e40:	d839883a 	mov	fp,sp
	metal_mutex_release(atomic_mutex);
 1005e44:	d0a75017 	ldw	r2,-25280(gp)
 1005e48:	1009883a 	mov	r4,r2
 1005e4c:	1005dcc0 	call	1005dcc <metal_mutex_release>
}
 1005e50:	0001883a 	nop
 1005e54:	e037883a 	mov	sp,fp
 1005e58:	dfc00117 	ldw	ra,4(sp)
 1005e5c:	df000017 	ldw	fp,0(sp)
 1005e60:	dec00204 	addi	sp,sp,8
 1005e64:	f800283a 	ret

01005e68 <atomic_mutex_acquire>:

void atomic_mutex_acquire(void)
{
 1005e68:	defffe04 	addi	sp,sp,-8
 1005e6c:	dfc00115 	stw	ra,4(sp)
 1005e70:	df000015 	stw	fp,0(sp)
 1005e74:	d839883a 	mov	fp,sp
	metal_mutex_acquire(atomic_mutex);
 1005e78:	d0a75017 	ldw	r2,-25280(gp)
 1005e7c:	1009883a 	mov	r4,r2
 1005e80:	1005d980 	call	1005d98 <metal_mutex_acquire>
}
 1005e84:	0001883a 	nop
 1005e88:	e037883a 	mov	sp,fp
 1005e8c:	dfc00117 	ldw	ra,4(sp)
 1005e90:	df000017 	ldw	fp,0(sp)
 1005e94:	dec00204 	addi	sp,sp,8
 1005e98:	f800283a 	ret

01005e9c <atomic_mutex_release>:

void atomic_mutex_release(void)
{
 1005e9c:	defffe04 	addi	sp,sp,-8
 1005ea0:	dfc00115 	stw	ra,4(sp)
 1005ea4:	df000015 	stw	fp,0(sp)
 1005ea8:	d839883a 	mov	fp,sp
	metal_mutex_deinit(atomic_mutex);
 1005eac:	d0a75017 	ldw	r2,-25280(gp)
 1005eb0:	1009883a 	mov	r4,r2
 1005eb4:	1005d640 	call	1005d64 <metal_mutex_deinit>
}
 1005eb8:	0001883a 	nop
 1005ebc:	e037883a 	mov	sp,fp
 1005ec0:	dfc00117 	ldw	ra,4(sp)
 1005ec4:	df000017 	ldw	fp,0(sp)
 1005ec8:	dec00204 	addi	sp,sp,8
 1005ecc:	f800283a 	ret

01005ed0 <system_metal_logger>:
	return 0;
}
*/
static void system_metal_logger(enum metal_log_level level,
			   const char *format, ...)
{
 1005ed0:	defffb04 	addi	sp,sp,-20
 1005ed4:	df000215 	stw	fp,8(sp)
 1005ed8:	df000204 	addi	fp,sp,8
 1005edc:	e13ffe15 	stw	r4,-8(fp)
 1005ee0:	e17fff15 	stw	r5,-4(fp)
 1005ee4:	e1800115 	stw	r6,4(fp)
 1005ee8:	e1c00215 	stw	r7,8(fp)
	(void)level;
	(void)format;
}
 1005eec:	0001883a 	nop
 1005ef0:	e037883a 	mov	sp,fp
 1005ef4:	df000017 	ldw	fp,0(sp)
 1005ef8:	dec00304 	addi	sp,sp,12
 1005efc:	f800283a 	ret

01005f00 <init_system>:


/* Main hw machinery initialization entry point, called from main()*/
/* return 0 on success */
int init_system(void)
{
 1005f00:	defffb04 	addi	sp,sp,-20
 1005f04:	dfc00415 	stw	ra,16(sp)
 1005f08:	df000315 	stw	fp,12(sp)
 1005f0c:	df000304 	addi	fp,sp,12
	int ret;
	struct metal_init_params metal_param = {
 1005f10:	00804034 	movhi	r2,256
 1005f14:	1097b404 	addi	r2,r2,24272
 1005f18:	e0bffe15 	stw	r2,-8(fp)
 1005f1c:	00800184 	movi	r2,6
 1005f20:	e0bfff15 	stw	r2,-4(fp)
		.log_handler = system_metal_logger,
		.log_level = METAL_LOG_INFO,
	};

	/* Low level abstraction layer for openamp initialization */
	metal_init(&metal_param);
 1005f24:	e0bffe04 	addi	r2,fp,-8
 1005f28:	1009883a 	mov	r4,r2
 1005f2c:	1007f380 	call	1007f38 <metal_init>

	/* configure the global interrupt controller */
	//app_gic_initialize();

	/* Initialize metal Xilinx IRQ controller */
	ret = metal_nios2_irq_init();
 1005f30:	10076e00 	call	10076e0 <metal_nios2_irq_init>
 1005f34:	e0bffd15 	stw	r2,-12(fp)
	if (ret) {
 1005f38:	e0bffd17 	ldw	r2,-12(fp)
 1005f3c:	10000526 	beq	r2,zero,1005f54 <init_system+0x54>
		printf("%s: Nios metal IRQ controller init failed.\r\n",
 1005f40:	014040f4 	movhi	r5,259
 1005f44:	29648504 	addi	r5,r5,-28140
 1005f48:	010040f4 	movhi	r4,259
 1005f4c:	21247904 	addi	r4,r4,-28188
 1005f50:	1015b940 	call	1015b94 <printf>
			__func__);
	}

	return ret;
 1005f54:	e0bffd17 	ldw	r2,-12(fp)
}
 1005f58:	e037883a 	mov	sp,fp
 1005f5c:	dfc00117 	ldw	ra,4(sp)
 1005f60:	df000017 	ldw	fp,0(sp)
 1005f64:	dec00204 	addi	sp,sp,8
 1005f68:	f800283a 	ret

01005f6c <cleanup_system>:

void cleanup_system()
{
 1005f6c:	defffe04 	addi	sp,sp,-8
 1005f70:	dfc00115 	stw	ra,4(sp)
 1005f74:	df000015 	stw	fp,0(sp)
 1005f78:	d839883a 	mov	fp,sp
	metal_finish();
 1005f7c:	1007fe40 	call	1007fe4 <metal_finish>

	/*Xil_DCacheDisable();
	Xil_ICacheDisable();
	Xil_DCacheInvalidate();
	Xil_ICacheInvalidate();*/
}
 1005f80:	0001883a 	nop
 1005f84:	e037883a 	mov	sp,fp
 1005f88:	dfc00117 	ldw	ra,4(sp)
 1005f8c:	df000017 	ldw	fp,0(sp)
 1005f90:	dec00204 	addi	sp,sp,8
 1005f94:	f800283a 	ret

01005f98 <metal_list_add_before>:
	list->next = list->prev = list;
}

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
 1005f98:	defffd04 	addi	sp,sp,-12
 1005f9c:	df000215 	stw	fp,8(sp)
 1005fa0:	df000204 	addi	fp,sp,8
 1005fa4:	e13ffe15 	stw	r4,-8(fp)
 1005fa8:	e17fff15 	stw	r5,-4(fp)
	new_node->prev = node->prev;
 1005fac:	e0bffe17 	ldw	r2,-8(fp)
 1005fb0:	10c00117 	ldw	r3,4(r2)
 1005fb4:	e0bfff17 	ldw	r2,-4(fp)
 1005fb8:	10c00115 	stw	r3,4(r2)
	new_node->next = node;
 1005fbc:	e0bfff17 	ldw	r2,-4(fp)
 1005fc0:	e0fffe17 	ldw	r3,-8(fp)
 1005fc4:	10c00015 	stw	r3,0(r2)
	new_node->next->prev = new_node;
 1005fc8:	e0bfff17 	ldw	r2,-4(fp)
 1005fcc:	10800017 	ldw	r2,0(r2)
 1005fd0:	e0ffff17 	ldw	r3,-4(fp)
 1005fd4:	10c00115 	stw	r3,4(r2)
	new_node->prev->next = new_node;
 1005fd8:	e0bfff17 	ldw	r2,-4(fp)
 1005fdc:	10800117 	ldw	r2,4(r2)
 1005fe0:	e0ffff17 	ldw	r3,-4(fp)
 1005fe4:	10c00015 	stw	r3,0(r2)
}
 1005fe8:	0001883a 	nop
 1005fec:	e037883a 	mov	sp,fp
 1005ff0:	df000017 	ldw	fp,0(sp)
 1005ff4:	dec00104 	addi	sp,sp,4
 1005ff8:	f800283a 	ret

01005ffc <metal_list_add_tail>:
	metal_list_add_after(list, node);
}

static inline void metal_list_add_tail(struct metal_list *list,
				       struct metal_list *node)
{
 1005ffc:	defffc04 	addi	sp,sp,-16
 1006000:	dfc00315 	stw	ra,12(sp)
 1006004:	df000215 	stw	fp,8(sp)
 1006008:	df000204 	addi	fp,sp,8
 100600c:	e13ffe15 	stw	r4,-8(fp)
 1006010:	e17fff15 	stw	r5,-4(fp)
	metal_list_add_before(list, node);
 1006014:	e17fff17 	ldw	r5,-4(fp)
 1006018:	e13ffe17 	ldw	r4,-8(fp)
 100601c:	1005f980 	call	1005f98 <metal_list_add_before>
}
 1006020:	0001883a 	nop
 1006024:	e037883a 	mov	sp,fp
 1006028:	dfc00117 	ldw	ra,4(sp)
 100602c:	df000017 	ldw	fp,0(sp)
 1006030:	dec00204 	addi	sp,sp,8
 1006034:	f800283a 	ret

01006038 <metal_add_test_case>:
	return errstr;
}
#endif

void metal_add_test_case(struct metal_test_case *test_case)
{
 1006038:	defffd04 	addi	sp,sp,-12
 100603c:	dfc00215 	stw	ra,8(sp)
 1006040:	df000115 	stw	fp,4(sp)
 1006044:	df000104 	addi	fp,sp,4
 1006048:	e13fff15 	stw	r4,-4(fp)
	metal_list_add_tail(&test_cases, &test_case->node);
 100604c:	e0bfff17 	ldw	r2,-4(fp)
 1006050:	100b883a 	mov	r5,r2
 1006054:	d1200204 	addi	r4,gp,-32760
 1006058:	1005ffc0 	call	1005ffc <metal_list_add_tail>
}
 100605c:	0001883a 	nop
 1006060:	e037883a 	mov	sp,fp
 1006064:	dfc00117 	ldw	ra,4(sp)
 1006068:	df000017 	ldw	fp,0(sp)
 100606c:	dec00204 	addi	sp,sp,8
 1006070:	f800283a 	ret

01006074 <metal_tests_run>:

int metal_tests_run(struct metal_init_params *params)
{
 1006074:	deffee04 	addi	sp,sp,-72
 1006078:	dfc01115 	stw	ra,68(sp)
 100607c:	df001015 	stw	fp,64(sp)
 1006080:	dcc00f15 	stw	r19,60(sp)
 1006084:	dc800e15 	stw	r18,56(sp)
 1006088:	dc400d15 	stw	r17,52(sp)
 100608c:	dc000c15 	stw	r16,48(sp)
 1006090:	df001004 	addi	fp,sp,64
 1006094:	e13ffb15 	stw	r4,-20(fp)
	struct metal_init_params dparams = METAL_INIT_DEFAULTS;
 1006098:	00804074 	movhi	r2,257
 100609c:	10a2ea04 	addi	r2,r2,-29784
 10060a0:	e0bff915 	stw	r2,-28(fp)
 10060a4:	00800184 	movi	r2,6
 10060a8:	e0bffa15 	stw	r2,-24(fp)
	struct metal_test_case *test_case;
	struct metal_list *node;
	int error, errors = 0;
 10060ac:	e03ff415 	stw	zero,-48(fp)
	const char *dots = "..................................";
 10060b0:	008040f4 	movhi	r2,259
 10060b4:	10a48804 	addi	r2,r2,-28128
 10060b8:	e0bff515 	stw	r2,-44(fp)
	const char *pad;

	if (!params)
 10060bc:	e0bffb17 	ldw	r2,-20(fp)
 10060c0:	1000021e 	bne	r2,zero,10060cc <metal_tests_run+0x58>
		params = &dparams;
 10060c4:	e0bff904 	addi	r2,fp,-28
 10060c8:	e0bffb15 	stw	r2,-20(fp)

	params->log_level = METAL_LOG_DEBUG;
 10060cc:	e0bffb17 	ldw	r2,-20(fp)
 10060d0:	00c001c4 	movi	r3,7
 10060d4:	10c00115 	stw	r3,4(r2)
	error = metal_init(params);
 10060d8:	e13ffb17 	ldw	r4,-20(fp)
 10060dc:	1007f380 	call	1007f38 <metal_init>
 10060e0:	e0bff615 	stw	r2,-40(fp)
	if (error)
 10060e4:	e0bff617 	ldw	r2,-40(fp)
 10060e8:	10000226 	beq	r2,zero,10060f4 <metal_tests_run+0x80>
		return error;
 10060ec:	e0bff617 	ldw	r2,-40(fp)
 10060f0:	00005f06 	br	1006270 <metal_tests_run+0x1fc>

	metal_list_for_each(&test_cases, node) {
 10060f4:	d0a00217 	ldw	r2,-32760(gp)
 10060f8:	e0bff315 	stw	r2,-52(fp)
 10060fc:	00005706 	br	100625c <metal_tests_run+0x1e8>
		test_case = metal_container_of(node, struct metal_test_case,
 1006100:	e0bff317 	ldw	r2,-52(fp)
 1006104:	e0bff715 	stw	r2,-36(fp)
					       node);
		pad = dots + strlen(test_case->name);
 1006108:	e0bff717 	ldw	r2,-36(fp)
 100610c:	10800217 	ldw	r2,8(r2)
 1006110:	1009883a 	mov	r4,r2
 1006114:	10165b40 	call	10165b4 <strlen>
 1006118:	1007883a 	mov	r3,r2
 100611c:	e0bff517 	ldw	r2,-44(fp)
 1006120:	10c5883a 	add	r2,r2,r3
 1006124:	e0bff815 	stw	r2,-32(fp)
		metal_log(METAL_LOG_INFO,"running [%s]\n", test_case->name);
 1006128:	008060f4 	movhi	r2,387
 100612c:	10baf104 	addi	r2,r2,-5180
 1006130:	10800017 	ldw	r2,0(r2)
 1006134:	108001b0 	cmpltui	r2,r2,6
 1006138:	10000e1e 	bne	r2,zero,1006174 <metal_tests_run+0x100>
 100613c:	008060f4 	movhi	r2,387
 1006140:	10baf104 	addi	r2,r2,-5180
 1006144:	10800117 	ldw	r2,4(r2)
 1006148:	10000a26 	beq	r2,zero,1006174 <metal_tests_run+0x100>
 100614c:	008060f4 	movhi	r2,387
 1006150:	10baf104 	addi	r2,r2,-5180
 1006154:	10800117 	ldw	r2,4(r2)
 1006158:	e0fff717 	ldw	r3,-36(fp)
 100615c:	18c00217 	ldw	r3,8(r3)
 1006160:	180d883a 	mov	r6,r3
 1006164:	014040f4 	movhi	r5,259
 1006168:	29649104 	addi	r5,r5,-28092
 100616c:	01000184 	movi	r4,6
 1006170:	103ee83a 	callr	r2
		error = test_case->test();
 1006174:	e0bff717 	ldw	r2,-36(fp)
 1006178:	10800317 	ldw	r2,12(r2)
 100617c:	103ee83a 	callr	r2
 1006180:	e0bff615 	stw	r2,-40(fp)
		metal_log(METAL_LOG_INFO,"result [%s]%s %s%s%s\n",
 1006184:	008060f4 	movhi	r2,387
 1006188:	10baf104 	addi	r2,r2,-5180
 100618c:	10800017 	ldw	r2,0(r2)
 1006190:	108001b0 	cmpltui	r2,r2,6
 1006194:	1000291e 	bne	r2,zero,100623c <metal_tests_run+0x1c8>
 1006198:	008060f4 	movhi	r2,387
 100619c:	10baf104 	addi	r2,r2,-5180
 10061a0:	10800117 	ldw	r2,4(r2)
 10061a4:	10002526 	beq	r2,zero,100623c <metal_tests_run+0x1c8>
 10061a8:	008060f4 	movhi	r2,387
 10061ac:	10baf104 	addi	r2,r2,-5180
 10061b0:	14800117 	ldw	r18,4(r2)
 10061b4:	e0bff717 	ldw	r2,-36(fp)
 10061b8:	14c00217 	ldw	r19,8(r2)
 10061bc:	e0bff617 	ldw	r2,-40(fp)
 10061c0:	10000326 	beq	r2,zero,10061d0 <metal_tests_run+0x15c>
 10061c4:	040040f4 	movhi	r16,259
 10061c8:	84249504 	addi	r16,r16,-28076
 10061cc:	00000206 	br	10061d8 <metal_tests_run+0x164>
 10061d0:	040040f4 	movhi	r16,259
 10061d4:	84249704 	addi	r16,r16,-28068
 10061d8:	e0bff617 	ldw	r2,-40(fp)
 10061dc:	10000326 	beq	r2,zero,10061ec <metal_tests_run+0x178>
 10061e0:	044040f4 	movhi	r17,259
 10061e4:	8c649904 	addi	r17,r17,-28060
 10061e8:	00000206 	br	10061f4 <metal_tests_run+0x180>
 10061ec:	044040f4 	movhi	r17,259
 10061f0:	8c649c04 	addi	r17,r17,-28048
 10061f4:	e0bff617 	ldw	r2,-40(fp)
 10061f8:	10000526 	beq	r2,zero,1006210 <metal_tests_run+0x19c>
 10061fc:	e0bff617 	ldw	r2,-40(fp)
 1006200:	0085c83a 	sub	r2,zero,r2
 1006204:	1009883a 	mov	r4,r2
 1006208:	10165980 	call	1016598 <strerror>
 100620c:	00000206 	br	1006218 <metal_tests_run+0x1a4>
 1006210:	008040f4 	movhi	r2,259
 1006214:	10a49c04 	addi	r2,r2,-28048
 1006218:	d8800215 	stw	r2,8(sp)
 100621c:	dc400115 	stw	r17,4(sp)
 1006220:	dc000015 	stw	r16,0(sp)
 1006224:	e1fff817 	ldw	r7,-32(fp)
 1006228:	980d883a 	mov	r6,r19
 100622c:	014040f4 	movhi	r5,259
 1006230:	29649d04 	addi	r5,r5,-28044
 1006234:	01000184 	movi	r4,6
 1006238:	903ee83a 	callr	r18
		       test_case->name, pad,
		       error ? "fail" : "pass",
		       error ? " - error: " : "",
		       error ? strerror(-error) : "");
		if (error)
 100623c:	e0bff617 	ldw	r2,-40(fp)
 1006240:	10000326 	beq	r2,zero,1006250 <metal_tests_run+0x1dc>
			errors++;
 1006244:	e0bff417 	ldw	r2,-48(fp)
 1006248:	10800044 	addi	r2,r2,1
 100624c:	e0bff415 	stw	r2,-48(fp)
	params->log_level = METAL_LOG_DEBUG;
	error = metal_init(params);
	if (error)
		return error;

	metal_list_for_each(&test_cases, node) {
 1006250:	e0bff317 	ldw	r2,-52(fp)
 1006254:	10800017 	ldw	r2,0(r2)
 1006258:	e0bff315 	stw	r2,-52(fp)
 100625c:	e0fff317 	ldw	r3,-52(fp)
 1006260:	d0a00204 	addi	r2,gp,-32760
 1006264:	18bfa61e 	bne	r3,r2,1006100 <__alt_data_end+0xff006100>
		       error ? strerror(-error) : "");
		if (error)
			errors++;
	}

	metal_finish();
 1006268:	1007fe40 	call	1007fe4 <metal_finish>

	return errors;
 100626c:	e0bff417 	ldw	r2,-48(fp)
}
 1006270:	e6fffc04 	addi	sp,fp,-16
 1006274:	dfc00517 	ldw	ra,20(sp)
 1006278:	df000417 	ldw	fp,16(sp)
 100627c:	dcc00317 	ldw	r19,12(sp)
 1006280:	dc800217 	ldw	r18,8(sp)
 1006284:	dc400117 	ldw	r17,4(sp)
 1006288:	dc000017 	ldw	r16,0(sp)
 100628c:	dec00604 	addi	sp,sp,24
 1006290:	f800283a 	ret

01006294 <metal_list_init>:
 */
#define METAL_DECLARE_LIST(name)			\
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
 1006294:	defffe04 	addi	sp,sp,-8
 1006298:	df000115 	stw	fp,4(sp)
 100629c:	df000104 	addi	fp,sp,4
 10062a0:	e13fff15 	stw	r4,-4(fp)
	list->next = list->prev = list;
 10062a4:	e0bfff17 	ldw	r2,-4(fp)
 10062a8:	e0ffff17 	ldw	r3,-4(fp)
 10062ac:	10c00115 	stw	r3,4(r2)
 10062b0:	e0bfff17 	ldw	r2,-4(fp)
 10062b4:	10c00117 	ldw	r3,4(r2)
 10062b8:	e0bfff17 	ldw	r2,-4(fp)
 10062bc:	10c00015 	stw	r3,0(r2)
}
 10062c0:	0001883a 	nop
 10062c4:	e037883a 	mov	sp,fp
 10062c8:	df000017 	ldw	fp,0(sp)
 10062cc:	dec00104 	addi	sp,sp,4
 10062d0:	f800283a 	ret

010062d4 <metal_list_add_before>:

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
 10062d4:	defffd04 	addi	sp,sp,-12
 10062d8:	df000215 	stw	fp,8(sp)
 10062dc:	df000204 	addi	fp,sp,8
 10062e0:	e13ffe15 	stw	r4,-8(fp)
 10062e4:	e17fff15 	stw	r5,-4(fp)
	new_node->prev = node->prev;
 10062e8:	e0bffe17 	ldw	r2,-8(fp)
 10062ec:	10c00117 	ldw	r3,4(r2)
 10062f0:	e0bfff17 	ldw	r2,-4(fp)
 10062f4:	10c00115 	stw	r3,4(r2)
	new_node->next = node;
 10062f8:	e0bfff17 	ldw	r2,-4(fp)
 10062fc:	e0fffe17 	ldw	r3,-8(fp)
 1006300:	10c00015 	stw	r3,0(r2)
	new_node->next->prev = new_node;
 1006304:	e0bfff17 	ldw	r2,-4(fp)
 1006308:	10800017 	ldw	r2,0(r2)
 100630c:	e0ffff17 	ldw	r3,-4(fp)
 1006310:	10c00115 	stw	r3,4(r2)
	new_node->prev->next = new_node;
 1006314:	e0bfff17 	ldw	r2,-4(fp)
 1006318:	10800117 	ldw	r2,4(r2)
 100631c:	e0ffff17 	ldw	r3,-4(fp)
 1006320:	10c00015 	stw	r3,0(r2)
}
 1006324:	0001883a 	nop
 1006328:	e037883a 	mov	sp,fp
 100632c:	df000017 	ldw	fp,0(sp)
 1006330:	dec00104 	addi	sp,sp,4
 1006334:	f800283a 	ret

01006338 <metal_list_add_tail>:
	metal_list_add_after(list, node);
}

static inline void metal_list_add_tail(struct metal_list *list,
				       struct metal_list *node)
{
 1006338:	defffc04 	addi	sp,sp,-16
 100633c:	dfc00315 	stw	ra,12(sp)
 1006340:	df000215 	stw	fp,8(sp)
 1006344:	df000204 	addi	fp,sp,8
 1006348:	e13ffe15 	stw	r4,-8(fp)
 100634c:	e17fff15 	stw	r5,-4(fp)
	metal_list_add_before(list, node);
 1006350:	e17fff17 	ldw	r5,-4(fp)
 1006354:	e13ffe17 	ldw	r4,-8(fp)
 1006358:	10062d40 	call	10062d4 <metal_list_add_before>
}
 100635c:	0001883a 	nop
 1006360:	e037883a 	mov	sp,fp
 1006364:	dfc00117 	ldw	ra,4(sp)
 1006368:	df000017 	ldw	fp,0(sp)
 100636c:	dec00204 	addi	sp,sp,8
 1006370:	f800283a 	ret

01006374 <metal_list_del>:
{
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
 1006374:	defffe04 	addi	sp,sp,-8
 1006378:	df000115 	stw	fp,4(sp)
 100637c:	df000104 	addi	fp,sp,4
 1006380:	e13fff15 	stw	r4,-4(fp)
	node->next->prev = node->prev;
 1006384:	e0bfff17 	ldw	r2,-4(fp)
 1006388:	10800017 	ldw	r2,0(r2)
 100638c:	e0ffff17 	ldw	r3,-4(fp)
 1006390:	18c00117 	ldw	r3,4(r3)
 1006394:	10c00115 	stw	r3,4(r2)
	node->prev->next = node->next;
 1006398:	e0bfff17 	ldw	r2,-4(fp)
 100639c:	10800117 	ldw	r2,4(r2)
 10063a0:	e0ffff17 	ldw	r3,-4(fp)
 10063a4:	18c00017 	ldw	r3,0(r3)
 10063a8:	10c00015 	stw	r3,0(r2)
	node->next = node->prev = node;
 10063ac:	e0bfff17 	ldw	r2,-4(fp)
 10063b0:	e0ffff17 	ldw	r3,-4(fp)
 10063b4:	10c00115 	stw	r3,4(r2)
 10063b8:	e0bfff17 	ldw	r2,-4(fp)
 10063bc:	10c00117 	ldw	r3,4(r2)
 10063c0:	e0bfff17 	ldw	r2,-4(fp)
 10063c4:	10c00015 	stw	r3,0(r2)
}
 10063c8:	0001883a 	nop
 10063cc:	e037883a 	mov	sp,fp
 10063d0:	df000017 	ldw	fp,0(sp)
 10063d4:	dec00104 	addi	sp,sp,4
 10063d8:	f800283a 	ret

010063dc <__metal_cache_flush>:

extern void metal_machine_cache_flush(void *addr, unsigned int len);
extern void metal_machine_cache_invalidate(void *addr, unsigned int len);

static inline void __metal_cache_flush(void *addr, unsigned int len)
{
 10063dc:	defffc04 	addi	sp,sp,-16
 10063e0:	dfc00315 	stw	ra,12(sp)
 10063e4:	df000215 	stw	fp,8(sp)
 10063e8:	df000204 	addi	fp,sp,8
 10063ec:	e13ffe15 	stw	r4,-8(fp)
 10063f0:	e17fff15 	stw	r5,-4(fp)
	metal_machine_cache_flush(addr, len);
 10063f4:	e17fff17 	ldw	r5,-4(fp)
 10063f8:	e13ffe17 	ldw	r4,-8(fp)
 10063fc:	10077e80 	call	10077e8 <metal_machine_cache_flush>
}
 1006400:	0001883a 	nop
 1006404:	e037883a 	mov	sp,fp
 1006408:	dfc00117 	ldw	ra,4(sp)
 100640c:	df000017 	ldw	fp,0(sp)
 1006410:	dec00204 	addi	sp,sp,8
 1006414:	f800283a 	ret

01006418 <__metal_cache_invalidate>:

static inline void __metal_cache_invalidate(void *addr, unsigned int len)
{
 1006418:	defffc04 	addi	sp,sp,-16
 100641c:	dfc00315 	stw	ra,12(sp)
 1006420:	df000215 	stw	fp,8(sp)
 1006424:	df000204 	addi	fp,sp,8
 1006428:	e13ffe15 	stw	r4,-8(fp)
 100642c:	e17fff15 	stw	r5,-4(fp)
	metal_machine_cache_invalidate(addr, len);
 1006430:	e17fff17 	ldw	r5,-4(fp)
 1006434:	e13ffe17 	ldw	r4,-8(fp)
 1006438:	100783c0 	call	100783c <metal_machine_cache_invalidate>
}
 100643c:	0001883a 	nop
 1006440:	e037883a 	mov	sp,fp
 1006444:	dfc00117 	ldw	ra,4(sp)
 1006448:	df000017 	ldw	fp,0(sp)
 100644c:	dec00204 	addi	sp,sp,8
 1006450:	f800283a 	ret

01006454 <metal_cache_flush>:
 * @param[in] len  length of memory
 *                 If addr is NULL, and len is 0,
 *                 It will flush the whole data cache.
 */
static inline void metal_cache_flush(void *addr, unsigned int len)
{
 1006454:	defffc04 	addi	sp,sp,-16
 1006458:	dfc00315 	stw	ra,12(sp)
 100645c:	df000215 	stw	fp,8(sp)
 1006460:	df000204 	addi	fp,sp,8
 1006464:	e13ffe15 	stw	r4,-8(fp)
 1006468:	e17fff15 	stw	r5,-4(fp)
	__metal_cache_flush(addr, len);
 100646c:	e17fff17 	ldw	r5,-4(fp)
 1006470:	e13ffe17 	ldw	r4,-8(fp)
 1006474:	10063dc0 	call	10063dc <__metal_cache_flush>
}
 1006478:	0001883a 	nop
 100647c:	e037883a 	mov	sp,fp
 1006480:	dfc00117 	ldw	ra,4(sp)
 1006484:	df000017 	ldw	fp,0(sp)
 1006488:	dec00204 	addi	sp,sp,8
 100648c:	f800283a 	ret

01006490 <metal_cache_invalidate>:
 * @param[in] len  length of memory
 *                 If addr is NULL, and len is 0,
 *                 It will invalidate the whole data cache.
 */
static inline void metal_cache_invalidate(void *addr, unsigned int len)
{
 1006490:	defffc04 	addi	sp,sp,-16
 1006494:	dfc00315 	stw	ra,12(sp)
 1006498:	df000215 	stw	fp,8(sp)
 100649c:	df000204 	addi	fp,sp,8
 10064a0:	e13ffe15 	stw	r4,-8(fp)
 10064a4:	e17fff15 	stw	r5,-4(fp)
	__metal_cache_invalidate(addr, len);
 10064a8:	e17fff17 	ldw	r5,-4(fp)
 10064ac:	e13ffe17 	ldw	r4,-8(fp)
 10064b0:	10064180 	call	1006418 <__metal_cache_invalidate>
}
 10064b4:	0001883a 	nop
 10064b8:	e037883a 	mov	sp,fp
 10064bc:	dfc00117 	ldw	ra,4(sp)
 10064c0:	df000017 	ldw	fp,0(sp)
 10064c4:	dec00204 	addi	sp,sp,8
 10064c8:	f800283a 	ret

010064cc <metal_bus_register>:
#include <utilities.h>
#include <dma.h>
#include <cache.h>

int metal_bus_register(struct metal_bus *bus)
{
 10064cc:	defffd04 	addi	sp,sp,-12
 10064d0:	dfc00215 	stw	ra,8(sp)
 10064d4:	df000115 	stw	fp,4(sp)
 10064d8:	df000104 	addi	fp,sp,4
 10064dc:	e13fff15 	stw	r4,-4(fp)
	if (!bus || !bus->name || !strlen(bus->name))
 10064e0:	e0bfff17 	ldw	r2,-4(fp)
 10064e4:	10000a26 	beq	r2,zero,1006510 <metal_bus_register+0x44>
 10064e8:	e0bfff17 	ldw	r2,-4(fp)
 10064ec:	10800017 	ldw	r2,0(r2)
 10064f0:	10000726 	beq	r2,zero,1006510 <metal_bus_register+0x44>
 10064f4:	e0bfff17 	ldw	r2,-4(fp)
 10064f8:	10800017 	ldw	r2,0(r2)
 10064fc:	10800003 	ldbu	r2,0(r2)
 1006500:	10803fcc 	andi	r2,r2,255
 1006504:	1080201c 	xori	r2,r2,128
 1006508:	10bfe004 	addi	r2,r2,-128
 100650c:	1000021e 	bne	r2,zero,1006518 <metal_bus_register+0x4c>
		return -EINVAL;
 1006510:	00bffa84 	movi	r2,-22
 1006514:	00002606 	br	10065b0 <metal_bus_register+0xe4>
	if (metal_bus_find(bus->name, NULL) == 0)
 1006518:	e0bfff17 	ldw	r2,-4(fp)
 100651c:	10800017 	ldw	r2,0(r2)
 1006520:	000b883a 	mov	r5,zero
 1006524:	1009883a 	mov	r4,r2
 1006528:	10066680 	call	1006668 <metal_bus_find>
 100652c:	1000021e 	bne	r2,zero,1006538 <metal_bus_register+0x6c>
		return -EEXIST;
 1006530:	00bffbc4 	movi	r2,-17
 1006534:	00001e06 	br	10065b0 <metal_bus_register+0xe4>
	metal_list_init(&bus->devices);
 1006538:	e0bfff17 	ldw	r2,-4(fp)
 100653c:	10800704 	addi	r2,r2,28
 1006540:	1009883a 	mov	r4,r2
 1006544:	10062940 	call	1006294 <metal_list_init>
	metal_list_add_tail(&_metal.common.bus_list, &bus->node);
 1006548:	e0bfff17 	ldw	r2,-4(fp)
 100654c:	10800904 	addi	r2,r2,36
 1006550:	100b883a 	mov	r5,r2
 1006554:	010060f4 	movhi	r4,387
 1006558:	213af304 	addi	r4,r4,-5172
 100655c:	10063380 	call	1006338 <metal_list_add_tail>
	metal_log(METAL_LOG_DEBUG, "registered %s bus\n", bus->name);
 1006560:	008060f4 	movhi	r2,387
 1006564:	10baf104 	addi	r2,r2,-5180
 1006568:	10800017 	ldw	r2,0(r2)
 100656c:	108001f0 	cmpltui	r2,r2,7
 1006570:	10000e1e 	bne	r2,zero,10065ac <metal_bus_register+0xe0>
 1006574:	008060f4 	movhi	r2,387
 1006578:	10baf104 	addi	r2,r2,-5180
 100657c:	10800117 	ldw	r2,4(r2)
 1006580:	10000a26 	beq	r2,zero,10065ac <metal_bus_register+0xe0>
 1006584:	008060f4 	movhi	r2,387
 1006588:	10baf104 	addi	r2,r2,-5180
 100658c:	10800117 	ldw	r2,4(r2)
 1006590:	e0ffff17 	ldw	r3,-4(fp)
 1006594:	18c00017 	ldw	r3,0(r3)
 1006598:	180d883a 	mov	r6,r3
 100659c:	014040f4 	movhi	r5,259
 10065a0:	2964a304 	addi	r5,r5,-28020
 10065a4:	010001c4 	movi	r4,7
 10065a8:	103ee83a 	callr	r2
	return 0;
 10065ac:	0005883a 	mov	r2,zero
}
 10065b0:	e037883a 	mov	sp,fp
 10065b4:	dfc00117 	ldw	ra,4(sp)
 10065b8:	df000017 	ldw	fp,0(sp)
 10065bc:	dec00204 	addi	sp,sp,8
 10065c0:	f800283a 	ret

010065c4 <metal_bus_unregister>:

int metal_bus_unregister(struct metal_bus *bus)
{
 10065c4:	defffd04 	addi	sp,sp,-12
 10065c8:	dfc00215 	stw	ra,8(sp)
 10065cc:	df000115 	stw	fp,4(sp)
 10065d0:	df000104 	addi	fp,sp,4
 10065d4:	e13fff15 	stw	r4,-4(fp)
	metal_list_del(&bus->node);
 10065d8:	e0bfff17 	ldw	r2,-4(fp)
 10065dc:	10800904 	addi	r2,r2,36
 10065e0:	1009883a 	mov	r4,r2
 10065e4:	10063740 	call	1006374 <metal_list_del>
	if (bus->ops.bus_close)
 10065e8:	e0bfff17 	ldw	r2,-4(fp)
 10065ec:	10800117 	ldw	r2,4(r2)
 10065f0:	10000426 	beq	r2,zero,1006604 <metal_bus_unregister+0x40>
		bus->ops.bus_close(bus);
 10065f4:	e0bfff17 	ldw	r2,-4(fp)
 10065f8:	10800117 	ldw	r2,4(r2)
 10065fc:	e13fff17 	ldw	r4,-4(fp)
 1006600:	103ee83a 	callr	r2
	metal_log(METAL_LOG_DEBUG, "unregistered %s bus\n", bus->name);
 1006604:	008060f4 	movhi	r2,387
 1006608:	10baf104 	addi	r2,r2,-5180
 100660c:	10800017 	ldw	r2,0(r2)
 1006610:	108001f0 	cmpltui	r2,r2,7
 1006614:	10000e1e 	bne	r2,zero,1006650 <metal_bus_unregister+0x8c>
 1006618:	008060f4 	movhi	r2,387
 100661c:	10baf104 	addi	r2,r2,-5180
 1006620:	10800117 	ldw	r2,4(r2)
 1006624:	10000a26 	beq	r2,zero,1006650 <metal_bus_unregister+0x8c>
 1006628:	008060f4 	movhi	r2,387
 100662c:	10baf104 	addi	r2,r2,-5180
 1006630:	10800117 	ldw	r2,4(r2)
 1006634:	e0ffff17 	ldw	r3,-4(fp)
 1006638:	18c00017 	ldw	r3,0(r3)
 100663c:	180d883a 	mov	r6,r3
 1006640:	014040f4 	movhi	r5,259
 1006644:	2964a804 	addi	r5,r5,-28000
 1006648:	010001c4 	movi	r4,7
 100664c:	103ee83a 	callr	r2
	return 0;
 1006650:	0005883a 	mov	r2,zero
}
 1006654:	e037883a 	mov	sp,fp
 1006658:	dfc00117 	ldw	ra,4(sp)
 100665c:	df000017 	ldw	fp,0(sp)
 1006660:	dec00204 	addi	sp,sp,8
 1006664:	f800283a 	ret

01006668 <metal_bus_find>:

int metal_bus_find(const char *name, struct metal_bus **result)
{
 1006668:	defffa04 	addi	sp,sp,-24
 100666c:	dfc00515 	stw	ra,20(sp)
 1006670:	df000415 	stw	fp,16(sp)
 1006674:	df000404 	addi	fp,sp,16
 1006678:	e13ffe15 	stw	r4,-8(fp)
 100667c:	e17fff15 	stw	r5,-4(fp)
	struct metal_list *node;
	struct metal_bus *bus;

	metal_list_for_each(&_metal.common.bus_list, node) {
 1006680:	008060f4 	movhi	r2,387
 1006684:	10baf104 	addi	r2,r2,-5180
 1006688:	10800217 	ldw	r2,8(r2)
 100668c:	e0bffc15 	stw	r2,-16(fp)
 1006690:	00001406 	br	10066e4 <metal_bus_find+0x7c>
		bus = metal_container_of(node, struct metal_bus, node);
 1006694:	e0bffc17 	ldw	r2,-16(fp)
 1006698:	10bff704 	addi	r2,r2,-36
 100669c:	e0bffd15 	stw	r2,-12(fp)
		if (strcmp(bus->name, name) != 0)
 10066a0:	e0bffd17 	ldw	r2,-12(fp)
 10066a4:	10800017 	ldw	r2,0(r2)
 10066a8:	e17ffe17 	ldw	r5,-8(fp)
 10066ac:	1009883a 	mov	r4,r2
 10066b0:	1015e600 	call	1015e60 <strcmp>
 10066b4:	10000426 	beq	r2,zero,10066c8 <metal_bus_find+0x60>
int metal_bus_find(const char *name, struct metal_bus **result)
{
	struct metal_list *node;
	struct metal_bus *bus;

	metal_list_for_each(&_metal.common.bus_list, node) {
 10066b8:	e0bffc17 	ldw	r2,-16(fp)
 10066bc:	10800017 	ldw	r2,0(r2)
 10066c0:	e0bffc15 	stw	r2,-16(fp)
 10066c4:	00000706 	br	10066e4 <metal_bus_find+0x7c>
		bus = metal_container_of(node, struct metal_bus, node);
		if (strcmp(bus->name, name) != 0)
			continue;
		if (result)
 10066c8:	e0bfff17 	ldw	r2,-4(fp)
 10066cc:	10000326 	beq	r2,zero,10066dc <metal_bus_find+0x74>
			*result = bus;
 10066d0:	e0bfff17 	ldw	r2,-4(fp)
 10066d4:	e0fffd17 	ldw	r3,-12(fp)
 10066d8:	10c00015 	stw	r3,0(r2)
		return 0;
 10066dc:	0005883a 	mov	r2,zero
 10066e0:	00000506 	br	10066f8 <metal_bus_find+0x90>
int metal_bus_find(const char *name, struct metal_bus **result)
{
	struct metal_list *node;
	struct metal_bus *bus;

	metal_list_for_each(&_metal.common.bus_list, node) {
 10066e4:	e0fffc17 	ldw	r3,-16(fp)
 10066e8:	008060f4 	movhi	r2,387
 10066ec:	10baf304 	addi	r2,r2,-5172
 10066f0:	18bfe81e 	bne	r3,r2,1006694 <__alt_data_end+0xff006694>
			continue;
		if (result)
			*result = bus;
		return 0;
	}
	return -ENOENT;
 10066f4:	00bfff84 	movi	r2,-2
}
 10066f8:	e037883a 	mov	sp,fp
 10066fc:	dfc00117 	ldw	ra,4(sp)
 1006700:	df000017 	ldw	fp,0(sp)
 1006704:	dec00204 	addi	sp,sp,8
 1006708:	f800283a 	ret

0100670c <metal_device_open>:

int metal_device_open(const char *bus_name, const char *dev_name,
		      struct metal_device **device)
{
 100670c:	defff904 	addi	sp,sp,-28
 1006710:	dfc00615 	stw	ra,24(sp)
 1006714:	df000515 	stw	fp,20(sp)
 1006718:	df000504 	addi	fp,sp,20
 100671c:	e13ffd15 	stw	r4,-12(fp)
 1006720:	e17ffe15 	stw	r5,-8(fp)
 1006724:	e1bfff15 	stw	r6,-4(fp)
	struct metal_bus *bus;
	int error;

	if (!bus_name || !strlen(bus_name) ||
 1006728:	e0bffd17 	ldw	r2,-12(fp)
 100672c:	10001026 	beq	r2,zero,1006770 <metal_device_open+0x64>
 1006730:	e0bffd17 	ldw	r2,-12(fp)
 1006734:	10800003 	ldbu	r2,0(r2)
 1006738:	10803fcc 	andi	r2,r2,255
 100673c:	1080201c 	xori	r2,r2,128
 1006740:	10bfe004 	addi	r2,r2,-128
 1006744:	10000a26 	beq	r2,zero,1006770 <metal_device_open+0x64>
 1006748:	e0bffe17 	ldw	r2,-8(fp)
 100674c:	10000826 	beq	r2,zero,1006770 <metal_device_open+0x64>
	    !dev_name || !strlen(dev_name) ||
 1006750:	e0bffe17 	ldw	r2,-8(fp)
 1006754:	10800003 	ldbu	r2,0(r2)
 1006758:	10803fcc 	andi	r2,r2,255
 100675c:	1080201c 	xori	r2,r2,128
 1006760:	10bfe004 	addi	r2,r2,-128
 1006764:	10000226 	beq	r2,zero,1006770 <metal_device_open+0x64>
 1006768:	e0bfff17 	ldw	r2,-4(fp)
 100676c:	1000021e 	bne	r2,zero,1006778 <metal_device_open+0x6c>
	    !device)
		return -EINVAL;
 1006770:	00bffa84 	movi	r2,-22
 1006774:	00001b06 	br	10067e4 <metal_device_open+0xd8>

	error = metal_bus_find(bus_name, &bus);
 1006778:	e0bffc04 	addi	r2,fp,-16
 100677c:	100b883a 	mov	r5,r2
 1006780:	e13ffd17 	ldw	r4,-12(fp)
 1006784:	10066680 	call	1006668 <metal_bus_find>
 1006788:	e0bffb15 	stw	r2,-20(fp)
	if (error)
 100678c:	e0bffb17 	ldw	r2,-20(fp)
 1006790:	10000226 	beq	r2,zero,100679c <metal_device_open+0x90>
		return error;
 1006794:	e0bffb17 	ldw	r2,-20(fp)
 1006798:	00001206 	br	10067e4 <metal_device_open+0xd8>

	if (!bus->ops.dev_open)
 100679c:	e0bffc17 	ldw	r2,-16(fp)
 10067a0:	10800217 	ldw	r2,8(r2)
 10067a4:	1000021e 	bne	r2,zero,10067b0 <metal_device_open+0xa4>
		return -ENODEV;
 10067a8:	00bffb44 	movi	r2,-19
 10067ac:	00000d06 	br	10067e4 <metal_device_open+0xd8>

	error = (*bus->ops.dev_open)(bus, dev_name, device);
 10067b0:	e0bffc17 	ldw	r2,-16(fp)
 10067b4:	10800217 	ldw	r2,8(r2)
 10067b8:	e0fffc17 	ldw	r3,-16(fp)
 10067bc:	e1bfff17 	ldw	r6,-4(fp)
 10067c0:	e17ffe17 	ldw	r5,-8(fp)
 10067c4:	1809883a 	mov	r4,r3
 10067c8:	103ee83a 	callr	r2
 10067cc:	e0bffb15 	stw	r2,-20(fp)
	if (error)
 10067d0:	e0bffb17 	ldw	r2,-20(fp)
 10067d4:	10000226 	beq	r2,zero,10067e0 <metal_device_open+0xd4>
		return error;
 10067d8:	e0bffb17 	ldw	r2,-20(fp)
 10067dc:	00000106 	br	10067e4 <metal_device_open+0xd8>

	return 0;
 10067e0:	0005883a 	mov	r2,zero
}
 10067e4:	e037883a 	mov	sp,fp
 10067e8:	dfc00117 	ldw	ra,4(sp)
 10067ec:	df000017 	ldw	fp,0(sp)
 10067f0:	dec00204 	addi	sp,sp,8
 10067f4:	f800283a 	ret

010067f8 <metal_device_close>:

void metal_device_close(struct metal_device *device)
{
 10067f8:	defffd04 	addi	sp,sp,-12
 10067fc:	dfc00215 	stw	ra,8(sp)
 1006800:	df000115 	stw	fp,4(sp)
 1006804:	df000104 	addi	fp,sp,4
 1006808:	e13fff15 	stw	r4,-4(fp)
	metal_assert(device && device->bus);
 100680c:	e0bfff17 	ldw	r2,-4(fp)
 1006810:	10000326 	beq	r2,zero,1006820 <metal_device_close+0x28>
 1006814:	e0bfff17 	ldw	r2,-4(fp)
 1006818:	10800117 	ldw	r2,4(r2)
 100681c:	1000081e 	bne	r2,zero,1006840 <metal_device_close+0x48>
 1006820:	01c040f4 	movhi	r7,259
 1006824:	39e4ae04 	addi	r7,r7,-27976
 1006828:	018040f4 	movhi	r6,259
 100682c:	31a4ba04 	addi	r6,r6,-27928
 1006830:	014014c4 	movi	r5,83
 1006834:	010040f4 	movhi	r4,259
 1006838:	2124b404 	addi	r4,r4,-27952
 100683c:	10157a00 	call	10157a0 <__assert_func>
	if (device->bus->ops.dev_close)
 1006840:	e0bfff17 	ldw	r2,-4(fp)
 1006844:	10800117 	ldw	r2,4(r2)
 1006848:	10800317 	ldw	r2,12(r2)
 100684c:	10000826 	beq	r2,zero,1006870 <metal_device_close+0x78>
		device->bus->ops.dev_close(device->bus, device);
 1006850:	e0bfff17 	ldw	r2,-4(fp)
 1006854:	10800117 	ldw	r2,4(r2)
 1006858:	10800317 	ldw	r2,12(r2)
 100685c:	e0ffff17 	ldw	r3,-4(fp)
 1006860:	18c00117 	ldw	r3,4(r3)
 1006864:	e17fff17 	ldw	r5,-4(fp)
 1006868:	1809883a 	mov	r4,r3
 100686c:	103ee83a 	callr	r2
}
 1006870:	0001883a 	nop
 1006874:	e037883a 	mov	sp,fp
 1006878:	dfc00117 	ldw	ra,4(sp)
 100687c:	df000017 	ldw	fp,0(sp)
 1006880:	dec00204 	addi	sp,sp,8
 1006884:	f800283a 	ret

01006888 <metal_register_generic_device>:

int metal_register_generic_device(struct metal_device *device)
{
 1006888:	defffd04 	addi	sp,sp,-12
 100688c:	dfc00215 	stw	ra,8(sp)
 1006890:	df000115 	stw	fp,4(sp)
 1006894:	df000104 	addi	fp,sp,4
 1006898:	e13fff15 	stw	r4,-4(fp)
	if (!device->name || !strlen(device->name) ||
 100689c:	e0bfff17 	ldw	r2,-4(fp)
 10068a0:	10800017 	ldw	r2,0(r2)
 10068a4:	10000b26 	beq	r2,zero,10068d4 <metal_register_generic_device+0x4c>
 10068a8:	e0bfff17 	ldw	r2,-4(fp)
 10068ac:	10800017 	ldw	r2,0(r2)
 10068b0:	10800003 	ldbu	r2,0(r2)
 10068b4:	10803fcc 	andi	r2,r2,255
 10068b8:	1080201c 	xori	r2,r2,128
 10068bc:	10bfe004 	addi	r2,r2,-128
 10068c0:	10000426 	beq	r2,zero,10068d4 <metal_register_generic_device+0x4c>
	    device->num_regions > METAL_MAX_DEVICE_REGIONS)
 10068c4:	e0bfff17 	ldw	r2,-4(fp)
 10068c8:	10800217 	ldw	r2,8(r2)
		device->bus->ops.dev_close(device->bus, device);
}

int metal_register_generic_device(struct metal_device *device)
{
	if (!device->name || !strlen(device->name) ||
 10068cc:	108000b0 	cmpltui	r2,r2,2
 10068d0:	1000021e 	bne	r2,zero,10068dc <metal_register_generic_device+0x54>
	    device->num_regions > METAL_MAX_DEVICE_REGIONS)
		return -EINVAL;
 10068d4:	00bffa84 	movi	r2,-22
 10068d8:	00000b06 	br	1006908 <metal_register_generic_device+0x80>

	device->bus = &metal_generic_bus;
 10068dc:	e0ffff17 	ldw	r3,-4(fp)
 10068e0:	008040f4 	movhi	r2,259
 10068e4:	10ab4e04 	addi	r2,r2,-21192
 10068e8:	18800115 	stw	r2,4(r3)
	metal_list_add_tail(&_metal.common.generic_device_list,
 10068ec:	e0bfff17 	ldw	r2,-4(fp)
 10068f0:	10801104 	addi	r2,r2,68
 10068f4:	100b883a 	mov	r5,r2
 10068f8:	010060f4 	movhi	r4,387
 10068fc:	213af704 	addi	r4,r4,-5156
 1006900:	10063380 	call	1006338 <metal_list_add_tail>
			    &device->node);
	return 0;
 1006904:	0005883a 	mov	r2,zero
}
 1006908:	e037883a 	mov	sp,fp
 100690c:	dfc00117 	ldw	ra,4(sp)
 1006910:	df000017 	ldw	fp,0(sp)
 1006914:	dec00204 	addi	sp,sp,8
 1006918:	f800283a 	ret

0100691c <metal_generic_dev_open>:

int metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,
			   struct metal_device **device)
{
 100691c:	defff904 	addi	sp,sp,-28
 1006920:	dfc00615 	stw	ra,24(sp)
 1006924:	df000515 	stw	fp,20(sp)
 1006928:	df000504 	addi	fp,sp,20
 100692c:	e13ffd15 	stw	r4,-12(fp)
 1006930:	e17ffe15 	stw	r5,-8(fp)
 1006934:	e1bfff15 	stw	r6,-4(fp)
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
 1006938:	008060f4 	movhi	r2,387
 100693c:	10baf104 	addi	r2,r2,-5180
 1006940:	10800617 	ldw	r2,24(r2)
 1006944:	e0bffb15 	stw	r2,-20(fp)
 1006948:	00001306 	br	1006998 <metal_generic_dev_open+0x7c>
		dev = metal_container_of(node, struct metal_device, node);
 100694c:	e0bffb17 	ldw	r2,-20(fp)
 1006950:	10bfef04 	addi	r2,r2,-68
 1006954:	e0bffc15 	stw	r2,-16(fp)
		if (strcmp(dev->name, dev_name) != 0)
 1006958:	e0bffc17 	ldw	r2,-16(fp)
 100695c:	10800017 	ldw	r2,0(r2)
 1006960:	e17ffe17 	ldw	r5,-8(fp)
 1006964:	1009883a 	mov	r4,r2
 1006968:	1015e600 	call	1015e60 <strcmp>
 100696c:	10000426 	beq	r2,zero,1006980 <metal_generic_dev_open+0x64>
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
 1006970:	e0bffb17 	ldw	r2,-20(fp)
 1006974:	10800017 	ldw	r2,0(r2)
 1006978:	e0bffb15 	stw	r2,-20(fp)
 100697c:	00000606 	br	1006998 <metal_generic_dev_open+0x7c>
		dev = metal_container_of(node, struct metal_device, node);
		if (strcmp(dev->name, dev_name) != 0)
			continue;
		*device = dev;
 1006980:	e0bfff17 	ldw	r2,-4(fp)
 1006984:	e0fffc17 	ldw	r3,-16(fp)
 1006988:	10c00015 	stw	r3,0(r2)
		return metal_generic_dev_sys_open(dev);
 100698c:	e13ffc17 	ldw	r4,-16(fp)
 1006990:	1006fe00 	call	1006fe0 <metal_generic_dev_sys_open>
 1006994:	00000506 	br	10069ac <metal_generic_dev_open+0x90>
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
 1006998:	e0fffb17 	ldw	r3,-20(fp)
 100699c:	008060f4 	movhi	r2,387
 10069a0:	10baf704 	addi	r2,r2,-5156
 10069a4:	18bfe91e 	bne	r3,r2,100694c <__alt_data_end+0xff00694c>
			continue;
		*device = dev;
		return metal_generic_dev_sys_open(dev);
	}

	return -ENODEV;
 10069a8:	00bffb44 	movi	r2,-19
}
 10069ac:	e037883a 	mov	sp,fp
 10069b0:	dfc00117 	ldw	ra,4(sp)
 10069b4:	df000017 	ldw	fp,0(sp)
 10069b8:	dec00204 	addi	sp,sp,8
 10069bc:	f800283a 	ret

010069c0 <metal_generic_dev_dma_map>:
			     struct metal_device *device,
			     uint32_t dir,
			     struct metal_sg *sg_in,
			     int nents_in,
			     struct metal_sg *sg_out)
{
 10069c0:	defff904 	addi	sp,sp,-28
 10069c4:	dfc00615 	stw	ra,24(sp)
 10069c8:	df000515 	stw	fp,20(sp)
 10069cc:	df000504 	addi	fp,sp,20
 10069d0:	e13ffc15 	stw	r4,-16(fp)
 10069d4:	e17ffd15 	stw	r5,-12(fp)
 10069d8:	e1bffe15 	stw	r6,-8(fp)
 10069dc:	e1ffff15 	stw	r7,-4(fp)
	int i;
	(void)bus;
	(void)device;

	if (sg_out != sg_in)
 10069e0:	e0c00317 	ldw	r3,12(fp)
 10069e4:	e0bfff17 	ldw	r2,-4(fp)
 10069e8:	18800626 	beq	r3,r2,1006a04 <metal_generic_dev_dma_map+0x44>
		memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));
 10069ec:	e0800217 	ldw	r2,8(fp)
 10069f0:	10800324 	muli	r2,r2,12
 10069f4:	100d883a 	mov	r6,r2
 10069f8:	e17fff17 	ldw	r5,-4(fp)
 10069fc:	e1000317 	ldw	r4,12(fp)
 1006a00:	10158f40 	call	10158f4 <memcpy>
	for (i = 0; i < nents_in; i++) {
 1006a04:	e03ffb15 	stw	zero,-20(fp)
 1006a08:	00001e06 	br	1006a84 <metal_generic_dev_dma_map+0xc4>
		if (dir == METAL_DMA_DEV_W) {
 1006a0c:	e0bffe17 	ldw	r2,-8(fp)
 1006a10:	10800098 	cmpnei	r2,r2,2
 1006a14:	10000c1e 	bne	r2,zero,1006a48 <metal_generic_dev_dma_map+0x88>
			metal_cache_flush(sg_out[i].virt, sg_out[i].len);
 1006a18:	e0bffb17 	ldw	r2,-20(fp)
 1006a1c:	10800324 	muli	r2,r2,12
 1006a20:	e0c00317 	ldw	r3,12(fp)
 1006a24:	1885883a 	add	r2,r3,r2
 1006a28:	11000017 	ldw	r4,0(r2)
 1006a2c:	e0bffb17 	ldw	r2,-20(fp)
 1006a30:	10800324 	muli	r2,r2,12
 1006a34:	e0c00317 	ldw	r3,12(fp)
 1006a38:	1885883a 	add	r2,r3,r2
 1006a3c:	10800217 	ldw	r2,8(r2)
 1006a40:	100b883a 	mov	r5,r2
 1006a44:	10064540 	call	1006454 <metal_cache_flush>
		}
		metal_cache_invalidate(sg_out[i].virt, sg_out[i].len);
 1006a48:	e0bffb17 	ldw	r2,-20(fp)
 1006a4c:	10800324 	muli	r2,r2,12
 1006a50:	e0c00317 	ldw	r3,12(fp)
 1006a54:	1885883a 	add	r2,r3,r2
 1006a58:	11000017 	ldw	r4,0(r2)
 1006a5c:	e0bffb17 	ldw	r2,-20(fp)
 1006a60:	10800324 	muli	r2,r2,12
 1006a64:	e0c00317 	ldw	r3,12(fp)
 1006a68:	1885883a 	add	r2,r3,r2
 1006a6c:	10800217 	ldw	r2,8(r2)
 1006a70:	100b883a 	mov	r5,r2
 1006a74:	10064900 	call	1006490 <metal_cache_invalidate>
	(void)bus;
	(void)device;

	if (sg_out != sg_in)
		memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));
	for (i = 0; i < nents_in; i++) {
 1006a78:	e0bffb17 	ldw	r2,-20(fp)
 1006a7c:	10800044 	addi	r2,r2,1
 1006a80:	e0bffb15 	stw	r2,-20(fp)
 1006a84:	e0fffb17 	ldw	r3,-20(fp)
 1006a88:	e0800217 	ldw	r2,8(fp)
 1006a8c:	18bfdf16 	blt	r3,r2,1006a0c <__alt_data_end+0xff006a0c>
			metal_cache_flush(sg_out[i].virt, sg_out[i].len);
		}
		metal_cache_invalidate(sg_out[i].virt, sg_out[i].len);
	}

	return nents_in;
 1006a90:	e0800217 	ldw	r2,8(fp)
}
 1006a94:	e037883a 	mov	sp,fp
 1006a98:	dfc00117 	ldw	ra,4(sp)
 1006a9c:	df000017 	ldw	fp,0(sp)
 1006aa0:	dec00204 	addi	sp,sp,8
 1006aa4:	f800283a 	ret

01006aa8 <metal_generic_dev_dma_unmap>:
void metal_generic_dev_dma_unmap(struct metal_bus *bus,
				 struct metal_device *device,
				 uint32_t dir,
				 struct metal_sg *sg,
				 int nents)
{
 1006aa8:	defff904 	addi	sp,sp,-28
 1006aac:	dfc00615 	stw	ra,24(sp)
 1006ab0:	df000515 	stw	fp,20(sp)
 1006ab4:	df000504 	addi	fp,sp,20
 1006ab8:	e13ffc15 	stw	r4,-16(fp)
 1006abc:	e17ffd15 	stw	r5,-12(fp)
 1006ac0:	e1bffe15 	stw	r6,-8(fp)
 1006ac4:	e1ffff15 	stw	r7,-4(fp)
	int i;
	(void)bus;
	(void)device;
	(void)dir;

	for (i = 0; i < nents; i++) {
 1006ac8:	e03ffb15 	stw	zero,-20(fp)
 1006acc:	00000f06 	br	1006b0c <metal_generic_dev_dma_unmap+0x64>
		metal_cache_invalidate(sg[i].virt, sg[i].len);
 1006ad0:	e0bffb17 	ldw	r2,-20(fp)
 1006ad4:	10800324 	muli	r2,r2,12
 1006ad8:	e0ffff17 	ldw	r3,-4(fp)
 1006adc:	1885883a 	add	r2,r3,r2
 1006ae0:	11000017 	ldw	r4,0(r2)
 1006ae4:	e0bffb17 	ldw	r2,-20(fp)
 1006ae8:	10800324 	muli	r2,r2,12
 1006aec:	e0ffff17 	ldw	r3,-4(fp)
 1006af0:	1885883a 	add	r2,r3,r2
 1006af4:	10800217 	ldw	r2,8(r2)
 1006af8:	100b883a 	mov	r5,r2
 1006afc:	10064900 	call	1006490 <metal_cache_invalidate>
	int i;
	(void)bus;
	(void)device;
	(void)dir;

	for (i = 0; i < nents; i++) {
 1006b00:	e0bffb17 	ldw	r2,-20(fp)
 1006b04:	10800044 	addi	r2,r2,1
 1006b08:	e0bffb15 	stw	r2,-20(fp)
 1006b0c:	e0fffb17 	ldw	r3,-20(fp)
 1006b10:	e0800217 	ldw	r2,8(fp)
 1006b14:	18bfee16 	blt	r3,r2,1006ad0 <__alt_data_end+0xff006ad0>
		metal_cache_invalidate(sg[i].virt, sg[i].len);
	}
}
 1006b18:	0001883a 	nop
 1006b1c:	e037883a 	mov	sp,fp
 1006b20:	dfc00117 	ldw	ra,4(sp)
 1006b24:	df000017 	ldw	fp,0(sp)
 1006b28:	dec00204 	addi	sp,sp,8
 1006b2c:	f800283a 	ret

01006b30 <metal_dma_map>:
int metal_dma_map(struct metal_device *dev,
		  uint32_t dir,
		  struct metal_sg *sg_in,
		  int nents_in,
		  struct metal_sg *sg_out)
{
 1006b30:	defff704 	addi	sp,sp,-36
 1006b34:	dfc00815 	stw	ra,32(sp)
 1006b38:	df000715 	stw	fp,28(sp)
 1006b3c:	df000704 	addi	fp,sp,28
 1006b40:	e13ffc15 	stw	r4,-16(fp)
 1006b44:	e17ffd15 	stw	r5,-12(fp)
 1006b48:	e1bffe15 	stw	r6,-8(fp)
 1006b4c:	e1ffff15 	stw	r7,-4(fp)
	int nents_out;

	if (!dev || !sg_in || !sg_out)
 1006b50:	e0bffc17 	ldw	r2,-16(fp)
 1006b54:	10000426 	beq	r2,zero,1006b68 <metal_dma_map+0x38>
 1006b58:	e0bffe17 	ldw	r2,-8(fp)
 1006b5c:	10000226 	beq	r2,zero,1006b68 <metal_dma_map+0x38>
 1006b60:	e0800217 	ldw	r2,8(fp)
 1006b64:	1000021e 	bne	r2,zero,1006b70 <metal_dma_map+0x40>
		return -EINVAL;
 1006b68:	00bffa84 	movi	r2,-22
 1006b6c:	00001b06 	br	1006bdc <metal_dma_map+0xac>
	if (!dev->bus->ops.dev_dma_map)
 1006b70:	e0bffc17 	ldw	r2,-16(fp)
 1006b74:	10800117 	ldw	r2,4(r2)
 1006b78:	10800517 	ldw	r2,20(r2)
 1006b7c:	1000021e 	bne	r2,zero,1006b88 <metal_dma_map+0x58>
		return -ENODEV;
 1006b80:	00bffb44 	movi	r2,-19
 1006b84:	00001506 	br	1006bdc <metal_dma_map+0xac>

	/* memory barrier */
	if (dir == METAL_DMA_DEV_R)
 1006b88:	e0bffd17 	ldw	r2,-12(fp)
 1006b8c:	10800058 	cmpnei	r2,r2,1
 1006b90:	1000021e 	bne	r2,zero,1006b9c <metal_dma_map+0x6c>
		/* If it is device read, apply memory write fence. */
		atomic_thread_fence(memory_order_release);
 1006b94:	0001b03a 	sync
 1006b98:	00000106 	br	1006ba0 <metal_dma_map+0x70>
	else
		/* If it is device write or device r/w,
		   apply memory r/w fence. */
		atomic_thread_fence(memory_order_acq_rel);
 1006b9c:	0001b03a 	sync
	nents_out = dev->bus->ops.dev_dma_map(dev->bus,
 1006ba0:	e0bffc17 	ldw	r2,-16(fp)
 1006ba4:	10800117 	ldw	r2,4(r2)
 1006ba8:	10800517 	ldw	r2,20(r2)
 1006bac:	e0fffc17 	ldw	r3,-16(fp)
 1006bb0:	19000117 	ldw	r4,4(r3)
 1006bb4:	e0c00217 	ldw	r3,8(fp)
 1006bb8:	d8c00115 	stw	r3,4(sp)
 1006bbc:	e0ffff17 	ldw	r3,-4(fp)
 1006bc0:	d8c00015 	stw	r3,0(sp)
 1006bc4:	e1fffe17 	ldw	r7,-8(fp)
 1006bc8:	e1bffd17 	ldw	r6,-12(fp)
 1006bcc:	e17ffc17 	ldw	r5,-16(fp)
 1006bd0:	103ee83a 	callr	r2
 1006bd4:	e0bffb15 	stw	r2,-20(fp)
			dev, dir, sg_in, nents_in, sg_out);
	return nents_out;
 1006bd8:	e0bffb17 	ldw	r2,-20(fp)
}
 1006bdc:	e037883a 	mov	sp,fp
 1006be0:	dfc00117 	ldw	ra,4(sp)
 1006be4:	df000017 	ldw	fp,0(sp)
 1006be8:	dec00204 	addi	sp,sp,8
 1006bec:	f800283a 	ret

01006bf0 <metal_dma_unmap>:

void metal_dma_unmap(struct metal_device *dev,
		  uint32_t dir,
		  struct metal_sg *sg,
		  int nents)
{
 1006bf0:	defff904 	addi	sp,sp,-28
 1006bf4:	dfc00615 	stw	ra,24(sp)
 1006bf8:	df000515 	stw	fp,20(sp)
 1006bfc:	df000504 	addi	fp,sp,20
 1006c00:	e13ffc15 	stw	r4,-16(fp)
 1006c04:	e17ffd15 	stw	r5,-12(fp)
 1006c08:	e1bffe15 	stw	r6,-8(fp)
 1006c0c:	e1ffff15 	stw	r7,-4(fp)
	/* memory barrier */
	if (dir == METAL_DMA_DEV_R)
 1006c10:	e0bffd17 	ldw	r2,-12(fp)
 1006c14:	10800058 	cmpnei	r2,r2,1
 1006c18:	1000021e 	bne	r2,zero,1006c24 <metal_dma_unmap+0x34>
		/* If it is device read, apply memory write fence. */
		atomic_thread_fence(memory_order_release);
 1006c1c:	0001b03a 	sync
 1006c20:	00000106 	br	1006c28 <metal_dma_unmap+0x38>
	else
		/* If it is device write or device r/w,
		   apply memory r/w fence. */
		atomic_thread_fence(memory_order_acq_rel);
 1006c24:	0001b03a 	sync

	if (!dev || !dev->bus->ops.dev_dma_unmap || !sg)
 1006c28:	e0bffc17 	ldw	r2,-16(fp)
 1006c2c:	10001226 	beq	r2,zero,1006c78 <metal_dma_unmap+0x88>
 1006c30:	e0bffc17 	ldw	r2,-16(fp)
 1006c34:	10800117 	ldw	r2,4(r2)
 1006c38:	10800617 	ldw	r2,24(r2)
 1006c3c:	10000e26 	beq	r2,zero,1006c78 <metal_dma_unmap+0x88>
 1006c40:	e0bffe17 	ldw	r2,-8(fp)
 1006c44:	10000c26 	beq	r2,zero,1006c78 <metal_dma_unmap+0x88>
		return;
	dev->bus->ops.dev_dma_unmap(dev->bus,
 1006c48:	e0bffc17 	ldw	r2,-16(fp)
 1006c4c:	10800117 	ldw	r2,4(r2)
 1006c50:	10800617 	ldw	r2,24(r2)
 1006c54:	e0fffc17 	ldw	r3,-16(fp)
 1006c58:	19000117 	ldw	r4,4(r3)
 1006c5c:	e0ffff17 	ldw	r3,-4(fp)
 1006c60:	d8c00015 	stw	r3,0(sp)
 1006c64:	e1fffe17 	ldw	r7,-8(fp)
 1006c68:	e1bffd17 	ldw	r6,-12(fp)
 1006c6c:	e17ffc17 	ldw	r5,-16(fp)
 1006c70:	103ee83a 	callr	r2
 1006c74:	00000106 	br	1006c7c <metal_dma_unmap+0x8c>
		/* If it is device write or device r/w,
		   apply memory r/w fence. */
		atomic_thread_fence(memory_order_acq_rel);

	if (!dev || !dev->bus->ops.dev_dma_unmap || !sg)
		return;
 1006c78:	0001883a 	nop
	dev->bus->ops.dev_dma_unmap(dev->bus,
			dev, dir, sg, nents);
}
 1006c7c:	e037883a 	mov	sp,fp
 1006c80:	dfc00117 	ldw	ra,4(sp)
 1006c84:	df000017 	ldw	fp,0(sp)
 1006c88:	dec00204 	addi	sp,sp,8
 1006c8c:	f800283a 	ret

01006c90 <metal_allocate_memory>:
#ifdef __cplusplus
extern "C" {
#endif

static inline void *metal_allocate_memory(unsigned int size)
{
 1006c90:	defffd04 	addi	sp,sp,-12
 1006c94:	dfc00215 	stw	ra,8(sp)
 1006c98:	df000115 	stw	fp,4(sp)
 1006c9c:	df000104 	addi	fp,sp,4
 1006ca0:	e13fff15 	stw	r4,-4(fp)
	return (pvPortMalloc(size));
 1006ca4:	e13fff17 	ldw	r4,-4(fp)
 1006ca8:	10010b00 	call	10010b0 <pvPortMalloc>
}
 1006cac:	e037883a 	mov	sp,fp
 1006cb0:	dfc00117 	ldw	ra,4(sp)
 1006cb4:	df000017 	ldw	fp,0(sp)
 1006cb8:	dec00204 	addi	sp,sp,8
 1006cbc:	f800283a 	ret

01006cc0 <metal_free_memory>:

static inline void metal_free_memory(void *ptr)
{
 1006cc0:	defffd04 	addi	sp,sp,-12
 1006cc4:	dfc00215 	stw	ra,8(sp)
 1006cc8:	df000115 	stw	fp,4(sp)
 1006ccc:	df000104 	addi	fp,sp,4
 1006cd0:	e13fff15 	stw	r4,-4(fp)
	vPortFree(ptr);
 1006cd4:	e13fff17 	ldw	r4,-4(fp)
 1006cd8:	10012840 	call	1001284 <vPortFree>
}
 1006cdc:	0001883a 	nop
 1006ce0:	e037883a 	mov	sp,fp
 1006ce4:	dfc00117 	ldw	ra,4(sp)
 1006ce8:	df000017 	ldw	fp,0(sp)
 1006cec:	dec00204 	addi	sp,sp,8
 1006cf0:	f800283a 	ret

01006cf4 <alloc_thread>:
#include <sys.h>

static const int test_count = 10;

static void *alloc_thread(void *arg)
{
 1006cf4:	defffa04 	addi	sp,sp,-24
 1006cf8:	dfc00515 	stw	ra,20(sp)
 1006cfc:	df000415 	stw	fp,16(sp)
 1006d00:	df000404 	addi	fp,sp,16
 1006d04:	e13fff15 	stw	r4,-4(fp)
	int i;
	void *ptr;
	void *rv = 0;
 1006d08:	e03ffd15 	stw	zero,-12(fp)

	(void)arg;

	for (i = 0; i < test_count; i++) {
 1006d0c:	e03ffc15 	stw	zero,-16(fp)
 1006d10:	00001d06 	br	1006d88 <alloc_thread+0x94>
		/* expecting the implementation to be thread safe */
		ptr = metal_allocate_memory(256 /*10*i*/);
 1006d14:	01004004 	movi	r4,256
 1006d18:	1006c900 	call	1006c90 <metal_allocate_memory>
 1006d1c:	e0bffe15 	stw	r2,-8(fp)
		if (!ptr) {
 1006d20:	e0bffe17 	ldw	r2,-8(fp)
 1006d24:	1000131e 	bne	r2,zero,1006d74 <alloc_thread+0x80>
			metal_log(METAL_LOG_DEBUG, "failed to allocate memmory\n");
 1006d28:	008060f4 	movhi	r2,387
 1006d2c:	10baf104 	addi	r2,r2,-5180
 1006d30:	10800017 	ldw	r2,0(r2)
 1006d34:	108001f0 	cmpltui	r2,r2,7
 1006d38:	10000b1e 	bne	r2,zero,1006d68 <alloc_thread+0x74>
 1006d3c:	008060f4 	movhi	r2,387
 1006d40:	10baf104 	addi	r2,r2,-5180
 1006d44:	10800117 	ldw	r2,4(r2)
 1006d48:	10000726 	beq	r2,zero,1006d68 <alloc_thread+0x74>
 1006d4c:	008060f4 	movhi	r2,387
 1006d50:	10baf104 	addi	r2,r2,-5180
 1006d54:	10800117 	ldw	r2,4(r2)
 1006d58:	014040f4 	movhi	r5,259
 1006d5c:	2964bf04 	addi	r5,r5,-27908
 1006d60:	010001c4 	movi	r4,7
 1006d64:	103ee83a 	callr	r2
		        rv = (void *)-ENOMEM;
 1006d68:	00bffd04 	movi	r2,-12
 1006d6c:	e0bffd15 	stw	r2,-12(fp)
			break;
 1006d70:	00000806 	br	1006d94 <alloc_thread+0xa0>
		}

		metal_free_memory(ptr);
 1006d74:	e13ffe17 	ldw	r4,-8(fp)
 1006d78:	1006cc00 	call	1006cc0 <metal_free_memory>
	void *ptr;
	void *rv = 0;

	(void)arg;

	for (i = 0; i < test_count; i++) {
 1006d7c:	e0bffc17 	ldw	r2,-16(fp)
 1006d80:	10800044 	addi	r2,r2,1
 1006d84:	e0bffc15 	stw	r2,-16(fp)
 1006d88:	00800284 	movi	r2,10
 1006d8c:	e0fffc17 	ldw	r3,-16(fp)
 1006d90:	18bfe016 	blt	r3,r2,1006d14 <__alt_data_end+0xff006d14>
		}

		metal_free_memory(ptr);
	}

	return rv;
 1006d94:	e0bffd17 	ldw	r2,-12(fp)
}
 1006d98:	e037883a 	mov	sp,fp
 1006d9c:	dfc00117 	ldw	ra,4(sp)
 1006da0:	df000017 	ldw	fp,0(sp)
 1006da4:	dec00204 	addi	sp,sp,8
 1006da8:	f800283a 	ret

01006dac <alloc>:

static int alloc(void)
{
 1006dac:	defffc04 	addi	sp,sp,-16
 1006db0:	dfc00315 	stw	ra,12(sp)
 1006db4:	df000215 	stw	fp,8(sp)
 1006db8:	df000204 	addi	fp,sp,8
	const int threads = 10;
 1006dbc:	00800284 	movi	r2,10
 1006dc0:	e0bffe15 	stw	r2,-8(fp)
	int rc;

	rc =  metal_run(threads, alloc_thread, NULL);
 1006dc4:	000d883a 	mov	r6,zero
 1006dc8:	01404034 	movhi	r5,256
 1006dcc:	295b3d04 	addi	r5,r5,27892
 1006dd0:	e13ffe17 	ldw	r4,-8(fp)
 1006dd4:	1007ab40 	call	1007ab4 <metal_run>
 1006dd8:	e0bfff15 	stw	r2,-4(fp)

	return rc;
 1006ddc:	e0bfff17 	ldw	r2,-4(fp)
}
 1006de0:	e037883a 	mov	sp,fp
 1006de4:	dfc00117 	ldw	ra,4(sp)
 1006de8:	df000017 	ldw	fp,0(sp)
 1006dec:	dec00204 	addi	sp,sp,8
 1006df0:	f800283a 	ret

01006df4 <metal_test_alloc>:
METAL_ADD_TEST(alloc);
 1006df4:	defffe04 	addi	sp,sp,-8
 1006df8:	dfc00115 	stw	ra,4(sp)
 1006dfc:	df000015 	stw	fp,0(sp)
 1006e00:	d839883a 	mov	fp,sp
 1006e04:	010040f4 	movhi	r4,259
 1006e08:	212b5904 	addi	r4,r4,-21148
 1006e0c:	10060380 	call	1006038 <metal_add_test_case>
 1006e10:	0001883a 	nop
 1006e14:	e037883a 	mov	sp,fp
 1006e18:	dfc00117 	ldw	ra,4(sp)
 1006e1c:	df000017 	ldw	fp,0(sp)
 1006e20:	dec00204 	addi	sp,sp,8
 1006e24:	f800283a 	ret

01006e28 <atomic_thread>:
#include "../atomic_mutex.h"

static const int atomic_test_count = 1000;

static void *atomic_thread(void *arg)
{
 1006e28:	defff804 	addi	sp,sp,-32
 1006e2c:	dfc00715 	stw	ra,28(sp)
 1006e30:	df000615 	stw	fp,24(sp)
 1006e34:	df000604 	addi	fp,sp,24
 1006e38:	e13fff15 	stw	r4,-4(fp)
	atomic_int *c = arg;
 1006e3c:	e0bfff17 	ldw	r2,-4(fp)
 1006e40:	e0bffb15 	stw	r2,-20(fp)
	int i;

	for (i = 0; i < atomic_test_count; i++) {
 1006e44:	e03ffa15 	stw	zero,-24(fp)
 1006e48:	00001106 	br	1006e90 <atomic_thread+0x68>
		atomic_mutex_acquire();
 1006e4c:	1005e680 	call	1005e68 <atomic_mutex_acquire>
		atomic_fetch_add(c, 1);
 1006e50:	e0bffb17 	ldw	r2,-20(fp)
 1006e54:	e0bffc15 	stw	r2,-16(fp)
 1006e58:	e0bffc17 	ldw	r2,-16(fp)
 1006e5c:	10800017 	ldw	r2,0(r2)
 1006e60:	e0bffd15 	stw	r2,-12(fp)
 1006e64:	00800044 	movi	r2,1
 1006e68:	e0bffe15 	stw	r2,-8(fp)
 1006e6c:	e0fffd17 	ldw	r3,-12(fp)
 1006e70:	e0bffe17 	ldw	r2,-8(fp)
 1006e74:	1887883a 	add	r3,r3,r2
 1006e78:	e0bffb17 	ldw	r2,-20(fp)
 1006e7c:	10c00015 	stw	r3,0(r2)
		atomic_mutex_release();
 1006e80:	1005e9c0 	call	1005e9c <atomic_mutex_release>
static void *atomic_thread(void *arg)
{
	atomic_int *c = arg;
	int i;

	for (i = 0; i < atomic_test_count; i++) {
 1006e84:	e0bffa17 	ldw	r2,-24(fp)
 1006e88:	10800044 	addi	r2,r2,1
 1006e8c:	e0bffa15 	stw	r2,-24(fp)
 1006e90:	0080fa04 	movi	r2,1000
 1006e94:	e0fffa17 	ldw	r3,-24(fp)
 1006e98:	18bfec16 	blt	r3,r2,1006e4c <__alt_data_end+0xff006e4c>
		atomic_mutex_acquire();
		atomic_fetch_add(c, 1);
		atomic_mutex_release();
	}

	return NULL;
 1006e9c:	0005883a 	mov	r2,zero
}
 1006ea0:	e037883a 	mov	sp,fp
 1006ea4:	dfc00117 	ldw	ra,4(sp)
 1006ea8:	df000017 	ldw	fp,0(sp)
 1006eac:	dec00204 	addi	sp,sp,8
 1006eb0:	f800283a 	ret

01006eb4 <atomic>:

static int atomic(void)
{
 1006eb4:	defffa04 	addi	sp,sp,-24
 1006eb8:	dfc00515 	stw	ra,20(sp)
 1006ebc:	df000415 	stw	fp,16(sp)
 1006ec0:	df000404 	addi	fp,sp,16
	const int threads = 10;
 1006ec4:	00800284 	movi	r2,10
 1006ec8:	e0bffd15 	stw	r2,-12(fp)
	atomic_int counter = ATOMIC_VAR_INIT(0);
 1006ecc:	e03fff15 	stw	zero,-4(fp)
	int value, error;

	error = metal_run(threads, atomic_thread, &counter);
 1006ed0:	e0bfff04 	addi	r2,fp,-4
 1006ed4:	100d883a 	mov	r6,r2
 1006ed8:	01404034 	movhi	r5,256
 1006edc:	295b8a04 	addi	r5,r5,28200
 1006ee0:	e13ffd17 	ldw	r4,-12(fp)
 1006ee4:	1007ab40 	call	1007ab4 <metal_run>
 1006ee8:	e0bffc15 	stw	r2,-16(fp)
	if (!error) {
 1006eec:	e0bffc17 	ldw	r2,-16(fp)
 1006ef0:	10001e1e 	bne	r2,zero,1006f6c <atomic+0xb8>
		value = atomic_load(&counter);
 1006ef4:	0001b03a 	sync
 1006ef8:	e0bfff17 	ldw	r2,-4(fp)
 1006efc:	e0bffe15 	stw	r2,-8(fp)
		value -= atomic_test_count * threads;
 1006f00:	00c0fa04 	movi	r3,1000
 1006f04:	e0bffd17 	ldw	r2,-12(fp)
 1006f08:	1885383a 	mul	r2,r3,r2
 1006f0c:	e0fffe17 	ldw	r3,-8(fp)
 1006f10:	1885c83a 	sub	r2,r3,r2
 1006f14:	e0bffe15 	stw	r2,-8(fp)
		if (value) {
 1006f18:	e0bffe17 	ldw	r2,-8(fp)
 1006f1c:	10001326 	beq	r2,zero,1006f6c <atomic+0xb8>
			metal_log(METAL_LOG_DEBUG, "counter mismatch, delta = %d\n",
 1006f20:	008060f4 	movhi	r2,387
 1006f24:	10baf104 	addi	r2,r2,-5180
 1006f28:	10800017 	ldw	r2,0(r2)
 1006f2c:	108001f0 	cmpltui	r2,r2,7
 1006f30:	10000c1e 	bne	r2,zero,1006f64 <atomic+0xb0>
 1006f34:	008060f4 	movhi	r2,387
 1006f38:	10baf104 	addi	r2,r2,-5180
 1006f3c:	10800117 	ldw	r2,4(r2)
 1006f40:	10000826 	beq	r2,zero,1006f64 <atomic+0xb0>
 1006f44:	008060f4 	movhi	r2,387
 1006f48:	10baf104 	addi	r2,r2,-5180
 1006f4c:	10800117 	ldw	r2,4(r2)
 1006f50:	e1bffe17 	ldw	r6,-8(fp)
 1006f54:	014040f4 	movhi	r5,259
 1006f58:	2964c804 	addi	r5,r5,-27872
 1006f5c:	010001c4 	movi	r4,7
 1006f60:	103ee83a 	callr	r2
				  value);
			error = -EINVAL;
 1006f64:	00bffa84 	movi	r2,-22
 1006f68:	e0bffc15 	stw	r2,-16(fp)
		}
	}

	return error;
 1006f6c:	e0bffc17 	ldw	r2,-16(fp)
}
 1006f70:	e037883a 	mov	sp,fp
 1006f74:	dfc00117 	ldw	ra,4(sp)
 1006f78:	df000017 	ldw	fp,0(sp)
 1006f7c:	dec00204 	addi	sp,sp,8
 1006f80:	f800283a 	ret

01006f84 <metal_test_atomic>:
METAL_ADD_TEST(atomic);
 1006f84:	defffe04 	addi	sp,sp,-8
 1006f88:	dfc00115 	stw	ra,4(sp)
 1006f8c:	df000015 	stw	fp,0(sp)
 1006f90:	d839883a 	mov	fp,sp
 1006f94:	010040f4 	movhi	r4,259
 1006f98:	212b5d04 	addi	r4,r4,-21132
 1006f9c:	10060380 	call	1006038 <metal_add_test_case>
 1006fa0:	0001883a 	nop
 1006fa4:	e037883a 	mov	sp,fp
 1006fa8:	dfc00117 	ldw	ra,4(sp)
 1006fac:	df000017 	ldw	fp,0(sp)
 1006fb0:	dec00204 	addi	sp,sp,8
 1006fb4:	f800283a 	ret

01006fb8 <metal_condition_wait>:

#include <condition.h>

int metal_condition_wait(struct metal_condition *cv,
			 metal_mutex_t *m)
{
 1006fb8:	defffd04 	addi	sp,sp,-12
 1006fbc:	df000215 	stw	fp,8(sp)
 1006fc0:	df000204 	addi	fp,sp,8
 1006fc4:	e13ffe15 	stw	r4,-8(fp)
 1006fc8:	e17fff15 	stw	r5,-4(fp)
	/* TODO: Implement condition variable for FreeRTOS */
	(void)cv;
	(void)m;
	return 0;
 1006fcc:	0005883a 	mov	r2,zero
}
 1006fd0:	e037883a 	mov	sp,fp
 1006fd4:	df000017 	ldw	fp,0(sp)
 1006fd8:	dec00104 	addi	sp,sp,4
 1006fdc:	f800283a 	ret

01006fe0 <metal_generic_dev_sys_open>:
#include <device.h>
#include <sys.h>
#include <utilities.h>

int metal_generic_dev_sys_open(struct metal_device *dev)
{
 1006fe0:	defffb04 	addi	sp,sp,-20
 1006fe4:	dfc00415 	stw	ra,16(sp)
 1006fe8:	df000315 	stw	fp,12(sp)
 1006fec:	df000304 	addi	fp,sp,12
 1006ff0:	e13fff15 	stw	r4,-4(fp)
	struct metal_io_region *io;
	unsigned i;

	/* map I/O memory regions */
	for (i = 0; i < dev->num_regions; i++) {
 1006ff4:	e03ffd15 	stw	zero,-12(fp)
 1006ff8:	00000e06 	br	1007034 <metal_generic_dev_sys_open+0x54>
		io = &dev->regions[i];
 1006ffc:	e0bffd17 	ldw	r2,-12(fp)
 1007000:	10800e24 	muli	r2,r2,56
 1007004:	10800304 	addi	r2,r2,12
 1007008:	e0ffff17 	ldw	r3,-4(fp)
 100700c:	1885883a 	add	r2,r3,r2
 1007010:	e0bffe15 	stw	r2,-8(fp)
		if (!io->size)
 1007014:	e0bffe17 	ldw	r2,-8(fp)
 1007018:	10800217 	ldw	r2,8(r2)
 100701c:	10000a26 	beq	r2,zero,1007048 <metal_generic_dev_sys_open+0x68>
			break;
		metal_sys_io_mem_map(io);
 1007020:	e13ffe17 	ldw	r4,-8(fp)
 1007024:	10070d00 	call	10070d0 <metal_sys_io_mem_map>
{
	struct metal_io_region *io;
	unsigned i;

	/* map I/O memory regions */
	for (i = 0; i < dev->num_regions; i++) {
 1007028:	e0bffd17 	ldw	r2,-12(fp)
 100702c:	10800044 	addi	r2,r2,1
 1007030:	e0bffd15 	stw	r2,-12(fp)
 1007034:	e0bfff17 	ldw	r2,-4(fp)
 1007038:	10800217 	ldw	r2,8(r2)
 100703c:	e0fffd17 	ldw	r3,-12(fp)
 1007040:	18bfee36 	bltu	r3,r2,1006ffc <__alt_data_end+0xff006ffc>
 1007044:	00000106 	br	100704c <metal_generic_dev_sys_open+0x6c>
		io = &dev->regions[i];
		if (!io->size)
			break;
 1007048:	0001883a 	nop
		metal_sys_io_mem_map(io);
	}

	return 0;
 100704c:	0005883a 	mov	r2,zero
}
 1007050:	e037883a 	mov	sp,fp
 1007054:	dfc00117 	ldw	ra,4(sp)
 1007058:	df000017 	ldw	fp,0(sp)
 100705c:	dec00204 	addi	sp,sp,8
 1007060:	f800283a 	ret

01007064 <metal_sys_init>:
#include <device.h>

struct metal_state _metal;

int metal_sys_init(const struct metal_init_params *params)
{
 1007064:	defffd04 	addi	sp,sp,-12
 1007068:	dfc00215 	stw	ra,8(sp)
 100706c:	df000115 	stw	fp,4(sp)
 1007070:	df000104 	addi	fp,sp,4
 1007074:	e13fff15 	stw	r4,-4(fp)
	metal_unused(params);
	metal_bus_register(&metal_generic_bus);
 1007078:	010040f4 	movhi	r4,259
 100707c:	212b4e04 	addi	r4,r4,-21192
 1007080:	10064cc0 	call	10064cc <metal_bus_register>
	return 0;
 1007084:	0005883a 	mov	r2,zero
}
 1007088:	e037883a 	mov	sp,fp
 100708c:	dfc00117 	ldw	ra,4(sp)
 1007090:	df000017 	ldw	fp,0(sp)
 1007094:	dec00204 	addi	sp,sp,8
 1007098:	f800283a 	ret

0100709c <metal_sys_finish>:

void metal_sys_finish(void)
{
 100709c:	defffe04 	addi	sp,sp,-8
 10070a0:	dfc00115 	stw	ra,4(sp)
 10070a4:	df000015 	stw	fp,0(sp)
 10070a8:	d839883a 	mov	fp,sp
	metal_bus_unregister(&metal_generic_bus);
 10070ac:	010040f4 	movhi	r4,259
 10070b0:	212b4e04 	addi	r4,r4,-21192
 10070b4:	10065c40 	call	10065c4 <metal_bus_unregister>
}
 10070b8:	0001883a 	nop
 10070bc:	e037883a 	mov	sp,fp
 10070c0:	dfc00117 	ldw	ra,4(sp)
 10070c4:	df000017 	ldw	fp,0(sp)
 10070c8:	dec00204 	addi	sp,sp,8
 10070cc:	f800283a 	ret

010070d0 <metal_sys_io_mem_map>:
 */

#include <metal_io.h>

void metal_sys_io_mem_map(struct metal_io_region *io)
{
 10070d0:	defffa04 	addi	sp,sp,-24
 10070d4:	dfc00515 	stw	ra,20(sp)
 10070d8:	df000415 	stw	fp,16(sp)
 10070dc:	df000404 	addi	fp,sp,16
 10070e0:	e13fff15 	stw	r4,-4(fp)
	unsigned long p;
	size_t psize;
	void *va;

	va = io->virt;
 10070e4:	e0bfff17 	ldw	r2,-4(fp)
 10070e8:	10800017 	ldw	r2,0(r2)
 10070ec:	e0bffe15 	stw	r2,-8(fp)
	psize = io->size;
 10070f0:	e0bfff17 	ldw	r2,-4(fp)
 10070f4:	10800217 	ldw	r2,8(r2)
 10070f8:	e0bffd15 	stw	r2,-12(fp)
	if (psize) {
 10070fc:	e0bffd17 	ldw	r2,-12(fp)
 1007100:	10002826 	beq	r2,zero,10071a4 <metal_sys_io_mem_map+0xd4>
		if (psize >> io->page_shift)
 1007104:	e0bfff17 	ldw	r2,-4(fp)
 1007108:	10800317 	ldw	r2,12(r2)
 100710c:	e0fffd17 	ldw	r3,-12(fp)
 1007110:	1884d83a 	srl	r2,r3,r2
 1007114:	10000526 	beq	r2,zero,100712c <metal_sys_io_mem_map+0x5c>
			psize = (size_t)1 << io->page_shift;
 1007118:	e0bfff17 	ldw	r2,-4(fp)
 100711c:	10800317 	ldw	r2,12(r2)
 1007120:	00c00044 	movi	r3,1
 1007124:	1884983a 	sll	r2,r3,r2
 1007128:	e0bffd15 	stw	r2,-12(fp)
		for (p = 0; p <= (io->size >> io->page_shift); p++) {
 100712c:	e03ffc15 	stw	zero,-16(fp)
 1007130:	00001506 	br	1007188 <metal_sys_io_mem_map+0xb8>
			metal_machine_io_mem_map(va, io->physmap[p],
 1007134:	e0bfff17 	ldw	r2,-4(fp)
 1007138:	10c00117 	ldw	r3,4(r2)
 100713c:	e0bffc17 	ldw	r2,-16(fp)
 1007140:	1085883a 	add	r2,r2,r2
 1007144:	1085883a 	add	r2,r2,r2
 1007148:	1885883a 	add	r2,r3,r2
 100714c:	10c00017 	ldw	r3,0(r2)
 1007150:	e0bfff17 	ldw	r2,-4(fp)
 1007154:	10800517 	ldw	r2,20(r2)
 1007158:	100f883a 	mov	r7,r2
 100715c:	e1bffd17 	ldw	r6,-12(fp)
 1007160:	180b883a 	mov	r5,r3
 1007164:	e13ffe17 	ldw	r4,-8(fp)
 1007168:	10078880 	call	1007888 <metal_machine_io_mem_map>
						 psize, io->mem_flags);
			va += psize;
 100716c:	e0fffe17 	ldw	r3,-8(fp)
 1007170:	e0bffd17 	ldw	r2,-12(fp)
 1007174:	1885883a 	add	r2,r3,r2
 1007178:	e0bffe15 	stw	r2,-8(fp)
	va = io->virt;
	psize = io->size;
	if (psize) {
		if (psize >> io->page_shift)
			psize = (size_t)1 << io->page_shift;
		for (p = 0; p <= (io->size >> io->page_shift); p++) {
 100717c:	e0bffc17 	ldw	r2,-16(fp)
 1007180:	10800044 	addi	r2,r2,1
 1007184:	e0bffc15 	stw	r2,-16(fp)
 1007188:	e0bfff17 	ldw	r2,-4(fp)
 100718c:	10c00217 	ldw	r3,8(r2)
 1007190:	e0bfff17 	ldw	r2,-4(fp)
 1007194:	10800317 	ldw	r2,12(r2)
 1007198:	1886d83a 	srl	r3,r3,r2
 100719c:	e0bffc17 	ldw	r2,-16(fp)
 10071a0:	18bfe42e 	bgeu	r3,r2,1007134 <__alt_data_end+0xff007134>
			metal_machine_io_mem_map(va, io->physmap[p],
						 psize, io->mem_flags);
			va += psize;
		}
	}
}
 10071a4:	0001883a 	nop
 10071a8:	e037883a 	mov	sp,fp
 10071ac:	dfc00117 	ldw	ra,4(sp)
 10071b0:	df000017 	ldw	fp,0(sp)
 10071b4:	dec00204 	addi	sp,sp,8
 10071b8:	f800283a 	ret

010071bc <metal_irq_save_disable>:
#include <metal_list.h>
#include <utilities.h>
#include <alloc.h>

unsigned int metal_irq_save_disable(void)
{
 10071bc:	defffe04 	addi	sp,sp,-8
 10071c0:	dfc00115 	stw	ra,4(sp)
 10071c4:	df000015 	stw	fp,0(sp)
 10071c8:	d839883a 	mov	fp,sp
	return sys_irq_save_disable();
 10071cc:	10077a80 	call	10077a8 <sys_irq_save_disable>
}
 10071d0:	e037883a 	mov	sp,fp
 10071d4:	dfc00117 	ldw	ra,4(sp)
 10071d8:	df000017 	ldw	fp,0(sp)
 10071dc:	dec00204 	addi	sp,sp,8
 10071e0:	f800283a 	ret

010071e4 <metal_irq_restore_enable>:

void metal_irq_restore_enable(unsigned int flags)
{
 10071e4:	defffd04 	addi	sp,sp,-12
 10071e8:	dfc00215 	stw	ra,8(sp)
 10071ec:	df000115 	stw	fp,4(sp)
 10071f0:	df000104 	addi	fp,sp,4
 10071f4:	e13fff15 	stw	r4,-4(fp)
	sys_irq_restore_enable(flags);
 10071f8:	e13fff17 	ldw	r4,-4(fp)
 10071fc:	10077700 	call	1007770 <sys_irq_restore_enable>
}
 1007200:	0001883a 	nop
 1007204:	e037883a 	mov	sp,fp
 1007208:	dfc00117 	ldw	ra,4(sp)
 100720c:	df000017 	ldw	fp,0(sp)
 1007210:	dec00204 	addi	sp,sp,8
 1007214:	f800283a 	ret

01007218 <__metal_mutex_init>:
 * static singleton mutex
 */
#define METAL_MUTEX_DEFINE(m) metal_mutex_t m = METAL_MUTEX_INIT(m)

static inline void __metal_mutex_init(metal_mutex_t *mutex)
{
 1007218:	defffe04 	addi	sp,sp,-8
 100721c:	df000115 	stw	fp,4(sp)
 1007220:	df000104 	addi	fp,sp,4
 1007224:	e13fff15 	stw	r4,-4(fp)
	atomic_store(&mutex->v, 0);
 1007228:	e0bfff17 	ldw	r2,-4(fp)
 100722c:	10000015 	stw	zero,0(r2)
 1007230:	0001b03a 	sync
}
 1007234:	0001883a 	nop
 1007238:	e037883a 	mov	sp,fp
 100723c:	df000017 	ldw	fp,0(sp)
 1007240:	dec00104 	addi	sp,sp,4
 1007244:	f800283a 	ret

01007248 <__metal_mutex_deinit>:

static inline void __metal_mutex_deinit(metal_mutex_t *mutex)
{
 1007248:	defffe04 	addi	sp,sp,-8
 100724c:	df000115 	stw	fp,4(sp)
 1007250:	df000104 	addi	fp,sp,4
 1007254:	e13fff15 	stw	r4,-4(fp)
	(void)mutex;
}
 1007258:	0001883a 	nop
 100725c:	e037883a 	mov	sp,fp
 1007260:	df000017 	ldw	fp,0(sp)
 1007264:	dec00104 	addi	sp,sp,4
 1007268:	f800283a 	ret

0100726c <__metal_mutex_acquire>:
{
	return 1 - atomic_flag_test_and_set(&mutex->v);
}

static inline void __metal_mutex_acquire(metal_mutex_t *mutex)
{
 100726c:	defffb04 	addi	sp,sp,-20
 1007270:	df000415 	stw	fp,16(sp)
 1007274:	df000404 	addi	fp,sp,16
 1007278:	e13fff15 	stw	r4,-4(fp)
	while (atomic_flag_test_and_set(&mutex->v)) {
 100727c:	0001883a 	nop
 1007280:	e0bfff17 	ldw	r2,-4(fp)
 1007284:	e0bffc15 	stw	r2,-16(fp)
 1007288:	e0bffc17 	ldw	r2,-16(fp)
 100728c:	10800017 	ldw	r2,0(r2)
 1007290:	e0bffd15 	stw	r2,-12(fp)
 1007294:	00800044 	movi	r2,1
 1007298:	e0bffe15 	stw	r2,-8(fp)
 100729c:	e0bfff17 	ldw	r2,-4(fp)
 10072a0:	e0fffe17 	ldw	r3,-8(fp)
 10072a4:	10c00015 	stw	r3,0(r2)
 10072a8:	e0bffd17 	ldw	r2,-12(fp)
 10072ac:	103ff41e 	bne	r2,zero,1007280 <__alt_data_end+0xff007280>
		;
	}
}
 10072b0:	0001883a 	nop
 10072b4:	e037883a 	mov	sp,fp
 10072b8:	df000017 	ldw	fp,0(sp)
 10072bc:	dec00104 	addi	sp,sp,4
 10072c0:	f800283a 	ret

010072c4 <__metal_mutex_release>:

static inline void __metal_mutex_release(metal_mutex_t *mutex)
{
 10072c4:	defffe04 	addi	sp,sp,-8
 10072c8:	df000115 	stw	fp,4(sp)
 10072cc:	df000104 	addi	fp,sp,4
 10072d0:	e13fff15 	stw	r4,-4(fp)
	atomic_flag_clear(&mutex->v);
 10072d4:	e0bfff17 	ldw	r2,-4(fp)
 10072d8:	0001b03a 	sync
 10072dc:	10000015 	stw	zero,0(r2)
}
 10072e0:	0001883a 	nop
 10072e4:	e037883a 	mov	sp,fp
 10072e8:	df000017 	ldw	fp,0(sp)
 10072ec:	dec00104 	addi	sp,sp,4
 10072f0:	f800283a 	ret

010072f4 <metal_mutex_init>:
/**
 * @brief	Initialize a libmetal mutex.
 * @param[in]	mutex	Mutex to initialize.
 */
static inline void metal_mutex_init(metal_mutex_t *mutex)
{
 10072f4:	defffd04 	addi	sp,sp,-12
 10072f8:	dfc00215 	stw	ra,8(sp)
 10072fc:	df000115 	stw	fp,4(sp)
 1007300:	df000104 	addi	fp,sp,4
 1007304:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_init(mutex);
 1007308:	e13fff17 	ldw	r4,-4(fp)
 100730c:	10072180 	call	1007218 <__metal_mutex_init>
}
 1007310:	0001883a 	nop
 1007314:	e037883a 	mov	sp,fp
 1007318:	dfc00117 	ldw	ra,4(sp)
 100731c:	df000017 	ldw	fp,0(sp)
 1007320:	dec00204 	addi	sp,sp,8
 1007324:	f800283a 	ret

01007328 <metal_mutex_deinit>:
/**
 * @brief	Deinitialize a libmetal mutex.
 * @param[in]	mutex	Mutex to deinitialize.
 */
static inline void metal_mutex_deinit(metal_mutex_t *mutex)
{
 1007328:	defffd04 	addi	sp,sp,-12
 100732c:	dfc00215 	stw	ra,8(sp)
 1007330:	df000115 	stw	fp,4(sp)
 1007334:	df000104 	addi	fp,sp,4
 1007338:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_deinit(mutex);
 100733c:	e13fff17 	ldw	r4,-4(fp)
 1007340:	10072480 	call	1007248 <__metal_mutex_deinit>
}
 1007344:	0001883a 	nop
 1007348:	e037883a 	mov	sp,fp
 100734c:	dfc00117 	ldw	ra,4(sp)
 1007350:	df000017 	ldw	fp,0(sp)
 1007354:	dec00204 	addi	sp,sp,8
 1007358:	f800283a 	ret

0100735c <metal_mutex_acquire>:
/**
 * @brief	Acquire a mutex 
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
 100735c:	defffd04 	addi	sp,sp,-12
 1007360:	dfc00215 	stw	ra,8(sp)
 1007364:	df000115 	stw	fp,4(sp)
 1007368:	df000104 	addi	fp,sp,4
 100736c:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_acquire(mutex);
 1007370:	e13fff17 	ldw	r4,-4(fp)
 1007374:	100726c0 	call	100726c <__metal_mutex_acquire>
}
 1007378:	0001883a 	nop
 100737c:	e037883a 	mov	sp,fp
 1007380:	dfc00117 	ldw	ra,4(sp)
 1007384:	df000017 	ldw	fp,0(sp)
 1007388:	dec00204 	addi	sp,sp,8
 100738c:	f800283a 	ret

01007390 <metal_mutex_release>:
 * @brief	Release a previously acquired mutex.
 * @param[in]	mutex	Mutex to mutex.
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
 1007390:	defffd04 	addi	sp,sp,-12
 1007394:	dfc00215 	stw	ra,8(sp)
 1007398:	df000115 	stw	fp,4(sp)
 100739c:	df000104 	addi	fp,sp,4
 10073a0:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_release(mutex);
 10073a4:	e13fff17 	ldw	r4,-4(fp)
 10073a8:	10072c40 	call	10072c4 <__metal_mutex_release>
}
 10073ac:	0001883a 	nop
 10073b0:	e037883a 	mov	sp,fp
 10073b4:	dfc00117 	ldw	ra,4(sp)
 10073b8:	df000017 	ldw	fp,0(sp)
 10073bc:	dec00204 	addi	sp,sp,8
 10073c0:	f800283a 	ret

010073c4 <mutex_thread>:
#include <mutex.h>

static const int mutex_test_count = 1000;

static void *mutex_thread(void *arg)
{
 10073c4:	defffb04 	addi	sp,sp,-20
 10073c8:	dfc00415 	stw	ra,16(sp)
 10073cc:	df000315 	stw	fp,12(sp)
 10073d0:	df000304 	addi	fp,sp,12
 10073d4:	e13fff15 	stw	r4,-4(fp)
	metal_mutex_t *l = arg;
 10073d8:	e0bfff17 	ldw	r2,-4(fp)
 10073dc:	e0bffe15 	stw	r2,-8(fp)
	int i;

	for (i = 0; i < mutex_test_count; i++) {
 10073e0:	e03ffd15 	stw	zero,-12(fp)
 10073e4:	00000906 	br	100740c <mutex_thread+0x48>
		metal_mutex_acquire(l);
 10073e8:	e13ffe17 	ldw	r4,-8(fp)
 10073ec:	100735c0 	call	100735c <metal_mutex_acquire>
		usleep(1);
 10073f0:	01000044 	movi	r4,1
 10073f4:	10271640 	call	1027164 <usleep>
		metal_mutex_release(l);
 10073f8:	e13ffe17 	ldw	r4,-8(fp)
 10073fc:	10073900 	call	1007390 <metal_mutex_release>
static void *mutex_thread(void *arg)
{
	metal_mutex_t *l = arg;
	int i;

	for (i = 0; i < mutex_test_count; i++) {
 1007400:	e0bffd17 	ldw	r2,-12(fp)
 1007404:	10800044 	addi	r2,r2,1
 1007408:	e0bffd15 	stw	r2,-12(fp)
 100740c:	0080fa04 	movi	r2,1000
 1007410:	e0fffd17 	ldw	r3,-12(fp)
 1007414:	18bff416 	blt	r3,r2,10073e8 <__alt_data_end+0xff0073e8>
		metal_mutex_acquire(l);
		usleep(1);
		metal_mutex_release(l);
	}

	return NULL;
 1007418:	0005883a 	mov	r2,zero
}
 100741c:	e037883a 	mov	sp,fp
 1007420:	dfc00117 	ldw	ra,4(sp)
 1007424:	df000017 	ldw	fp,0(sp)
 1007428:	dec00204 	addi	sp,sp,8
 100742c:	f800283a 	ret

01007430 <mutex>:

static int mutex(void)
{
 1007430:	defffb04 	addi	sp,sp,-20
 1007434:	dfc00415 	stw	ra,16(sp)
 1007438:	df000315 	stw	fp,12(sp)
 100743c:	df000304 	addi	fp,sp,12
	metal_mutex_t lock;
	const int threads = 10;
 1007440:	00800284 	movi	r2,10
 1007444:	e0bffd15 	stw	r2,-12(fp)
	int rc;

	metal_mutex_init(&lock);
 1007448:	e0bfff04 	addi	r2,fp,-4
 100744c:	1009883a 	mov	r4,r2
 1007450:	10072f40 	call	10072f4 <metal_mutex_init>

	rc = metal_run(threads, mutex_thread, &lock);
 1007454:	e0bfff04 	addi	r2,fp,-4
 1007458:	100d883a 	mov	r6,r2
 100745c:	01404034 	movhi	r5,256
 1007460:	295cf104 	addi	r5,r5,29636
 1007464:	e13ffd17 	ldw	r4,-12(fp)
 1007468:	1007ab40 	call	1007ab4 <metal_run>
 100746c:	e0bffe15 	stw	r2,-8(fp)

	metal_mutex_deinit(&lock);
 1007470:	e0bfff04 	addi	r2,fp,-4
 1007474:	1009883a 	mov	r4,r2
 1007478:	10073280 	call	1007328 <metal_mutex_deinit>
	return rc;
 100747c:	e0bffe17 	ldw	r2,-8(fp)
}
 1007480:	e037883a 	mov	sp,fp
 1007484:	dfc00117 	ldw	ra,4(sp)
 1007488:	df000017 	ldw	fp,0(sp)
 100748c:	dec00204 	addi	sp,sp,8
 1007490:	f800283a 	ret

01007494 <metal_test_mutex>:
METAL_ADD_TEST(mutex);
 1007494:	defffe04 	addi	sp,sp,-8
 1007498:	dfc00115 	stw	ra,4(sp)
 100749c:	df000015 	stw	fp,0(sp)
 10074a0:	d839883a 	mov	fp,sp
 10074a4:	010040f4 	movhi	r4,259
 10074a8:	212b6104 	addi	r4,r4,-21116
 10074ac:	10060380 	call	1006038 <metal_add_test_case>
 10074b0:	0001883a 	nop
 10074b4:	e037883a 	mov	sp,fp
 10074b8:	dfc00117 	ldw	ra,4(sp)
 10074bc:	df000017 	ldw	fp,0(sp)
 10074c0:	dec00204 	addi	sp,sp,8
 10074c4:	f800283a 	ret

010074c8 <metal_irq_handle>:
 * @param[in] irq IRQ id which will be passed to handler
 * @return IRQ handler status
 */
static inline
int metal_irq_handle(struct metal_irq *irq_data, int irq)
{
 10074c8:	defffc04 	addi	sp,sp,-16
 10074cc:	dfc00315 	stw	ra,12(sp)
 10074d0:	df000215 	stw	fp,8(sp)
 10074d4:	df000204 	addi	fp,sp,8
 10074d8:	e13ffe15 	stw	r4,-8(fp)
 10074dc:	e17fff15 	stw	r5,-4(fp)
	if (irq_data != NULL && irq_data->hd != NULL) {
 10074e0:	e0bffe17 	ldw	r2,-8(fp)
 10074e4:	10000b26 	beq	r2,zero,1007514 <metal_irq_handle+0x4c>
 10074e8:	e0bffe17 	ldw	r2,-8(fp)
 10074ec:	10800017 	ldw	r2,0(r2)
 10074f0:	10000826 	beq	r2,zero,1007514 <metal_irq_handle+0x4c>
		return irq_data->hd(irq, irq_data->arg);
 10074f4:	e0bffe17 	ldw	r2,-8(fp)
 10074f8:	10800017 	ldw	r2,0(r2)
 10074fc:	e0fffe17 	ldw	r3,-8(fp)
 1007500:	18c00117 	ldw	r3,4(r3)
 1007504:	180b883a 	mov	r5,r3
 1007508:	e13fff17 	ldw	r4,-4(fp)
 100750c:	103ee83a 	callr	r2
 1007510:	00000106 	br	1007518 <metal_irq_handle+0x50>
	} else {
		return METAL_IRQ_NOT_HANDLED;
 1007514:	0005883a 	mov	r2,zero
	}
}
 1007518:	e037883a 	mov	sp,fp
 100751c:	dfc00117 	ldw	ra,4(sp)
 1007520:	df000017 	ldw	fp,0(sp)
 1007524:	dec00204 	addi	sp,sp,8
 1007528:	f800283a 	ret

0100752c <sys_irq_enable>:

#define NIOS_MAXIRQS 	NIOS2_NIRQ
#define	IC_ID_IGNORE 	0

static inline void sys_irq_enable(unsigned int vector)
{
 100752c:	defffd04 	addi	sp,sp,-12
 1007530:	dfc00215 	stw	ra,8(sp)
 1007534:	df000115 	stw	fp,4(sp)
 1007538:	df000104 	addi	fp,sp,4
 100753c:	e13fff15 	stw	r4,-4(fp)
	alt_ic_irq_enable(IC_ID_IGNORE, (alt_u32)vector);
 1007540:	e17fff17 	ldw	r5,-4(fp)
 1007544:	0009883a 	mov	r4,zero
 1007548:	10268ac0 	call	10268ac <alt_ic_irq_enable>
}
 100754c:	0001883a 	nop
 1007550:	e037883a 	mov	sp,fp
 1007554:	dfc00117 	ldw	ra,4(sp)
 1007558:	df000017 	ldw	fp,0(sp)
 100755c:	dec00204 	addi	sp,sp,8
 1007560:	f800283a 	ret

01007564 <sys_irq_disable>:

static inline void sys_irq_disable(unsigned int vector)
{
 1007564:	defffd04 	addi	sp,sp,-12
 1007568:	dfc00215 	stw	ra,8(sp)
 100756c:	df000115 	stw	fp,4(sp)
 1007570:	df000104 	addi	fp,sp,4
 1007574:	e13fff15 	stw	r4,-4(fp)
	alt_ic_irq_disable(IC_ID_IGNORE, (alt_u32)vector);
 1007578:	e17fff17 	ldw	r5,-4(fp)
 100757c:	0009883a 	mov	r4,zero
 1007580:	10269340 	call	1026934 <alt_ic_irq_disable>
}
 1007584:	0001883a 	nop
 1007588:	e037883a 	mov	sp,fp
 100758c:	dfc00117 	ldw	ra,4(sp)
 1007590:	df000017 	ldw	fp,0(sp)
 1007594:	dec00204 	addi	sp,sp,8
 1007598:	f800283a 	ret

0100759c <metal_nios2_irq_set_enable>:

static struct metal_irq irqs[MAX_IRQS]; /**< Linux IRQs array */

static void metal_nios2_irq_set_enable(struct metal_irq_controller *irq_cntr,
				     int irq, unsigned int state)
{
 100759c:	defffb04 	addi	sp,sp,-20
 10075a0:	dfc00415 	stw	ra,16(sp)
 10075a4:	df000315 	stw	fp,12(sp)
 10075a8:	df000304 	addi	fp,sp,12
 10075ac:	e13ffd15 	stw	r4,-12(fp)
 10075b0:	e17ffe15 	stw	r5,-8(fp)
 10075b4:	e1bfff15 	stw	r6,-4(fp)
	if (irq < irq_cntr->irq_base ||
 10075b8:	e0bffd17 	ldw	r2,-12(fp)
 10075bc:	10800017 	ldw	r2,0(r2)
 10075c0:	e0fffe17 	ldw	r3,-8(fp)
 10075c4:	18800716 	blt	r3,r2,10075e4 <metal_nios2_irq_set_enable+0x48>
	    irq >= irq_cntr->irq_base + irq_cntr->irq_num) {
 10075c8:	e0bffd17 	ldw	r2,-12(fp)
 10075cc:	10c00017 	ldw	r3,0(r2)
 10075d0:	e0bffd17 	ldw	r2,-12(fp)
 10075d4:	10800117 	ldw	r2,4(r2)
 10075d8:	1885883a 	add	r2,r3,r2
static struct metal_irq irqs[MAX_IRQS]; /**< Linux IRQs array */

static void metal_nios2_irq_set_enable(struct metal_irq_controller *irq_cntr,
				     int irq, unsigned int state)
{
	if (irq < irq_cntr->irq_base ||
 10075dc:	e0fffe17 	ldw	r3,-8(fp)
 10075e0:	18801416 	blt	r3,r2,1007634 <metal_nios2_irq_set_enable+0x98>
	    irq >= irq_cntr->irq_base + irq_cntr->irq_num) {
		metal_log(METAL_LOG_ERROR, "%s: invalid irq %d\n",
 10075e4:	008060f4 	movhi	r2,387
 10075e8:	10baf104 	addi	r2,r2,-5180
 10075ec:	10800017 	ldw	r2,0(r2)
 10075f0:	108000f0 	cmpltui	r2,r2,3
 10075f4:	10001a1e 	bne	r2,zero,1007660 <metal_nios2_irq_set_enable+0xc4>
 10075f8:	008060f4 	movhi	r2,387
 10075fc:	10baf104 	addi	r2,r2,-5180
 1007600:	10800117 	ldw	r2,4(r2)
 1007604:	10001626 	beq	r2,zero,1007660 <metal_nios2_irq_set_enable+0xc4>
 1007608:	008060f4 	movhi	r2,387
 100760c:	10baf104 	addi	r2,r2,-5180
 1007610:	10800117 	ldw	r2,4(r2)
 1007614:	e1fffe17 	ldw	r7,-8(fp)
 1007618:	018040f4 	movhi	r6,259
 100761c:	31a4e304 	addi	r6,r6,-27764
 1007620:	014040f4 	movhi	r5,259
 1007624:	2964d404 	addi	r5,r5,-27824
 1007628:	010000c4 	movi	r4,3
 100762c:	103ee83a 	callr	r2
			  __func__, irq);
		return;
 1007630:	00000b06 	br	1007660 <metal_nios2_irq_set_enable+0xc4>
	} else if (state == METAL_IRQ_ENABLE) {
 1007634:	e0bfff17 	ldw	r2,-4(fp)
 1007638:	10800058 	cmpnei	r2,r2,1
 100763c:	1000041e 	bne	r2,zero,1007650 <metal_nios2_irq_set_enable+0xb4>
		sys_irq_enable((unsigned int)irq);
 1007640:	e0bffe17 	ldw	r2,-8(fp)
 1007644:	1009883a 	mov	r4,r2
 1007648:	100752c0 	call	100752c <sys_irq_enable>
 100764c:	00000506 	br	1007664 <metal_nios2_irq_set_enable+0xc8>
	} else {
		sys_irq_disable((unsigned int)irq);
 1007650:	e0bffe17 	ldw	r2,-8(fp)
 1007654:	1009883a 	mov	r4,r2
 1007658:	10075640 	call	1007564 <sys_irq_disable>
 100765c:	00000106 	br	1007664 <metal_nios2_irq_set_enable+0xc8>
{
	if (irq < irq_cntr->irq_base ||
	    irq >= irq_cntr->irq_base + irq_cntr->irq_num) {
		metal_log(METAL_LOG_ERROR, "%s: invalid irq %d\n",
			  __func__, irq);
		return;
 1007660:	0001883a 	nop
	} else if (state == METAL_IRQ_ENABLE) {
		sys_irq_enable((unsigned int)irq);
	} else {
		sys_irq_disable((unsigned int)irq);
	}
}
 1007664:	e037883a 	mov	sp,fp
 1007668:	dfc00117 	ldw	ra,4(sp)
 100766c:	df000017 	ldw	fp,0(sp)
 1007670:	dec00204 	addi	sp,sp,8
 1007674:	f800283a 	ret

01007678 <metal_nios2_irq_isr>:

/**
 * @brief default handler
 */
void metal_nios2_irq_isr(void *arg)
{
 1007678:	defffc04 	addi	sp,sp,-16
 100767c:	dfc00315 	stw	ra,12(sp)
 1007680:	df000215 	stw	fp,8(sp)
 1007684:	df000204 	addi	fp,sp,8
 1007688:	e13fff15 	stw	r4,-4(fp)
	unsigned int vector;

	vector = (uintptr_t)arg;
 100768c:	e0bfff17 	ldw	r2,-4(fp)
 1007690:	e0bffe15 	stw	r2,-8(fp)
	if (vector >= MAX_IRQS) {
 1007694:	e0bffe17 	ldw	r2,-8(fp)
 1007698:	10800830 	cmpltui	r2,r2,32
 100769c:	10000a26 	beq	r2,zero,10076c8 <metal_nios2_irq_isr+0x50>
		return;
	}
	(void)metal_irq_handle(&irqs[vector], (int)vector);
 10076a0:	e0bffe17 	ldw	r2,-8(fp)
 10076a4:	100690fa 	slli	r3,r2,3
 10076a8:	008060f4 	movhi	r2,387
 10076ac:	10b9e604 	addi	r2,r2,-6248
 10076b0:	1885883a 	add	r2,r3,r2
 10076b4:	e0fffe17 	ldw	r3,-8(fp)
 10076b8:	180b883a 	mov	r5,r3
 10076bc:	1009883a 	mov	r4,r2
 10076c0:	10074c80 	call	10074c8 <metal_irq_handle>
 10076c4:	00000106 	br	10076cc <metal_nios2_irq_isr+0x54>
{
	unsigned int vector;

	vector = (uintptr_t)arg;
	if (vector >= MAX_IRQS) {
		return;
 10076c8:	0001883a 	nop
	}
	(void)metal_irq_handle(&irqs[vector], (int)vector);
}
 10076cc:	e037883a 	mov	sp,fp
 10076d0:	dfc00117 	ldw	ra,4(sp)
 10076d4:	df000017 	ldw	fp,0(sp)
 10076d8:	dec00204 	addi	sp,sp,8
 10076dc:	f800283a 	ret

010076e0 <metal_nios2_irq_init>:

int metal_nios2_irq_init(void)
{
 10076e0:	defffd04 	addi	sp,sp,-12
 10076e4:	dfc00215 	stw	ra,8(sp)
 10076e8:	df000115 	stw	fp,4(sp)
 10076ec:	df000104 	addi	fp,sp,4
	int ret;

	ret =  metal_irq_register_controller(&nios2_irq_cntr);
 10076f0:	010040f4 	movhi	r4,259
 10076f4:	212b6504 	addi	r4,r4,-21100
 10076f8:	10088a40 	call	10088a4 <metal_irq_register_controller>
 10076fc:	e0bfff15 	stw	r2,-4(fp)
	if (ret < 0) {
 1007700:	e0bfff17 	ldw	r2,-4(fp)
 1007704:	1000140e 	bge	r2,zero,1007758 <metal_nios2_irq_init+0x78>
		metal_log(METAL_LOG_ERROR, "%s: register irq controller failed.\n",
 1007708:	008060f4 	movhi	r2,387
 100770c:	10baf104 	addi	r2,r2,-5180
 1007710:	10800017 	ldw	r2,0(r2)
 1007714:	108000f0 	cmpltui	r2,r2,3
 1007718:	10000d1e 	bne	r2,zero,1007750 <metal_nios2_irq_init+0x70>
 100771c:	008060f4 	movhi	r2,387
 1007720:	10baf104 	addi	r2,r2,-5180
 1007724:	10800117 	ldw	r2,4(r2)
 1007728:	10000926 	beq	r2,zero,1007750 <metal_nios2_irq_init+0x70>
 100772c:	008060f4 	movhi	r2,387
 1007730:	10baf104 	addi	r2,r2,-5180
 1007734:	10800117 	ldw	r2,4(r2)
 1007738:	018040f4 	movhi	r6,259
 100773c:	31a4ea04 	addi	r6,r6,-27736
 1007740:	014040f4 	movhi	r5,259
 1007744:	2964d904 	addi	r5,r5,-27804
 1007748:	010000c4 	movi	r4,3
 100774c:	103ee83a 	callr	r2
			  __func__);
		return ret;
 1007750:	e0bfff17 	ldw	r2,-4(fp)
 1007754:	00000106 	br	100775c <metal_nios2_irq_init+0x7c>
	}
	return 0;
 1007758:	0005883a 	mov	r2,zero
}
 100775c:	e037883a 	mov	sp,fp
 1007760:	dfc00117 	ldw	ra,4(sp)
 1007764:	df000017 	ldw	fp,0(sp)
 1007768:	dec00204 	addi	sp,sp,8
 100776c:	f800283a 	ret

01007770 <sys_irq_restore_enable>:

/* Mask off lower bits of addr */
//#define     ARM_AR_MEM_TTB_SECT_SIZE_MASK          (~(ARM_AR_MEM_TTB_SECT_SIZE-1UL))

void sys_irq_restore_enable(unsigned int flags)
{
 1007770:	defffd04 	addi	sp,sp,-12
 1007774:	df000215 	stw	fp,8(sp)
 1007778:	df000204 	addi	fp,sp,8
 100777c:	e13fff15 	stw	r4,-4(fp)
	alt_irq_enable_all(~flags);
 1007780:	e0bfff17 	ldw	r2,-4(fp)
 1007784:	0084303a 	nor	r2,zero,r2
 1007788:	e0bffe15 	stw	r2,-8(fp)
 100778c:	e0bffe17 	ldw	r2,-8(fp)
 1007790:	1001703a 	wrctl	status,r2
}
 1007794:	0001883a 	nop
 1007798:	e037883a 	mov	sp,fp
 100779c:	df000017 	ldw	fp,0(sp)
 10077a0:	dec00104 	addi	sp,sp,4
 10077a4:	f800283a 	ret

010077a8 <sys_irq_save_disable>:

unsigned int sys_irq_save_disable(void)
{
 10077a8:	defffd04 	addi	sp,sp,-12
 10077ac:	df000215 	stw	fp,8(sp)
 10077b0:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10077b4:	0005303a 	rdctl	r2,status
 10077b8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10077bc:	e0ffff17 	ldw	r3,-4(fp)
 10077c0:	00bfff84 	movi	r2,-2
 10077c4:	1884703a 	and	r2,r3,r2
 10077c8:	1001703a 	wrctl	status,r2
  
  return context;
 10077cc:	e0bfff17 	ldw	r2,-4(fp)
	unsigned int state;

	state = alt_irq_disable_all();
 10077d0:	e0bffe15 	stw	r2,-8(fp)

	return state;
 10077d4:	e0bffe17 	ldw	r2,-8(fp)
}
 10077d8:	e037883a 	mov	sp,fp
 10077dc:	df000017 	ldw	fp,0(sp)
 10077e0:	dec00104 	addi	sp,sp,4
 10077e4:	f800283a 	ret

010077e8 <metal_machine_cache_flush>:

void metal_machine_cache_flush(void *addr, unsigned int len)
{
 10077e8:	defffc04 	addi	sp,sp,-16
 10077ec:	dfc00315 	stw	ra,12(sp)
 10077f0:	df000215 	stw	fp,8(sp)
 10077f4:	df000204 	addi	fp,sp,8
 10077f8:	e13ffe15 	stw	r4,-8(fp)
 10077fc:	e17fff15 	stw	r5,-4(fp)
	if (!addr && !len)
 1007800:	e0bffe17 	ldw	r2,-8(fp)
 1007804:	1000041e 	bne	r2,zero,1007818 <metal_machine_cache_flush+0x30>
 1007808:	e0bfff17 	ldw	r2,-4(fp)
 100780c:	1000021e 	bne	r2,zero,1007818 <metal_machine_cache_flush+0x30>
		alt_dcache_flush_all();
 1007810:	10266a80 	call	10266a8 <alt_dcache_flush_all>
 1007814:	00000306 	br	1007824 <metal_machine_cache_flush+0x3c>
	else
		alt_dcache_flush(addr, len);
 1007818:	e17fff17 	ldw	r5,-4(fp)
 100781c:	e13ffe17 	ldw	r4,-8(fp)
 1007820:	10266300 	call	1026630 <alt_dcache_flush>
}
 1007824:	0001883a 	nop
 1007828:	e037883a 	mov	sp,fp
 100782c:	dfc00117 	ldw	ra,4(sp)
 1007830:	df000017 	ldw	fp,0(sp)
 1007834:	dec00204 	addi	sp,sp,8
 1007838:	f800283a 	ret

0100783c <metal_machine_cache_invalidate>:

void metal_machine_cache_invalidate(void *addr, unsigned int len)
{
 100783c:	defffd04 	addi	sp,sp,-12
 1007840:	df000215 	stw	fp,8(sp)
 1007844:	df000204 	addi	fp,sp,8
 1007848:	e13ffe15 	stw	r4,-8(fp)
 100784c:	e17fff15 	stw	r5,-4(fp)
	/*if (!addr && !len)
		Xil_DCacheInvalidate();
	else
		Xil_DCacheInvalidateRange((intptr_t)addr, len);*/
}
 1007850:	0001883a 	nop
 1007854:	e037883a 	mov	sp,fp
 1007858:	df000017 	ldw	fp,0(sp)
 100785c:	dec00104 	addi	sp,sp,4
 1007860:	f800283a 	ret

01007864 <metal_generic_default_poll>:

/**
 * @brief poll function until some event happens
 */
void metal_weak metal_generic_default_poll(void)
{
 1007864:	deffff04 	addi	sp,sp,-4
 1007868:	df000015 	stw	fp,0(sp)
 100786c:	d839883a 	mov	fp,sp
	asm volatile("nop");
 1007870:	0001883a 	nop
}
 1007874:	0001883a 	nop
 1007878:	e037883a 	mov	sp,fp
 100787c:	df000017 	ldw	fp,0(sp)
 1007880:	dec00104 	addi	sp,sp,4
 1007884:	f800283a 	ret

01007888 <metal_machine_io_mem_map>:

void *metal_machine_io_mem_map(void *va, metal_phys_addr_t pa,
				      size_t size, unsigned int flags)
{
 1007888:	defffb04 	addi	sp,sp,-20
 100788c:	df000415 	stw	fp,16(sp)
 1007890:	df000404 	addi	fp,sp,16
 1007894:	e13ffc15 	stw	r4,-16(fp)
 1007898:	e17ffd15 	stw	r5,-12(fp)
 100789c:	e1bffe15 	stw	r6,-8(fp)
 10078a0:	e1ffff15 	stw	r7,-4(fp)
	(void)pa;
	(void)size;
	(void)flags;

	return va;
 10078a4:	e0bffc17 	ldw	r2,-16(fp)
}
 10078a8:	e037883a 	mov	sp,fp
 10078ac:	df000017 	ldw	fp,0(sp)
 10078b0:	dec00104 	addi	sp,sp,4
 10078b4:	f800283a 	ret

010078b8 <metal_shmem_open>:

#include <shmem.h>

int metal_shmem_open(const char *name, size_t size,
		     struct metal_io_region **io)
{
 10078b8:	defffb04 	addi	sp,sp,-20
 10078bc:	dfc00415 	stw	ra,16(sp)
 10078c0:	df000315 	stw	fp,12(sp)
 10078c4:	df000304 	addi	fp,sp,12
 10078c8:	e13ffd15 	stw	r4,-12(fp)
 10078cc:	e17ffe15 	stw	r5,-8(fp)
 10078d0:	e1bfff15 	stw	r6,-4(fp)
	return metal_shmem_open_generic(name, size, io);
 10078d4:	e1bfff17 	ldw	r6,-4(fp)
 10078d8:	e17ffe17 	ldw	r5,-8(fp)
 10078dc:	e13ffd17 	ldw	r4,-12(fp)
 10078e0:	1008e100 	call	1008e10 <metal_shmem_open_generic>
}
 10078e4:	e037883a 	mov	sp,fp
 10078e8:	dfc00117 	ldw	ra,4(sp)
 10078ec:	df000017 	ldw	fp,0(sp)
 10078f0:	dec00204 	addi	sp,sp,8
 10078f4:	f800283a 	ret

010078f8 <__metal_sleep_usec>:
#ifdef __cplusplus
extern "C" {
#endif

static inline int __metal_sleep_usec(unsigned int usec)
{
 10078f8:	defffc04 	addi	sp,sp,-16
 10078fc:	dfc00315 	stw	ra,12(sp)
 1007900:	df000215 	stw	fp,8(sp)
 1007904:	df000204 	addi	fp,sp,8
 1007908:	e13fff15 	stw	r4,-4(fp)
	const TickType_t xDelay = usec / portTICK_PERIOD_MS;
 100790c:	e0bfff17 	ldw	r2,-4(fp)
 1007910:	e0bffe15 	stw	r2,-8(fp)
	vTaskDelay(xDelay);
 1007914:	e13ffe17 	ldw	r4,-8(fp)
 1007918:	1003cbc0 	call	1003cbc <vTaskDelay>
	return 0;
 100791c:	0005883a 	mov	r2,zero
}
 1007920:	e037883a 	mov	sp,fp
 1007924:	dfc00117 	ldw	ra,4(sp)
 1007928:	df000017 	ldw	fp,0(sp)
 100792c:	dec00204 	addi	sp,sp,8
 1007930:	f800283a 	ret

01007934 <metal_sleep_usec>:
 *
 * @param[in]  usec      microsecond intervals
 * @return     0 on success, non-zero for failures
 */
static inline int metal_sleep_usec(unsigned int usec)
{
 1007934:	defffd04 	addi	sp,sp,-12
 1007938:	dfc00215 	stw	ra,8(sp)
 100793c:	df000115 	stw	fp,4(sp)
 1007940:	df000104 	addi	fp,sp,4
 1007944:	e13fff15 	stw	r4,-4(fp)
	return __metal_sleep_usec(usec);
 1007948:	e13fff17 	ldw	r4,-4(fp)
 100794c:	10078f80 	call	10078f8 <__metal_sleep_usec>
}
 1007950:	e037883a 	mov	sp,fp
 1007954:	dfc00117 	ldw	ra,4(sp)
 1007958:	df000017 	ldw	fp,0(sp)
 100795c:	dec00204 	addi	sp,sp,8
 1007960:	f800283a 	ret

01007964 <sleep>:
#include <sleep.h>
#include <log.h>
#include <sys.h>

static int sleep(void)
{
 1007964:	defff404 	addi	sp,sp,-48
 1007968:	dfc00b15 	stw	ra,44(sp)
 100796c:	df000a15 	stw	fp,40(sp)
 1007970:	dc400915 	stw	r17,36(sp)
 1007974:	dc000815 	stw	r16,32(sp)
 1007978:	df000a04 	addi	fp,sp,40
	int rc;
	unsigned int usec = 3;
 100797c:	008000c4 	movi	r2,3
 1007980:	e0bff715 	stw	r2,-36(fp)
	unsigned long long tstart, tend, tdelayed;

	tstart = metal_get_timestamp();
 1007984:	1007ea80 	call	1007ea8 <metal_get_timestamp>
 1007988:	e0bff815 	stw	r2,-32(fp)
 100798c:	e0fff915 	stw	r3,-28(fp)
	metal_sleep_usec((usec/portTICK_PERIOD_MS));
 1007990:	e13ff717 	ldw	r4,-36(fp)
 1007994:	10079340 	call	1007934 <metal_sleep_usec>
	tend = metal_get_timestamp();
 1007998:	1007ea80 	call	1007ea8 <metal_get_timestamp>
 100799c:	e0bffa15 	stw	r2,-24(fp)
 10079a0:	e0fffb15 	stw	r3,-20(fp)
	tdelayed = tend - tstart;
 10079a4:	e13ffa17 	ldw	r4,-24(fp)
 10079a8:	e17ffb17 	ldw	r5,-20(fp)
 10079ac:	e1bff817 	ldw	r6,-32(fp)
 10079b0:	e1fff917 	ldw	r7,-28(fp)
 10079b4:	2185c83a 	sub	r2,r4,r6
 10079b8:	2091803a 	cmpltu	r8,r4,r2
 10079bc:	29c7c83a 	sub	r3,r5,r7
 10079c0:	1a09c83a 	sub	r4,r3,r8
 10079c4:	2007883a 	mov	r3,r4
 10079c8:	e0bffc15 	stw	r2,-16(fp)
 10079cc:	e0fffd15 	stw	r3,-12(fp)
	if (tdelayed > (usec/portTICK_PERIOD_MS))
 10079d0:	e0bff717 	ldw	r2,-36(fp)
 10079d4:	1021883a 	mov	r16,r2
 10079d8:	0023883a 	mov	r17,zero
 10079dc:	e0bffd17 	ldw	r2,-12(fp)
 10079e0:	88800436 	bltu	r17,r2,10079f4 <sleep+0x90>
 10079e4:	e0bffd17 	ldw	r2,-12(fp)
 10079e8:	1440051e 	bne	r2,r17,1007a00 <sleep+0x9c>
 10079ec:	e0bffc17 	ldw	r2,-16(fp)
 10079f0:	8080032e 	bgeu	r16,r2,1007a00 <sleep+0x9c>
		rc = -1;
 10079f4:	00bfffc4 	movi	r2,-1
 10079f8:	e0bff615 	stw	r2,-40(fp)
 10079fc:	00000106 	br	1007a04 <sleep+0xa0>
	else
		rc = 0;
 1007a00:	e03ff615 	stw	zero,-40(fp)

	return rc;
 1007a04:	e0bff617 	ldw	r2,-40(fp)
}
 1007a08:	e6fffe04 	addi	sp,fp,-8
 1007a0c:	dfc00317 	ldw	ra,12(sp)
 1007a10:	df000217 	ldw	fp,8(sp)
 1007a14:	dc400117 	ldw	r17,4(sp)
 1007a18:	dc000017 	ldw	r16,0(sp)
 1007a1c:	dec00404 	addi	sp,sp,16
 1007a20:	f800283a 	ret

01007a24 <metal_test_sleep>:
METAL_ADD_TEST(sleep);
 1007a24:	defffe04 	addi	sp,sp,-8
 1007a28:	dfc00115 	stw	ra,4(sp)
 1007a2c:	df000015 	stw	fp,0(sp)
 1007a30:	d839883a 	mov	fp,sp
 1007a34:	010040f4 	movhi	r4,259
 1007a38:	212b6d04 	addi	r4,r4,-21068
 1007a3c:	10060380 	call	1006038 <metal_add_test_case>
 1007a40:	0001883a 	nop
 1007a44:	e037883a 	mov	sp,fp
 1007a48:	dfc00117 	ldw	ra,4(sp)
 1007a4c:	df000017 	ldw	fp,0(sp)
 1007a50:	dec00204 	addi	sp,sp,8
 1007a54:	f800283a 	ret

01007a58 <thread_wrapper>:
		metal_thread_t thread_func;
		void *arg;
	} thread_wrap_arg_t;

static void thread_wrapper(void *arg)
{
 1007a58:	defffc04 	addi	sp,sp,-16
 1007a5c:	dfc00315 	stw	ra,12(sp)
 1007a60:	df000215 	stw	fp,8(sp)
 1007a64:	df000204 	addi	fp,sp,8
 1007a68:	e13fff15 	stw	r4,-4(fp)
	thread_wrap_arg_t *wrap_p = (thread_wrap_arg_t *)arg;
 1007a6c:	e0bfff17 	ldw	r2,-4(fp)
 1007a70:	e0bffe15 	stw	r2,-8(fp)
	(void)wrap_p->thread_func(wrap_p->arg);
 1007a74:	e0bffe17 	ldw	r2,-8(fp)
 1007a78:	10800017 	ldw	r2,0(r2)
 1007a7c:	e0fffe17 	ldw	r3,-8(fp)
 1007a80:	18c00117 	ldw	r3,4(r3)
 1007a84:	1809883a 	mov	r4,r3
 1007a88:	103ee83a 	callr	r2
	vPortFree(wrap_p);
 1007a8c:	e13ffe17 	ldw	r4,-8(fp)
 1007a90:	10012840 	call	1001284 <vPortFree>
	vTaskDelete(NULL);
 1007a94:	0009883a 	mov	r4,zero
 1007a98:	1003ae40 	call	1003ae4 <vTaskDelete>
}       
 1007a9c:	0001883a 	nop
 1007aa0:	e037883a 	mov	sp,fp
 1007aa4:	dfc00117 	ldw	ra,4(sp)
 1007aa8:	df000017 	ldw	fp,0(sp)
 1007aac:	dec00204 	addi	sp,sp,8
 1007ab0:	f800283a 	ret

01007ab4 <metal_run>:

int metal_run(int threads, metal_thread_t child, void *arg)
{
 1007ab4:	defff504 	addi	sp,sp,-44
 1007ab8:	dfc00a15 	stw	ra,40(sp)
 1007abc:	df000915 	stw	fp,36(sp)
 1007ac0:	dc000815 	stw	r16,32(sp)
 1007ac4:	df000904 	addi	fp,sp,36
 1007ac8:	e13ffc15 	stw	r4,-16(fp)
 1007acc:	e17ffd15 	stw	r5,-12(fp)
 1007ad0:	e1bffe15 	stw	r6,-8(fp)
 1007ad4:	d809883a 	mov	r4,sp
 1007ad8:	2021883a 	mov	r16,r4
	TaskHandle_t tids[threads];
 1007adc:	e13ffc17 	ldw	r4,-16(fp)
 1007ae0:	217fffc4 	addi	r5,r4,-1
 1007ae4:	e17ff815 	stw	r5,-32(fp)
 1007ae8:	200b883a 	mov	r5,r4
 1007aec:	2817883a 	mov	r11,r5
 1007af0:	0019883a 	mov	r12,zero
 1007af4:	580ad6fa 	srli	r5,r11,27
 1007af8:	6010917a 	slli	r8,r12,5
 1007afc:	2a10b03a 	or	r8,r5,r8
 1007b00:	580e917a 	slli	r7,r11,5
 1007b04:	200b883a 	mov	r5,r4
 1007b08:	2813883a 	mov	r9,r5
 1007b0c:	0015883a 	mov	r10,zero
 1007b10:	480ad6fa 	srli	r5,r9,27
 1007b14:	5006917a 	slli	r3,r10,5
 1007b18:	28c6b03a 	or	r3,r5,r3
 1007b1c:	4804917a 	slli	r2,r9,5
 1007b20:	2005883a 	mov	r2,r4
 1007b24:	1085883a 	add	r2,r2,r2
 1007b28:	1085883a 	add	r2,r2,r2
 1007b2c:	108000c4 	addi	r2,r2,3
 1007b30:	108000c4 	addi	r2,r2,3
 1007b34:	1004d0ba 	srli	r2,r2,2
 1007b38:	1085883a 	add	r2,r2,r2
 1007b3c:	1085883a 	add	r2,r2,r2
 1007b40:	d8b7c83a 	sub	sp,sp,r2
 1007b44:	d8800104 	addi	r2,sp,4
 1007b48:	108000c4 	addi	r2,r2,3
 1007b4c:	1004d0ba 	srli	r2,r2,2
 1007b50:	1085883a 	add	r2,r2,r2
 1007b54:	1085883a 	add	r2,r2,r2
 1007b58:	e0bff915 	stw	r2,-28(fp)
	int error, ts_created;

	error = metal_run_noblock(threads, child, arg, (void *)tids, &ts_created);
 1007b5c:	e0fff917 	ldw	r3,-28(fp)
 1007b60:	e0bffb04 	addi	r2,fp,-20
 1007b64:	d8800015 	stw	r2,0(sp)
 1007b68:	180f883a 	mov	r7,r3
 1007b6c:	e1bffe17 	ldw	r6,-8(fp)
 1007b70:	e17ffd17 	ldw	r5,-12(fp)
 1007b74:	e13ffc17 	ldw	r4,-16(fp)
 1007b78:	1007bb40 	call	1007bb4 <metal_run_noblock>
 1007b7c:	e0bffa15 	stw	r2,-24(fp)

	metal_finish_threads(ts_created, (void *)tids);
 1007b80:	e0bffb17 	ldw	r2,-20(fp)
 1007b84:	e0fff917 	ldw	r3,-28(fp)
 1007b88:	180b883a 	mov	r5,r3
 1007b8c:	1009883a 	mov	r4,r2
 1007b90:	1007dc80 	call	1007dc8 <metal_finish_threads>

	return error;
 1007b94:	e0bffa17 	ldw	r2,-24(fp)
 1007b98:	8037883a 	mov	sp,r16
}
 1007b9c:	e6ffff04 	addi	sp,fp,-4
 1007ba0:	dfc00217 	ldw	ra,8(sp)
 1007ba4:	df000117 	ldw	fp,4(sp)
 1007ba8:	dc000017 	ldw	r16,0(sp)
 1007bac:	dec00304 	addi	sp,sp,12
 1007bb0:	f800283a 	ret

01007bb4 <metal_run_noblock>:


int metal_run_noblock(int threads, metal_thread_t child,
		     void *arg, void *tids, int *threads_out)
{
 1007bb4:	defff004 	addi	sp,sp,-64
 1007bb8:	dfc00f15 	stw	ra,60(sp)
 1007bbc:	df000e15 	stw	fp,56(sp)
 1007bc0:	df000e04 	addi	fp,sp,56
 1007bc4:	e13ffc15 	stw	r4,-16(fp)
 1007bc8:	e17ffd15 	stw	r5,-12(fp)
 1007bcc:	e1bffe15 	stw	r6,-8(fp)
 1007bd0:	e1ffff15 	stw	r7,-4(fp)
	int i;
	TaskHandle_t *tid_p = (TaskHandle_t *)tids;
 1007bd4:	e0bfff17 	ldw	r2,-4(fp)
 1007bd8:	e0bff615 	stw	r2,-40(fp)
	BaseType_t stat = pdPASS;
 1007bdc:	00800044 	movi	r2,1
 1007be0:	e0bff515 	stw	r2,-44(fp)
	char tn[15];
	thread_wrap_arg_t *wrap_p;

	if (!tids) {
 1007be4:	e0bfff17 	ldw	r2,-4(fp)
 1007be8:	1000121e 	bne	r2,zero,1007c34 <metal_run_noblock+0x80>
		metal_log(METAL_LOG_ERROR, "invalid argument, tids is NULL.\n");
 1007bec:	008060f4 	movhi	r2,387
 1007bf0:	10baf104 	addi	r2,r2,-5180
 1007bf4:	10800017 	ldw	r2,0(r2)
 1007bf8:	108000f0 	cmpltui	r2,r2,3
 1007bfc:	10000b1e 	bne	r2,zero,1007c2c <metal_run_noblock+0x78>
 1007c00:	008060f4 	movhi	r2,387
 1007c04:	10baf104 	addi	r2,r2,-5180
 1007c08:	10800117 	ldw	r2,4(r2)
 1007c0c:	10000726 	beq	r2,zero,1007c2c <metal_run_noblock+0x78>
 1007c10:	008060f4 	movhi	r2,387
 1007c14:	10baf104 	addi	r2,r2,-5180
 1007c18:	10800117 	ldw	r2,4(r2)
 1007c1c:	014040f4 	movhi	r5,259
 1007c20:	2964f204 	addi	r5,r5,-27704
 1007c24:	010000c4 	movi	r4,3
 1007c28:	103ee83a 	callr	r2
		return -EINVAL;
 1007c2c:	00bffa84 	movi	r2,-22
 1007c30:	00006006 	br	1007db4 <metal_run_noblock+0x200>
	}

	for (i = 0; i < threads; i++) {
 1007c34:	e03ff415 	stw	zero,-48(fp)
 1007c38:	00004f06 	br	1007d78 <metal_run_noblock+0x1c4>
		snprintf(tn, metal_dim(tn), "%d", i);
 1007c3c:	e0bff804 	addi	r2,fp,-32
 1007c40:	e1fff417 	ldw	r7,-48(fp)
 1007c44:	018040f4 	movhi	r6,259
 1007c48:	31a4fb04 	addi	r6,r6,-27668
 1007c4c:	014003c4 	movi	r5,15
 1007c50:	1009883a 	mov	r4,r2
 1007c54:	1015d7c0 	call	1015d7c <snprintf>
		wrap_p = pvPortMalloc(sizeof(thread_wrap_arg_t));
 1007c58:	01000204 	movi	r4,8
 1007c5c:	10010b00 	call	10010b0 <pvPortMalloc>
 1007c60:	e0bff715 	stw	r2,-36(fp)
		if (!wrap_p) {
 1007c64:	e0bff717 	ldw	r2,-36(fp)
 1007c68:	1000121e 	bne	r2,zero,1007cb4 <metal_run_noblock+0x100>
			metal_log(METAL_LOG_ERROR, "failed to allocate wrapper %d\n", i);
 1007c6c:	008060f4 	movhi	r2,387
 1007c70:	10baf104 	addi	r2,r2,-5180
 1007c74:	10800017 	ldw	r2,0(r2)
 1007c78:	108000f0 	cmpltui	r2,r2,3
 1007c7c:	1000421e 	bne	r2,zero,1007d88 <metal_run_noblock+0x1d4>
 1007c80:	008060f4 	movhi	r2,387
 1007c84:	10baf104 	addi	r2,r2,-5180
 1007c88:	10800117 	ldw	r2,4(r2)
 1007c8c:	10003e26 	beq	r2,zero,1007d88 <metal_run_noblock+0x1d4>
 1007c90:	008060f4 	movhi	r2,387
 1007c94:	10baf104 	addi	r2,r2,-5180
 1007c98:	10800117 	ldw	r2,4(r2)
 1007c9c:	e1bff417 	ldw	r6,-48(fp)
 1007ca0:	014040f4 	movhi	r5,259
 1007ca4:	2964fc04 	addi	r5,r5,-27664
 1007ca8:	010000c4 	movi	r4,3
 1007cac:	103ee83a 	callr	r2
			break;
 1007cb0:	00003506 	br	1007d88 <metal_run_noblock+0x1d4>
		}
			
		wrap_p->thread_func = child;
 1007cb4:	e0bff717 	ldw	r2,-36(fp)
 1007cb8:	e0fffd17 	ldw	r3,-12(fp)
 1007cbc:	10c00015 	stw	r3,0(r2)
		wrap_p->arg = arg;
 1007cc0:	e0bff717 	ldw	r2,-36(fp)
 1007cc4:	e0fffe17 	ldw	r3,-8(fp)
 1007cc8:	10c00115 	stw	r3,4(r2)
		stat = xTaskCreate(thread_wrapper, tn, TEST_THREAD_STACK_SIZE,
 1007ccc:	e0bff417 	ldw	r2,-48(fp)
				   wrap_p, 2, &tid_p[i]);
 1007cd0:	1085883a 	add	r2,r2,r2
 1007cd4:	1085883a 	add	r2,r2,r2
 1007cd8:	1007883a 	mov	r3,r2
			break;
		}
			
		wrap_p->thread_func = child;
		wrap_p->arg = arg;
		stat = xTaskCreate(thread_wrapper, tn, TEST_THREAD_STACK_SIZE,
 1007cdc:	e0bff617 	ldw	r2,-40(fp)
 1007ce0:	10c5883a 	add	r2,r2,r3
 1007ce4:	e0fff804 	addi	r3,fp,-32
 1007ce8:	d8800115 	stw	r2,4(sp)
 1007cec:	00800084 	movi	r2,2
 1007cf0:	d8800015 	stw	r2,0(sp)
 1007cf4:	e1fff717 	ldw	r7,-36(fp)
 1007cf8:	01802004 	movi	r6,128
 1007cfc:	180b883a 	mov	r5,r3
 1007d00:	01004034 	movhi	r4,256
 1007d04:	211e9604 	addi	r4,r4,31320
 1007d08:	100371c0 	call	100371c <xTaskCreate>
 1007d0c:	e0bff515 	stw	r2,-44(fp)
				   wrap_p, 2, &tid_p[i]);
		if (stat != pdPASS) {
 1007d10:	e0bff517 	ldw	r2,-44(fp)
 1007d14:	10800060 	cmpeqi	r2,r2,1
 1007d18:	1000141e 	bne	r2,zero,1007d6c <metal_run_noblock+0x1b8>
			metal_log(METAL_LOG_ERROR, "failed to create thread %d\n", i);
 1007d1c:	008060f4 	movhi	r2,387
 1007d20:	10baf104 	addi	r2,r2,-5180
 1007d24:	10800017 	ldw	r2,0(r2)
 1007d28:	108000f0 	cmpltui	r2,r2,3
 1007d2c:	10000c1e 	bne	r2,zero,1007d60 <metal_run_noblock+0x1ac>
 1007d30:	008060f4 	movhi	r2,387
 1007d34:	10baf104 	addi	r2,r2,-5180
 1007d38:	10800117 	ldw	r2,4(r2)
 1007d3c:	10000826 	beq	r2,zero,1007d60 <metal_run_noblock+0x1ac>
 1007d40:	008060f4 	movhi	r2,387
 1007d44:	10baf104 	addi	r2,r2,-5180
 1007d48:	10800117 	ldw	r2,4(r2)
 1007d4c:	e1bff417 	ldw	r6,-48(fp)
 1007d50:	014040f4 	movhi	r5,259
 1007d54:	29650404 	addi	r5,r5,-27632
 1007d58:	010000c4 	movi	r4,3
 1007d5c:	103ee83a 	callr	r2
			vPortFree(wrap_p);
 1007d60:	e13ff717 	ldw	r4,-36(fp)
 1007d64:	10012840 	call	1001284 <vPortFree>
			break;
 1007d68:	00000806 	br	1007d8c <metal_run_noblock+0x1d8>
	if (!tids) {
		metal_log(METAL_LOG_ERROR, "invalid argument, tids is NULL.\n");
		return -EINVAL;
	}

	for (i = 0; i < threads; i++) {
 1007d6c:	e0bff417 	ldw	r2,-48(fp)
 1007d70:	10800044 	addi	r2,r2,1
 1007d74:	e0bff415 	stw	r2,-48(fp)
 1007d78:	e0fff417 	ldw	r3,-48(fp)
 1007d7c:	e0bffc17 	ldw	r2,-16(fp)
 1007d80:	18bfae16 	blt	r3,r2,1007c3c <__alt_data_end+0xff007c3c>
 1007d84:	00000106 	br	1007d8c <metal_run_noblock+0x1d8>
		snprintf(tn, metal_dim(tn), "%d", i);
		wrap_p = pvPortMalloc(sizeof(thread_wrap_arg_t));
		if (!wrap_p) {
			metal_log(METAL_LOG_ERROR, "failed to allocate wrapper %d\n", i);
			break;
 1007d88:	0001883a 	nop
			vPortFree(wrap_p);
			break;
		}
	}

	*threads_out = i;
 1007d8c:	e0800217 	ldw	r2,8(fp)
 1007d90:	e0fff417 	ldw	r3,-48(fp)
 1007d94:	10c00015 	stw	r3,0(r2)
	return pdPASS == stat ? 0 : -ENOMEM;
 1007d98:	e0bff517 	ldw	r2,-44(fp)
 1007d9c:	10800058 	cmpnei	r2,r2,1
 1007da0:	1000021e 	bne	r2,zero,1007dac <metal_run_noblock+0x1f8>
 1007da4:	0005883a 	mov	r2,zero
 1007da8:	00000206 	br	1007db4 <metal_run_noblock+0x200>
 1007dac:	00bffd04 	movi	r2,-12
 1007db0:	0001883a 	nop
}
 1007db4:	e037883a 	mov	sp,fp
 1007db8:	dfc00117 	ldw	ra,4(sp)
 1007dbc:	df000017 	ldw	fp,0(sp)
 1007dc0:	dec00204 	addi	sp,sp,8
 1007dc4:	f800283a 	ret

01007dc8 <metal_finish_threads>:


void metal_finish_threads(int threads, void *tids)
{
 1007dc8:	defff904 	addi	sp,sp,-28
 1007dcc:	dfc00615 	stw	ra,24(sp)
 1007dd0:	df000515 	stw	fp,20(sp)
 1007dd4:	df000504 	addi	fp,sp,20
 1007dd8:	e13ffe15 	stw	r4,-8(fp)
 1007ddc:	e17fff15 	stw	r5,-4(fp)
	int i;
	TaskHandle_t *tid_p = (TaskHandle_t *)tids;
 1007de0:	e0bfff17 	ldw	r2,-4(fp)
 1007de4:	e0bffc15 	stw	r2,-16(fp)

	if (!tids) {
 1007de8:	e0bfff17 	ldw	r2,-4(fp)
 1007dec:	1000111e 	bne	r2,zero,1007e34 <metal_finish_threads+0x6c>
		metal_log(METAL_LOG_ERROR, "invalid argument, tids is NULL.\n");
 1007df0:	008060f4 	movhi	r2,387
 1007df4:	10baf104 	addi	r2,r2,-5180
 1007df8:	10800017 	ldw	r2,0(r2)
 1007dfc:	108000f0 	cmpltui	r2,r2,3
 1007e00:	1000231e 	bne	r2,zero,1007e90 <metal_finish_threads+0xc8>
 1007e04:	008060f4 	movhi	r2,387
 1007e08:	10baf104 	addi	r2,r2,-5180
 1007e0c:	10800117 	ldw	r2,4(r2)
 1007e10:	10001f26 	beq	r2,zero,1007e90 <metal_finish_threads+0xc8>
 1007e14:	008060f4 	movhi	r2,387
 1007e18:	10baf104 	addi	r2,r2,-5180
 1007e1c:	10800117 	ldw	r2,4(r2)
 1007e20:	014040f4 	movhi	r5,259
 1007e24:	2964f204 	addi	r5,r5,-27704
 1007e28:	010000c4 	movi	r4,3
 1007e2c:	103ee83a 	callr	r2
		return;
 1007e30:	00001706 	br	1007e90 <metal_finish_threads+0xc8>
	}

	for (i = 0; i < threads; i++) {
 1007e34:	e03ffb15 	stw	zero,-20(fp)
 1007e38:	00001106 	br	1007e80 <metal_finish_threads+0xb8>
		eTaskState ts;
		do {
			taskYIELD();
 1007e3c:	003b683a 	trap	0
			ts=eTaskGetState(tid_p[i]);
 1007e40:	e0bffb17 	ldw	r2,-20(fp)
 1007e44:	1085883a 	add	r2,r2,r2
 1007e48:	1085883a 	add	r2,r2,r2
 1007e4c:	1007883a 	mov	r3,r2
 1007e50:	e0bffc17 	ldw	r2,-16(fp)
 1007e54:	10c5883a 	add	r2,r2,r3
 1007e58:	10800017 	ldw	r2,0(r2)
 1007e5c:	1009883a 	mov	r4,r2
 1007e60:	1003d180 	call	1003d18 <eTaskGetState>
 1007e64:	e0bffd15 	stw	r2,-12(fp)
		} while (ts != eDeleted);
 1007e68:	e0bffd17 	ldw	r2,-12(fp)
 1007e6c:	10800118 	cmpnei	r2,r2,4
 1007e70:	103ff21e 	bne	r2,zero,1007e3c <__alt_data_end+0xff007e3c>
	if (!tids) {
		metal_log(METAL_LOG_ERROR, "invalid argument, tids is NULL.\n");
		return;
	}

	for (i = 0; i < threads; i++) {
 1007e74:	e0bffb17 	ldw	r2,-20(fp)
 1007e78:	10800044 	addi	r2,r2,1
 1007e7c:	e0bffb15 	stw	r2,-20(fp)
 1007e80:	e0fffb17 	ldw	r3,-20(fp)
 1007e84:	e0bffe17 	ldw	r2,-8(fp)
 1007e88:	18bfec16 	blt	r3,r2,1007e3c <__alt_data_end+0xff007e3c>
 1007e8c:	00000106 	br	1007e94 <metal_finish_threads+0xcc>
	int i;
	TaskHandle_t *tid_p = (TaskHandle_t *)tids;

	if (!tids) {
		metal_log(METAL_LOG_ERROR, "invalid argument, tids is NULL.\n");
		return;
 1007e90:	0001883a 	nop
		do {
			taskYIELD();
			ts=eTaskGetState(tid_p[i]);
		} while (ts != eDeleted);
	}
}
 1007e94:	e037883a 	mov	sp,fp
 1007e98:	dfc00117 	ldw	ra,4(sp)
 1007e9c:	df000017 	ldw	fp,0(sp)
 1007ea0:	dec00204 	addi	sp,sp,8
 1007ea4:	f800283a 	ret

01007ea8 <metal_get_timestamp>:
#include <task.h>

#include <time.h>

unsigned long long metal_get_timestamp(void)
{
 1007ea8:	defffc04 	addi	sp,sp,-16
 1007eac:	dfc00315 	stw	ra,12(sp)
 1007eb0:	df000215 	stw	fp,8(sp)
 1007eb4:	dc400115 	stw	r17,4(sp)
 1007eb8:	dc000015 	stw	r16,0(sp)
 1007ebc:	df000204 	addi	fp,sp,8
	return (unsigned long long)xTaskGetTickCount();
 1007ec0:	10045e00 	call	10045e0 <xTaskGetTickCount>
 1007ec4:	1021883a 	mov	r16,r2
 1007ec8:	0023883a 	mov	r17,zero
 1007ecc:	8007883a 	mov	r3,r16
 1007ed0:	8809883a 	mov	r4,r17
}
 1007ed4:	1805883a 	mov	r2,r3
 1007ed8:	2007883a 	mov	r3,r4
 1007edc:	e6fffe04 	addi	sp,fp,-8
 1007ee0:	dfc00317 	ldw	ra,12(sp)
 1007ee4:	df000217 	ldw	fp,8(sp)
 1007ee8:	dc400117 	ldw	r17,4(sp)
 1007eec:	dc000017 	ldw	r16,0(sp)
 1007ef0:	dec00404 	addi	sp,sp,16
 1007ef4:	f800283a 	ret

01007ef8 <metal_list_init>:
 */
#define METAL_DECLARE_LIST(name)			\
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
 1007ef8:	defffe04 	addi	sp,sp,-8
 1007efc:	df000115 	stw	fp,4(sp)
 1007f00:	df000104 	addi	fp,sp,4
 1007f04:	e13fff15 	stw	r4,-4(fp)
	list->next = list->prev = list;
 1007f08:	e0bfff17 	ldw	r2,-4(fp)
 1007f0c:	e0ffff17 	ldw	r3,-4(fp)
 1007f10:	10c00115 	stw	r3,4(r2)
 1007f14:	e0bfff17 	ldw	r2,-4(fp)
 1007f18:	10c00117 	ldw	r3,4(r2)
 1007f1c:	e0bfff17 	ldw	r2,-4(fp)
 1007f20:	10c00015 	stw	r3,0(r2)
}
 1007f24:	0001883a 	nop
 1007f28:	e037883a 	mov	sp,fp
 1007f2c:	df000017 	ldw	fp,0(sp)
 1007f30:	dec00104 	addi	sp,sp,4
 1007f34:	f800283a 	ret

01007f38 <metal_init>:
#include <string.h>

#include <sys.h>

int metal_init(const struct metal_init_params *params)
{
 1007f38:	defffc04 	addi	sp,sp,-16
 1007f3c:	dfc00315 	stw	ra,12(sp)
 1007f40:	df000215 	stw	fp,8(sp)
 1007f44:	df000204 	addi	fp,sp,8
 1007f48:	e13fff15 	stw	r4,-4(fp)
	int error = 0;
 1007f4c:	e03ffe15 	stw	zero,-8(fp)

	memset(&_metal, 0, sizeof(_metal));
 1007f50:	01800804 	movi	r6,32
 1007f54:	000b883a 	mov	r5,zero
 1007f58:	010060f4 	movhi	r4,387
 1007f5c:	213af104 	addi	r4,r4,-5180
 1007f60:	1015a3c0 	call	1015a3c <memset>

	_metal.common.log_handler   = params->log_handler;
 1007f64:	e0bfff17 	ldw	r2,-4(fp)
 1007f68:	10c00017 	ldw	r3,0(r2)
 1007f6c:	008060f4 	movhi	r2,387
 1007f70:	10baf104 	addi	r2,r2,-5180
 1007f74:	10c00115 	stw	r3,4(r2)
	_metal.common.log_level     = params->log_level;
 1007f78:	e0bfff17 	ldw	r2,-4(fp)
 1007f7c:	10c00117 	ldw	r3,4(r2)
 1007f80:	008060f4 	movhi	r2,387
 1007f84:	10baf104 	addi	r2,r2,-5180
 1007f88:	10c00015 	stw	r3,0(r2)

	metal_list_init(&_metal.common.bus_list);
 1007f8c:	010060f4 	movhi	r4,387
 1007f90:	213af304 	addi	r4,r4,-5172
 1007f94:	1007ef80 	call	1007ef8 <metal_list_init>
	metal_list_init(&_metal.common.generic_shmem_list);
 1007f98:	010060f4 	movhi	r4,387
 1007f9c:	213af504 	addi	r4,r4,-5164
 1007fa0:	1007ef80 	call	1007ef8 <metal_list_init>
	metal_list_init(&_metal.common.generic_device_list);
 1007fa4:	010060f4 	movhi	r4,387
 1007fa8:	213af704 	addi	r4,r4,-5156
 1007fac:	1007ef80 	call	1007ef8 <metal_list_init>

	error = metal_sys_init(params);
 1007fb0:	e13fff17 	ldw	r4,-4(fp)
 1007fb4:	10070640 	call	1007064 <metal_sys_init>
 1007fb8:	e0bffe15 	stw	r2,-8(fp)
	if (error)
 1007fbc:	e0bffe17 	ldw	r2,-8(fp)
 1007fc0:	10000226 	beq	r2,zero,1007fcc <metal_init+0x94>
		return error;
 1007fc4:	e0bffe17 	ldw	r2,-8(fp)
 1007fc8:	00000106 	br	1007fd0 <metal_init+0x98>

	return error;
 1007fcc:	e0bffe17 	ldw	r2,-8(fp)
}
 1007fd0:	e037883a 	mov	sp,fp
 1007fd4:	dfc00117 	ldw	ra,4(sp)
 1007fd8:	df000017 	ldw	fp,0(sp)
 1007fdc:	dec00204 	addi	sp,sp,8
 1007fe0:	f800283a 	ret

01007fe4 <metal_finish>:

void metal_finish(void)
{
 1007fe4:	defffe04 	addi	sp,sp,-8
 1007fe8:	dfc00115 	stw	ra,4(sp)
 1007fec:	df000015 	stw	fp,0(sp)
 1007ff0:	d839883a 	mov	fp,sp
	metal_sys_finish();
 1007ff4:	100709c0 	call	100709c <metal_sys_finish>
	memset(&_metal, 0, sizeof(_metal));
 1007ff8:	01800804 	movi	r6,32
 1007ffc:	000b883a 	mov	r5,zero
 1008000:	010060f4 	movhi	r4,387
 1008004:	213af104 	addi	r4,r4,-5180
 1008008:	1015a3c0 	call	1015a3c <memset>
}
 100800c:	0001883a 	nop
 1008010:	e037883a 	mov	sp,fp
 1008014:	dfc00117 	ldw	ra,4(sp)
 1008018:	df000017 	ldw	fp,0(sp)
 100801c:	dec00204 	addi	sp,sp,8
 1008020:	f800283a 	ret

01008024 <metal_io_virt>:
 * @param[in]	offset	Offset into shared memory segment.
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
 1008024:	defffd04 	addi	sp,sp,-12
 1008028:	df000215 	stw	fp,8(sp)
 100802c:	df000204 	addi	fp,sp,8
 1008030:	e13ffe15 	stw	r4,-8(fp)
 1008034:	e17fff15 	stw	r5,-4(fp)
	return (io->virt != METAL_BAD_VA && offset < io->size
 1008038:	e0bffe17 	ldw	r2,-8(fp)
 100803c:	10800017 	ldw	r2,0(r2)
		? (uint8_t *)io->virt + offset
		: NULL);
 1008040:	10bfffe0 	cmpeqi	r2,r2,-1
 1008044:	1000091e 	bne	r2,zero,100806c <metal_io_virt+0x48>
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
	return (io->virt != METAL_BAD_VA && offset < io->size
 1008048:	e0bffe17 	ldw	r2,-8(fp)
 100804c:	10800217 	ldw	r2,8(r2)
 1008050:	e0ffff17 	ldw	r3,-4(fp)
 1008054:	1880052e 	bgeu	r3,r2,100806c <metal_io_virt+0x48>
		? (uint8_t *)io->virt + offset
 1008058:	e0bffe17 	ldw	r2,-8(fp)
 100805c:	10c00017 	ldw	r3,0(r2)
		: NULL);
 1008060:	e0bfff17 	ldw	r2,-4(fp)
 1008064:	1885883a 	add	r2,r3,r2
 1008068:	00000106 	br	1008070 <metal_io_virt+0x4c>
 100806c:	0005883a 	mov	r2,zero
}
 1008070:	e037883a 	mov	sp,fp
 1008074:	df000017 	ldw	fp,0(sp)
 1008078:	dec00104 	addi	sp,sp,4
 100807c:	f800283a 	ret

01008080 <metal_io_init>:

void metal_io_init(struct metal_io_region *io, void *virt,
	      const metal_phys_addr_t *physmap, size_t size,
	      unsigned page_shift, unsigned int mem_flags,
	      const struct metal_io_ops *ops)
{
 1008080:	defff204 	addi	sp,sp,-56
 1008084:	dfc00d15 	stw	ra,52(sp)
 1008088:	df000c15 	stw	fp,48(sp)
 100808c:	df000c04 	addi	fp,sp,48
 1008090:	e13ffc15 	stw	r4,-16(fp)
 1008094:	e17ffd15 	stw	r5,-12(fp)
 1008098:	e1bffe15 	stw	r6,-8(fp)
 100809c:	e1ffff15 	stw	r7,-4(fp)
	const struct metal_io_ops nops = {
 10080a0:	e03ff415 	stw	zero,-48(fp)
 10080a4:	e03ff515 	stw	zero,-44(fp)
 10080a8:	e03ff615 	stw	zero,-40(fp)
 10080ac:	e03ff715 	stw	zero,-36(fp)
 10080b0:	e03ff815 	stw	zero,-32(fp)
 10080b4:	e03ff915 	stw	zero,-28(fp)
 10080b8:	e03ffa15 	stw	zero,-24(fp)
 10080bc:	e03ffb15 	stw	zero,-20(fp)
		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
	};

	io->virt = virt;
 10080c0:	e0bffc17 	ldw	r2,-16(fp)
 10080c4:	e0fffd17 	ldw	r3,-12(fp)
 10080c8:	10c00015 	stw	r3,0(r2)
	io->physmap = physmap;
 10080cc:	e0bffc17 	ldw	r2,-16(fp)
 10080d0:	e0fffe17 	ldw	r3,-8(fp)
 10080d4:	10c00115 	stw	r3,4(r2)
	io->size = size;
 10080d8:	e0bffc17 	ldw	r2,-16(fp)
 10080dc:	e0ffff17 	ldw	r3,-4(fp)
 10080e0:	10c00215 	stw	r3,8(r2)
	io->page_shift = page_shift;
 10080e4:	e0bffc17 	ldw	r2,-16(fp)
 10080e8:	e0c00217 	ldw	r3,8(fp)
 10080ec:	10c00315 	stw	r3,12(r2)
	if (page_shift >= sizeof(io->page_mask) * CHAR_BIT)
 10080f0:	e0800217 	ldw	r2,8(fp)
 10080f4:	10800830 	cmpltui	r2,r2,32
 10080f8:	1000041e 	bne	r2,zero,100810c <metal_io_init+0x8c>
		/* avoid overflow */
		io->page_mask = -1UL;
 10080fc:	e0bffc17 	ldw	r2,-16(fp)
 1008100:	00ffffc4 	movi	r3,-1
 1008104:	10c00415 	stw	r3,16(r2)
 1008108:	00000606 	br	1008124 <metal_io_init+0xa4>
	else
		io->page_mask = (1UL << page_shift) - 1UL;
 100810c:	00c00044 	movi	r3,1
 1008110:	e0800217 	ldw	r2,8(fp)
 1008114:	1884983a 	sll	r2,r3,r2
 1008118:	10ffffc4 	addi	r3,r2,-1
 100811c:	e0bffc17 	ldw	r2,-16(fp)
 1008120:	10c00415 	stw	r3,16(r2)
	io->mem_flags = mem_flags;
 1008124:	e0bffc17 	ldw	r2,-16(fp)
 1008128:	e0c00317 	ldw	r3,12(fp)
 100812c:	10c00515 	stw	r3,20(r2)
	io->ops = ops ? *ops : nops;
 1008130:	e0800417 	ldw	r2,16(fp)
 1008134:	10001326 	beq	r2,zero,1008184 <metal_io_init+0x104>
 1008138:	e0bffc17 	ldw	r2,-16(fp)
 100813c:	e0c00417 	ldw	r3,16(fp)
 1008140:	19000017 	ldw	r4,0(r3)
 1008144:	11000615 	stw	r4,24(r2)
 1008148:	19000117 	ldw	r4,4(r3)
 100814c:	11000715 	stw	r4,28(r2)
 1008150:	19000217 	ldw	r4,8(r3)
 1008154:	11000815 	stw	r4,32(r2)
 1008158:	19000317 	ldw	r4,12(r3)
 100815c:	11000915 	stw	r4,36(r2)
 1008160:	19000417 	ldw	r4,16(r3)
 1008164:	11000a15 	stw	r4,40(r2)
 1008168:	19000517 	ldw	r4,20(r3)
 100816c:	11000b15 	stw	r4,44(r2)
 1008170:	19000617 	ldw	r4,24(r3)
 1008174:	11000c15 	stw	r4,48(r2)
 1008178:	18c00717 	ldw	r3,28(r3)
 100817c:	10c00d15 	stw	r3,52(r2)
 1008180:	00001106 	br	10081c8 <metal_io_init+0x148>
 1008184:	e0bffc17 	ldw	r2,-16(fp)
 1008188:	e0fff417 	ldw	r3,-48(fp)
 100818c:	10c00615 	stw	r3,24(r2)
 1008190:	e0fff517 	ldw	r3,-44(fp)
 1008194:	10c00715 	stw	r3,28(r2)
 1008198:	e0fff617 	ldw	r3,-40(fp)
 100819c:	10c00815 	stw	r3,32(r2)
 10081a0:	e0fff717 	ldw	r3,-36(fp)
 10081a4:	10c00915 	stw	r3,36(r2)
 10081a8:	e0fff817 	ldw	r3,-32(fp)
 10081ac:	10c00a15 	stw	r3,40(r2)
 10081b0:	e0fff917 	ldw	r3,-28(fp)
 10081b4:	10c00b15 	stw	r3,44(r2)
 10081b8:	e0fffa17 	ldw	r3,-24(fp)
 10081bc:	10c00c15 	stw	r3,48(r2)
 10081c0:	e0fffb17 	ldw	r3,-20(fp)
 10081c4:	10c00d15 	stw	r3,52(r2)
	metal_sys_io_mem_map(io);
 10081c8:	e13ffc17 	ldw	r4,-16(fp)
 10081cc:	10070d00 	call	10070d0 <metal_sys_io_mem_map>
}
 10081d0:	0001883a 	nop
 10081d4:	e037883a 	mov	sp,fp
 10081d8:	dfc00117 	ldw	ra,4(sp)
 10081dc:	df000017 	ldw	fp,0(sp)
 10081e0:	dec00204 	addi	sp,sp,8
 10081e4:	f800283a 	ret

010081e8 <metal_io_block_read>:

int metal_io_block_read(struct metal_io_region *io, unsigned long offset,
	       void *restrict dst, int len)
{
 10081e8:	defff604 	addi	sp,sp,-40
 10081ec:	dfc00915 	stw	ra,36(sp)
 10081f0:	df000815 	stw	fp,32(sp)
 10081f4:	df000804 	addi	fp,sp,32
 10081f8:	e13ffc15 	stw	r4,-16(fp)
 10081fc:	e17ffd15 	stw	r5,-12(fp)
 1008200:	e1bffe15 	stw	r6,-8(fp)
 1008204:	e1ffff15 	stw	r7,-4(fp)
	unsigned char *ptr = metal_io_virt(io, offset);
 1008208:	e17ffd17 	ldw	r5,-12(fp)
 100820c:	e13ffc17 	ldw	r4,-16(fp)
 1008210:	10080240 	call	1008024 <metal_io_virt>
 1008214:	e0bff915 	stw	r2,-28(fp)
	unsigned char *dest = dst;
 1008218:	e0bffe17 	ldw	r2,-8(fp)
 100821c:	e0bffa15 	stw	r2,-24(fp)
	int retlen;

	if (offset >= io->size)
 1008220:	e0bffc17 	ldw	r2,-16(fp)
 1008224:	10800217 	ldw	r2,8(r2)
 1008228:	e0fffd17 	ldw	r3,-12(fp)
 100822c:	18800236 	bltu	r3,r2,1008238 <metal_io_block_read+0x50>
		return -ERANGE;
 1008230:	00bff784 	movi	r2,-34
 1008234:	00005406 	br	1008388 <metal_io_block_read+0x1a0>
	if ((offset + len) > io->size)
 1008238:	e0ffff17 	ldw	r3,-4(fp)
 100823c:	e0bffd17 	ldw	r2,-12(fp)
 1008240:	1885883a 	add	r2,r3,r2
 1008244:	e0fffc17 	ldw	r3,-16(fp)
 1008248:	18c00217 	ldw	r3,8(r3)
 100824c:	1880052e 	bgeu	r3,r2,1008264 <metal_io_block_read+0x7c>
		len = io->size - offset;
 1008250:	e0bffc17 	ldw	r2,-16(fp)
 1008254:	10c00217 	ldw	r3,8(r2)
 1008258:	e0bffd17 	ldw	r2,-12(fp)
 100825c:	1885c83a 	sub	r2,r3,r2
 1008260:	e0bfff15 	stw	r2,-4(fp)
	retlen = len;
 1008264:	e0bfff17 	ldw	r2,-4(fp)
 1008268:	e0bffb15 	stw	r2,-20(fp)
	if (io->ops.block_read) {
 100826c:	e0bffc17 	ldw	r2,-16(fp)
 1008270:	10800817 	ldw	r2,32(r2)
 1008274:	10000b26 	beq	r2,zero,10082a4 <metal_io_block_read+0xbc>
		retlen = (*io->ops.block_read)(
 1008278:	e0bffc17 	ldw	r2,-16(fp)
 100827c:	10800817 	ldw	r2,32(r2)
 1008280:	e0ffff17 	ldw	r3,-4(fp)
 1008284:	d8c00015 	stw	r3,0(sp)
 1008288:	01c00144 	movi	r7,5
 100828c:	e1bffe17 	ldw	r6,-8(fp)
 1008290:	e17ffd17 	ldw	r5,-12(fp)
 1008294:	e13ffc17 	ldw	r4,-16(fp)
 1008298:	103ee83a 	callr	r2
 100829c:	e0bffb15 	stw	r2,-20(fp)
 10082a0:	00003806 	br	1008384 <metal_io_block_read+0x19c>
			io, offset, dst, memory_order_seq_cst, len);
	} else {
		atomic_thread_fence(memory_order_seq_cst);
 10082a4:	0001b03a 	sync
		while ( len && (
 10082a8:	00000d06 	br	10082e0 <metal_io_block_read+0xf8>
			((uintptr_t)dest % sizeof(int)) ||
			((uintptr_t)ptr % sizeof(int)))) {
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
 10082ac:	e0bff917 	ldw	r2,-28(fp)
 10082b0:	10c00003 	ldbu	r3,0(r2)
	} else {
		atomic_thread_fence(memory_order_seq_cst);
		while ( len && (
			((uintptr_t)dest % sizeof(int)) ||
			((uintptr_t)ptr % sizeof(int)))) {
			*(unsigned char *)dest =
 10082b4:	e0bffa17 	ldw	r2,-24(fp)
 10082b8:	10c00005 	stb	r3,0(r2)
				*(const unsigned char *)ptr;
			dest++;
 10082bc:	e0bffa17 	ldw	r2,-24(fp)
 10082c0:	10800044 	addi	r2,r2,1
 10082c4:	e0bffa15 	stw	r2,-24(fp)
			ptr++;
 10082c8:	e0bff917 	ldw	r2,-28(fp)
 10082cc:	10800044 	addi	r2,r2,1
 10082d0:	e0bff915 	stw	r2,-28(fp)
			len--;
 10082d4:	e0bfff17 	ldw	r2,-4(fp)
 10082d8:	10bfffc4 	addi	r2,r2,-1
 10082dc:	e0bfff15 	stw	r2,-4(fp)
	if (io->ops.block_read) {
		retlen = (*io->ops.block_read)(
			io, offset, dst, memory_order_seq_cst, len);
	} else {
		atomic_thread_fence(memory_order_seq_cst);
		while ( len && (
 10082e0:	e0bfff17 	ldw	r2,-4(fp)
 10082e4:	10001426 	beq	r2,zero,1008338 <metal_io_block_read+0x150>
			((uintptr_t)dest % sizeof(int)) ||
 10082e8:	e0bffa17 	ldw	r2,-24(fp)
 10082ec:	108000cc 	andi	r2,r2,3
	if (io->ops.block_read) {
		retlen = (*io->ops.block_read)(
			io, offset, dst, memory_order_seq_cst, len);
	} else {
		atomic_thread_fence(memory_order_seq_cst);
		while ( len && (
 10082f0:	103fee1e 	bne	r2,zero,10082ac <__alt_data_end+0xff0082ac>
			((uintptr_t)dest % sizeof(int)) ||
			((uintptr_t)ptr % sizeof(int)))) {
 10082f4:	e0bff917 	ldw	r2,-28(fp)
 10082f8:	108000cc 	andi	r2,r2,3
		retlen = (*io->ops.block_read)(
			io, offset, dst, memory_order_seq_cst, len);
	} else {
		atomic_thread_fence(memory_order_seq_cst);
		while ( len && (
			((uintptr_t)dest % sizeof(int)) ||
 10082fc:	103feb1e 	bne	r2,zero,10082ac <__alt_data_end+0xff0082ac>
				*(const unsigned char *)ptr;
			dest++;
			ptr++;
			len--;
		}
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 1008300:	00000d06 	br	1008338 <metal_io_block_read+0x150>
					ptr += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)dest = *(const unsigned int *)ptr;
 1008304:	e0bff917 	ldw	r2,-28(fp)
 1008308:	10c00017 	ldw	r3,0(r2)
 100830c:	e0bffa17 	ldw	r2,-24(fp)
 1008310:	10c00015 	stw	r3,0(r2)
				*(const unsigned char *)ptr;
			dest++;
			ptr++;
			len--;
		}
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 1008314:	e0bffa17 	ldw	r2,-24(fp)
 1008318:	10800104 	addi	r2,r2,4
 100831c:	e0bffa15 	stw	r2,-24(fp)
					ptr += sizeof(int),
 1008320:	e0bff917 	ldw	r2,-28(fp)
 1008324:	10800104 	addi	r2,r2,4
 1008328:	e0bff915 	stw	r2,-28(fp)
					len -= sizeof(int))
 100832c:	e0bfff17 	ldw	r2,-4(fp)
 1008330:	10bfff04 	addi	r2,r2,-4
 1008334:	e0bfff15 	stw	r2,-4(fp)
				*(const unsigned char *)ptr;
			dest++;
			ptr++;
			len--;
		}
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 1008338:	e0bfff17 	ldw	r2,-4(fp)
 100833c:	10800108 	cmpgei	r2,r2,4
 1008340:	103ff01e 	bne	r2,zero,1008304 <__alt_data_end+0xff008304>
					ptr += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)dest = *(const unsigned int *)ptr;
		for (; len != 0; dest++, ptr++, len--)
 1008344:	00000d06 	br	100837c <metal_io_block_read+0x194>
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
 1008348:	e0bff917 	ldw	r2,-28(fp)
 100834c:	10c00003 	ldbu	r3,0(r2)
		for (; len >= (int)sizeof(int); dest += sizeof(int),
					ptr += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)dest = *(const unsigned int *)ptr;
		for (; len != 0; dest++, ptr++, len--)
			*(unsigned char *)dest =
 1008350:	e0bffa17 	ldw	r2,-24(fp)
 1008354:	10c00005 	stb	r3,0(r2)
		}
		for (; len >= (int)sizeof(int); dest += sizeof(int),
					ptr += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)dest = *(const unsigned int *)ptr;
		for (; len != 0; dest++, ptr++, len--)
 1008358:	e0bffa17 	ldw	r2,-24(fp)
 100835c:	10800044 	addi	r2,r2,1
 1008360:	e0bffa15 	stw	r2,-24(fp)
 1008364:	e0bff917 	ldw	r2,-28(fp)
 1008368:	10800044 	addi	r2,r2,1
 100836c:	e0bff915 	stw	r2,-28(fp)
 1008370:	e0bfff17 	ldw	r2,-4(fp)
 1008374:	10bfffc4 	addi	r2,r2,-1
 1008378:	e0bfff15 	stw	r2,-4(fp)
 100837c:	e0bfff17 	ldw	r2,-4(fp)
 1008380:	103ff11e 	bne	r2,zero,1008348 <__alt_data_end+0xff008348>
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
	}
	return retlen;
 1008384:	e0bffb17 	ldw	r2,-20(fp)
}
 1008388:	e037883a 	mov	sp,fp
 100838c:	dfc00117 	ldw	ra,4(sp)
 1008390:	df000017 	ldw	fp,0(sp)
 1008394:	dec00204 	addi	sp,sp,8
 1008398:	f800283a 	ret

0100839c <metal_io_block_write>:

int metal_io_block_write(struct metal_io_region *io, unsigned long offset,
	       const void *restrict src, int len)
{
 100839c:	defff604 	addi	sp,sp,-40
 10083a0:	dfc00915 	stw	ra,36(sp)
 10083a4:	df000815 	stw	fp,32(sp)
 10083a8:	df000804 	addi	fp,sp,32
 10083ac:	e13ffc15 	stw	r4,-16(fp)
 10083b0:	e17ffd15 	stw	r5,-12(fp)
 10083b4:	e1bffe15 	stw	r6,-8(fp)
 10083b8:	e1ffff15 	stw	r7,-4(fp)
	unsigned char *ptr = metal_io_virt(io, offset);
 10083bc:	e17ffd17 	ldw	r5,-12(fp)
 10083c0:	e13ffc17 	ldw	r4,-16(fp)
 10083c4:	10080240 	call	1008024 <metal_io_virt>
 10083c8:	e0bff915 	stw	r2,-28(fp)
	const unsigned char *source = src;
 10083cc:	e0bffe17 	ldw	r2,-8(fp)
 10083d0:	e0bffa15 	stw	r2,-24(fp)
	int retlen;

	if (offset >= io->size)
 10083d4:	e0bffc17 	ldw	r2,-16(fp)
 10083d8:	10800217 	ldw	r2,8(r2)
 10083dc:	e0fffd17 	ldw	r3,-12(fp)
 10083e0:	18800236 	bltu	r3,r2,10083ec <metal_io_block_write+0x50>
		return -ERANGE;
 10083e4:	00bff784 	movi	r2,-34
 10083e8:	00005306 	br	1008538 <metal_io_block_write+0x19c>
	if ((offset + len) > io->size)
 10083ec:	e0ffff17 	ldw	r3,-4(fp)
 10083f0:	e0bffd17 	ldw	r2,-12(fp)
 10083f4:	1885883a 	add	r2,r3,r2
 10083f8:	e0fffc17 	ldw	r3,-16(fp)
 10083fc:	18c00217 	ldw	r3,8(r3)
 1008400:	1880052e 	bgeu	r3,r2,1008418 <metal_io_block_write+0x7c>
		len = io->size - offset;
 1008404:	e0bffc17 	ldw	r2,-16(fp)
 1008408:	10c00217 	ldw	r3,8(r2)
 100840c:	e0bffd17 	ldw	r2,-12(fp)
 1008410:	1885c83a 	sub	r2,r3,r2
 1008414:	e0bfff15 	stw	r2,-4(fp)
	retlen = len;
 1008418:	e0bfff17 	ldw	r2,-4(fp)
 100841c:	e0bffb15 	stw	r2,-20(fp)
	if (io->ops.block_write) {
 1008420:	e0bffc17 	ldw	r2,-16(fp)
 1008424:	10800917 	ldw	r2,36(r2)
 1008428:	10001826 	beq	r2,zero,100848c <metal_io_block_write+0xf0>
		retlen = (*io->ops.block_write)(
 100842c:	e0bffc17 	ldw	r2,-16(fp)
 1008430:	10800917 	ldw	r2,36(r2)
 1008434:	e0ffff17 	ldw	r3,-4(fp)
 1008438:	d8c00015 	stw	r3,0(sp)
 100843c:	01c00144 	movi	r7,5
 1008440:	e1bffe17 	ldw	r6,-8(fp)
 1008444:	e17ffd17 	ldw	r5,-12(fp)
 1008448:	e13ffc17 	ldw	r4,-16(fp)
 100844c:	103ee83a 	callr	r2
 1008450:	e0bffb15 	stw	r2,-20(fp)
 1008454:	00003706 	br	1008534 <metal_io_block_write+0x198>
	} else {
		while ( len && (
			((uintptr_t)ptr % sizeof(int)) ||
			((uintptr_t)source % sizeof(int)))) {
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
 1008458:	e0bffa17 	ldw	r2,-24(fp)
 100845c:	10c00003 	ldbu	r3,0(r2)
			io, offset, src, memory_order_seq_cst, len);
	} else {
		while ( len && (
			((uintptr_t)ptr % sizeof(int)) ||
			((uintptr_t)source % sizeof(int)))) {
			*(unsigned char *)ptr =
 1008460:	e0bff917 	ldw	r2,-28(fp)
 1008464:	10c00005 	stb	r3,0(r2)
				*(const unsigned char *)source;
			ptr++;
 1008468:	e0bff917 	ldw	r2,-28(fp)
 100846c:	10800044 	addi	r2,r2,1
 1008470:	e0bff915 	stw	r2,-28(fp)
			source++;
 1008474:	e0bffa17 	ldw	r2,-24(fp)
 1008478:	10800044 	addi	r2,r2,1
 100847c:	e0bffa15 	stw	r2,-24(fp)
			len--;
 1008480:	e0bfff17 	ldw	r2,-4(fp)
 1008484:	10bfffc4 	addi	r2,r2,-1
 1008488:	e0bfff15 	stw	r2,-4(fp)
	retlen = len;
	if (io->ops.block_write) {
		retlen = (*io->ops.block_write)(
			io, offset, src, memory_order_seq_cst, len);
	} else {
		while ( len && (
 100848c:	e0bfff17 	ldw	r2,-4(fp)
 1008490:	10001426 	beq	r2,zero,10084e4 <metal_io_block_write+0x148>
			((uintptr_t)ptr % sizeof(int)) ||
 1008494:	e0bff917 	ldw	r2,-28(fp)
 1008498:	108000cc 	andi	r2,r2,3
	retlen = len;
	if (io->ops.block_write) {
		retlen = (*io->ops.block_write)(
			io, offset, src, memory_order_seq_cst, len);
	} else {
		while ( len && (
 100849c:	103fee1e 	bne	r2,zero,1008458 <__alt_data_end+0xff008458>
			((uintptr_t)ptr % sizeof(int)) ||
			((uintptr_t)source % sizeof(int)))) {
 10084a0:	e0bffa17 	ldw	r2,-24(fp)
 10084a4:	108000cc 	andi	r2,r2,3
	if (io->ops.block_write) {
		retlen = (*io->ops.block_write)(
			io, offset, src, memory_order_seq_cst, len);
	} else {
		while ( len && (
			((uintptr_t)ptr % sizeof(int)) ||
 10084a8:	103feb1e 	bne	r2,zero,1008458 <__alt_data_end+0xff008458>
				*(const unsigned char *)source;
			ptr++;
			source++;
			len--;
		}
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 10084ac:	00000d06 	br	10084e4 <metal_io_block_write+0x148>
					source += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)ptr = *(const unsigned int *)source;
 10084b0:	e0bffa17 	ldw	r2,-24(fp)
 10084b4:	10c00017 	ldw	r3,0(r2)
 10084b8:	e0bff917 	ldw	r2,-28(fp)
 10084bc:	10c00015 	stw	r3,0(r2)
				*(const unsigned char *)source;
			ptr++;
			source++;
			len--;
		}
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 10084c0:	e0bff917 	ldw	r2,-28(fp)
 10084c4:	10800104 	addi	r2,r2,4
 10084c8:	e0bff915 	stw	r2,-28(fp)
					source += sizeof(int),
 10084cc:	e0bffa17 	ldw	r2,-24(fp)
 10084d0:	10800104 	addi	r2,r2,4
 10084d4:	e0bffa15 	stw	r2,-24(fp)
					len -= sizeof(int))
 10084d8:	e0bfff17 	ldw	r2,-4(fp)
 10084dc:	10bfff04 	addi	r2,r2,-4
 10084e0:	e0bfff15 	stw	r2,-4(fp)
				*(const unsigned char *)source;
			ptr++;
			source++;
			len--;
		}
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 10084e4:	e0bfff17 	ldw	r2,-4(fp)
 10084e8:	10800108 	cmpgei	r2,r2,4
 10084ec:	103ff01e 	bne	r2,zero,10084b0 <__alt_data_end+0xff0084b0>
					source += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)ptr = *(const unsigned int *)source;
		for (; len != 0; ptr++, source++, len--)
 10084f0:	00000d06 	br	1008528 <metal_io_block_write+0x18c>
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
 10084f4:	e0bffa17 	ldw	r2,-24(fp)
 10084f8:	10c00003 	ldbu	r3,0(r2)
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
					source += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)ptr = *(const unsigned int *)source;
		for (; len != 0; ptr++, source++, len--)
			*(unsigned char *)ptr =
 10084fc:	e0bff917 	ldw	r2,-28(fp)
 1008500:	10c00005 	stb	r3,0(r2)
		}
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
					source += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)ptr = *(const unsigned int *)source;
		for (; len != 0; ptr++, source++, len--)
 1008504:	e0bff917 	ldw	r2,-28(fp)
 1008508:	10800044 	addi	r2,r2,1
 100850c:	e0bff915 	stw	r2,-28(fp)
 1008510:	e0bffa17 	ldw	r2,-24(fp)
 1008514:	10800044 	addi	r2,r2,1
 1008518:	e0bffa15 	stw	r2,-24(fp)
 100851c:	e0bfff17 	ldw	r2,-4(fp)
 1008520:	10bfffc4 	addi	r2,r2,-1
 1008524:	e0bfff15 	stw	r2,-4(fp)
 1008528:	e0bfff17 	ldw	r2,-4(fp)
 100852c:	103ff11e 	bne	r2,zero,10084f4 <__alt_data_end+0xff0084f4>
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
		atomic_thread_fence(memory_order_seq_cst);
 1008530:	0001b03a 	sync
	}
	return retlen;
 1008534:	e0bffb17 	ldw	r2,-20(fp)
}
 1008538:	e037883a 	mov	sp,fp
 100853c:	dfc00117 	ldw	ra,4(sp)
 1008540:	df000017 	ldw	fp,0(sp)
 1008544:	dec00204 	addi	sp,sp,8
 1008548:	f800283a 	ret

0100854c <metal_io_block_set>:

int metal_io_block_set(struct metal_io_region *io, unsigned long offset,
	       unsigned char value, int len)
{
 100854c:	defff504 	addi	sp,sp,-44
 1008550:	dfc00a15 	stw	ra,40(sp)
 1008554:	df000915 	stw	fp,36(sp)
 1008558:	df000904 	addi	fp,sp,36
 100855c:	e13ffc15 	stw	r4,-16(fp)
 1008560:	e17ffd15 	stw	r5,-12(fp)
 1008564:	3005883a 	mov	r2,r6
 1008568:	e1ffff15 	stw	r7,-4(fp)
 100856c:	e0bffe05 	stb	r2,-8(fp)
	unsigned char *ptr = metal_io_virt(io, offset);
 1008570:	e17ffd17 	ldw	r5,-12(fp)
 1008574:	e13ffc17 	ldw	r4,-16(fp)
 1008578:	10080240 	call	1008024 <metal_io_virt>
 100857c:	e0bff815 	stw	r2,-32(fp)
	int retlen = len;
 1008580:	e0bfff17 	ldw	r2,-4(fp)
 1008584:	e0bffb15 	stw	r2,-20(fp)

	if (offset >= io->size)
 1008588:	e0bffc17 	ldw	r2,-16(fp)
 100858c:	10800217 	ldw	r2,8(r2)
 1008590:	e0fffd17 	ldw	r3,-12(fp)
 1008594:	18800236 	bltu	r3,r2,10085a0 <metal_io_block_set+0x54>
		return -ERANGE;
 1008598:	00bff784 	movi	r2,-34
 100859c:	00005706 	br	10086fc <metal_io_block_set+0x1b0>
	if ((offset + len) > io->size)
 10085a0:	e0ffff17 	ldw	r3,-4(fp)
 10085a4:	e0bffd17 	ldw	r2,-12(fp)
 10085a8:	1885883a 	add	r2,r3,r2
 10085ac:	e0fffc17 	ldw	r3,-16(fp)
 10085b0:	18c00217 	ldw	r3,8(r3)
 10085b4:	1880052e 	bgeu	r3,r2,10085cc <metal_io_block_set+0x80>
		len = io->size - offset;
 10085b8:	e0bffc17 	ldw	r2,-16(fp)
 10085bc:	10c00217 	ldw	r3,8(r2)
 10085c0:	e0bffd17 	ldw	r2,-12(fp)
 10085c4:	1885c83a 	sub	r2,r3,r2
 10085c8:	e0bfff15 	stw	r2,-4(fp)
	retlen = len;
 10085cc:	e0bfff17 	ldw	r2,-4(fp)
 10085d0:	e0bffb15 	stw	r2,-20(fp)
	if (io->ops.block_set) {
 10085d4:	e0bffc17 	ldw	r2,-16(fp)
 10085d8:	10800a17 	ldw	r2,40(r2)
 10085dc:	10000b26 	beq	r2,zero,100860c <metal_io_block_set+0xc0>
		(*io->ops.block_set)(
 10085e0:	e0bffc17 	ldw	r2,-16(fp)
 10085e4:	10800a17 	ldw	r2,40(r2)
 10085e8:	e13ffe03 	ldbu	r4,-8(fp)
 10085ec:	e0ffff17 	ldw	r3,-4(fp)
 10085f0:	d8c00015 	stw	r3,0(sp)
 10085f4:	01c00144 	movi	r7,5
 10085f8:	200d883a 	mov	r6,r4
 10085fc:	e17ffd17 	ldw	r5,-12(fp)
 1008600:	e13ffc17 	ldw	r4,-16(fp)
 1008604:	103ee83a 	callr	r2
 1008608:	00003b06 	br	10086f8 <metal_io_block_set+0x1ac>
			io, offset, value, memory_order_seq_cst, len);
	} else {
		unsigned int cint = value;
 100860c:	e0bffe03 	ldbu	r2,-8(fp)
 1008610:	e0bff915 	stw	r2,-28(fp)
		unsigned int i;

		for (i = 1; i < sizeof(int); i++)
 1008614:	00800044 	movi	r2,1
 1008618:	e0bffa15 	stw	r2,-24(fp)
 100861c:	00000a06 	br	1008648 <metal_io_block_set+0xfc>
			cint |= ((unsigned int)value << (CHAR_BIT * i));
 1008620:	e0fffe03 	ldbu	r3,-8(fp)
 1008624:	e0bffa17 	ldw	r2,-24(fp)
 1008628:	100490fa 	slli	r2,r2,3
 100862c:	1884983a 	sll	r2,r3,r2
 1008630:	e0fff917 	ldw	r3,-28(fp)
 1008634:	1884b03a 	or	r2,r3,r2
 1008638:	e0bff915 	stw	r2,-28(fp)
			io, offset, value, memory_order_seq_cst, len);
	} else {
		unsigned int cint = value;
		unsigned int i;

		for (i = 1; i < sizeof(int); i++)
 100863c:	e0bffa17 	ldw	r2,-24(fp)
 1008640:	10800044 	addi	r2,r2,1
 1008644:	e0bffa15 	stw	r2,-24(fp)
 1008648:	e0bffa17 	ldw	r2,-24(fp)
 100864c:	10800130 	cmpltui	r2,r2,4
 1008650:	103ff31e 	bne	r2,zero,1008620 <__alt_data_end+0xff008620>
			cint |= ((unsigned int)value << (CHAR_BIT * i));

		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
 1008654:	00000906 	br	100867c <metal_io_block_set+0x130>
			*(unsigned char *)ptr = (unsigned char) value;
 1008658:	e0bff817 	ldw	r2,-32(fp)
 100865c:	e0fffe03 	ldbu	r3,-8(fp)
 1008660:	10c00005 	stb	r3,0(r2)
		unsigned int i;

		for (i = 1; i < sizeof(int); i++)
			cint |= ((unsigned int)value << (CHAR_BIT * i));

		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
 1008664:	e0bff817 	ldw	r2,-32(fp)
 1008668:	10800044 	addi	r2,r2,1
 100866c:	e0bff815 	stw	r2,-32(fp)
 1008670:	e0bfff17 	ldw	r2,-4(fp)
 1008674:	10bfffc4 	addi	r2,r2,-1
 1008678:	e0bfff15 	stw	r2,-4(fp)
 100867c:	e0bfff17 	ldw	r2,-4(fp)
 1008680:	10000d26 	beq	r2,zero,10086b8 <metal_io_block_set+0x16c>
 1008684:	e0bff817 	ldw	r2,-32(fp)
 1008688:	108000cc 	andi	r2,r2,3
 100868c:	103ff21e 	bne	r2,zero,1008658 <__alt_data_end+0xff008658>
			*(unsigned char *)ptr = (unsigned char) value;
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 1008690:	00000906 	br	10086b8 <metal_io_block_set+0x16c>
						len -= sizeof(int))
			*(unsigned int *)ptr = cint;
 1008694:	e0bff817 	ldw	r2,-32(fp)
 1008698:	e0fff917 	ldw	r3,-28(fp)
 100869c:	10c00015 	stw	r3,0(r2)
		for (i = 1; i < sizeof(int); i++)
			cint |= ((unsigned int)value << (CHAR_BIT * i));

		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
			*(unsigned char *)ptr = (unsigned char) value;
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 10086a0:	e0bff817 	ldw	r2,-32(fp)
 10086a4:	10800104 	addi	r2,r2,4
 10086a8:	e0bff815 	stw	r2,-32(fp)
						len -= sizeof(int))
 10086ac:	e0bfff17 	ldw	r2,-4(fp)
 10086b0:	10bfff04 	addi	r2,r2,-4
 10086b4:	e0bfff15 	stw	r2,-4(fp)
		for (i = 1; i < sizeof(int); i++)
			cint |= ((unsigned int)value << (CHAR_BIT * i));

		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
			*(unsigned char *)ptr = (unsigned char) value;
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 10086b8:	e0bfff17 	ldw	r2,-4(fp)
 10086bc:	10800108 	cmpgei	r2,r2,4
 10086c0:	103ff41e 	bne	r2,zero,1008694 <__alt_data_end+0xff008694>
						len -= sizeof(int))
			*(unsigned int *)ptr = cint;
		for (; len != 0; ptr++, len--)
 10086c4:	00000906 	br	10086ec <metal_io_block_set+0x1a0>
			*(unsigned char *)ptr = (unsigned char) value;
 10086c8:	e0bff817 	ldw	r2,-32(fp)
 10086cc:	e0fffe03 	ldbu	r3,-8(fp)
 10086d0:	10c00005 	stb	r3,0(r2)
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
			*(unsigned char *)ptr = (unsigned char) value;
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
						len -= sizeof(int))
			*(unsigned int *)ptr = cint;
		for (; len != 0; ptr++, len--)
 10086d4:	e0bff817 	ldw	r2,-32(fp)
 10086d8:	10800044 	addi	r2,r2,1
 10086dc:	e0bff815 	stw	r2,-32(fp)
 10086e0:	e0bfff17 	ldw	r2,-4(fp)
 10086e4:	10bfffc4 	addi	r2,r2,-1
 10086e8:	e0bfff15 	stw	r2,-4(fp)
 10086ec:	e0bfff17 	ldw	r2,-4(fp)
 10086f0:	103ff51e 	bne	r2,zero,10086c8 <__alt_data_end+0xff0086c8>
			*(unsigned char *)ptr = (unsigned char) value;
		atomic_thread_fence(memory_order_seq_cst);
 10086f4:	0001b03a 	sync
	}
	return retlen;
 10086f8:	e0bffb17 	ldw	r2,-20(fp)
}
 10086fc:	e037883a 	mov	sp,fp
 1008700:	dfc00117 	ldw	ra,4(sp)
 1008704:	df000017 	ldw	fp,0(sp)
 1008708:	dec00204 	addi	sp,sp,8
 100870c:	f800283a 	ret

01008710 <metal_list_add_before>:

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
 1008710:	defffd04 	addi	sp,sp,-12
 1008714:	df000215 	stw	fp,8(sp)
 1008718:	df000204 	addi	fp,sp,8
 100871c:	e13ffe15 	stw	r4,-8(fp)
 1008720:	e17fff15 	stw	r5,-4(fp)
	new_node->prev = node->prev;
 1008724:	e0bffe17 	ldw	r2,-8(fp)
 1008728:	10c00117 	ldw	r3,4(r2)
 100872c:	e0bfff17 	ldw	r2,-4(fp)
 1008730:	10c00115 	stw	r3,4(r2)
	new_node->next = node;
 1008734:	e0bfff17 	ldw	r2,-4(fp)
 1008738:	e0fffe17 	ldw	r3,-8(fp)
 100873c:	10c00015 	stw	r3,0(r2)
	new_node->next->prev = new_node;
 1008740:	e0bfff17 	ldw	r2,-4(fp)
 1008744:	10800017 	ldw	r2,0(r2)
 1008748:	e0ffff17 	ldw	r3,-4(fp)
 100874c:	10c00115 	stw	r3,4(r2)
	new_node->prev->next = new_node;
 1008750:	e0bfff17 	ldw	r2,-4(fp)
 1008754:	10800117 	ldw	r2,4(r2)
 1008758:	e0ffff17 	ldw	r3,-4(fp)
 100875c:	10c00015 	stw	r3,0(r2)
}
 1008760:	0001883a 	nop
 1008764:	e037883a 	mov	sp,fp
 1008768:	df000017 	ldw	fp,0(sp)
 100876c:	dec00104 	addi	sp,sp,4
 1008770:	f800283a 	ret

01008774 <metal_list_add_tail>:
	metal_list_add_after(list, node);
}

static inline void metal_list_add_tail(struct metal_list *list,
				       struct metal_list *node)
{
 1008774:	defffc04 	addi	sp,sp,-16
 1008778:	dfc00315 	stw	ra,12(sp)
 100877c:	df000215 	stw	fp,8(sp)
 1008780:	df000204 	addi	fp,sp,8
 1008784:	e13ffe15 	stw	r4,-8(fp)
 1008788:	e17fff15 	stw	r5,-4(fp)
	metal_list_add_before(list, node);
 100878c:	e17fff17 	ldw	r5,-4(fp)
 1008790:	e13ffe17 	ldw	r4,-8(fp)
 1008794:	10087100 	call	1008710 <metal_list_add_before>
}
 1008798:	0001883a 	nop
 100879c:	e037883a 	mov	sp,fp
 10087a0:	dfc00117 	ldw	ra,4(sp)
 10087a4:	df000017 	ldw	fp,0(sp)
 10087a8:	dec00204 	addi	sp,sp,8
 10087ac:	f800283a 	ret

010087b0 <metal_irq_allocate>:

/** List of registered IRQ controller */
static METAL_DECLARE_LIST(irq_cntrs);

static int metal_irq_allocate(int irq_base, int irq_num)
{
 10087b0:	defff704 	addi	sp,sp,-36
 10087b4:	df000815 	stw	fp,32(sp)
 10087b8:	df000804 	addi	fp,sp,32
 10087bc:	e13ffe15 	stw	r4,-8(fp)
 10087c0:	e17fff15 	stw	r5,-4(fp)
	struct metal_list *node;
	struct metal_irq_controller *cntr;
	int irq_tocheck = irq_base, irq_end_tocheck;
 10087c4:	e0bffe17 	ldw	r2,-8(fp)
 10087c8:	e0bff915 	stw	r2,-28(fp)

	if (irq_num == 0) {
 10087cc:	e0bfff17 	ldw	r2,-4(fp)
 10087d0:	1000021e 	bne	r2,zero,10087dc <metal_irq_allocate+0x2c>
		return METAL_IRQ_ANY;
 10087d4:	00bfffc4 	movi	r2,-1
 10087d8:	00002e06 	br	1008894 <metal_irq_allocate+0xe4>
	}
	if (irq_tocheck == METAL_IRQ_ANY) {
 10087dc:	e0bff917 	ldw	r2,-28(fp)
 10087e0:	10bfffd8 	cmpnei	r2,r2,-1
 10087e4:	1000011e 	bne	r2,zero,10087ec <metal_irq_allocate+0x3c>
		irq_tocheck = 0;
 10087e8:	e03ff915 	stw	zero,-28(fp)
	}
	irq_end_tocheck = irq_tocheck + irq_num;
 10087ec:	e0fff917 	ldw	r3,-28(fp)
 10087f0:	e0bfff17 	ldw	r2,-4(fp)
 10087f4:	1885883a 	add	r2,r3,r2
 10087f8:	e0bffa15 	stw	r2,-24(fp)

	metal_list_for_each(&irq_cntrs, node) {
 10087fc:	d0a00717 	ldw	r2,-32740(gp)
 1008800:	e0bff815 	stw	r2,-32(fp)
 1008804:	00001f06 	br	1008884 <metal_irq_allocate+0xd4>
		int cntr_irq_base, cntr_irq_end;

		cntr = metal_container_of(node,
 1008808:	e0bff817 	ldw	r2,-32(fp)
 100880c:	10bffb04 	addi	r2,r2,-20
 1008810:	e0bffb15 	stw	r2,-20(fp)
					  struct metal_irq_controller, node);
		cntr_irq_base = cntr->irq_base;
 1008814:	e0bffb17 	ldw	r2,-20(fp)
 1008818:	10800017 	ldw	r2,0(r2)
 100881c:	e0bffc15 	stw	r2,-16(fp)
		cntr_irq_end = cntr_irq_base + cntr->irq_num;
 1008820:	e0bffb17 	ldw	r2,-20(fp)
 1008824:	10c00117 	ldw	r3,4(r2)
 1008828:	e0bffc17 	ldw	r2,-16(fp)
 100882c:	1885883a 	add	r2,r3,r2
 1008830:	e0bffd15 	stw	r2,-12(fp)
		if (irq_tocheck < cntr_irq_end &&
 1008834:	e0fff917 	ldw	r3,-28(fp)
 1008838:	e0bffd17 	ldw	r2,-12(fp)
 100883c:	18800e0e 	bge	r3,r2,1008878 <metal_irq_allocate+0xc8>
 1008840:	e0bffa17 	ldw	r2,-24(fp)
 1008844:	e0fffc17 	ldw	r3,-16(fp)
 1008848:	18800b0e 	bge	r3,r2,1008878 <metal_irq_allocate+0xc8>
		    irq_end_tocheck > cntr_irq_base) {
			if (irq_base != METAL_IRQ_ANY) {
 100884c:	e0bffe17 	ldw	r2,-8(fp)
 1008850:	10bfffe0 	cmpeqi	r2,r2,-1
 1008854:	1000021e 	bne	r2,zero,1008860 <metal_irq_allocate+0xb0>
				/* IRQ has been allocated */
				return METAL_IRQ_ANY;
 1008858:	00bfffc4 	movi	r2,-1
 100885c:	00000d06 	br	1008894 <metal_irq_allocate+0xe4>
			}
			irq_tocheck = cntr_irq_end;
 1008860:	e0bffd17 	ldw	r2,-12(fp)
 1008864:	e0bff915 	stw	r2,-28(fp)
			irq_end_tocheck = irq_tocheck + irq_num;
 1008868:	e0fff917 	ldw	r3,-28(fp)
 100886c:	e0bfff17 	ldw	r2,-4(fp)
 1008870:	1885883a 	add	r2,r3,r2
 1008874:	e0bffa15 	stw	r2,-24(fp)
	if (irq_tocheck == METAL_IRQ_ANY) {
		irq_tocheck = 0;
	}
	irq_end_tocheck = irq_tocheck + irq_num;

	metal_list_for_each(&irq_cntrs, node) {
 1008878:	e0bff817 	ldw	r2,-32(fp)
 100887c:	10800017 	ldw	r2,0(r2)
 1008880:	e0bff815 	stw	r2,-32(fp)
 1008884:	e0fff817 	ldw	r3,-32(fp)
 1008888:	d0a00704 	addi	r2,gp,-32740
 100888c:	18bfde1e 	bne	r3,r2,1008808 <__alt_data_end+0xff008808>
			}
			irq_tocheck = cntr_irq_end;
			irq_end_tocheck = irq_tocheck + irq_num;
		}
	}
	return irq_tocheck;
 1008890:	e0bff917 	ldw	r2,-28(fp)
}
 1008894:	e037883a 	mov	sp,fp
 1008898:	df000017 	ldw	fp,0(sp)
 100889c:	dec00104 	addi	sp,sp,4
 10088a0:	f800283a 	ret

010088a4 <metal_irq_register_controller>:

int metal_irq_register_controller(struct metal_irq_controller *cntr)
{
 10088a4:	defffb04 	addi	sp,sp,-20
 10088a8:	dfc00415 	stw	ra,16(sp)
 10088ac:	df000315 	stw	fp,12(sp)
 10088b0:	df000304 	addi	fp,sp,12
 10088b4:	e13fff15 	stw	r4,-4(fp)
	int irq_base;
	struct metal_list *node;

	if (cntr == NULL) {
 10088b8:	e0bfff17 	ldw	r2,-4(fp)
 10088bc:	1000021e 	bne	r2,zero,10088c8 <metal_irq_register_controller+0x24>
		return -EINVAL;
 10088c0:	00bffa84 	movi	r2,-22
 10088c4:	00002506 	br	100895c <metal_irq_register_controller+0xb8>
	}
	metal_list_for_each(&irq_cntrs, node) {
 10088c8:	d0a00717 	ldw	r2,-32740(gp)
 10088cc:	e0bffd15 	stw	r2,-12(fp)
 10088d0:	00000906 	br	10088f8 <metal_irq_register_controller+0x54>
		if (node == &cntr->node) {
 10088d4:	e0bfff17 	ldw	r2,-4(fp)
 10088d8:	10c00504 	addi	r3,r2,20
 10088dc:	e0bffd17 	ldw	r2,-12(fp)
 10088e0:	1880021e 	bne	r3,r2,10088ec <metal_irq_register_controller+0x48>
			return 0;
 10088e4:	0005883a 	mov	r2,zero
 10088e8:	00001c06 	br	100895c <metal_irq_register_controller+0xb8>
	struct metal_list *node;

	if (cntr == NULL) {
		return -EINVAL;
	}
	metal_list_for_each(&irq_cntrs, node) {
 10088ec:	e0bffd17 	ldw	r2,-12(fp)
 10088f0:	10800017 	ldw	r2,0(r2)
 10088f4:	e0bffd15 	stw	r2,-12(fp)
 10088f8:	e0fffd17 	ldw	r3,-12(fp)
 10088fc:	d0a00704 	addi	r2,gp,-32740
 1008900:	18bff41e 	bne	r3,r2,10088d4 <__alt_data_end+0xff0088d4>
		}
	}

	/* Allocate IRQ numbers which are not yet used by any IRQ
	 * controllers.*/
	irq_base = metal_irq_allocate(cntr->irq_base , cntr->irq_num);
 1008904:	e0bfff17 	ldw	r2,-4(fp)
 1008908:	10c00017 	ldw	r3,0(r2)
 100890c:	e0bfff17 	ldw	r2,-4(fp)
 1008910:	10800117 	ldw	r2,4(r2)
 1008914:	100b883a 	mov	r5,r2
 1008918:	1809883a 	mov	r4,r3
 100891c:	10087b00 	call	10087b0 <metal_irq_allocate>
 1008920:	e0bffe15 	stw	r2,-8(fp)
	if (irq_base == METAL_IRQ_ANY) {
 1008924:	e0bffe17 	ldw	r2,-8(fp)
 1008928:	10bfffd8 	cmpnei	r2,r2,-1
 100892c:	1000021e 	bne	r2,zero,1008938 <metal_irq_register_controller+0x94>
		return -EINVAL;
 1008930:	00bffa84 	movi	r2,-22
 1008934:	00000906 	br	100895c <metal_irq_register_controller+0xb8>
	}
	cntr->irq_base = irq_base;
 1008938:	e0bfff17 	ldw	r2,-4(fp)
 100893c:	e0fffe17 	ldw	r3,-8(fp)
 1008940:	10c00015 	stw	r3,0(r2)

	metal_list_add_tail(&irq_cntrs, &cntr->node);
 1008944:	e0bfff17 	ldw	r2,-4(fp)
 1008948:	10800504 	addi	r2,r2,20
 100894c:	100b883a 	mov	r5,r2
 1008950:	d1200704 	addi	r4,gp,-32740
 1008954:	10087740 	call	1008774 <metal_list_add_tail>
	return 0;
 1008958:	0005883a 	mov	r2,zero
}
 100895c:	e037883a 	mov	sp,fp
 1008960:	dfc00117 	ldw	ra,4(sp)
 1008964:	df000017 	ldw	fp,0(sp)
 1008968:	dec00204 	addi	sp,sp,8
 100896c:	f800283a 	ret

01008970 <metal_irq_get_controller>:

static struct metal_irq_controller *metal_irq_get_controller(int irq)
{
 1008970:	defffa04 	addi	sp,sp,-24
 1008974:	df000515 	stw	fp,20(sp)
 1008978:	df000504 	addi	fp,sp,20
 100897c:	e13fff15 	stw	r4,-4(fp)
	struct metal_list *node;
	struct metal_irq_controller *cntr;

	metal_list_for_each(&irq_cntrs, node) {
 1008980:	d0a00717 	ldw	r2,-32740(gp)
 1008984:	e0bffb15 	stw	r2,-20(fp)
 1008988:	00001606 	br	10089e4 <metal_irq_get_controller+0x74>
		int irq_base, irq_end;

		cntr = (struct metal_irq_controller *)
		       metal_container_of(node, struct metal_irq_controller,
 100898c:	e0bffb17 	ldw	r2,-20(fp)
 1008990:	10bffb04 	addi	r2,r2,-20
	struct metal_irq_controller *cntr;

	metal_list_for_each(&irq_cntrs, node) {
		int irq_base, irq_end;

		cntr = (struct metal_irq_controller *)
 1008994:	e0bffc15 	stw	r2,-16(fp)
		       metal_container_of(node, struct metal_irq_controller,
				          node);
		irq_base = cntr->irq_base;
 1008998:	e0bffc17 	ldw	r2,-16(fp)
 100899c:	10800017 	ldw	r2,0(r2)
 10089a0:	e0bffd15 	stw	r2,-12(fp)
		irq_end = irq_base + cntr->irq_num;
 10089a4:	e0bffc17 	ldw	r2,-16(fp)
 10089a8:	10c00117 	ldw	r3,4(r2)
 10089ac:	e0bffd17 	ldw	r2,-12(fp)
 10089b0:	1885883a 	add	r2,r3,r2
 10089b4:	e0bffe15 	stw	r2,-8(fp)
		if (irq >= irq_base && irq < irq_end) {
 10089b8:	e0ffff17 	ldw	r3,-4(fp)
 10089bc:	e0bffd17 	ldw	r2,-12(fp)
 10089c0:	18800516 	blt	r3,r2,10089d8 <metal_irq_get_controller+0x68>
 10089c4:	e0ffff17 	ldw	r3,-4(fp)
 10089c8:	e0bffe17 	ldw	r2,-8(fp)
 10089cc:	1880020e 	bge	r3,r2,10089d8 <metal_irq_get_controller+0x68>
		       return cntr;
 10089d0:	e0bffc17 	ldw	r2,-16(fp)
 10089d4:	00000706 	br	10089f4 <metal_irq_get_controller+0x84>
static struct metal_irq_controller *metal_irq_get_controller(int irq)
{
	struct metal_list *node;
	struct metal_irq_controller *cntr;

	metal_list_for_each(&irq_cntrs, node) {
 10089d8:	e0bffb17 	ldw	r2,-20(fp)
 10089dc:	10800017 	ldw	r2,0(r2)
 10089e0:	e0bffb15 	stw	r2,-20(fp)
 10089e4:	e0fffb17 	ldw	r3,-20(fp)
 10089e8:	d0a00704 	addi	r2,gp,-32740
 10089ec:	18bfe71e 	bne	r3,r2,100898c <__alt_data_end+0xff00898c>
		irq_end = irq_base + cntr->irq_num;
		if (irq >= irq_base && irq < irq_end) {
		       return cntr;
		}
	}
	return NULL;
 10089f0:	0005883a 	mov	r2,zero
}
 10089f4:	e037883a 	mov	sp,fp
 10089f8:	df000017 	ldw	fp,0(sp)
 10089fc:	dec00104 	addi	sp,sp,4
 1008a00:	f800283a 	ret

01008a04 <_metal_irq_set_enable>:

static void _metal_irq_set_enable(int irq, unsigned int state)
{
 1008a04:	defffb04 	addi	sp,sp,-20
 1008a08:	dfc00415 	stw	ra,16(sp)
 1008a0c:	df000315 	stw	fp,12(sp)
 1008a10:	df000304 	addi	fp,sp,12
 1008a14:	e13ffe15 	stw	r4,-8(fp)
 1008a18:	e17fff15 	stw	r5,-4(fp)
	struct metal_irq_controller *cntr;

	cntr = metal_irq_get_controller(irq);
 1008a1c:	e13ffe17 	ldw	r4,-8(fp)
 1008a20:	10089700 	call	1008970 <metal_irq_get_controller>
 1008a24:	e0bffd15 	stw	r2,-12(fp)
	if (cntr == NULL) {
 1008a28:	e0bffd17 	ldw	r2,-12(fp)
 1008a2c:	10000726 	beq	r2,zero,1008a4c <_metal_irq_set_enable+0x48>
		return;
	}
	cntr->irq_set_enable(cntr, irq, state);
 1008a30:	e0bffd17 	ldw	r2,-12(fp)
 1008a34:	10800317 	ldw	r2,12(r2)
 1008a38:	e1bfff17 	ldw	r6,-4(fp)
 1008a3c:	e17ffe17 	ldw	r5,-8(fp)
 1008a40:	e13ffd17 	ldw	r4,-12(fp)
 1008a44:	103ee83a 	callr	r2
 1008a48:	00000106 	br	1008a50 <_metal_irq_set_enable+0x4c>
{
	struct metal_irq_controller *cntr;

	cntr = metal_irq_get_controller(irq);
	if (cntr == NULL) {
		return;
 1008a4c:	0001883a 	nop
	}
	cntr->irq_set_enable(cntr, irq, state);
}
 1008a50:	e037883a 	mov	sp,fp
 1008a54:	dfc00117 	ldw	ra,4(sp)
 1008a58:	df000017 	ldw	fp,0(sp)
 1008a5c:	dec00204 	addi	sp,sp,8
 1008a60:	f800283a 	ret

01008a64 <metal_irq_register>:

int metal_irq_register(int irq,
		       metal_irq_handler irq_handler,
		       void *arg)
{
 1008a64:	defff904 	addi	sp,sp,-28
 1008a68:	dfc00615 	stw	ra,24(sp)
 1008a6c:	df000515 	stw	fp,20(sp)
 1008a70:	df000504 	addi	fp,sp,20
 1008a74:	e13ffd15 	stw	r4,-12(fp)
 1008a78:	e17ffe15 	stw	r5,-8(fp)
 1008a7c:	e1bfff15 	stw	r6,-4(fp)
	struct metal_irq_controller *cntr;
	struct metal_irq *irq_data;

	cntr = metal_irq_get_controller(irq);
 1008a80:	e13ffd17 	ldw	r4,-12(fp)
 1008a84:	10089700 	call	1008970 <metal_irq_get_controller>
 1008a88:	e0bffb15 	stw	r2,-20(fp)
	if (cntr == NULL) {
 1008a8c:	e0bffb17 	ldw	r2,-20(fp)
 1008a90:	1000021e 	bne	r2,zero,1008a9c <metal_irq_register+0x38>
		return -EINVAL;
 1008a94:	00bffa84 	movi	r2,-22
 1008a98:	00002006 	br	1008b1c <metal_irq_register+0xb8>
	}
	if (cntr->irq_register != NULL) {
 1008a9c:	e0bffb17 	ldw	r2,-20(fp)
 1008aa0:	10800417 	ldw	r2,16(r2)
 1008aa4:	10000826 	beq	r2,zero,1008ac8 <metal_irq_register+0x64>
		return cntr->irq_register(cntr, irq, irq_handler, arg);
 1008aa8:	e0bffb17 	ldw	r2,-20(fp)
 1008aac:	10800417 	ldw	r2,16(r2)
 1008ab0:	e1ffff17 	ldw	r7,-4(fp)
 1008ab4:	e1bffe17 	ldw	r6,-8(fp)
 1008ab8:	e17ffd17 	ldw	r5,-12(fp)
 1008abc:	e13ffb17 	ldw	r4,-20(fp)
 1008ac0:	103ee83a 	callr	r2
 1008ac4:	00001506 	br	1008b1c <metal_irq_register+0xb8>
	}
	if (cntr->irqs == NULL) {
 1008ac8:	e0bffb17 	ldw	r2,-20(fp)
 1008acc:	10800717 	ldw	r2,28(r2)
 1008ad0:	1000021e 	bne	r2,zero,1008adc <metal_irq_register+0x78>
		return -EINVAL;
 1008ad4:	00bffa84 	movi	r2,-22
 1008ad8:	00001006 	br	1008b1c <metal_irq_register+0xb8>
	}
	irq_data = &cntr->irqs[irq - cntr->irq_base];
 1008adc:	e0bffb17 	ldw	r2,-20(fp)
 1008ae0:	10c00717 	ldw	r3,28(r2)
 1008ae4:	e0bffb17 	ldw	r2,-20(fp)
 1008ae8:	10800017 	ldw	r2,0(r2)
 1008aec:	e13ffd17 	ldw	r4,-12(fp)
 1008af0:	2085c83a 	sub	r2,r4,r2
 1008af4:	100490fa 	slli	r2,r2,3
 1008af8:	1885883a 	add	r2,r3,r2
 1008afc:	e0bffc15 	stw	r2,-16(fp)
	irq_data->hd = irq_handler;
 1008b00:	e0bffc17 	ldw	r2,-16(fp)
 1008b04:	e0fffe17 	ldw	r3,-8(fp)
 1008b08:	10c00015 	stw	r3,0(r2)
	irq_data->arg = arg;
 1008b0c:	e0bffc17 	ldw	r2,-16(fp)
 1008b10:	e0ffff17 	ldw	r3,-4(fp)
 1008b14:	10c00115 	stw	r3,4(r2)
	return 0;
 1008b18:	0005883a 	mov	r2,zero
}
 1008b1c:	e037883a 	mov	sp,fp
 1008b20:	dfc00117 	ldw	ra,4(sp)
 1008b24:	df000017 	ldw	fp,0(sp)
 1008b28:	dec00204 	addi	sp,sp,8
 1008b2c:	f800283a 	ret

01008b30 <metal_irq_enable>:

void metal_irq_enable(unsigned int vector)
{
 1008b30:	defffd04 	addi	sp,sp,-12
 1008b34:	dfc00215 	stw	ra,8(sp)
 1008b38:	df000115 	stw	fp,4(sp)
 1008b3c:	df000104 	addi	fp,sp,4
 1008b40:	e13fff15 	stw	r4,-4(fp)
	_metal_irq_set_enable((int)vector, METAL_IRQ_ENABLE);
 1008b44:	e0bfff17 	ldw	r2,-4(fp)
 1008b48:	01400044 	movi	r5,1
 1008b4c:	1009883a 	mov	r4,r2
 1008b50:	1008a040 	call	1008a04 <_metal_irq_set_enable>
}
 1008b54:	0001883a 	nop
 1008b58:	e037883a 	mov	sp,fp
 1008b5c:	dfc00117 	ldw	ra,4(sp)
 1008b60:	df000017 	ldw	fp,0(sp)
 1008b64:	dec00204 	addi	sp,sp,8
 1008b68:	f800283a 	ret

01008b6c <metal_irq_disable>:

void metal_irq_disable(unsigned int vector)
{
 1008b6c:	defffd04 	addi	sp,sp,-12
 1008b70:	dfc00215 	stw	ra,8(sp)
 1008b74:	df000115 	stw	fp,4(sp)
 1008b78:	df000104 	addi	fp,sp,4
 1008b7c:	e13fff15 	stw	r4,-4(fp)
	_metal_irq_set_enable((int)vector, METAL_IRQ_DISABLE);
 1008b80:	e0bfff17 	ldw	r2,-4(fp)
 1008b84:	000b883a 	mov	r5,zero
 1008b88:	1009883a 	mov	r4,r2
 1008b8c:	1008a040 	call	1008a04 <_metal_irq_set_enable>
}
 1008b90:	0001883a 	nop
 1008b94:	e037883a 	mov	sp,fp
 1008b98:	dfc00117 	ldw	ra,4(sp)
 1008b9c:	df000017 	ldw	fp,0(sp)
 1008ba0:	dec00204 	addi	sp,sp,8
 1008ba4:	f800283a 	ret

01008ba8 <metal_default_log_handler>:
#include <log.h>
#include <sys.h>

void metal_default_log_handler(enum metal_log_level level,
			       const char *format, ...)
{
 1008ba8:	defffb04 	addi	sp,sp,-20
 1008bac:	df000215 	stw	fp,8(sp)
 1008bb0:	df000204 	addi	fp,sp,8
 1008bb4:	e13ffe15 	stw	r4,-8(fp)
 1008bb8:	e17fff15 	stw	r5,-4(fp)
 1008bbc:	e1800115 	stw	r6,4(fp)
 1008bc0:	e1c00215 	stw	r7,8(fp)
	fprintf(stderr, "%s%s", level_strs[level], msg);
#else
	(void)level;
	(void)format;
#endif
}
 1008bc4:	0001883a 	nop
 1008bc8:	e037883a 	mov	sp,fp
 1008bcc:	df000017 	ldw	fp,0(sp)
 1008bd0:	dec00304 	addi	sp,sp,12
 1008bd4:	f800283a 	ret

01008bd8 <metal_set_log_handler>:

void metal_set_log_handler(metal_log_handler handler)
{
 1008bd8:	defffe04 	addi	sp,sp,-8
 1008bdc:	df000115 	stw	fp,4(sp)
 1008be0:	df000104 	addi	fp,sp,4
 1008be4:	e13fff15 	stw	r4,-4(fp)
	_metal.common.log_handler = handler;
 1008be8:	008060f4 	movhi	r2,387
 1008bec:	10baf104 	addi	r2,r2,-5180
 1008bf0:	e0ffff17 	ldw	r3,-4(fp)
 1008bf4:	10c00115 	stw	r3,4(r2)
}
 1008bf8:	0001883a 	nop
 1008bfc:	e037883a 	mov	sp,fp
 1008c00:	df000017 	ldw	fp,0(sp)
 1008c04:	dec00104 	addi	sp,sp,4
 1008c08:	f800283a 	ret

01008c0c <metal_get_log_handler>:

metal_log_handler metal_get_log_handler(void)
{
 1008c0c:	deffff04 	addi	sp,sp,-4
 1008c10:	df000015 	stw	fp,0(sp)
 1008c14:	d839883a 	mov	fp,sp
	return _metal.common.log_handler;
 1008c18:	008060f4 	movhi	r2,387
 1008c1c:	10baf104 	addi	r2,r2,-5180
 1008c20:	10800117 	ldw	r2,4(r2)
}
 1008c24:	e037883a 	mov	sp,fp
 1008c28:	df000017 	ldw	fp,0(sp)
 1008c2c:	dec00104 	addi	sp,sp,4
 1008c30:	f800283a 	ret

01008c34 <metal_set_log_level>:

void metal_set_log_level(enum metal_log_level level)
{
 1008c34:	defffe04 	addi	sp,sp,-8
 1008c38:	df000115 	stw	fp,4(sp)
 1008c3c:	df000104 	addi	fp,sp,4
 1008c40:	e13fff15 	stw	r4,-4(fp)
	_metal.common.log_level = level;
 1008c44:	008060f4 	movhi	r2,387
 1008c48:	10baf104 	addi	r2,r2,-5180
 1008c4c:	e0ffff17 	ldw	r3,-4(fp)
 1008c50:	10c00015 	stw	r3,0(r2)
}
 1008c54:	0001883a 	nop
 1008c58:	e037883a 	mov	sp,fp
 1008c5c:	df000017 	ldw	fp,0(sp)
 1008c60:	dec00104 	addi	sp,sp,4
 1008c64:	f800283a 	ret

01008c68 <metal_get_log_level>:

enum metal_log_level metal_get_log_level(void)
{
 1008c68:	deffff04 	addi	sp,sp,-4
 1008c6c:	df000015 	stw	fp,0(sp)
 1008c70:	d839883a 	mov	fp,sp
	return _metal.common.log_level;
 1008c74:	008060f4 	movhi	r2,387
 1008c78:	10baf104 	addi	r2,r2,-5180
 1008c7c:	10800017 	ldw	r2,0(r2)
}
 1008c80:	e037883a 	mov	sp,fp
 1008c84:	df000017 	ldw	fp,0(sp)
 1008c88:	dec00104 	addi	sp,sp,4
 1008c8c:	f800283a 	ret

01008c90 <metal_list_add_before>:
	list->next = list->prev = list;
}

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
 1008c90:	defffd04 	addi	sp,sp,-12
 1008c94:	df000215 	stw	fp,8(sp)
 1008c98:	df000204 	addi	fp,sp,8
 1008c9c:	e13ffe15 	stw	r4,-8(fp)
 1008ca0:	e17fff15 	stw	r5,-4(fp)
	new_node->prev = node->prev;
 1008ca4:	e0bffe17 	ldw	r2,-8(fp)
 1008ca8:	10c00117 	ldw	r3,4(r2)
 1008cac:	e0bfff17 	ldw	r2,-4(fp)
 1008cb0:	10c00115 	stw	r3,4(r2)
	new_node->next = node;
 1008cb4:	e0bfff17 	ldw	r2,-4(fp)
 1008cb8:	e0fffe17 	ldw	r3,-8(fp)
 1008cbc:	10c00015 	stw	r3,0(r2)
	new_node->next->prev = new_node;
 1008cc0:	e0bfff17 	ldw	r2,-4(fp)
 1008cc4:	10800017 	ldw	r2,0(r2)
 1008cc8:	e0ffff17 	ldw	r3,-4(fp)
 1008ccc:	10c00115 	stw	r3,4(r2)
	new_node->prev->next = new_node;
 1008cd0:	e0bfff17 	ldw	r2,-4(fp)
 1008cd4:	10800117 	ldw	r2,4(r2)
 1008cd8:	e0ffff17 	ldw	r3,-4(fp)
 1008cdc:	10c00015 	stw	r3,0(r2)
}
 1008ce0:	0001883a 	nop
 1008ce4:	e037883a 	mov	sp,fp
 1008ce8:	df000017 	ldw	fp,0(sp)
 1008cec:	dec00104 	addi	sp,sp,4
 1008cf0:	f800283a 	ret

01008cf4 <metal_list_add_tail>:
	metal_list_add_after(list, node);
}

static inline void metal_list_add_tail(struct metal_list *list,
				       struct metal_list *node)
{
 1008cf4:	defffc04 	addi	sp,sp,-16
 1008cf8:	dfc00315 	stw	ra,12(sp)
 1008cfc:	df000215 	stw	fp,8(sp)
 1008d00:	df000204 	addi	fp,sp,8
 1008d04:	e13ffe15 	stw	r4,-8(fp)
 1008d08:	e17fff15 	stw	r5,-4(fp)
	metal_list_add_before(list, node);
 1008d0c:	e17fff17 	ldw	r5,-4(fp)
 1008d10:	e13ffe17 	ldw	r4,-8(fp)
 1008d14:	1008c900 	call	1008c90 <metal_list_add_before>
}
 1008d18:	0001883a 	nop
 1008d1c:	e037883a 	mov	sp,fp
 1008d20:	dfc00117 	ldw	ra,4(sp)
 1008d24:	df000017 	ldw	fp,0(sp)
 1008d28:	dec00204 	addi	sp,sp,8
 1008d2c:	f800283a 	ret

01008d30 <metal_io_region_size>:
 *
 * @param[in]	io	I/O region handle.
 * @return	Size of I/O region.
 */
static inline size_t metal_io_region_size(struct metal_io_region *io)
{
 1008d30:	defffe04 	addi	sp,sp,-8
 1008d34:	df000115 	stw	fp,4(sp)
 1008d38:	df000104 	addi	fp,sp,4
 1008d3c:	e13fff15 	stw	r4,-4(fp)
	return io->size;
 1008d40:	e0bfff17 	ldw	r2,-4(fp)
 1008d44:	10800217 	ldw	r2,8(r2)
}
 1008d48:	e037883a 	mov	sp,fp
 1008d4c:	df000017 	ldw	fp,0(sp)
 1008d50:	dec00104 	addi	sp,sp,4
 1008d54:	f800283a 	ret

01008d58 <metal_shmem_register_generic>:
#include <shmem.h>
#include <sys.h>
#include <utilities.h>

int metal_shmem_register_generic(struct metal_generic_shmem *shmem)
{
 1008d58:	defffd04 	addi	sp,sp,-12
 1008d5c:	dfc00215 	stw	ra,8(sp)
 1008d60:	df000115 	stw	fp,4(sp)
 1008d64:	df000104 	addi	fp,sp,4
 1008d68:	e13fff15 	stw	r4,-4(fp)
	/* Make sure that we can be found. */
	metal_assert(shmem->name && strlen(shmem->name) != 0);
 1008d6c:	e0bfff17 	ldw	r2,-4(fp)
 1008d70:	10800017 	ldw	r2,0(r2)
 1008d74:	10000726 	beq	r2,zero,1008d94 <metal_shmem_register_generic+0x3c>
 1008d78:	e0bfff17 	ldw	r2,-4(fp)
 1008d7c:	10800017 	ldw	r2,0(r2)
 1008d80:	10800003 	ldbu	r2,0(r2)
 1008d84:	10803fcc 	andi	r2,r2,255
 1008d88:	1080201c 	xori	r2,r2,128
 1008d8c:	10bfe004 	addi	r2,r2,-128
 1008d90:	1000081e 	bne	r2,zero,1008db4 <metal_shmem_register_generic+0x5c>
 1008d94:	01c040f4 	movhi	r7,259
 1008d98:	39e50b04 	addi	r7,r7,-27604
 1008d9c:	018040f4 	movhi	r6,259
 1008da0:	31a51f04 	addi	r6,r6,-27524
 1008da4:	01400584 	movi	r5,22
 1008da8:	010040f4 	movhi	r4,259
 1008dac:	21251504 	addi	r4,r4,-27564
 1008db0:	10157a00 	call	10157a0 <__assert_func>

	/* Statically registered shmem regions cannot have a destructor. */
	metal_assert(!shmem->io.ops.close);
 1008db4:	e0bfff17 	ldw	r2,-4(fp)
 1008db8:	10800c17 	ldw	r2,48(r2)
 1008dbc:	10000826 	beq	r2,zero,1008de0 <metal_shmem_register_generic+0x88>
 1008dc0:	01c040f4 	movhi	r7,259
 1008dc4:	39e51904 	addi	r7,r7,-27548
 1008dc8:	018040f4 	movhi	r6,259
 1008dcc:	31a51f04 	addi	r6,r6,-27524
 1008dd0:	01400644 	movi	r5,25
 1008dd4:	010040f4 	movhi	r4,259
 1008dd8:	21251504 	addi	r4,r4,-27564
 1008ddc:	10157a00 	call	10157a0 <__assert_func>

	metal_list_add_tail(&_metal.common.generic_shmem_list,
 1008de0:	e0bfff17 	ldw	r2,-4(fp)
 1008de4:	10800f04 	addi	r2,r2,60
 1008de8:	100b883a 	mov	r5,r2
 1008dec:	010060f4 	movhi	r4,387
 1008df0:	213af504 	addi	r4,r4,-5164
 1008df4:	1008cf40 	call	1008cf4 <metal_list_add_tail>
			    &shmem->node);
	return 0;
 1008df8:	0005883a 	mov	r2,zero
}
 1008dfc:	e037883a 	mov	sp,fp
 1008e00:	dfc00117 	ldw	ra,4(sp)
 1008e04:	df000017 	ldw	fp,0(sp)
 1008e08:	dec00204 	addi	sp,sp,8
 1008e0c:	f800283a 	ret

01008e10 <metal_shmem_open_generic>:

int metal_shmem_open_generic(const char *name, size_t size,
			     struct metal_io_region **result)
{
 1008e10:	defff904 	addi	sp,sp,-28
 1008e14:	dfc00615 	stw	ra,24(sp)
 1008e18:	df000515 	stw	fp,20(sp)
 1008e1c:	df000504 	addi	fp,sp,20
 1008e20:	e13ffd15 	stw	r4,-12(fp)
 1008e24:	e17ffe15 	stw	r5,-8(fp)
 1008e28:	e1bfff15 	stw	r6,-4(fp)
	struct metal_generic_shmem *shmem;
	struct metal_list *node;

	metal_list_for_each(&_metal.common.generic_shmem_list, node) {
 1008e2c:	008060f4 	movhi	r2,387
 1008e30:	10baf104 	addi	r2,r2,-5180
 1008e34:	10800417 	ldw	r2,16(r2)
 1008e38:	e0bffb15 	stw	r2,-20(fp)
 1008e3c:	00001c06 	br	1008eb0 <metal_shmem_open_generic+0xa0>
		shmem = metal_container_of(node, struct metal_generic_shmem, node);
 1008e40:	e0bffb17 	ldw	r2,-20(fp)
 1008e44:	10bff104 	addi	r2,r2,-60
 1008e48:	e0bffc15 	stw	r2,-16(fp)
		if (strcmp(shmem->name, name) != 0)
 1008e4c:	e0bffc17 	ldw	r2,-16(fp)
 1008e50:	10800017 	ldw	r2,0(r2)
 1008e54:	e17ffd17 	ldw	r5,-12(fp)
 1008e58:	1009883a 	mov	r4,r2
 1008e5c:	1015e600 	call	1015e60 <strcmp>
 1008e60:	10000d1e 	bne	r2,zero,1008e98 <metal_shmem_open_generic+0x88>
			continue;
		if (size > metal_io_region_size(&shmem->io))
 1008e64:	e0bffc17 	ldw	r2,-16(fp)
 1008e68:	10800104 	addi	r2,r2,4
 1008e6c:	1009883a 	mov	r4,r2
 1008e70:	1008d300 	call	1008d30 <metal_io_region_size>
 1008e74:	1007883a 	mov	r3,r2
 1008e78:	e0bffe17 	ldw	r2,-8(fp)
 1008e7c:	18800836 	bltu	r3,r2,1008ea0 <metal_shmem_open_generic+0x90>
			continue;
		*result = &shmem->io;
 1008e80:	e0bffc17 	ldw	r2,-16(fp)
 1008e84:	10c00104 	addi	r3,r2,4
 1008e88:	e0bfff17 	ldw	r2,-4(fp)
 1008e8c:	10c00015 	stw	r3,0(r2)
		return 0;
 1008e90:	0005883a 	mov	r2,zero
 1008e94:	00000b06 	br	1008ec4 <metal_shmem_open_generic+0xb4>
	struct metal_list *node;

	metal_list_for_each(&_metal.common.generic_shmem_list, node) {
		shmem = metal_container_of(node, struct metal_generic_shmem, node);
		if (strcmp(shmem->name, name) != 0)
			continue;
 1008e98:	0001883a 	nop
 1008e9c:	00000106 	br	1008ea4 <metal_shmem_open_generic+0x94>
		if (size > metal_io_region_size(&shmem->io))
			continue;
 1008ea0:	0001883a 	nop
			     struct metal_io_region **result)
{
	struct metal_generic_shmem *shmem;
	struct metal_list *node;

	metal_list_for_each(&_metal.common.generic_shmem_list, node) {
 1008ea4:	e0bffb17 	ldw	r2,-20(fp)
 1008ea8:	10800017 	ldw	r2,0(r2)
 1008eac:	e0bffb15 	stw	r2,-20(fp)
 1008eb0:	e0fffb17 	ldw	r3,-20(fp)
 1008eb4:	008060f4 	movhi	r2,387
 1008eb8:	10baf504 	addi	r2,r2,-5164
 1008ebc:	18bfe01e 	bne	r3,r2,1008e40 <__alt_data_end+0xff008e40>
			continue;
		*result = &shmem->io;
		return 0;
	}

	return -ENOENT;
 1008ec0:	00bfff84 	movi	r2,-2
}
 1008ec4:	e037883a 	mov	sp,fp
 1008ec8:	dfc00117 	ldw	ra,4(sp)
 1008ecc:	df000017 	ldw	fp,0(sp)
 1008ed0:	dec00204 	addi	sp,sp,8
 1008ed4:	f800283a 	ret

01008ed8 <metal_irq_handle>:
 * @param[in] irq IRQ id which will be passed to handler
 * @return IRQ handler status
 */
static inline
int metal_irq_handle(struct metal_irq *irq_data, int irq)
{
 1008ed8:	defffc04 	addi	sp,sp,-16
 1008edc:	dfc00315 	stw	ra,12(sp)
 1008ee0:	df000215 	stw	fp,8(sp)
 1008ee4:	df000204 	addi	fp,sp,8
 1008ee8:	e13ffe15 	stw	r4,-8(fp)
 1008eec:	e17fff15 	stw	r5,-4(fp)
	if (irq_data != NULL && irq_data->hd != NULL) {
 1008ef0:	e0bffe17 	ldw	r2,-8(fp)
 1008ef4:	10000b26 	beq	r2,zero,1008f24 <metal_irq_handle+0x4c>
 1008ef8:	e0bffe17 	ldw	r2,-8(fp)
 1008efc:	10800017 	ldw	r2,0(r2)
 1008f00:	10000826 	beq	r2,zero,1008f24 <metal_irq_handle+0x4c>
		return irq_data->hd(irq, irq_data->arg);
 1008f04:	e0bffe17 	ldw	r2,-8(fp)
 1008f08:	10800017 	ldw	r2,0(r2)
 1008f0c:	e0fffe17 	ldw	r3,-8(fp)
 1008f10:	18c00117 	ldw	r3,4(r3)
 1008f14:	180b883a 	mov	r5,r3
 1008f18:	e13fff17 	ldw	r4,-4(fp)
 1008f1c:	103ee83a 	callr	r2
 1008f20:	00000106 	br	1008f28 <metal_irq_handle+0x50>
	} else {
		return METAL_IRQ_NOT_HANDLED;
 1008f24:	0005883a 	mov	r2,zero
	}
}
 1008f28:	e037883a 	mov	sp,fp
 1008f2c:	dfc00117 	ldw	ra,4(sp)
 1008f30:	df000017 	ldw	fp,0(sp)
 1008f34:	dec00204 	addi	sp,sp,8
 1008f38:	f800283a 	ret

01008f3c <metal_softirq_set_enable>:
static int metal_softirq_avail = 0;
METAL_SOFTIRQ_ARRAY_DECLARE(METAL_SOFTIRQ_NUM)

static void metal_softirq_set_enable(struct metal_irq_controller *cntr,
				     int irq, unsigned int enable)
{
 1008f3c:	defffc04 	addi	sp,sp,-16
 1008f40:	df000315 	stw	fp,12(sp)
 1008f44:	df000304 	addi	fp,sp,12
 1008f48:	e13ffd15 	stw	r4,-12(fp)
 1008f4c:	e17ffe15 	stw	r5,-8(fp)
 1008f50:	e1bfff15 	stw	r6,-4(fp)
	if (irq < cntr->irq_base ||
 1008f54:	e0bffd17 	ldw	r2,-12(fp)
 1008f58:	10800017 	ldw	r2,0(r2)
 1008f5c:	e0fffe17 	ldw	r3,-8(fp)
 1008f60:	18801e16 	blt	r3,r2,1008fdc <metal_softirq_set_enable+0xa0>
	    irq >= (cntr->irq_base + cntr->irq_num)) {
 1008f64:	e0bffd17 	ldw	r2,-12(fp)
 1008f68:	10c00017 	ldw	r3,0(r2)
 1008f6c:	e0bffd17 	ldw	r2,-12(fp)
 1008f70:	10800117 	ldw	r2,4(r2)
 1008f74:	1885883a 	add	r2,r3,r2
METAL_SOFTIRQ_ARRAY_DECLARE(METAL_SOFTIRQ_NUM)

static void metal_softirq_set_enable(struct metal_irq_controller *cntr,
				     int irq, unsigned int enable)
{
	if (irq < cntr->irq_base ||
 1008f78:	e0fffe17 	ldw	r3,-8(fp)
 1008f7c:	1880170e 	bge	r3,r2,1008fdc <metal_softirq_set_enable+0xa0>
	    irq >= (cntr->irq_base + cntr->irq_num)) {
		return;
	}

	irq -= cntr->irq_base;
 1008f80:	e0bffd17 	ldw	r2,-12(fp)
 1008f84:	10800017 	ldw	r2,0(r2)
 1008f88:	e0fffe17 	ldw	r3,-8(fp)
 1008f8c:	1885c83a 	sub	r2,r3,r2
 1008f90:	e0bffe15 	stw	r2,-8(fp)
	if (enable ==  METAL_IRQ_ENABLE) {
 1008f94:	e0bfff17 	ldw	r2,-4(fp)
 1008f98:	10800058 	cmpnei	r2,r2,1
 1008f9c:	1000081e 	bne	r2,zero,1008fc0 <metal_softirq_set_enable+0x84>
		atomic_store(&metal_softirq_enabled[irq], 1);
 1008fa0:	008060f4 	movhi	r2,387
 1008fa4:	10bab604 	addi	r2,r2,-5416
 1008fa8:	e0fffe17 	ldw	r3,-8(fp)
 1008fac:	10c5883a 	add	r2,r2,r3
 1008fb0:	00c00044 	movi	r3,1
 1008fb4:	10c00005 	stb	r3,0(r2)
 1008fb8:	0001b03a 	sync
 1008fbc:	00000806 	br	1008fe0 <metal_softirq_set_enable+0xa4>
	} else {
		atomic_store(&metal_softirq_enabled[irq], 0);
 1008fc0:	008060f4 	movhi	r2,387
 1008fc4:	10bab604 	addi	r2,r2,-5416
 1008fc8:	e0fffe17 	ldw	r3,-8(fp)
 1008fcc:	10c5883a 	add	r2,r2,r3
 1008fd0:	10000005 	stb	zero,0(r2)
 1008fd4:	0001b03a 	sync
 1008fd8:	00000106 	br	1008fe0 <metal_softirq_set_enable+0xa4>
static void metal_softirq_set_enable(struct metal_irq_controller *cntr,
				     int irq, unsigned int enable)
{
	if (irq < cntr->irq_base ||
	    irq >= (cntr->irq_base + cntr->irq_num)) {
		return;
 1008fdc:	0001883a 	nop
	if (enable ==  METAL_IRQ_ENABLE) {
		atomic_store(&metal_softirq_enabled[irq], 1);
	} else {
		atomic_store(&metal_softirq_enabled[irq], 0);
	}
}
 1008fe0:	e037883a 	mov	sp,fp
 1008fe4:	df000017 	ldw	fp,0(sp)
 1008fe8:	dec00104 	addi	sp,sp,4
 1008fec:	f800283a 	ret

01008ff0 <metal_softirq_set>:
				    NULL,
				    metal_softirq_set_enable, NULL,
				    metal_softirqs)

void metal_softirq_set(int irq)
{
 1008ff0:	defffd04 	addi	sp,sp,-12
 1008ff4:	df000215 	stw	fp,8(sp)
 1008ff8:	df000204 	addi	fp,sp,8
 1008ffc:	e13fff15 	stw	r4,-4(fp)
	struct metal_irq_controller *cntr;

	cntr = &metal_softirq_cntr;
 1009000:	008040f4 	movhi	r2,259
 1009004:	10ab7104 	addi	r2,r2,-21052
 1009008:	e0bffe15 	stw	r2,-8(fp)

	if (irq < cntr->irq_base ||
 100900c:	e0bffe17 	ldw	r2,-8(fp)
 1009010:	10800017 	ldw	r2,0(r2)
 1009014:	e0ffff17 	ldw	r3,-4(fp)
 1009018:	18801416 	blt	r3,r2,100906c <metal_softirq_set+0x7c>
	    irq >= (cntr->irq_base + cntr->irq_num)) {
 100901c:	e0bffe17 	ldw	r2,-8(fp)
 1009020:	10c00017 	ldw	r3,0(r2)
 1009024:	e0bffe17 	ldw	r2,-8(fp)
 1009028:	10800117 	ldw	r2,4(r2)
 100902c:	1885883a 	add	r2,r3,r2
{
	struct metal_irq_controller *cntr;

	cntr = &metal_softirq_cntr;

	if (irq < cntr->irq_base ||
 1009030:	e0ffff17 	ldw	r3,-4(fp)
 1009034:	18800d0e 	bge	r3,r2,100906c <metal_softirq_set+0x7c>
	    irq >= (cntr->irq_base + cntr->irq_num)) {
		return;
	}

	irq -= cntr->irq_base;
 1009038:	e0bffe17 	ldw	r2,-8(fp)
 100903c:	10800017 	ldw	r2,0(r2)
 1009040:	e0ffff17 	ldw	r3,-4(fp)
 1009044:	1885c83a 	sub	r2,r3,r2
 1009048:	e0bfff15 	stw	r2,-4(fp)
	atomic_store(&metal_softirq_pending[irq], 1);
 100904c:	008060f4 	movhi	r2,387
 1009050:	10baa604 	addi	r2,r2,-5480
 1009054:	e0ffff17 	ldw	r3,-4(fp)
 1009058:	10c5883a 	add	r2,r2,r3
 100905c:	00c00044 	movi	r3,1
 1009060:	10c00005 	stb	r3,0(r2)
 1009064:	0001b03a 	sync
 1009068:	00000106 	br	1009070 <metal_softirq_set+0x80>

	cntr = &metal_softirq_cntr;

	if (irq < cntr->irq_base ||
	    irq >= (cntr->irq_base + cntr->irq_num)) {
		return;
 100906c:	0001883a 	nop
	}

	irq -= cntr->irq_base;
	atomic_store(&metal_softirq_pending[irq], 1);
}
 1009070:	e037883a 	mov	sp,fp
 1009074:	df000017 	ldw	fp,0(sp)
 1009078:	dec00104 	addi	sp,sp,4
 100907c:	f800283a 	ret

01009080 <metal_softirq_init>:

int metal_softirq_init()
{
 1009080:	defffe04 	addi	sp,sp,-8
 1009084:	dfc00115 	stw	ra,4(sp)
 1009088:	df000015 	stw	fp,0(sp)
 100908c:	d839883a 	mov	fp,sp
	return metal_irq_register_controller(&metal_softirq_cntr);
 1009090:	010040f4 	movhi	r4,259
 1009094:	212b7104 	addi	r4,r4,-21052
 1009098:	10088a40 	call	10088a4 <metal_irq_register_controller>
}
 100909c:	e037883a 	mov	sp,fp
 10090a0:	dfc00117 	ldw	ra,4(sp)
 10090a4:	df000017 	ldw	fp,0(sp)
 10090a8:	dec00204 	addi	sp,sp,8
 10090ac:	f800283a 	ret

010090b0 <metal_softirq_allocate>:

int metal_softirq_allocate(int num)
{
 10090b0:	defffc04 	addi	sp,sp,-16
 10090b4:	dfc00315 	stw	ra,12(sp)
 10090b8:	df000215 	stw	fp,8(sp)
 10090bc:	df000204 	addi	fp,sp,8
 10090c0:	e13fff15 	stw	r4,-4(fp)
	int irq_base;

	if ((metal_softirq_avail + num) >= metal_softirq_num) {
 10090c4:	d0e75117 	ldw	r3,-25276(gp)
 10090c8:	e0bfff17 	ldw	r2,-4(fp)
 10090cc:	1887883a 	add	r3,r3,r2
 10090d0:	00801004 	movi	r2,64
 10090d4:	18801316 	blt	r3,r2,1009124 <metal_softirq_allocate+0x74>
		metal_log(METAL_LOG_ERROR, "No %d available soft irqs.\r\n",
 10090d8:	008060f4 	movhi	r2,387
 10090dc:	10baf104 	addi	r2,r2,-5180
 10090e0:	10800017 	ldw	r2,0(r2)
 10090e4:	108000f0 	cmpltui	r2,r2,3
 10090e8:	10000c1e 	bne	r2,zero,100911c <metal_softirq_allocate+0x6c>
 10090ec:	008060f4 	movhi	r2,387
 10090f0:	10baf104 	addi	r2,r2,-5180
 10090f4:	10800117 	ldw	r2,4(r2)
 10090f8:	10000826 	beq	r2,zero,100911c <metal_softirq_allocate+0x6c>
 10090fc:	008060f4 	movhi	r2,387
 1009100:	10baf104 	addi	r2,r2,-5180
 1009104:	10800117 	ldw	r2,4(r2)
 1009108:	e1bfff17 	ldw	r6,-4(fp)
 100910c:	014040f4 	movhi	r5,259
 1009110:	29652704 	addi	r5,r5,-27492
 1009114:	010000c4 	movi	r4,3
 1009118:	103ee83a 	callr	r2
			  num);
		return -EINVAL;
 100911c:	00bffa84 	movi	r2,-22
 1009120:	00000d06 	br	1009158 <metal_softirq_allocate+0xa8>
	}
	irq_base = metal_softirq_avail;
 1009124:	d0a75117 	ldw	r2,-25276(gp)
 1009128:	e0bffe15 	stw	r2,-8(fp)
	irq_base += metal_softirq_cntr.irq_base;
 100912c:	008040f4 	movhi	r2,259
 1009130:	10ab7104 	addi	r2,r2,-21052
 1009134:	10800017 	ldw	r2,0(r2)
 1009138:	e0fffe17 	ldw	r3,-8(fp)
 100913c:	1885883a 	add	r2,r3,r2
 1009140:	e0bffe15 	stw	r2,-8(fp)
	metal_softirq_avail += num;
 1009144:	d0e75117 	ldw	r3,-25276(gp)
 1009148:	e0bfff17 	ldw	r2,-4(fp)
 100914c:	1885883a 	add	r2,r3,r2
 1009150:	d0a75115 	stw	r2,-25276(gp)
	return irq_base;
 1009154:	e0bffe17 	ldw	r2,-8(fp)
}
 1009158:	e037883a 	mov	sp,fp
 100915c:	dfc00117 	ldw	ra,4(sp)
 1009160:	df000017 	ldw	fp,0(sp)
 1009164:	dec00204 	addi	sp,sp,8
 1009168:	f800283a 	ret

0100916c <metal_softirq_dispatch>:

void metal_softirq_dispatch()
{
 100916c:	defff604 	addi	sp,sp,-40
 1009170:	dfc00915 	stw	ra,36(sp)
 1009174:	df000815 	stw	fp,32(sp)
 1009178:	df000804 	addi	fp,sp,32
	int i;

	for (i = 0; i < metal_softirq_num; i++) {
 100917c:	e03ff815 	stw	zero,-32(fp)
 1009180:	00003f06 	br	1009280 <metal_softirq_dispatch+0x114>
		struct metal_irq *irq;
		char is_pending = 1;
 1009184:	00800044 	movi	r2,1
 1009188:	e0bfff05 	stb	r2,-4(fp)

		atomic_char val1;
		atomic_char val2;

		atomic_mutex_acquire();
 100918c:	1005e680 	call	1005e68 <atomic_mutex_acquire>
		val1 = atomic_load(&metal_softirq_enabled[i]);
 1009190:	0001b03a 	sync
 1009194:	008060f4 	movhi	r2,387
 1009198:	10bab604 	addi	r2,r2,-5416
 100919c:	e0fff817 	ldw	r3,-32(fp)
 10091a0:	10c5883a 	add	r2,r2,r3
 10091a4:	10800003 	ldbu	r2,0(r2)
 10091a8:	e0bffa45 	stb	r2,-23(fp)
		val2 = atomic_compare_exchange_strong(&metal_softirq_pending[i],
 10091ac:	e0fff817 	ldw	r3,-32(fp)
 10091b0:	008060f4 	movhi	r2,387
 10091b4:	10baa604 	addi	r2,r2,-5480
 10091b8:	1885883a 	add	r2,r3,r2
 10091bc:	e0bffb15 	stw	r2,-20(fp)
 10091c0:	e0bfff04 	addi	r2,fp,-4
 10091c4:	e0bffc15 	stw	r2,-16(fp)
 10091c8:	e0bffc17 	ldw	r2,-16(fp)
 10091cc:	10800003 	ldbu	r2,0(r2)
 10091d0:	e0bffd05 	stb	r2,-12(fp)
 10091d4:	e03ffd45 	stb	zero,-11(fp)
 10091d8:	e0bff917 	ldw	r2,-28(fp)
 10091dc:	10800003 	ldbu	r2,0(r2)
 10091e0:	10c03fcc 	andi	r3,r2,255
 10091e4:	18c0201c 	xori	r3,r3,128
 10091e8:	18ffe004 	addi	r3,r3,-128
 10091ec:	e0bffa07 	ldb	r2,-24(fp)
 10091f0:	1880031e 	bne	r3,r2,1009200 <metal_softirq_dispatch+0x94>
 10091f4:	e0bff917 	ldw	r2,-28(fp)
 10091f8:	e0fffd43 	ldbu	r3,-11(fp)
 10091fc:	10c00005 	stb	r3,0(r2)
 1009200:	e0bffa03 	ldbu	r2,-24(fp)
 1009204:	e0bffd85 	stb	r2,-10(fp)
 1009208:	e0bffc17 	ldw	r2,-16(fp)
 100920c:	e0fffd83 	ldbu	r3,-10(fp)
 1009210:	10c00005 	stb	r3,0(r2)
 1009214:	e0fffd87 	ldb	r3,-10(fp)
 1009218:	e0bffd07 	ldb	r2,-12(fp)
 100921c:	1885003a 	cmpeq	r2,r3,r2
 1009220:	10803fcc 	andi	r2,r2,255
 1009224:	e0bffdc5 	stb	r2,-9(fp)
				   &is_pending, 0);
		atomic_mutex_release();
 1009228:	1005e9c0 	call	1005e9c <atomic_mutex_release>

		if (val1 != 0 && val2) {
 100922c:	e0bffa47 	ldb	r2,-23(fp)
 1009230:	10001026 	beq	r2,zero,1009274 <metal_softirq_dispatch+0x108>
 1009234:	e0bffdc7 	ldb	r2,-9(fp)
 1009238:	10000e26 	beq	r2,zero,1009274 <metal_softirq_dispatch+0x108>
			irq = &metal_softirqs[i];
 100923c:	e0bff817 	ldw	r2,-32(fp)
 1009240:	100690fa 	slli	r3,r2,3
 1009244:	008060f4 	movhi	r2,387
 1009248:	10ba2604 	addi	r2,r2,-5992
 100924c:	1885883a 	add	r2,r3,r2
 1009250:	e0bffe15 	stw	r2,-8(fp)
			(void)metal_irq_handle(irq,
					       i + metal_softirq_cntr.irq_base);
 1009254:	008040f4 	movhi	r2,259
 1009258:	10ab7104 	addi	r2,r2,-21052
 100925c:	10c00017 	ldw	r3,0(r2)
				   &is_pending, 0);
		atomic_mutex_release();

		if (val1 != 0 && val2) {
			irq = &metal_softirqs[i];
			(void)metal_irq_handle(irq,
 1009260:	e0bff817 	ldw	r2,-32(fp)
 1009264:	1885883a 	add	r2,r3,r2
 1009268:	100b883a 	mov	r5,r2
 100926c:	e13ffe17 	ldw	r4,-8(fp)
 1009270:	1008ed80 	call	1008ed8 <metal_irq_handle>

void metal_softirq_dispatch()
{
	int i;

	for (i = 0; i < metal_softirq_num; i++) {
 1009274:	e0bff817 	ldw	r2,-32(fp)
 1009278:	10800044 	addi	r2,r2,1
 100927c:	e0bff815 	stw	r2,-32(fp)
 1009280:	00801004 	movi	r2,64
 1009284:	e0fff817 	ldw	r3,-32(fp)
 1009288:	18bfbe16 	blt	r3,r2,1009184 <__alt_data_end+0xff009184>
			irq = &metal_softirqs[i];
			(void)metal_irq_handle(irq,
					       i + metal_softirq_cntr.irq_base);
		}
	}
}
 100928c:	0001883a 	nop
 1009290:	e037883a 	mov	sp,fp
 1009294:	dfc00117 	ldw	ra,4(sp)
 1009298:	df000017 	ldw	fp,0(sp)
 100929c:	dec00204 	addi	sp,sp,8
 10092a0:	f800283a 	ret

010092a4 <__metal_mutex_init>:
 * static singleton mutex
 */
#define METAL_MUTEX_DEFINE(m) metal_mutex_t m = METAL_MUTEX_INIT(m)

static inline void __metal_mutex_init(metal_mutex_t *mutex)
{
 10092a4:	defffe04 	addi	sp,sp,-8
 10092a8:	df000115 	stw	fp,4(sp)
 10092ac:	df000104 	addi	fp,sp,4
 10092b0:	e13fff15 	stw	r4,-4(fp)
	atomic_store(&mutex->v, 0);
 10092b4:	e0bfff17 	ldw	r2,-4(fp)
 10092b8:	10000015 	stw	zero,0(r2)
 10092bc:	0001b03a 	sync
}
 10092c0:	0001883a 	nop
 10092c4:	e037883a 	mov	sp,fp
 10092c8:	df000017 	ldw	fp,0(sp)
 10092cc:	dec00104 	addi	sp,sp,4
 10092d0:	f800283a 	ret

010092d4 <__metal_mutex_deinit>:

static inline void __metal_mutex_deinit(metal_mutex_t *mutex)
{
 10092d4:	defffe04 	addi	sp,sp,-8
 10092d8:	df000115 	stw	fp,4(sp)
 10092dc:	df000104 	addi	fp,sp,4
 10092e0:	e13fff15 	stw	r4,-4(fp)
	(void)mutex;
}
 10092e4:	0001883a 	nop
 10092e8:	e037883a 	mov	sp,fp
 10092ec:	df000017 	ldw	fp,0(sp)
 10092f0:	dec00104 	addi	sp,sp,4
 10092f4:	f800283a 	ret

010092f8 <__metal_mutex_acquire>:
{
	return 1 - atomic_flag_test_and_set(&mutex->v);
}

static inline void __metal_mutex_acquire(metal_mutex_t *mutex)
{
 10092f8:	defffb04 	addi	sp,sp,-20
 10092fc:	df000415 	stw	fp,16(sp)
 1009300:	df000404 	addi	fp,sp,16
 1009304:	e13fff15 	stw	r4,-4(fp)
	while (atomic_flag_test_and_set(&mutex->v)) {
 1009308:	0001883a 	nop
 100930c:	e0bfff17 	ldw	r2,-4(fp)
 1009310:	e0bffc15 	stw	r2,-16(fp)
 1009314:	e0bffc17 	ldw	r2,-16(fp)
 1009318:	10800017 	ldw	r2,0(r2)
 100931c:	e0bffd15 	stw	r2,-12(fp)
 1009320:	00800044 	movi	r2,1
 1009324:	e0bffe15 	stw	r2,-8(fp)
 1009328:	e0bfff17 	ldw	r2,-4(fp)
 100932c:	e0fffe17 	ldw	r3,-8(fp)
 1009330:	10c00015 	stw	r3,0(r2)
 1009334:	e0bffd17 	ldw	r2,-12(fp)
 1009338:	103ff41e 	bne	r2,zero,100930c <__alt_data_end+0xff00930c>
		;
	}
}
 100933c:	0001883a 	nop
 1009340:	e037883a 	mov	sp,fp
 1009344:	df000017 	ldw	fp,0(sp)
 1009348:	dec00104 	addi	sp,sp,4
 100934c:	f800283a 	ret

01009350 <__metal_mutex_release>:

static inline void __metal_mutex_release(metal_mutex_t *mutex)
{
 1009350:	defffe04 	addi	sp,sp,-8
 1009354:	df000115 	stw	fp,4(sp)
 1009358:	df000104 	addi	fp,sp,4
 100935c:	e13fff15 	stw	r4,-4(fp)
	atomic_flag_clear(&mutex->v);
 1009360:	e0bfff17 	ldw	r2,-4(fp)
 1009364:	0001b03a 	sync
 1009368:	10000015 	stw	zero,0(r2)
}
 100936c:	0001883a 	nop
 1009370:	e037883a 	mov	sp,fp
 1009374:	df000017 	ldw	fp,0(sp)
 1009378:	dec00104 	addi	sp,sp,4
 100937c:	f800283a 	ret

01009380 <metal_mutex_init>:
/**
 * @brief	Initialize a libmetal mutex.
 * @param[in]	mutex	Mutex to initialize.
 */
static inline void metal_mutex_init(metal_mutex_t *mutex)
{
 1009380:	defffd04 	addi	sp,sp,-12
 1009384:	dfc00215 	stw	ra,8(sp)
 1009388:	df000115 	stw	fp,4(sp)
 100938c:	df000104 	addi	fp,sp,4
 1009390:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_init(mutex);
 1009394:	e13fff17 	ldw	r4,-4(fp)
 1009398:	10092a40 	call	10092a4 <__metal_mutex_init>
}
 100939c:	0001883a 	nop
 10093a0:	e037883a 	mov	sp,fp
 10093a4:	dfc00117 	ldw	ra,4(sp)
 10093a8:	df000017 	ldw	fp,0(sp)
 10093ac:	dec00204 	addi	sp,sp,8
 10093b0:	f800283a 	ret

010093b4 <metal_mutex_deinit>:
/**
 * @brief	Deinitialize a libmetal mutex.
 * @param[in]	mutex	Mutex to deinitialize.
 */
static inline void metal_mutex_deinit(metal_mutex_t *mutex)
{
 10093b4:	defffd04 	addi	sp,sp,-12
 10093b8:	dfc00215 	stw	ra,8(sp)
 10093bc:	df000115 	stw	fp,4(sp)
 10093c0:	df000104 	addi	fp,sp,4
 10093c4:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_deinit(mutex);
 10093c8:	e13fff17 	ldw	r4,-4(fp)
 10093cc:	10092d40 	call	10092d4 <__metal_mutex_deinit>
}
 10093d0:	0001883a 	nop
 10093d4:	e037883a 	mov	sp,fp
 10093d8:	dfc00117 	ldw	ra,4(sp)
 10093dc:	df000017 	ldw	fp,0(sp)
 10093e0:	dec00204 	addi	sp,sp,8
 10093e4:	f800283a 	ret

010093e8 <metal_mutex_acquire>:
/**
 * @brief	Acquire a mutex 
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
 10093e8:	defffd04 	addi	sp,sp,-12
 10093ec:	dfc00215 	stw	ra,8(sp)
 10093f0:	df000115 	stw	fp,4(sp)
 10093f4:	df000104 	addi	fp,sp,4
 10093f8:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_acquire(mutex);
 10093fc:	e13fff17 	ldw	r4,-4(fp)
 1009400:	10092f80 	call	10092f8 <__metal_mutex_acquire>
}
 1009404:	0001883a 	nop
 1009408:	e037883a 	mov	sp,fp
 100940c:	dfc00117 	ldw	ra,4(sp)
 1009410:	df000017 	ldw	fp,0(sp)
 1009414:	dec00204 	addi	sp,sp,8
 1009418:	f800283a 	ret

0100941c <metal_mutex_release>:
 * @brief	Release a previously acquired mutex.
 * @param[in]	mutex	Mutex to mutex.
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
 100941c:	defffd04 	addi	sp,sp,-12
 1009420:	dfc00215 	stw	ra,8(sp)
 1009424:	df000115 	stw	fp,4(sp)
 1009428:	df000104 	addi	fp,sp,4
 100942c:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_release(mutex);
 1009430:	e13fff17 	ldw	r4,-4(fp)
 1009434:	10093500 	call	1009350 <__metal_mutex_release>
}
 1009438:	0001883a 	nop
 100943c:	e037883a 	mov	sp,fp
 1009440:	dfc00117 	ldw	ra,4(sp)
 1009444:	df000017 	ldw	fp,0(sp)
 1009448:	dec00204 	addi	sp,sp,8
 100944c:	f800283a 	ret

01009450 <metal_spinlock_init>:
/**
 * @brief	Initialize a libmetal spinlock.
 * @param[in]	slock	Spinlock to initialize.
 */
static inline void metal_spinlock_init(struct metal_spinlock *slock)
{
 1009450:	defffe04 	addi	sp,sp,-8
 1009454:	df000115 	stw	fp,4(sp)
 1009458:	df000104 	addi	fp,sp,4
 100945c:	e13fff15 	stw	r4,-4(fp)
	atomic_flag_clear(&slock->v);
 1009460:	e0bfff17 	ldw	r2,-4(fp)
 1009464:	0001b03a 	sync
 1009468:	10000015 	stw	zero,0(r2)
}
 100946c:	0001883a 	nop
 1009470:	e037883a 	mov	sp,fp
 1009474:	df000017 	ldw	fp,0(sp)
 1009478:	dec00104 	addi	sp,sp,4
 100947c:	f800283a 	ret

01009480 <metal_spinlock_acquire>:
 * @brief	Acquire a spinlock.
 * @param[in]	slock   Spinlock to acquire.
 * @see metal_spinlock_release
 */
static inline void metal_spinlock_acquire(struct metal_spinlock *slock)
{
 1009480:	defff604 	addi	sp,sp,-40
 1009484:	dfc00915 	stw	ra,36(sp)
 1009488:	df000815 	stw	fp,32(sp)
 100948c:	df000804 	addi	fp,sp,32
 1009490:	e13fff15 	stw	r4,-4(fp)
	atomic_flag val;

	atomic_mutex_acquire();
 1009494:	1005e680 	call	1005e68 <atomic_mutex_acquire>
	val = atomic_flag_test_and_set(&slock->v);
 1009498:	e0bfff17 	ldw	r2,-4(fp)
 100949c:	e0bff915 	stw	r2,-28(fp)
 10094a0:	e0bff917 	ldw	r2,-28(fp)
 10094a4:	10800017 	ldw	r2,0(r2)
 10094a8:	e0bffa15 	stw	r2,-24(fp)
 10094ac:	00800044 	movi	r2,1
 10094b0:	e0bffb15 	stw	r2,-20(fp)
 10094b4:	e0bfff17 	ldw	r2,-4(fp)
 10094b8:	e0fffb17 	ldw	r3,-20(fp)
 10094bc:	10c00015 	stw	r3,0(r2)
 10094c0:	e0bffa17 	ldw	r2,-24(fp)
 10094c4:	e0bff815 	stw	r2,-32(fp)
	atomic_mutex_release();
 10094c8:	1005e9c0 	call	1005e9c <atomic_mutex_release>

	while (val) {
 10094cc:	00000f06 	br	100950c <metal_spinlock_acquire+0x8c>
		metal_cpu_yield();
 10094d0:	0001883a 	nop

		atomic_mutex_acquire();
 10094d4:	1005e680 	call	1005e68 <atomic_mutex_acquire>
		val = atomic_flag_test_and_set(&slock->v);
 10094d8:	e0bfff17 	ldw	r2,-4(fp)
 10094dc:	e0bffc15 	stw	r2,-16(fp)
 10094e0:	e0bffc17 	ldw	r2,-16(fp)
 10094e4:	10800017 	ldw	r2,0(r2)
 10094e8:	e0bffd15 	stw	r2,-12(fp)
 10094ec:	00800044 	movi	r2,1
 10094f0:	e0bffe15 	stw	r2,-8(fp)
 10094f4:	e0bfff17 	ldw	r2,-4(fp)
 10094f8:	e0fffe17 	ldw	r3,-8(fp)
 10094fc:	10c00015 	stw	r3,0(r2)
 1009500:	e0bffd17 	ldw	r2,-12(fp)
 1009504:	e0bff815 	stw	r2,-32(fp)
		atomic_mutex_release();
 1009508:	1005e9c0 	call	1005e9c <atomic_mutex_release>

	atomic_mutex_acquire();
	val = atomic_flag_test_and_set(&slock->v);
	atomic_mutex_release();

	while (val) {
 100950c:	e0bff817 	ldw	r2,-32(fp)
 1009510:	103fef1e 	bne	r2,zero,10094d0 <__alt_data_end+0xff0094d0>

		atomic_mutex_acquire();
		val = atomic_flag_test_and_set(&slock->v);
		atomic_mutex_release();
	}
}
 1009514:	0001883a 	nop
 1009518:	e037883a 	mov	sp,fp
 100951c:	dfc00117 	ldw	ra,4(sp)
 1009520:	df000017 	ldw	fp,0(sp)
 1009524:	dec00204 	addi	sp,sp,8
 1009528:	f800283a 	ret

0100952c <metal_spinlock_release>:
 * @brief	Release a previously acquired spinlock.
 * @param[in]	slock	Spinlock to release.
 * @see metal_spinlock_acquire
 */
static inline void metal_spinlock_release(struct metal_spinlock *slock)
{
 100952c:	defffe04 	addi	sp,sp,-8
 1009530:	df000115 	stw	fp,4(sp)
 1009534:	df000104 	addi	fp,sp,4
 1009538:	e13fff15 	stw	r4,-4(fp)
	atomic_flag_clear(&slock->v);
 100953c:	e0bfff17 	ldw	r2,-4(fp)
 1009540:	0001b03a 	sync
 1009544:	10000015 	stw	zero,0(r2)
}
 1009548:	0001883a 	nop
 100954c:	e037883a 	mov	sp,fp
 1009550:	df000017 	ldw	fp,0(sp)
 1009554:	dec00104 	addi	sp,sp,4
 1009558:	f800283a 	ret

0100955c <rpmsg_send>:
 *
 * Returns number of bytes it has sent or negative error value on failure.
 */
static inline int rpmsg_send(struct rpmsg_endpoint *ept, const void *data,
			     int len)
{
 100955c:	defff904 	addi	sp,sp,-28
 1009560:	dfc00615 	stw	ra,24(sp)
 1009564:	df000515 	stw	fp,20(sp)
 1009568:	df000504 	addi	fp,sp,20
 100956c:	e13ffd15 	stw	r4,-12(fp)
 1009570:	e17ffe15 	stw	r5,-8(fp)
 1009574:	e1bfff15 	stw	r6,-4(fp)
	if (ept->dest_addr == RPMSG_ADDR_ANY)
 1009578:	e0bffd17 	ldw	r2,-12(fp)
 100957c:	10800a17 	ldw	r2,40(r2)
 1009580:	10bfffd8 	cmpnei	r2,r2,-1
 1009584:	1000021e 	bne	r2,zero,1009590 <rpmsg_send+0x34>
		return RPMSG_ERR_ADDR;
 1009588:	00be0a44 	movi	r2,-2007
 100958c:	00000d06 	br	10095c4 <rpmsg_send+0x68>
	return rpmsg_send_offchannel_raw(ept, ept->addr, ept->dest_addr, data,
 1009590:	e0bffd17 	ldw	r2,-12(fp)
 1009594:	10c00917 	ldw	r3,36(r2)
 1009598:	e0bffd17 	ldw	r2,-12(fp)
 100959c:	11000a17 	ldw	r4,40(r2)
 10095a0:	00800044 	movi	r2,1
 10095a4:	d8800115 	stw	r2,4(sp)
 10095a8:	e0bfff17 	ldw	r2,-4(fp)
 10095ac:	d8800015 	stw	r2,0(sp)
 10095b0:	e1fffe17 	ldw	r7,-8(fp)
 10095b4:	200d883a 	mov	r6,r4
 10095b8:	180b883a 	mov	r5,r3
 10095bc:	e13ffd17 	ldw	r4,-12(fp)
 10095c0:	1010b280 	call	1010b28 <rpmsg_send_offchannel_raw>
					 len, true);
}
 10095c4:	e037883a 	mov	sp,fp
 10095c8:	dfc00117 	ldw	ra,4(sp)
 10095cc:	df000017 	ldw	fp,0(sp)
 10095d0:	dec00204 	addi	sp,sp,8
 10095d4:	f800283a 	ret

010095d8 <is_rpmsg_ept_ready>:
 *
 * Returns 1 if the rpmsg endpoint has both local addr and destination
 * addr set, 0 otherwise
 */
static inline unsigned int is_rpmsg_ept_ready(struct rpmsg_endpoint *ept)
{
 10095d8:	defffe04 	addi	sp,sp,-8
 10095dc:	df000115 	stw	fp,4(sp)
 10095e0:	df000104 	addi	fp,sp,4
 10095e4:	e13fff15 	stw	r4,-4(fp)
	return (ept->dest_addr != RPMSG_ADDR_ANY) &&
 10095e8:	e0bfff17 	ldw	r2,-4(fp)
 10095ec:	10800a17 	ldw	r2,40(r2)
 10095f0:	10bfffe0 	cmpeqi	r2,r2,-1
 10095f4:	1000061e 	bne	r2,zero,1009610 <is_rpmsg_ept_ready+0x38>
		(ept->addr != RPMSG_ADDR_ANY);
 10095f8:	e0bfff17 	ldw	r2,-4(fp)
 10095fc:	10800917 	ldw	r2,36(r2)
 * Returns 1 if the rpmsg endpoint has both local addr and destination
 * addr set, 0 otherwise
 */
static inline unsigned int is_rpmsg_ept_ready(struct rpmsg_endpoint *ept)
{
	return (ept->dest_addr != RPMSG_ADDR_ANY) &&
 1009600:	10bfffe0 	cmpeqi	r2,r2,-1
 1009604:	1000021e 	bne	r2,zero,1009610 <is_rpmsg_ept_ready+0x38>
 1009608:	00800044 	movi	r2,1
 100960c:	00000106 	br	1009614 <is_rpmsg_ept_ready+0x3c>
 1009610:	0005883a 	mov	r2,zero
		(ept->addr != RPMSG_ADDR_ANY);
}
 1009614:	e037883a 	mov	sp,fp
 1009618:	df000017 	ldw	fp,0(sp)
 100961c:	dec00104 	addi	sp,sp,4
 1009620:	f800283a 	ret

01009624 <rpmsg_rpc_ept_cb>:
 *************************************************************************/
static struct rpmsg_rpc_data *rpmsg_default_rpc;

static int rpmsg_rpc_ept_cb(struct rpmsg_endpoint *ept, void *data, size_t len,
			    uint32_t src, void *priv)
{
 1009624:	defff804 	addi	sp,sp,-32
 1009628:	dfc00715 	stw	ra,28(sp)
 100962c:	df000615 	stw	fp,24(sp)
 1009630:	df000604 	addi	fp,sp,24
 1009634:	e13ffc15 	stw	r4,-16(fp)
 1009638:	e17ffd15 	stw	r5,-12(fp)
 100963c:	e1bffe15 	stw	r6,-8(fp)
 1009640:	e1ffff15 	stw	r7,-4(fp)
	struct rpmsg_rpc_syscall *syscall;

	(void)priv;
	(void)src;

	if (data != NULL && ept != NULL) {
 1009644:	e0bffd17 	ldw	r2,-12(fp)
 1009648:	10002c26 	beq	r2,zero,10096fc <rpmsg_rpc_ept_cb+0xd8>
 100964c:	e0bffc17 	ldw	r2,-16(fp)
 1009650:	10002a26 	beq	r2,zero,10096fc <rpmsg_rpc_ept_cb+0xd8>
		syscall = data;
 1009654:	e0bffd17 	ldw	r2,-12(fp)
 1009658:	e0bffa15 	stw	r2,-24(fp)
		if (syscall->id == TERM_SYSCALL_ID) {
 100965c:	e0bffa17 	ldw	r2,-24(fp)
 1009660:	10800017 	ldw	r2,0(r2)
 1009664:	10800198 	cmpnei	r2,r2,6
 1009668:	1000031e 	bne	r2,zero,1009678 <rpmsg_rpc_ept_cb+0x54>
			rpmsg_destroy_ept(ept);
 100966c:	e13ffc17 	ldw	r4,-16(fp)
 1009670:	10110180 	call	1011018 <rpmsg_destroy_ept>
 1009674:	00002106 	br	10096fc <rpmsg_rpc_ept_cb+0xd8>
		} else {
			struct rpmsg_rpc_data *rpc;

			rpc = metal_container_of(ept,
 1009678:	e0bffc17 	ldw	r2,-16(fp)
 100967c:	e0bffb15 	stw	r2,-20(fp)
						 struct rpmsg_rpc_data,
						 ept);
			metal_spinlock_acquire(&rpc->buflock);
 1009680:	e0bffb17 	ldw	r2,-20(fp)
 1009684:	10801804 	addi	r2,r2,96
 1009688:	1009883a 	mov	r4,r2
 100968c:	10094800 	call	1009480 <metal_spinlock_acquire>
			if (rpc->respbuf != NULL && rpc->respbuf_len != 0) {
 1009690:	e0bffb17 	ldw	r2,-20(fp)
 1009694:	10801217 	ldw	r2,72(r2)
 1009698:	10001026 	beq	r2,zero,10096dc <rpmsg_rpc_ept_cb+0xb8>
 100969c:	e0bffb17 	ldw	r2,-20(fp)
 10096a0:	10801317 	ldw	r2,76(r2)
 10096a4:	10000d26 	beq	r2,zero,10096dc <rpmsg_rpc_ept_cb+0xb8>
				if (len > rpc->respbuf_len)
 10096a8:	e0bffb17 	ldw	r2,-20(fp)
 10096ac:	10c01317 	ldw	r3,76(r2)
 10096b0:	e0bffe17 	ldw	r2,-8(fp)
 10096b4:	1880032e 	bgeu	r3,r2,10096c4 <rpmsg_rpc_ept_cb+0xa0>
					len = rpc->respbuf_len;
 10096b8:	e0bffb17 	ldw	r2,-20(fp)
 10096bc:	10801317 	ldw	r2,76(r2)
 10096c0:	e0bffe15 	stw	r2,-8(fp)
				memcpy(rpc->respbuf, data, len);
 10096c4:	e0bffb17 	ldw	r2,-20(fp)
 10096c8:	10801217 	ldw	r2,72(r2)
 10096cc:	e1bffe17 	ldw	r6,-8(fp)
 10096d0:	e17ffd17 	ldw	r5,-12(fp)
 10096d4:	1009883a 	mov	r4,r2
 10096d8:	10158f40 	call	10158f4 <memcpy>
			}
			atomic_flag_clear(&rpc->nacked);
 10096dc:	e0bffb17 	ldw	r2,-20(fp)
 10096e0:	10801104 	addi	r2,r2,68
 10096e4:	0001b03a 	sync
 10096e8:	10000015 	stw	zero,0(r2)
			metal_spinlock_release(&rpc->buflock);
 10096ec:	e0bffb17 	ldw	r2,-20(fp)
 10096f0:	10801804 	addi	r2,r2,96
 10096f4:	1009883a 	mov	r4,r2
 10096f8:	100952c0 	call	100952c <metal_spinlock_release>
		}
	}

	return RPMSG_SUCCESS;
 10096fc:	0005883a 	mov	r2,zero
}
 1009700:	e037883a 	mov	sp,fp
 1009704:	dfc00117 	ldw	ra,4(sp)
 1009708:	df000017 	ldw	fp,0(sp)
 100970c:	dec00204 	addi	sp,sp,8
 1009710:	f800283a 	ret

01009714 <rpmsg_service_unbind>:

static void rpmsg_service_unbind(struct rpmsg_endpoint *ept)
{
 1009714:	defffc04 	addi	sp,sp,-16
 1009718:	dfc00315 	stw	ra,12(sp)
 100971c:	df000215 	stw	fp,8(sp)
 1009720:	df000204 	addi	fp,sp,8
 1009724:	e13fff15 	stw	r4,-4(fp)
	struct rpmsg_rpc_data *rpc;

	rpc = metal_container_of(ept, struct rpmsg_rpc_data, ept);
 1009728:	e0bfff17 	ldw	r2,-4(fp)
 100972c:	e0bffe15 	stw	r2,-8(fp)
	rpc->ept_destroyed = 1;
 1009730:	e0bffe17 	ldw	r2,-8(fp)
 1009734:	00c00044 	movi	r3,1
 1009738:	10c01015 	stw	r3,64(r2)
	rpmsg_destroy_ept(ept);
 100973c:	e13fff17 	ldw	r4,-4(fp)
 1009740:	10110180 	call	1011018 <rpmsg_destroy_ept>
	atomic_flag_clear(&rpc->nacked);
 1009744:	e0bffe17 	ldw	r2,-8(fp)
 1009748:	10801104 	addi	r2,r2,68
 100974c:	0001b03a 	sync
 1009750:	10000015 	stw	zero,0(r2)
	if (rpc->shutdown_cb)
 1009754:	e0bffe17 	ldw	r2,-8(fp)
 1009758:	10801617 	ldw	r2,88(r2)
 100975c:	10000426 	beq	r2,zero,1009770 <rpmsg_service_unbind+0x5c>
		rpc->shutdown_cb(rpc);
 1009760:	e0bffe17 	ldw	r2,-8(fp)
 1009764:	10801617 	ldw	r2,88(r2)
 1009768:	e13ffe17 	ldw	r4,-8(fp)
 100976c:	103ee83a 	callr	r2
}
 1009770:	0001883a 	nop
 1009774:	e037883a 	mov	sp,fp
 1009778:	dfc00117 	ldw	ra,4(sp)
 100977c:	df000017 	ldw	fp,0(sp)
 1009780:	dec00204 	addi	sp,sp,8
 1009784:	f800283a 	ret

01009788 <rpmsg_rpc_init>:
		   struct rpmsg_device *rdev,
		   const char *ept_name, uint32_t ept_addr,
		   uint32_t ept_raddr,
		   void *poll_arg, rpmsg_rpc_poll poll,
		   rpmsg_rpc_shutdown_cb shutdown_cb)
{
 1009788:	defff604 	addi	sp,sp,-40
 100978c:	dfc00915 	stw	ra,36(sp)
 1009790:	df000815 	stw	fp,32(sp)
 1009794:	df000804 	addi	fp,sp,32
 1009798:	e13ffc15 	stw	r4,-16(fp)
 100979c:	e17ffd15 	stw	r5,-12(fp)
 10097a0:	e1bffe15 	stw	r6,-8(fp)
 10097a4:	e1ffff15 	stw	r7,-4(fp)
	int ret;

	if (rpc == NULL || rdev == NULL)
 10097a8:	e0bffc17 	ldw	r2,-16(fp)
 10097ac:	10000226 	beq	r2,zero,10097b8 <rpmsg_rpc_init+0x30>
 10097b0:	e0bffd17 	ldw	r2,-12(fp)
 10097b4:	1000021e 	bne	r2,zero,10097c0 <rpmsg_rpc_init+0x38>
		return -EINVAL;
 10097b8:	00bffa84 	movi	r2,-22
 10097bc:	00003f06 	br	10098bc <rpmsg_rpc_init+0x134>
	metal_spinlock_init(&rpc->buflock);
 10097c0:	e0bffc17 	ldw	r2,-16(fp)
 10097c4:	10801804 	addi	r2,r2,96
 10097c8:	1009883a 	mov	r4,r2
 10097cc:	10094500 	call	1009450 <metal_spinlock_init>
	metal_mutex_init(&rpc->lock);
 10097d0:	e0bffc17 	ldw	r2,-16(fp)
 10097d4:	10801704 	addi	r2,r2,92
 10097d8:	1009883a 	mov	r4,r2
 10097dc:	10093800 	call	1009380 <metal_mutex_init>
	rpc->shutdown_cb = shutdown_cb;
 10097e0:	e0bffc17 	ldw	r2,-16(fp)
 10097e4:	e0c00517 	ldw	r3,20(fp)
 10097e8:	10c01615 	stw	r3,88(r2)
	rpc->poll_arg = poll_arg;
 10097ec:	e0bffc17 	ldw	r2,-16(fp)
 10097f0:	e0c00317 	ldw	r3,12(fp)
 10097f4:	10c01515 	stw	r3,84(r2)
	rpc->poll = poll;
 10097f8:	e0bffc17 	ldw	r2,-16(fp)
 10097fc:	e0c00417 	ldw	r3,16(fp)
 1009800:	10c01415 	stw	r3,80(r2)
	rpc->ept_destroyed = 0;
 1009804:	e0bffc17 	ldw	r2,-16(fp)
 1009808:	10001015 	stw	zero,64(r2)
	rpc->respbuf = NULL;
 100980c:	e0bffc17 	ldw	r2,-16(fp)
 1009810:	10001215 	stw	zero,72(r2)
	rpc->respbuf_len = 0;
 1009814:	e0bffc17 	ldw	r2,-16(fp)
 1009818:	10001315 	stw	zero,76(r2)
	atomic_init(&rpc->nacked, 1);
 100981c:	e0bffc17 	ldw	r2,-16(fp)
 1009820:	00c00044 	movi	r3,1
 1009824:	10c01115 	stw	r3,68(r2)
	ret = rpmsg_create_ept(&rpc->ept, rdev,
 1009828:	e0fffc17 	ldw	r3,-16(fp)
 100982c:	00804074 	movhi	r2,257
 1009830:	10a5c504 	addi	r2,r2,-26860
 1009834:	d8800215 	stw	r2,8(sp)
 1009838:	00804074 	movhi	r2,257
 100983c:	10a58904 	addi	r2,r2,-27100
 1009840:	d8800115 	stw	r2,4(sp)
 1009844:	e0800217 	ldw	r2,8(fp)
 1009848:	d8800015 	stw	r2,0(sp)
 100984c:	e1ffff17 	ldw	r7,-4(fp)
 1009850:	e1bffe17 	ldw	r6,-8(fp)
 1009854:	e17ffd17 	ldw	r5,-12(fp)
 1009858:	1809883a 	mov	r4,r3
 100985c:	1010e900 	call	1010e90 <rpmsg_create_ept>
 1009860:	e0bffb15 	stw	r2,-20(fp)
			       ept_name, ept_addr, ept_raddr,
			       rpmsg_rpc_ept_cb, rpmsg_service_unbind);
	if (ret != 0) {
 1009864:	e0bffb17 	ldw	r2,-20(fp)
 1009868:	10000f26 	beq	r2,zero,10098a8 <rpmsg_rpc_init+0x120>
		metal_mutex_release(&rpc->lock);
 100986c:	e0bffc17 	ldw	r2,-16(fp)
 1009870:	10801704 	addi	r2,r2,92
 1009874:	1009883a 	mov	r4,r2
 1009878:	100941c0 	call	100941c <metal_mutex_release>
		return -EINVAL;
 100987c:	00bffa84 	movi	r2,-22
 1009880:	00000e06 	br	10098bc <rpmsg_rpc_init+0x134>
	}
	while (!is_rpmsg_ept_ready(&rpc->ept)) {
		if (rpc->poll)
 1009884:	e0bffc17 	ldw	r2,-16(fp)
 1009888:	10801417 	ldw	r2,80(r2)
 100988c:	10000626 	beq	r2,zero,10098a8 <rpmsg_rpc_init+0x120>
			rpc->poll(rpc->poll_arg);
 1009890:	e0bffc17 	ldw	r2,-16(fp)
 1009894:	10801417 	ldw	r2,80(r2)
 1009898:	e0fffc17 	ldw	r3,-16(fp)
 100989c:	18c01517 	ldw	r3,84(r3)
 10098a0:	1809883a 	mov	r4,r3
 10098a4:	103ee83a 	callr	r2
			       rpmsg_rpc_ept_cb, rpmsg_service_unbind);
	if (ret != 0) {
		metal_mutex_release(&rpc->lock);
		return -EINVAL;
	}
	while (!is_rpmsg_ept_ready(&rpc->ept)) {
 10098a8:	e0bffc17 	ldw	r2,-16(fp)
 10098ac:	1009883a 	mov	r4,r2
 10098b0:	10095d80 	call	10095d8 <is_rpmsg_ept_ready>
 10098b4:	103ff326 	beq	r2,zero,1009884 <__alt_data_end+0xff009884>
		if (rpc->poll)
			rpc->poll(rpc->poll_arg);
	}
	return 0;
 10098b8:	0005883a 	mov	r2,zero
}
 10098bc:	e037883a 	mov	sp,fp
 10098c0:	dfc00117 	ldw	ra,4(sp)
 10098c4:	df000017 	ldw	fp,0(sp)
 10098c8:	dec00204 	addi	sp,sp,8
 10098cc:	f800283a 	ret

010098d0 <rpmsg_rpc_release>:

void rpmsg_rpc_release(struct rpmsg_rpc_data *rpc)
{
 10098d0:	defffd04 	addi	sp,sp,-12
 10098d4:	dfc00215 	stw	ra,8(sp)
 10098d8:	df000115 	stw	fp,4(sp)
 10098dc:	df000104 	addi	fp,sp,4
 10098e0:	e13fff15 	stw	r4,-4(fp)
	if (rpc == NULL)
 10098e4:	e0bfff17 	ldw	r2,-4(fp)
 10098e8:	10002026 	beq	r2,zero,100996c <rpmsg_rpc_release+0x9c>
		return;
	if (rpc->ept_destroyed == 0)
 10098ec:	e0bfff17 	ldw	r2,-4(fp)
 10098f0:	10801017 	ldw	r2,64(r2)
 10098f4:	1000031e 	bne	r2,zero,1009904 <rpmsg_rpc_release+0x34>
		rpmsg_destroy_ept(&rpc->ept);
 10098f8:	e0bfff17 	ldw	r2,-4(fp)
 10098fc:	1009883a 	mov	r4,r2
 1009900:	10110180 	call	1011018 <rpmsg_destroy_ept>
	metal_mutex_acquire(&rpc->lock);
 1009904:	e0bfff17 	ldw	r2,-4(fp)
 1009908:	10801704 	addi	r2,r2,92
 100990c:	1009883a 	mov	r4,r2
 1009910:	10093e80 	call	10093e8 <metal_mutex_acquire>
	metal_spinlock_acquire(&rpc->buflock);
 1009914:	e0bfff17 	ldw	r2,-4(fp)
 1009918:	10801804 	addi	r2,r2,96
 100991c:	1009883a 	mov	r4,r2
 1009920:	10094800 	call	1009480 <metal_spinlock_acquire>
	rpc->respbuf = NULL;
 1009924:	e0bfff17 	ldw	r2,-4(fp)
 1009928:	10001215 	stw	zero,72(r2)
	rpc->respbuf_len = 0;
 100992c:	e0bfff17 	ldw	r2,-4(fp)
 1009930:	10001315 	stw	zero,76(r2)
	metal_spinlock_release(&rpc->buflock);
 1009934:	e0bfff17 	ldw	r2,-4(fp)
 1009938:	10801804 	addi	r2,r2,96
 100993c:	1009883a 	mov	r4,r2
 1009940:	100952c0 	call	100952c <metal_spinlock_release>
	metal_mutex_release(&rpc->lock);
 1009944:	e0bfff17 	ldw	r2,-4(fp)
 1009948:	10801704 	addi	r2,r2,92
 100994c:	1009883a 	mov	r4,r2
 1009950:	100941c0 	call	100941c <metal_mutex_release>
	metal_mutex_deinit(&rpc->lock);
 1009954:	e0bfff17 	ldw	r2,-4(fp)
 1009958:	10801704 	addi	r2,r2,92
 100995c:	1009883a 	mov	r4,r2
 1009960:	10093b40 	call	10093b4 <metal_mutex_deinit>

	return;
 1009964:	0001883a 	nop
 1009968:	00000106 	br	1009970 <rpmsg_rpc_release+0xa0>
}

void rpmsg_rpc_release(struct rpmsg_rpc_data *rpc)
{
	if (rpc == NULL)
		return;
 100996c:	0001883a 	nop
	metal_spinlock_release(&rpc->buflock);
	metal_mutex_release(&rpc->lock);
	metal_mutex_deinit(&rpc->lock);

	return;
}
 1009970:	e037883a 	mov	sp,fp
 1009974:	dfc00117 	ldw	ra,4(sp)
 1009978:	df000017 	ldw	fp,0(sp)
 100997c:	dec00204 	addi	sp,sp,8
 1009980:	f800283a 	ret

01009984 <rpmsg_rpc_send>:

int rpmsg_rpc_send(struct rpmsg_rpc_data *rpc,
		   void *req, size_t len,
		   void *resp, size_t resp_len)
{
 1009984:	deffef04 	addi	sp,sp,-68
 1009988:	dfc01015 	stw	ra,64(sp)
 100998c:	df000f15 	stw	fp,60(sp)
 1009990:	df000f04 	addi	fp,sp,60
 1009994:	e13ffc15 	stw	r4,-16(fp)
 1009998:	e17ffd15 	stw	r5,-12(fp)
 100999c:	e1bffe15 	stw	r6,-8(fp)
 10099a0:	e1ffff15 	stw	r7,-4(fp)
	int ret;

	if (rpc == NULL)
 10099a4:	e0bffc17 	ldw	r2,-16(fp)
 10099a8:	1000021e 	bne	r2,zero,10099b4 <rpmsg_rpc_send+0x30>
		return -EINVAL;
 10099ac:	00bffa84 	movi	r2,-22
 10099b0:	00005506 	br	1009b08 <rpmsg_rpc_send+0x184>
	metal_spinlock_acquire(&rpc->buflock);
 10099b4:	e0bffc17 	ldw	r2,-16(fp)
 10099b8:	10801804 	addi	r2,r2,96
 10099bc:	1009883a 	mov	r4,r2
 10099c0:	10094800 	call	1009480 <metal_spinlock_acquire>
	rpc->respbuf = resp;
 10099c4:	e0bffc17 	ldw	r2,-16(fp)
 10099c8:	e0ffff17 	ldw	r3,-4(fp)
 10099cc:	10c01215 	stw	r3,72(r2)
	rpc->respbuf_len = resp_len;
 10099d0:	e0bffc17 	ldw	r2,-16(fp)
 10099d4:	e0c00217 	ldw	r3,8(fp)
 10099d8:	10c01315 	stw	r3,76(r2)
	metal_spinlock_release(&rpc->buflock);
 10099dc:	e0bffc17 	ldw	r2,-16(fp)
 10099e0:	10801804 	addi	r2,r2,96
 10099e4:	1009883a 	mov	r4,r2
 10099e8:	100952c0 	call	100952c <metal_spinlock_release>

	atomic_mutex_acquire();
 10099ec:	1005e680 	call	1005e68 <atomic_mutex_acquire>
	(void)atomic_flag_test_and_set(&rpc->nacked);
 10099f0:	e0bffc17 	ldw	r2,-16(fp)
 10099f4:	10801104 	addi	r2,r2,68
 10099f8:	e0bff215 	stw	r2,-56(fp)
 10099fc:	e0bff217 	ldw	r2,-56(fp)
 1009a00:	10800017 	ldw	r2,0(r2)
 1009a04:	e0bff315 	stw	r2,-52(fp)
 1009a08:	00800044 	movi	r2,1
 1009a0c:	e0bff415 	stw	r2,-48(fp)
 1009a10:	e0bffc17 	ldw	r2,-16(fp)
 1009a14:	e0fff417 	ldw	r3,-48(fp)
 1009a18:	10c01115 	stw	r3,68(r2)
	atomic_mutex_release();
 1009a1c:	1005e9c0 	call	1005e9c <atomic_mutex_release>

	ret = rpmsg_send(&rpc->ept, req, len);
 1009a20:	e0bffc17 	ldw	r2,-16(fp)
 1009a24:	e0fffe17 	ldw	r3,-8(fp)
 1009a28:	180d883a 	mov	r6,r3
 1009a2c:	e17ffd17 	ldw	r5,-12(fp)
 1009a30:	1009883a 	mov	r4,r2
 1009a34:	100955c0 	call	100955c <rpmsg_send>
 1009a38:	e0bff515 	stw	r2,-44(fp)
	if (ret < 0)
 1009a3c:	e0bff517 	ldw	r2,-44(fp)
 1009a40:	1000020e 	bge	r2,zero,1009a4c <rpmsg_rpc_send+0xc8>
		return -EINVAL;
 1009a44:	00bffa84 	movi	r2,-22
 1009a48:	00002f06 	br	1009b08 <rpmsg_rpc_send+0x184>
	if (!resp)
 1009a4c:	e0bfff17 	ldw	r2,-4(fp)
 1009a50:	1000021e 	bne	r2,zero,1009a5c <rpmsg_rpc_send+0xd8>
		return ret;
 1009a54:	e0bff517 	ldw	r2,-44(fp)
 1009a58:	00002b06 	br	1009b08 <rpmsg_rpc_send+0x184>

	atomic_int val;

	atomic_mutex_acquire();
 1009a5c:	1005e680 	call	1005e68 <atomic_mutex_acquire>
	val = atomic_flag_test_and_set(&rpc->nacked);
 1009a60:	e0bffc17 	ldw	r2,-16(fp)
 1009a64:	10801104 	addi	r2,r2,68
 1009a68:	e0bff615 	stw	r2,-40(fp)
 1009a6c:	e0bff617 	ldw	r2,-40(fp)
 1009a70:	10800017 	ldw	r2,0(r2)
 1009a74:	e0bff715 	stw	r2,-36(fp)
 1009a78:	00800044 	movi	r2,1
 1009a7c:	e0bff815 	stw	r2,-32(fp)
 1009a80:	e0bffc17 	ldw	r2,-16(fp)
 1009a84:	e0fff817 	ldw	r3,-32(fp)
 1009a88:	10c01115 	stw	r3,68(r2)
 1009a8c:	e0bff717 	ldw	r2,-36(fp)
 1009a90:	e0bff115 	stw	r2,-60(fp)
	atomic_mutex_release();
 1009a94:	1005e9c0 	call	1005e9c <atomic_mutex_release>

	while(val) {
 1009a98:	00001806 	br	1009afc <rpmsg_rpc_send+0x178>
		if (rpc->poll)
 1009a9c:	e0bffc17 	ldw	r2,-16(fp)
 1009aa0:	10801417 	ldw	r2,80(r2)
 1009aa4:	10000626 	beq	r2,zero,1009ac0 <rpmsg_rpc_send+0x13c>
			rpc->poll(rpc->poll_arg);
 1009aa8:	e0bffc17 	ldw	r2,-16(fp)
 1009aac:	10801417 	ldw	r2,80(r2)
 1009ab0:	e0fffc17 	ldw	r3,-16(fp)
 1009ab4:	18c01517 	ldw	r3,84(r3)
 1009ab8:	1809883a 	mov	r4,r3
 1009abc:	103ee83a 	callr	r2

		atomic_mutex_acquire();
 1009ac0:	1005e680 	call	1005e68 <atomic_mutex_acquire>
		val = atomic_flag_test_and_set(&rpc->nacked);
 1009ac4:	e0bffc17 	ldw	r2,-16(fp)
 1009ac8:	10801104 	addi	r2,r2,68
 1009acc:	e0bff915 	stw	r2,-28(fp)
 1009ad0:	e0bff917 	ldw	r2,-28(fp)
 1009ad4:	10800017 	ldw	r2,0(r2)
 1009ad8:	e0bffa15 	stw	r2,-24(fp)
 1009adc:	00800044 	movi	r2,1
 1009ae0:	e0bffb15 	stw	r2,-20(fp)
 1009ae4:	e0bffc17 	ldw	r2,-16(fp)
 1009ae8:	e0fffb17 	ldw	r3,-20(fp)
 1009aec:	10c01115 	stw	r3,68(r2)
 1009af0:	e0bffa17 	ldw	r2,-24(fp)
 1009af4:	e0bff115 	stw	r2,-60(fp)
		atomic_mutex_release();
 1009af8:	1005e9c0 	call	1005e9c <atomic_mutex_release>

	atomic_mutex_acquire();
	val = atomic_flag_test_and_set(&rpc->nacked);
	atomic_mutex_release();

	while(val) {
 1009afc:	e0bff117 	ldw	r2,-60(fp)
 1009b00:	103fe61e 	bne	r2,zero,1009a9c <__alt_data_end+0xff009a9c>
		atomic_mutex_acquire();
		val = atomic_flag_test_and_set(&rpc->nacked);
		atomic_mutex_release();
	}

	return ret;
 1009b04:	e0bff517 	ldw	r2,-44(fp)
}
 1009b08:	e037883a 	mov	sp,fp
 1009b0c:	dfc00117 	ldw	ra,4(sp)
 1009b10:	df000017 	ldw	fp,0(sp)
 1009b14:	dec00204 	addi	sp,sp,8
 1009b18:	f800283a 	ret

01009b1c <rpmsg_set_default_rpc>:

void rpmsg_set_default_rpc(struct rpmsg_rpc_data *rpc)
{
 1009b1c:	defffe04 	addi	sp,sp,-8
 1009b20:	df000115 	stw	fp,4(sp)
 1009b24:	df000104 	addi	fp,sp,4
 1009b28:	e13fff15 	stw	r4,-4(fp)
	if (rpc == NULL)
 1009b2c:	e0bfff17 	ldw	r2,-4(fp)
 1009b30:	10000326 	beq	r2,zero,1009b40 <rpmsg_set_default_rpc+0x24>
		return;
	rpmsg_default_rpc = rpc;
 1009b34:	e0bfff17 	ldw	r2,-4(fp)
 1009b38:	d0a75215 	stw	r2,-25272(gp)
 1009b3c:	00000106 	br	1009b44 <rpmsg_set_default_rpc+0x28>
}

void rpmsg_set_default_rpc(struct rpmsg_rpc_data *rpc)
{
	if (rpc == NULL)
		return;
 1009b40:	0001883a 	nop
	rpmsg_default_rpc = rpc;
}
 1009b44:	e037883a 	mov	sp,fp
 1009b48:	df000017 	ldw	fp,0(sp)
 1009b4c:	dec00104 	addi	sp,sp,4
 1009b50:	f800283a 	ret

01009b54 <_open>:
 *
 *************************************************************************/
#define MAX_BUF_LEN 496UL

int _open(const char *filename, int flags, int mode)
{
 1009b54:	deff7504 	addi	sp,sp,-556
 1009b58:	dfc08a15 	stw	ra,552(sp)
 1009b5c:	df008915 	stw	fp,548(sp)
 1009b60:	df008904 	addi	fp,sp,548
 1009b64:	e13ffd15 	stw	r4,-12(fp)
 1009b68:	e17ffe15 	stw	r5,-8(fp)
 1009b6c:	e1bfff15 	stw	r6,-4(fp)
	struct rpmsg_rpc_data *rpc = rpmsg_default_rpc;
 1009b70:	d0a75217 	ldw	r2,-25272(gp)
 1009b74:	e0bf7915 	stw	r2,-540(fp)
	struct rpmsg_rpc_syscall *syscall;
	struct rpmsg_rpc_syscall resp;
	int filename_len = strlen(filename) + 1;
 1009b78:	e13ffd17 	ldw	r4,-12(fp)
 1009b7c:	10165b40 	call	10165b4 <strlen>
 1009b80:	10800044 	addi	r2,r2,1
 1009b84:	e0bf7a15 	stw	r2,-536(fp)
	int payload_size = sizeof(*syscall) + filename_len;
 1009b88:	e0bf7a17 	ldw	r2,-536(fp)
 1009b8c:	10800404 	addi	r2,r2,16
 1009b90:	e0bf7b15 	stw	r2,-532(fp)
	unsigned char tmpbuf[MAX_BUF_LEN];
	int ret;

	if (filename == NULL || payload_size > (int)MAX_BUF_LEN) {
 1009b94:	e0bffd17 	ldw	r2,-12(fp)
 1009b98:	10000326 	beq	r2,zero,1009ba8 <_open+0x54>
 1009b9c:	e0bf7b17 	ldw	r2,-532(fp)
 1009ba0:	10807c50 	cmplti	r2,r2,497
 1009ba4:	1000021e 	bne	r2,zero,1009bb0 <_open+0x5c>
		return -EINVAL;
 1009ba8:	00bffa84 	movi	r2,-22
 1009bac:	00003006 	br	1009c70 <_open+0x11c>
	}

	if (rpc == NULL)
 1009bb0:	e0bf7917 	ldw	r2,-540(fp)
 1009bb4:	1000021e 	bne	r2,zero,1009bc0 <_open+0x6c>
		return -EINVAL;
 1009bb8:	00bffa84 	movi	r2,-22
 1009bbc:	00002c06 	br	1009c70 <_open+0x11c>

	/* Construct rpc payload */
	syscall = (struct rpmsg_rpc_syscall *)tmpbuf;
 1009bc0:	e0bf8104 	addi	r2,fp,-508
 1009bc4:	e0bf7c15 	stw	r2,-528(fp)
	syscall->id = OPEN_SYSCALL_ID;
 1009bc8:	e0bf7c17 	ldw	r2,-528(fp)
 1009bcc:	00c00044 	movi	r3,1
 1009bd0:	10c00015 	stw	r3,0(r2)
	syscall->args.int_field1 = flags;
 1009bd4:	e0bf7c17 	ldw	r2,-528(fp)
 1009bd8:	e0fffe17 	ldw	r3,-8(fp)
 1009bdc:	10c00115 	stw	r3,4(r2)
	syscall->args.int_field2 = mode;
 1009be0:	e0bf7c17 	ldw	r2,-528(fp)
 1009be4:	e0ffff17 	ldw	r3,-4(fp)
 1009be8:	10c00215 	stw	r3,8(r2)
	syscall->args.data_len = filename_len;
 1009bec:	e0ff7a17 	ldw	r3,-536(fp)
 1009bf0:	e0bf7c17 	ldw	r2,-528(fp)
 1009bf4:	10c00315 	stw	r3,12(r2)
	memcpy(tmpbuf + sizeof(*syscall), filename, filename_len);
 1009bf8:	e0bf8104 	addi	r2,fp,-508
 1009bfc:	10800404 	addi	r2,r2,16
 1009c00:	e0ff7a17 	ldw	r3,-536(fp)
 1009c04:	180d883a 	mov	r6,r3
 1009c08:	e17ffd17 	ldw	r5,-12(fp)
 1009c0c:	1009883a 	mov	r4,r2
 1009c10:	10158f40 	call	10158f4 <memcpy>

	resp.id = 0;
 1009c14:	e03f7d15 	stw	zero,-524(fp)
	ret = rpmsg_rpc_send(rpc, tmpbuf, payload_size,
 1009c18:	e13f7b17 	ldw	r4,-532(fp)
 1009c1c:	e17f7d04 	addi	r5,fp,-524
 1009c20:	e0ff8104 	addi	r3,fp,-508
 1009c24:	00800404 	movi	r2,16
 1009c28:	d8800015 	stw	r2,0(sp)
 1009c2c:	280f883a 	mov	r7,r5
 1009c30:	200d883a 	mov	r6,r4
 1009c34:	180b883a 	mov	r5,r3
 1009c38:	e13f7917 	ldw	r4,-540(fp)
 1009c3c:	10099840 	call	1009984 <rpmsg_rpc_send>
 1009c40:	e0bf7815 	stw	r2,-544(fp)
			     (void *)&resp, sizeof(resp));
	if (ret >= 0) {
 1009c44:	e0bf7817 	ldw	r2,-544(fp)
 1009c48:	10000816 	blt	r2,zero,1009c6c <_open+0x118>
		/* Obtain return args and return to caller */
		if (resp.id == OPEN_SYSCALL_ID)
 1009c4c:	e0bf7d17 	ldw	r2,-524(fp)
 1009c50:	10800058 	cmpnei	r2,r2,1
 1009c54:	1000031e 	bne	r2,zero,1009c64 <_open+0x110>
			ret = resp.args.int_field1;
 1009c58:	e0bf7e17 	ldw	r2,-520(fp)
 1009c5c:	e0bf7815 	stw	r2,-544(fp)
 1009c60:	00000206 	br	1009c6c <_open+0x118>
		else
			ret = -EINVAL;
 1009c64:	00bffa84 	movi	r2,-22
 1009c68:	e0bf7815 	stw	r2,-544(fp)
	}

	return ret;
 1009c6c:	e0bf7817 	ldw	r2,-544(fp)
}
 1009c70:	e037883a 	mov	sp,fp
 1009c74:	dfc00117 	ldw	ra,4(sp)
 1009c78:	df000017 	ldw	fp,0(sp)
 1009c7c:	dec00204 	addi	sp,sp,8
 1009c80:	f800283a 	ret

01009c84 <_read>:
 *
 *       Low level function to redirect IO to serial.
 *
 *************************************************************************/
int _read(int fd, char *buffer, int buflen)
{
 1009c84:	deff7404 	addi	sp,sp,-560
 1009c88:	dfc08b15 	stw	ra,556(sp)
 1009c8c:	df008a15 	stw	fp,552(sp)
 1009c90:	df008a04 	addi	fp,sp,552
 1009c94:	e13ffd15 	stw	r4,-12(fp)
 1009c98:	e17ffe15 	stw	r5,-8(fp)
 1009c9c:	e1bfff15 	stw	r6,-4(fp)
	struct rpmsg_rpc_syscall syscall;
	struct rpmsg_rpc_syscall *resp;
	struct rpmsg_rpc_data *rpc = rpmsg_default_rpc;
 1009ca0:	d0a75217 	ldw	r2,-25272(gp)
 1009ca4:	e0bf7915 	stw	r2,-540(fp)
	int payload_size = sizeof(syscall);
 1009ca8:	00800404 	movi	r2,16
 1009cac:	e0bf7a15 	stw	r2,-536(fp)
	unsigned char tmpbuf[MAX_BUF_LEN];
	int ret;

	if (rpc == NULL || buffer == NULL || buflen == 0)
 1009cb0:	e0bf7917 	ldw	r2,-540(fp)
 1009cb4:	10000426 	beq	r2,zero,1009cc8 <_read+0x44>
 1009cb8:	e0bffe17 	ldw	r2,-8(fp)
 1009cbc:	10000226 	beq	r2,zero,1009cc8 <_read+0x44>
 1009cc0:	e0bfff17 	ldw	r2,-4(fp)
 1009cc4:	1000021e 	bne	r2,zero,1009cd0 <_read+0x4c>
		return -EINVAL;
 1009cc8:	00bffa84 	movi	r2,-22
 1009ccc:	00003806 	br	1009db0 <_read+0x12c>

	/* Construct rpc payload */
	syscall.id = READ_SYSCALL_ID;
 1009cd0:	00800104 	movi	r2,4
 1009cd4:	e0bf7d15 	stw	r2,-524(fp)
	syscall.args.int_field1 = fd;
 1009cd8:	e0bffd17 	ldw	r2,-12(fp)
 1009cdc:	e0bf7e15 	stw	r2,-520(fp)
	syscall.args.int_field2 = buflen;
 1009ce0:	e0bfff17 	ldw	r2,-4(fp)
 1009ce4:	e0bf7f15 	stw	r2,-516(fp)
	syscall.args.data_len = 0;	/*not used */
 1009ce8:	e03f8015 	stw	zero,-512(fp)

	resp = (struct rpmsg_rpc_syscall *)tmpbuf;
 1009cec:	e0bf8104 	addi	r2,fp,-508
 1009cf0:	e0bf7b15 	stw	r2,-532(fp)
	resp->id = 0;
 1009cf4:	e0bf7b17 	ldw	r2,-532(fp)
 1009cf8:	10000015 	stw	zero,0(r2)
	ret = rpmsg_rpc_send(rpc, (void *)&syscall, payload_size,
 1009cfc:	e13f7a17 	ldw	r4,-536(fp)
 1009d00:	e17f8104 	addi	r5,fp,-508
 1009d04:	e0ff7d04 	addi	r3,fp,-524
 1009d08:	00807c04 	movi	r2,496
 1009d0c:	d8800015 	stw	r2,0(sp)
 1009d10:	280f883a 	mov	r7,r5
 1009d14:	200d883a 	mov	r6,r4
 1009d18:	180b883a 	mov	r5,r3
 1009d1c:	e13f7917 	ldw	r4,-540(fp)
 1009d20:	10099840 	call	1009984 <rpmsg_rpc_send>
 1009d24:	e0bf7715 	stw	r2,-548(fp)
			     tmpbuf, sizeof(tmpbuf));

	/* Obtain return args and return to caller */
	if (ret >= 0) {
 1009d28:	e0bf7717 	ldw	r2,-548(fp)
 1009d2c:	10001f16 	blt	r2,zero,1009dac <_read+0x128>
		if (resp->id == READ_SYSCALL_ID) {
 1009d30:	e0bf7b17 	ldw	r2,-532(fp)
 1009d34:	10800017 	ldw	r2,0(r2)
 1009d38:	10800118 	cmpnei	r2,r2,4
 1009d3c:	1000191e 	bne	r2,zero,1009da4 <_read+0x120>
			if (resp->args.int_field1 > 0) {
 1009d40:	e0bf7b17 	ldw	r2,-532(fp)
 1009d44:	10800117 	ldw	r2,4(r2)
 1009d48:	0080120e 	bge	zero,r2,1009d94 <_read+0x110>
				int tmplen = resp->args.data_len;
 1009d4c:	e0bf7b17 	ldw	r2,-532(fp)
 1009d50:	10800317 	ldw	r2,12(r2)
 1009d54:	e0bf7815 	stw	r2,-544(fp)
				unsigned char *tmpptr = tmpbuf;
 1009d58:	e0bf8104 	addi	r2,fp,-508
 1009d5c:	e0bf7c15 	stw	r2,-528(fp)

				tmpptr += sizeof(*resp);
 1009d60:	e0bf7c17 	ldw	r2,-528(fp)
 1009d64:	10800404 	addi	r2,r2,16
 1009d68:	e0bf7c15 	stw	r2,-528(fp)
				if (tmplen > buflen)
 1009d6c:	e0bf7817 	ldw	r2,-544(fp)
 1009d70:	e0ffff17 	ldw	r3,-4(fp)
 1009d74:	1880020e 	bge	r3,r2,1009d80 <_read+0xfc>
					tmplen = buflen;
 1009d78:	e0bfff17 	ldw	r2,-4(fp)
 1009d7c:	e0bf7815 	stw	r2,-544(fp)
				memcpy(buffer, tmpptr, tmplen);
 1009d80:	e0bf7817 	ldw	r2,-544(fp)
 1009d84:	100d883a 	mov	r6,r2
 1009d88:	e17f7c17 	ldw	r5,-528(fp)
 1009d8c:	e13ffe17 	ldw	r4,-8(fp)
 1009d90:	10158f40 	call	10158f4 <memcpy>
			}
			ret = resp->args.int_field1;
 1009d94:	e0bf7b17 	ldw	r2,-532(fp)
 1009d98:	10800117 	ldw	r2,4(r2)
 1009d9c:	e0bf7715 	stw	r2,-548(fp)
 1009da0:	00000206 	br	1009dac <_read+0x128>
		} else {
			ret = -EINVAL;
 1009da4:	00bffa84 	movi	r2,-22
 1009da8:	e0bf7715 	stw	r2,-548(fp)
		}
	}

	return ret;
 1009dac:	e0bf7717 	ldw	r2,-548(fp)
}
 1009db0:	e037883a 	mov	sp,fp
 1009db4:	dfc00117 	ldw	ra,4(sp)
 1009db8:	df000017 	ldw	fp,0(sp)
 1009dbc:	dec00204 	addi	sp,sp,8
 1009dc0:	f800283a 	ret

01009dc4 <_write>:
 *
 *       Low level function to redirect IO to serial.
 *
 *************************************************************************/
int _write(int fd, const char *ptr, int len)
{
 1009dc4:	deff7404 	addi	sp,sp,-560
 1009dc8:	dfc08b15 	stw	ra,556(sp)
 1009dcc:	df008a15 	stw	fp,552(sp)
 1009dd0:	df008a04 	addi	fp,sp,552
 1009dd4:	e13ffd15 	stw	r4,-12(fp)
 1009dd8:	e17ffe15 	stw	r5,-8(fp)
 1009ddc:	e1bfff15 	stw	r6,-4(fp)
	int ret;
	struct rpmsg_rpc_syscall *syscall;
	struct rpmsg_rpc_syscall resp;
	int payload_size = sizeof(*syscall) + len;
 1009de0:	e0bfff17 	ldw	r2,-4(fp)
 1009de4:	10800404 	addi	r2,r2,16
 1009de8:	e0bf7815 	stw	r2,-544(fp)
	struct rpmsg_rpc_data *rpc = rpmsg_default_rpc;
 1009dec:	d0a75217 	ldw	r2,-25272(gp)
 1009df0:	e0bf7a15 	stw	r2,-536(fp)
	unsigned char tmpbuf[MAX_BUF_LEN];
	unsigned char *tmpptr;
	int null_term = 0;
 1009df4:	e03f7915 	stw	zero,-540(fp)

	if (rpc == NULL)
 1009df8:	e0bf7a17 	ldw	r2,-536(fp)
 1009dfc:	1000021e 	bne	r2,zero,1009e08 <_write+0x44>
		return -EINVAL;
 1009e00:	00bffa84 	movi	r2,-22
 1009e04:	00004106 	br	1009f0c <_write+0x148>
	if (fd == 1)
 1009e08:	e0bffd17 	ldw	r2,-12(fp)
 1009e0c:	10800058 	cmpnei	r2,r2,1
 1009e10:	1000021e 	bne	r2,zero,1009e1c <_write+0x58>
		null_term = 1;
 1009e14:	00800044 	movi	r2,1
 1009e18:	e0bf7915 	stw	r2,-540(fp)

	syscall = (struct rpmsg_rpc_syscall *)tmpbuf;
 1009e1c:	e0bf8104 	addi	r2,fp,-508
 1009e20:	e0bf7b15 	stw	r2,-532(fp)
	syscall->id = WRITE_SYSCALL_ID;
 1009e24:	e0bf7b17 	ldw	r2,-532(fp)
 1009e28:	00c000c4 	movi	r3,3
 1009e2c:	10c00015 	stw	r3,0(r2)
	syscall->args.int_field1 = fd;
 1009e30:	e0bf7b17 	ldw	r2,-532(fp)
 1009e34:	e0fffd17 	ldw	r3,-12(fp)
 1009e38:	10c00115 	stw	r3,4(r2)
	syscall->args.int_field2 = len;
 1009e3c:	e0bf7b17 	ldw	r2,-532(fp)
 1009e40:	e0ffff17 	ldw	r3,-4(fp)
 1009e44:	10c00215 	stw	r3,8(r2)
	syscall->args.data_len = len + null_term;
 1009e48:	e0ffff17 	ldw	r3,-4(fp)
 1009e4c:	e0bf7917 	ldw	r2,-540(fp)
 1009e50:	1885883a 	add	r2,r3,r2
 1009e54:	1007883a 	mov	r3,r2
 1009e58:	e0bf7b17 	ldw	r2,-532(fp)
 1009e5c:	10c00315 	stw	r3,12(r2)
	tmpptr = tmpbuf + sizeof(*syscall);
 1009e60:	e0bf8104 	addi	r2,fp,-508
 1009e64:	10800404 	addi	r2,r2,16
 1009e68:	e0bf7c15 	stw	r2,-528(fp)
	memcpy(tmpptr, ptr, len);
 1009e6c:	e0bfff17 	ldw	r2,-4(fp)
 1009e70:	100d883a 	mov	r6,r2
 1009e74:	e17ffe17 	ldw	r5,-8(fp)
 1009e78:	e13f7c17 	ldw	r4,-528(fp)
 1009e7c:	10158f40 	call	10158f4 <memcpy>
	if (null_term == 1) {
 1009e80:	e0bf7917 	ldw	r2,-540(fp)
 1009e84:	10800058 	cmpnei	r2,r2,1
 1009e88:	1000091e 	bne	r2,zero,1009eb0 <_write+0xec>
		*(char *)(tmpptr + len + null_term) = 0;
 1009e8c:	e0ffff17 	ldw	r3,-4(fp)
 1009e90:	e0bf7917 	ldw	r2,-540(fp)
 1009e94:	1885883a 	add	r2,r3,r2
 1009e98:	e0ff7c17 	ldw	r3,-528(fp)
 1009e9c:	1885883a 	add	r2,r3,r2
 1009ea0:	10000005 	stb	zero,0(r2)
		payload_size += 1;
 1009ea4:	e0bf7817 	ldw	r2,-544(fp)
 1009ea8:	10800044 	addi	r2,r2,1
 1009eac:	e0bf7815 	stw	r2,-544(fp)
	}
	resp.id = 0;
 1009eb0:	e03f7d15 	stw	zero,-524(fp)
	ret = rpmsg_rpc_send(rpc, tmpbuf, payload_size,
 1009eb4:	e13f7817 	ldw	r4,-544(fp)
 1009eb8:	e17f7d04 	addi	r5,fp,-524
 1009ebc:	e0ff8104 	addi	r3,fp,-508
 1009ec0:	00800404 	movi	r2,16
 1009ec4:	d8800015 	stw	r2,0(sp)
 1009ec8:	280f883a 	mov	r7,r5
 1009ecc:	200d883a 	mov	r6,r4
 1009ed0:	180b883a 	mov	r5,r3
 1009ed4:	e13f7a17 	ldw	r4,-536(fp)
 1009ed8:	10099840 	call	1009984 <rpmsg_rpc_send>
 1009edc:	e0bf7715 	stw	r2,-548(fp)
			     (void *)&resp, sizeof(resp));

	if (ret >= 0) {
 1009ee0:	e0bf7717 	ldw	r2,-548(fp)
 1009ee4:	10000816 	blt	r2,zero,1009f08 <_write+0x144>
		if (resp.id == WRITE_SYSCALL_ID)
 1009ee8:	e0bf7d17 	ldw	r2,-524(fp)
 1009eec:	108000d8 	cmpnei	r2,r2,3
 1009ef0:	1000031e 	bne	r2,zero,1009f00 <_write+0x13c>
			ret = resp.args.int_field1;
 1009ef4:	e0bf7e17 	ldw	r2,-520(fp)
 1009ef8:	e0bf7715 	stw	r2,-548(fp)
 1009efc:	00000206 	br	1009f08 <_write+0x144>
		else
			ret = -EINVAL;
 1009f00:	00bffa84 	movi	r2,-22
 1009f04:	e0bf7715 	stw	r2,-548(fp)
	}

	return ret;
 1009f08:	e0bf7717 	ldw	r2,-548(fp)

}
 1009f0c:	e037883a 	mov	sp,fp
 1009f10:	dfc00117 	ldw	ra,4(sp)
 1009f14:	df000017 	ldw	fp,0(sp)
 1009f18:	dec00204 	addi	sp,sp,8
 1009f1c:	f800283a 	ret

01009f20 <_close>:
 *
 *       Close a file.  Minimal implementation
 *
 *************************************************************************/
int _close(int fd)
{
 1009f20:	defff104 	addi	sp,sp,-60
 1009f24:	dfc00e15 	stw	ra,56(sp)
 1009f28:	df000d15 	stw	fp,52(sp)
 1009f2c:	df000d04 	addi	fp,sp,52
 1009f30:	e13fff15 	stw	r4,-4(fp)
	int ret;
	struct rpmsg_rpc_syscall syscall;
	struct rpmsg_rpc_syscall resp;
	int payload_size = sizeof(syscall);
 1009f34:	00800404 	movi	r2,16
 1009f38:	e0bff515 	stw	r2,-44(fp)
	struct rpmsg_rpc_data *rpc = rpmsg_default_rpc;
 1009f3c:	d0a75217 	ldw	r2,-25272(gp)
 1009f40:	e0bff615 	stw	r2,-40(fp)

	if (rpc == NULL)
 1009f44:	e0bff617 	ldw	r2,-40(fp)
 1009f48:	1000021e 	bne	r2,zero,1009f54 <_close+0x34>
		return -EINVAL;
 1009f4c:	00bffa84 	movi	r2,-22
 1009f50:	00001d06 	br	1009fc8 <_close+0xa8>
	syscall.id = CLOSE_SYSCALL_ID;
 1009f54:	00800084 	movi	r2,2
 1009f58:	e0bff715 	stw	r2,-36(fp)
	syscall.args.int_field1 = fd;
 1009f5c:	e0bfff17 	ldw	r2,-4(fp)
 1009f60:	e0bff815 	stw	r2,-32(fp)
	syscall.args.int_field2 = 0;	/*not used */
 1009f64:	e03ff915 	stw	zero,-28(fp)
	syscall.args.data_len = 0;	/*not used */
 1009f68:	e03ffa15 	stw	zero,-24(fp)

	resp.id = 0;
 1009f6c:	e03ffb15 	stw	zero,-20(fp)
	ret = rpmsg_rpc_send(rpc, (void*)&syscall, payload_size,
 1009f70:	e13ff517 	ldw	r4,-44(fp)
 1009f74:	e17ffb04 	addi	r5,fp,-20
 1009f78:	e0fff704 	addi	r3,fp,-36
 1009f7c:	00800404 	movi	r2,16
 1009f80:	d8800015 	stw	r2,0(sp)
 1009f84:	280f883a 	mov	r7,r5
 1009f88:	200d883a 	mov	r6,r4
 1009f8c:	180b883a 	mov	r5,r3
 1009f90:	e13ff617 	ldw	r4,-40(fp)
 1009f94:	10099840 	call	1009984 <rpmsg_rpc_send>
 1009f98:	e0bff415 	stw	r2,-48(fp)
			     (void*)&resp, sizeof(resp));

	if (ret >= 0) {
 1009f9c:	e0bff417 	ldw	r2,-48(fp)
 1009fa0:	10000816 	blt	r2,zero,1009fc4 <_close+0xa4>
		if (resp.id == CLOSE_SYSCALL_ID)
 1009fa4:	e0bffb17 	ldw	r2,-20(fp)
 1009fa8:	10800098 	cmpnei	r2,r2,2
 1009fac:	1000031e 	bne	r2,zero,1009fbc <_close+0x9c>
			ret = resp.args.int_field1;
 1009fb0:	e0bffc17 	ldw	r2,-16(fp)
 1009fb4:	e0bff415 	stw	r2,-48(fp)
 1009fb8:	00000206 	br	1009fc4 <_close+0xa4>
		else
			ret = -EINVAL;
 1009fbc:	00bffa84 	movi	r2,-22
 1009fc0:	e0bff415 	stw	r2,-48(fp)
	}

	return ret;
 1009fc4:	e0bff417 	ldw	r2,-48(fp)
}
 1009fc8:	e037883a 	mov	sp,fp
 1009fcc:	dfc00117 	ldw	ra,4(sp)
 1009fd0:	df000017 	ldw	fp,0(sp)
 1009fd4:	dec00204 	addi	sp,sp,8
 1009fd8:	f800283a 	ret

01009fdc <metal_allocate_memory>:
#ifdef __cplusplus
extern "C" {
#endif

static inline void *metal_allocate_memory(unsigned int size)
{
 1009fdc:	defffd04 	addi	sp,sp,-12
 1009fe0:	dfc00215 	stw	ra,8(sp)
 1009fe4:	df000115 	stw	fp,4(sp)
 1009fe8:	df000104 	addi	fp,sp,4
 1009fec:	e13fff15 	stw	r4,-4(fp)
	return (pvPortMalloc(size));
 1009ff0:	e13fff17 	ldw	r4,-4(fp)
 1009ff4:	10010b00 	call	10010b0 <pvPortMalloc>
}
 1009ff8:	e037883a 	mov	sp,fp
 1009ffc:	dfc00117 	ldw	ra,4(sp)
 100a000:	df000017 	ldw	fp,0(sp)
 100a004:	dec00204 	addi	sp,sp,8
 100a008:	f800283a 	ret

0100a00c <metal_free_memory>:

static inline void metal_free_memory(void *ptr)
{
 100a00c:	defffd04 	addi	sp,sp,-12
 100a010:	dfc00215 	stw	ra,8(sp)
 100a014:	df000115 	stw	fp,4(sp)
 100a018:	df000104 	addi	fp,sp,4
 100a01c:	e13fff15 	stw	r4,-4(fp)
	vPortFree(ptr);
 100a020:	e13fff17 	ldw	r4,-4(fp)
 100a024:	10012840 	call	1001284 <vPortFree>
}
 100a028:	0001883a 	nop
 100a02c:	e037883a 	mov	sp,fp
 100a030:	dfc00117 	ldw	ra,4(sp)
 100a034:	df000017 	ldw	fp,0(sp)
 100a038:	dec00204 	addi	sp,sp,8
 100a03c:	f800283a 	ret

0100a040 <elf_is_64>:

#include <lib/include/openamp/elf_loader.h>
#include <lib/include/openamp/remoteproc.h>

static int elf_is_64(const void *elf_info)
{
 100a040:	defffd04 	addi	sp,sp,-12
 100a044:	df000215 	stw	fp,8(sp)
 100a048:	df000204 	addi	fp,sp,8
 100a04c:	e13fff15 	stw	r4,-4(fp)
	const unsigned char *tmp = elf_info;
 100a050:	e0bfff17 	ldw	r2,-4(fp)
 100a054:	e0bffe15 	stw	r2,-8(fp)

	if (tmp[EI_CLASS] == ELFCLASS64)
 100a058:	e0bffe17 	ldw	r2,-8(fp)
 100a05c:	10800104 	addi	r2,r2,4
 100a060:	10800003 	ldbu	r2,0(r2)
 100a064:	10803fcc 	andi	r2,r2,255
 100a068:	10800098 	cmpnei	r2,r2,2
 100a06c:	1000021e 	bne	r2,zero,100a078 <elf_is_64+0x38>
		return 1;
 100a070:	00800044 	movi	r2,1
 100a074:	00000106 	br	100a07c <elf_is_64+0x3c>
	else
		return 0;
 100a078:	0005883a 	mov	r2,zero
}
 100a07c:	e037883a 	mov	sp,fp
 100a080:	df000017 	ldw	fp,0(sp)
 100a084:	dec00104 	addi	sp,sp,4
 100a088:	f800283a 	ret

0100a08c <elf_ehdr_size>:

static size_t elf_ehdr_size(const void *elf_info)
{
 100a08c:	defffd04 	addi	sp,sp,-12
 100a090:	dfc00215 	stw	ra,8(sp)
 100a094:	df000115 	stw	fp,4(sp)
 100a098:	df000104 	addi	fp,sp,4
 100a09c:	e13fff15 	stw	r4,-4(fp)
	if (elf_info == NULL)
 100a0a0:	e0bfff17 	ldw	r2,-4(fp)
 100a0a4:	1000021e 	bne	r2,zero,100a0b0 <elf_ehdr_size+0x24>
		return sizeof(Elf64_Ehdr);
 100a0a8:	00801004 	movi	r2,64
 100a0ac:	00000606 	br	100a0c8 <elf_ehdr_size+0x3c>
	else if (elf_is_64(elf_info) != 0)
 100a0b0:	e13fff17 	ldw	r4,-4(fp)
 100a0b4:	100a0400 	call	100a040 <elf_is_64>
 100a0b8:	10000226 	beq	r2,zero,100a0c4 <elf_ehdr_size+0x38>
		return sizeof(Elf64_Ehdr);
 100a0bc:	00801004 	movi	r2,64
 100a0c0:	00000106 	br	100a0c8 <elf_ehdr_size+0x3c>
	else
		return sizeof(Elf32_Ehdr);
 100a0c4:	00800d04 	movi	r2,52
}
 100a0c8:	e037883a 	mov	sp,fp
 100a0cc:	dfc00117 	ldw	ra,4(sp)
 100a0d0:	df000017 	ldw	fp,0(sp)
 100a0d4:	dec00204 	addi	sp,sp,8
 100a0d8:	f800283a 	ret

0100a0dc <elf_phoff>:

static size_t elf_phoff(const void *elf_info)
{
 100a0dc:	defffb04 	addi	sp,sp,-20
 100a0e0:	dfc00415 	stw	ra,16(sp)
 100a0e4:	df000315 	stw	fp,12(sp)
 100a0e8:	df000304 	addi	fp,sp,12
 100a0ec:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a0f0:	e13fff17 	ldw	r4,-4(fp)
 100a0f4:	100a0400 	call	100a040 <elf_is_64>
 100a0f8:	1000051e 	bne	r2,zero,100a110 <elf_phoff+0x34>
		const Elf32_Ehdr *ehdr = elf_info;
 100a0fc:	e0bfff17 	ldw	r2,-4(fp)
 100a100:	e0bffd15 	stw	r2,-12(fp)

		return ehdr->e_phoff;
 100a104:	e0bffd17 	ldw	r2,-12(fp)
 100a108:	10800717 	ldw	r2,28(r2)
 100a10c:	00000506 	br	100a124 <elf_phoff+0x48>
	} else {
		const Elf64_Ehdr *ehdr = elf_info;
 100a110:	e0bfff17 	ldw	r2,-4(fp)
 100a114:	e0bffe15 	stw	r2,-8(fp)

		return ehdr->e_phoff;
 100a118:	e13ffe17 	ldw	r4,-8(fp)
 100a11c:	20800817 	ldw	r2,32(r4)
 100a120:	20c00917 	ldw	r3,36(r4)
	}
}
 100a124:	e037883a 	mov	sp,fp
 100a128:	dfc00117 	ldw	ra,4(sp)
 100a12c:	df000017 	ldw	fp,0(sp)
 100a130:	dec00204 	addi	sp,sp,8
 100a134:	f800283a 	ret

0100a138 <elf_phentsize>:

static size_t elf_phentsize(const void *elf_info)
{
 100a138:	defffb04 	addi	sp,sp,-20
 100a13c:	dfc00415 	stw	ra,16(sp)
 100a140:	df000315 	stw	fp,12(sp)
 100a144:	df000304 	addi	fp,sp,12
 100a148:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a14c:	e13fff17 	ldw	r4,-4(fp)
 100a150:	100a0400 	call	100a040 <elf_is_64>
 100a154:	1000061e 	bne	r2,zero,100a170 <elf_phentsize+0x38>
		const Elf32_Ehdr *ehdr = elf_info;
 100a158:	e0bfff17 	ldw	r2,-4(fp)
 100a15c:	e0bffd15 	stw	r2,-12(fp)

		return ehdr->e_phentsize;
 100a160:	e0bffd17 	ldw	r2,-12(fp)
 100a164:	10800a8b 	ldhu	r2,42(r2)
 100a168:	10bfffcc 	andi	r2,r2,65535
 100a16c:	00000506 	br	100a184 <elf_phentsize+0x4c>
	} else {
		const Elf64_Ehdr *ehdr = elf_info;
 100a170:	e0bfff17 	ldw	r2,-4(fp)
 100a174:	e0bffe15 	stw	r2,-8(fp)

		return ehdr->e_phentsize;
 100a178:	e0bffe17 	ldw	r2,-8(fp)
 100a17c:	10800d8b 	ldhu	r2,54(r2)
 100a180:	10bfffcc 	andi	r2,r2,65535
	}
}
 100a184:	e037883a 	mov	sp,fp
 100a188:	dfc00117 	ldw	ra,4(sp)
 100a18c:	df000017 	ldw	fp,0(sp)
 100a190:	dec00204 	addi	sp,sp,8
 100a194:	f800283a 	ret

0100a198 <elf_phnum>:

static int elf_phnum(const void *elf_info)
{
 100a198:	defffb04 	addi	sp,sp,-20
 100a19c:	dfc00415 	stw	ra,16(sp)
 100a1a0:	df000315 	stw	fp,12(sp)
 100a1a4:	df000304 	addi	fp,sp,12
 100a1a8:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a1ac:	e13fff17 	ldw	r4,-4(fp)
 100a1b0:	100a0400 	call	100a040 <elf_is_64>
 100a1b4:	1000061e 	bne	r2,zero,100a1d0 <elf_phnum+0x38>
		const Elf32_Ehdr *ehdr = elf_info;
 100a1b8:	e0bfff17 	ldw	r2,-4(fp)
 100a1bc:	e0bffd15 	stw	r2,-12(fp)

		return ehdr->e_phnum;
 100a1c0:	e0bffd17 	ldw	r2,-12(fp)
 100a1c4:	10800b0b 	ldhu	r2,44(r2)
 100a1c8:	10bfffcc 	andi	r2,r2,65535
 100a1cc:	00000506 	br	100a1e4 <elf_phnum+0x4c>
	} else {
		const Elf64_Ehdr *ehdr = elf_info;
 100a1d0:	e0bfff17 	ldw	r2,-4(fp)
 100a1d4:	e0bffe15 	stw	r2,-8(fp)

		return ehdr->e_phnum;
 100a1d8:	e0bffe17 	ldw	r2,-8(fp)
 100a1dc:	10800e0b 	ldhu	r2,56(r2)
 100a1e0:	10bfffcc 	andi	r2,r2,65535
	}
}
 100a1e4:	e037883a 	mov	sp,fp
 100a1e8:	dfc00117 	ldw	ra,4(sp)
 100a1ec:	df000017 	ldw	fp,0(sp)
 100a1f0:	dec00204 	addi	sp,sp,8
 100a1f4:	f800283a 	ret

0100a1f8 <elf_shoff>:

static size_t elf_shoff(const void *elf_info)
{
 100a1f8:	defffb04 	addi	sp,sp,-20
 100a1fc:	dfc00415 	stw	ra,16(sp)
 100a200:	df000315 	stw	fp,12(sp)
 100a204:	df000304 	addi	fp,sp,12
 100a208:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a20c:	e13fff17 	ldw	r4,-4(fp)
 100a210:	100a0400 	call	100a040 <elf_is_64>
 100a214:	1000051e 	bne	r2,zero,100a22c <elf_shoff+0x34>
		const Elf32_Ehdr *ehdr = elf_info;
 100a218:	e0bfff17 	ldw	r2,-4(fp)
 100a21c:	e0bffd15 	stw	r2,-12(fp)

		return ehdr->e_shoff;
 100a220:	e0bffd17 	ldw	r2,-12(fp)
 100a224:	10800817 	ldw	r2,32(r2)
 100a228:	00000506 	br	100a240 <elf_shoff+0x48>
	} else {
		const Elf64_Ehdr *ehdr = elf_info;
 100a22c:	e0bfff17 	ldw	r2,-4(fp)
 100a230:	e0bffe15 	stw	r2,-8(fp)

		return ehdr->e_shoff;
 100a234:	e13ffe17 	ldw	r4,-8(fp)
 100a238:	20800a17 	ldw	r2,40(r4)
 100a23c:	20c00b17 	ldw	r3,44(r4)
	}
}
 100a240:	e037883a 	mov	sp,fp
 100a244:	dfc00117 	ldw	ra,4(sp)
 100a248:	df000017 	ldw	fp,0(sp)
 100a24c:	dec00204 	addi	sp,sp,8
 100a250:	f800283a 	ret

0100a254 <elf_shentsize>:

static size_t elf_shentsize(const void *elf_info)
{
 100a254:	defffb04 	addi	sp,sp,-20
 100a258:	dfc00415 	stw	ra,16(sp)
 100a25c:	df000315 	stw	fp,12(sp)
 100a260:	df000304 	addi	fp,sp,12
 100a264:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a268:	e13fff17 	ldw	r4,-4(fp)
 100a26c:	100a0400 	call	100a040 <elf_is_64>
 100a270:	1000061e 	bne	r2,zero,100a28c <elf_shentsize+0x38>
		const Elf32_Ehdr *ehdr = elf_info;
 100a274:	e0bfff17 	ldw	r2,-4(fp)
 100a278:	e0bffd15 	stw	r2,-12(fp)

		return ehdr->e_shentsize;
 100a27c:	e0bffd17 	ldw	r2,-12(fp)
 100a280:	10800b8b 	ldhu	r2,46(r2)
 100a284:	10bfffcc 	andi	r2,r2,65535
 100a288:	00000506 	br	100a2a0 <elf_shentsize+0x4c>
	} else {
		const Elf64_Ehdr *ehdr = elf_info;
 100a28c:	e0bfff17 	ldw	r2,-4(fp)
 100a290:	e0bffe15 	stw	r2,-8(fp)

		return ehdr->e_shentsize;
 100a294:	e0bffe17 	ldw	r2,-8(fp)
 100a298:	10800e8b 	ldhu	r2,58(r2)
 100a29c:	10bfffcc 	andi	r2,r2,65535
	}
}
 100a2a0:	e037883a 	mov	sp,fp
 100a2a4:	dfc00117 	ldw	ra,4(sp)
 100a2a8:	df000017 	ldw	fp,0(sp)
 100a2ac:	dec00204 	addi	sp,sp,8
 100a2b0:	f800283a 	ret

0100a2b4 <elf_shnum>:

static int elf_shnum(const void *elf_info)
{
 100a2b4:	defffb04 	addi	sp,sp,-20
 100a2b8:	dfc00415 	stw	ra,16(sp)
 100a2bc:	df000315 	stw	fp,12(sp)
 100a2c0:	df000304 	addi	fp,sp,12
 100a2c4:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a2c8:	e13fff17 	ldw	r4,-4(fp)
 100a2cc:	100a0400 	call	100a040 <elf_is_64>
 100a2d0:	1000061e 	bne	r2,zero,100a2ec <elf_shnum+0x38>
		const Elf32_Ehdr *ehdr = elf_info;
 100a2d4:	e0bfff17 	ldw	r2,-4(fp)
 100a2d8:	e0bffd15 	stw	r2,-12(fp)

		return ehdr->e_shnum;
 100a2dc:	e0bffd17 	ldw	r2,-12(fp)
 100a2e0:	10800c0b 	ldhu	r2,48(r2)
 100a2e4:	10bfffcc 	andi	r2,r2,65535
 100a2e8:	00000506 	br	100a300 <elf_shnum+0x4c>
	} else {
		const Elf64_Ehdr *ehdr = elf_info;
 100a2ec:	e0bfff17 	ldw	r2,-4(fp)
 100a2f0:	e0bffe15 	stw	r2,-8(fp)

		return ehdr->e_shnum;
 100a2f4:	e0bffe17 	ldw	r2,-8(fp)
 100a2f8:	10800f0b 	ldhu	r2,60(r2)
 100a2fc:	10bfffcc 	andi	r2,r2,65535
	}
}
 100a300:	e037883a 	mov	sp,fp
 100a304:	dfc00117 	ldw	ra,4(sp)
 100a308:	df000017 	ldw	fp,0(sp)
 100a30c:	dec00204 	addi	sp,sp,8
 100a310:	f800283a 	ret

0100a314 <elf_shstrndx>:

static int elf_shstrndx(const void *elf_info)
{
 100a314:	defffb04 	addi	sp,sp,-20
 100a318:	dfc00415 	stw	ra,16(sp)
 100a31c:	df000315 	stw	fp,12(sp)
 100a320:	df000304 	addi	fp,sp,12
 100a324:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a328:	e13fff17 	ldw	r4,-4(fp)
 100a32c:	100a0400 	call	100a040 <elf_is_64>
 100a330:	1000061e 	bne	r2,zero,100a34c <elf_shstrndx+0x38>
		const Elf32_Ehdr *ehdr = elf_info;
 100a334:	e0bfff17 	ldw	r2,-4(fp)
 100a338:	e0bffd15 	stw	r2,-12(fp)

		return ehdr->e_shstrndx;
 100a33c:	e0bffd17 	ldw	r2,-12(fp)
 100a340:	10800c8b 	ldhu	r2,50(r2)
 100a344:	10bfffcc 	andi	r2,r2,65535
 100a348:	00000506 	br	100a360 <elf_shstrndx+0x4c>
	} else {
		const Elf64_Ehdr *ehdr = elf_info;
 100a34c:	e0bfff17 	ldw	r2,-4(fp)
 100a350:	e0bffe15 	stw	r2,-8(fp)

		return ehdr->e_shstrndx;
 100a354:	e0bffe17 	ldw	r2,-8(fp)
 100a358:	10800f8b 	ldhu	r2,62(r2)
 100a35c:	10bfffcc 	andi	r2,r2,65535
	}
}
 100a360:	e037883a 	mov	sp,fp
 100a364:	dfc00117 	ldw	ra,4(sp)
 100a368:	df000017 	ldw	fp,0(sp)
 100a36c:	dec00204 	addi	sp,sp,8
 100a370:	f800283a 	ret

0100a374 <elf_phtable_ptr>:

static void **elf_phtable_ptr(void *elf_info)
{
 100a374:	defffb04 	addi	sp,sp,-20
 100a378:	dfc00415 	stw	ra,16(sp)
 100a37c:	df000315 	stw	fp,12(sp)
 100a380:	df000304 	addi	fp,sp,12
 100a384:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a388:	e13fff17 	ldw	r4,-4(fp)
 100a38c:	100a0400 	call	100a040 <elf_is_64>
 100a390:	1000051e 	bne	r2,zero,100a3a8 <elf_phtable_ptr+0x34>
		struct elf32_info *einfo = elf_info;
 100a394:	e0bfff17 	ldw	r2,-4(fp)
 100a398:	e0bffd15 	stw	r2,-12(fp)

		return (void **)&einfo->phdrs;
 100a39c:	e0bffd17 	ldw	r2,-12(fp)
 100a3a0:	10800e04 	addi	r2,r2,56
 100a3a4:	00000406 	br	100a3b8 <elf_phtable_ptr+0x44>
	} else {
		struct elf64_info *einfo = elf_info;
 100a3a8:	e0bfff17 	ldw	r2,-4(fp)
 100a3ac:	e0bffe15 	stw	r2,-8(fp)

		return (void **)&einfo->phdrs;
 100a3b0:	e0bffe17 	ldw	r2,-8(fp)
 100a3b4:	10801104 	addi	r2,r2,68
	}
}
 100a3b8:	e037883a 	mov	sp,fp
 100a3bc:	dfc00117 	ldw	ra,4(sp)
 100a3c0:	df000017 	ldw	fp,0(sp)
 100a3c4:	dec00204 	addi	sp,sp,8
 100a3c8:	f800283a 	ret

0100a3cc <elf_shtable_ptr>:

static void **elf_shtable_ptr(void *elf_info)
{
 100a3cc:	defffb04 	addi	sp,sp,-20
 100a3d0:	dfc00415 	stw	ra,16(sp)
 100a3d4:	df000315 	stw	fp,12(sp)
 100a3d8:	df000304 	addi	fp,sp,12
 100a3dc:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a3e0:	e13fff17 	ldw	r4,-4(fp)
 100a3e4:	100a0400 	call	100a040 <elf_is_64>
 100a3e8:	1000051e 	bne	r2,zero,100a400 <elf_shtable_ptr+0x34>
		struct elf32_info *einfo = elf_info;
 100a3ec:	e0bfff17 	ldw	r2,-4(fp)
 100a3f0:	e0bffd15 	stw	r2,-12(fp)

		return (void **)&einfo->shdrs;
 100a3f4:	e0bffd17 	ldw	r2,-12(fp)
 100a3f8:	10800f04 	addi	r2,r2,60
 100a3fc:	00000406 	br	100a410 <elf_shtable_ptr+0x44>
	} else {
		struct elf64_info *einfo = elf_info;
 100a400:	e0bfff17 	ldw	r2,-4(fp)
 100a404:	e0bffe15 	stw	r2,-8(fp)

		return (void **)&einfo->shdrs;
 100a408:	e0bffe17 	ldw	r2,-8(fp)
 100a40c:	10801204 	addi	r2,r2,72
	}
}
 100a410:	e037883a 	mov	sp,fp
 100a414:	dfc00117 	ldw	ra,4(sp)
 100a418:	df000017 	ldw	fp,0(sp)
 100a41c:	dec00204 	addi	sp,sp,8
 100a420:	f800283a 	ret

0100a424 <elf_shstrtab_ptr>:

static void **elf_shstrtab_ptr(void *elf_info)
{
 100a424:	defffb04 	addi	sp,sp,-20
 100a428:	dfc00415 	stw	ra,16(sp)
 100a42c:	df000315 	stw	fp,12(sp)
 100a430:	df000304 	addi	fp,sp,12
 100a434:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a438:	e13fff17 	ldw	r4,-4(fp)
 100a43c:	100a0400 	call	100a040 <elf_is_64>
 100a440:	1000051e 	bne	r2,zero,100a458 <elf_shstrtab_ptr+0x34>
		struct elf32_info *einfo = elf_info;
 100a444:	e0bfff17 	ldw	r2,-4(fp)
 100a448:	e0bffd15 	stw	r2,-12(fp)

		return &einfo->shstrtab;
 100a44c:	e0bffd17 	ldw	r2,-12(fp)
 100a450:	10801004 	addi	r2,r2,64
 100a454:	00000406 	br	100a468 <elf_shstrtab_ptr+0x44>
	} else {
		struct elf64_info *einfo = elf_info;
 100a458:	e0bfff17 	ldw	r2,-4(fp)
 100a45c:	e0bffe15 	stw	r2,-8(fp)

		return &einfo->shstrtab;
 100a460:	e0bffe17 	ldw	r2,-8(fp)
 100a464:	10801304 	addi	r2,r2,76
	}
}
 100a468:	e037883a 	mov	sp,fp
 100a46c:	dfc00117 	ldw	ra,4(sp)
 100a470:	df000017 	ldw	fp,0(sp)
 100a474:	dec00204 	addi	sp,sp,8
 100a478:	f800283a 	ret

0100a47c <elf_load_state>:

static int *elf_load_state(void *elf_info)
{
 100a47c:	defffb04 	addi	sp,sp,-20
 100a480:	dfc00415 	stw	ra,16(sp)
 100a484:	df000315 	stw	fp,12(sp)
 100a488:	df000304 	addi	fp,sp,12
 100a48c:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a490:	e13fff17 	ldw	r4,-4(fp)
 100a494:	100a0400 	call	100a040 <elf_is_64>
 100a498:	1000051e 	bne	r2,zero,100a4b0 <elf_load_state+0x34>
		struct elf32_info *einfo = elf_info;
 100a49c:	e0bfff17 	ldw	r2,-4(fp)
 100a4a0:	e0bffd15 	stw	r2,-12(fp)

		return &einfo->load_state;
 100a4a4:	e0bffd17 	ldw	r2,-12(fp)
 100a4a8:	10800d04 	addi	r2,r2,52
 100a4ac:	00000406 	br	100a4c0 <elf_load_state+0x44>
	} else {
		struct elf64_info *einfo = elf_info;
 100a4b0:	e0bfff17 	ldw	r2,-4(fp)
 100a4b4:	e0bffe15 	stw	r2,-8(fp)

		return &einfo->load_state;
 100a4b8:	e0bffe17 	ldw	r2,-8(fp)
 100a4bc:	10801004 	addi	r2,r2,64
	}
}
 100a4c0:	e037883a 	mov	sp,fp
 100a4c4:	dfc00117 	ldw	ra,4(sp)
 100a4c8:	df000017 	ldw	fp,0(sp)
 100a4cc:	dec00204 	addi	sp,sp,8
 100a4d0:	f800283a 	ret

0100a4d4 <elf_parse_segment>:
static void elf_parse_segment(void *elf_info, const void *elf_phdr,
			      unsigned int *p_type, size_t *p_offset,
			      metal_phys_addr_t *p_vaddr,
			      metal_phys_addr_t *p_paddr,
			      size_t *p_filesz, size_t *p_memsz)
{
 100a4d4:	defff804 	addi	sp,sp,-32
 100a4d8:	dfc00715 	stw	ra,28(sp)
 100a4dc:	df000615 	stw	fp,24(sp)
 100a4e0:	df000604 	addi	fp,sp,24
 100a4e4:	e13ffc15 	stw	r4,-16(fp)
 100a4e8:	e17ffd15 	stw	r5,-12(fp)
 100a4ec:	e1bffe15 	stw	r6,-8(fp)
 100a4f0:	e1ffff15 	stw	r7,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a4f4:	e13ffc17 	ldw	r4,-16(fp)
 100a4f8:	100a0400 	call	100a040 <elf_is_64>
 100a4fc:	1000271e 	bne	r2,zero,100a59c <elf_parse_segment+0xc8>
		const Elf32_Phdr *phdr = elf_phdr;
 100a500:	e0bffd17 	ldw	r2,-12(fp)
 100a504:	e0bffa15 	stw	r2,-24(fp)

		if (p_type != NULL)
 100a508:	e0bffe17 	ldw	r2,-8(fp)
 100a50c:	10000426 	beq	r2,zero,100a520 <elf_parse_segment+0x4c>
			*p_type = (unsigned int)phdr->p_type;
 100a510:	e0bffa17 	ldw	r2,-24(fp)
 100a514:	10c00017 	ldw	r3,0(r2)
 100a518:	e0bffe17 	ldw	r2,-8(fp)
 100a51c:	10c00015 	stw	r3,0(r2)
		if (p_offset != NULL)
 100a520:	e0bfff17 	ldw	r2,-4(fp)
 100a524:	10000426 	beq	r2,zero,100a538 <elf_parse_segment+0x64>
			*p_offset = (size_t)phdr->p_offset;
 100a528:	e0bffa17 	ldw	r2,-24(fp)
 100a52c:	10c00117 	ldw	r3,4(r2)
 100a530:	e0bfff17 	ldw	r2,-4(fp)
 100a534:	10c00015 	stw	r3,0(r2)
		if (p_vaddr != NULL)
 100a538:	e0800217 	ldw	r2,8(fp)
 100a53c:	10000426 	beq	r2,zero,100a550 <elf_parse_segment+0x7c>
			*p_vaddr = (metal_phys_addr_t)phdr->p_vaddr;
 100a540:	e0bffa17 	ldw	r2,-24(fp)
 100a544:	10c00217 	ldw	r3,8(r2)
 100a548:	e0800217 	ldw	r2,8(fp)
 100a54c:	10c00015 	stw	r3,0(r2)
		if (p_paddr != NULL)
 100a550:	e0800317 	ldw	r2,12(fp)
 100a554:	10000426 	beq	r2,zero,100a568 <elf_parse_segment+0x94>
			*p_paddr = (metal_phys_addr_t)phdr->p_paddr;
 100a558:	e0bffa17 	ldw	r2,-24(fp)
 100a55c:	10c00317 	ldw	r3,12(r2)
 100a560:	e0800317 	ldw	r2,12(fp)
 100a564:	10c00015 	stw	r3,0(r2)
		if (p_filesz != NULL)
 100a568:	e0800417 	ldw	r2,16(fp)
 100a56c:	10000426 	beq	r2,zero,100a580 <elf_parse_segment+0xac>
			*p_filesz = (size_t)phdr->p_filesz;
 100a570:	e0bffa17 	ldw	r2,-24(fp)
 100a574:	10c00417 	ldw	r3,16(r2)
 100a578:	e0800417 	ldw	r2,16(fp)
 100a57c:	10c00015 	stw	r3,0(r2)
		if (p_memsz != NULL)
 100a580:	e0800517 	ldw	r2,20(fp)
 100a584:	10003526 	beq	r2,zero,100a65c <elf_parse_segment+0x188>
			*p_memsz = (size_t)phdr->p_memsz;
 100a588:	e0bffa17 	ldw	r2,-24(fp)
 100a58c:	10c00517 	ldw	r3,20(r2)
 100a590:	e0800517 	ldw	r2,20(fp)
 100a594:	10c00015 	stw	r3,0(r2)
		if (p_filesz != NULL)
			*p_filesz = (size_t)phdr->p_filesz;
		if (p_memsz != NULL)
			*p_memsz = (size_t)phdr->p_memsz;
	}
}
 100a598:	00003006 	br	100a65c <elf_parse_segment+0x188>
		if (p_filesz != NULL)
			*p_filesz = (size_t)phdr->p_filesz;
		if (p_memsz != NULL)
			*p_memsz = (size_t)phdr->p_memsz;
	} else {
		const Elf64_Phdr *phdr = elf_phdr;
 100a59c:	e0bffd17 	ldw	r2,-12(fp)
 100a5a0:	e0bffb15 	stw	r2,-20(fp)

		if (p_type != NULL)
 100a5a4:	e0bffe17 	ldw	r2,-8(fp)
 100a5a8:	10000426 	beq	r2,zero,100a5bc <elf_parse_segment+0xe8>
			*p_type = (unsigned int)phdr->p_type;
 100a5ac:	e0bffb17 	ldw	r2,-20(fp)
 100a5b0:	10c00017 	ldw	r3,0(r2)
 100a5b4:	e0bffe17 	ldw	r2,-8(fp)
 100a5b8:	10c00015 	stw	r3,0(r2)
		if (p_offset != NULL)
 100a5bc:	e0bfff17 	ldw	r2,-4(fp)
 100a5c0:	10000626 	beq	r2,zero,100a5dc <elf_parse_segment+0x108>
			*p_offset = (size_t)phdr->p_offset;
 100a5c4:	e13ffb17 	ldw	r4,-20(fp)
 100a5c8:	20800217 	ldw	r2,8(r4)
 100a5cc:	20c00317 	ldw	r3,12(r4)
 100a5d0:	1007883a 	mov	r3,r2
 100a5d4:	e0bfff17 	ldw	r2,-4(fp)
 100a5d8:	10c00015 	stw	r3,0(r2)
		if (p_vaddr != NULL)
 100a5dc:	e0800217 	ldw	r2,8(fp)
 100a5e0:	10000626 	beq	r2,zero,100a5fc <elf_parse_segment+0x128>
			*p_vaddr = (metal_phys_addr_t)phdr->p_vaddr;
 100a5e4:	e13ffb17 	ldw	r4,-20(fp)
 100a5e8:	20800417 	ldw	r2,16(r4)
 100a5ec:	20c00517 	ldw	r3,20(r4)
 100a5f0:	1007883a 	mov	r3,r2
 100a5f4:	e0800217 	ldw	r2,8(fp)
 100a5f8:	10c00015 	stw	r3,0(r2)
		if (p_paddr != NULL)
 100a5fc:	e0800317 	ldw	r2,12(fp)
 100a600:	10000626 	beq	r2,zero,100a61c <elf_parse_segment+0x148>
			*p_paddr = (metal_phys_addr_t)phdr->p_paddr;
 100a604:	e13ffb17 	ldw	r4,-20(fp)
 100a608:	20800617 	ldw	r2,24(r4)
 100a60c:	20c00717 	ldw	r3,28(r4)
 100a610:	1007883a 	mov	r3,r2
 100a614:	e0800317 	ldw	r2,12(fp)
 100a618:	10c00015 	stw	r3,0(r2)
		if (p_filesz != NULL)
 100a61c:	e0800417 	ldw	r2,16(fp)
 100a620:	10000626 	beq	r2,zero,100a63c <elf_parse_segment+0x168>
			*p_filesz = (size_t)phdr->p_filesz;
 100a624:	e13ffb17 	ldw	r4,-20(fp)
 100a628:	20800817 	ldw	r2,32(r4)
 100a62c:	20c00917 	ldw	r3,36(r4)
 100a630:	1007883a 	mov	r3,r2
 100a634:	e0800417 	ldw	r2,16(fp)
 100a638:	10c00015 	stw	r3,0(r2)
		if (p_memsz != NULL)
 100a63c:	e0800517 	ldw	r2,20(fp)
 100a640:	10000626 	beq	r2,zero,100a65c <elf_parse_segment+0x188>
			*p_memsz = (size_t)phdr->p_memsz;
 100a644:	e13ffb17 	ldw	r4,-20(fp)
 100a648:	20800a17 	ldw	r2,40(r4)
 100a64c:	20c00b17 	ldw	r3,44(r4)
 100a650:	1007883a 	mov	r3,r2
 100a654:	e0800517 	ldw	r2,20(fp)
 100a658:	10c00015 	stw	r3,0(r2)
	}
}
 100a65c:	0001883a 	nop
 100a660:	e037883a 	mov	sp,fp
 100a664:	dfc00117 	ldw	ra,4(sp)
 100a668:	df000017 	ldw	fp,0(sp)
 100a66c:	dec00204 	addi	sp,sp,8
 100a670:	f800283a 	ret

0100a674 <elf_get_segment_from_index>:

static const void *elf_get_segment_from_index(void *elf_info, int index)
{
 100a674:	defff604 	addi	sp,sp,-40
 100a678:	dfc00915 	stw	ra,36(sp)
 100a67c:	df000815 	stw	fp,32(sp)
 100a680:	df000804 	addi	fp,sp,32
 100a684:	e13ffe15 	stw	r4,-8(fp)
 100a688:	e17fff15 	stw	r5,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a68c:	e13ffe17 	ldw	r4,-8(fp)
 100a690:	100a0400 	call	100a040 <elf_is_64>
 100a694:	1000191e 	bne	r2,zero,100a6fc <elf_get_segment_from_index+0x88>
		const struct elf32_info *einfo = elf_info;
 100a698:	e0bffe17 	ldw	r2,-8(fp)
 100a69c:	e0bff815 	stw	r2,-32(fp)
		const Elf32_Ehdr *ehdr = &einfo->ehdr;
 100a6a0:	e0bff817 	ldw	r2,-32(fp)
 100a6a4:	e0bff915 	stw	r2,-28(fp)
		const Elf32_Phdr *phdrs = einfo->phdrs;
 100a6a8:	e0bff817 	ldw	r2,-32(fp)
 100a6ac:	10800e17 	ldw	r2,56(r2)
 100a6b0:	e0bffa15 	stw	r2,-24(fp)

		if (phdrs == NULL)
 100a6b4:	e0bffa17 	ldw	r2,-24(fp)
 100a6b8:	1000021e 	bne	r2,zero,100a6c4 <elf_get_segment_from_index+0x50>
			return NULL;
 100a6bc:	0005883a 	mov	r2,zero
 100a6c0:	00002606 	br	100a75c <elf_get_segment_from_index+0xe8>
		if (index < 0 || index >= ehdr->e_phnum)
 100a6c4:	e0bfff17 	ldw	r2,-4(fp)
 100a6c8:	10000516 	blt	r2,zero,100a6e0 <elf_get_segment_from_index+0x6c>
 100a6cc:	e0bff917 	ldw	r2,-28(fp)
 100a6d0:	10800b0b 	ldhu	r2,44(r2)
 100a6d4:	10bfffcc 	andi	r2,r2,65535
 100a6d8:	e0ffff17 	ldw	r3,-4(fp)
 100a6dc:	18800216 	blt	r3,r2,100a6e8 <elf_get_segment_from_index+0x74>
			return NULL;
 100a6e0:	0005883a 	mov	r2,zero
 100a6e4:	00001d06 	br	100a75c <elf_get_segment_from_index+0xe8>
		return &phdrs[index];
 100a6e8:	e0bfff17 	ldw	r2,-4(fp)
 100a6ec:	1004917a 	slli	r2,r2,5
 100a6f0:	e0fffa17 	ldw	r3,-24(fp)
 100a6f4:	1885883a 	add	r2,r3,r2
 100a6f8:	00001806 	br	100a75c <elf_get_segment_from_index+0xe8>
	} else {
		const struct elf64_info *einfo = elf_info;
 100a6fc:	e0bffe17 	ldw	r2,-8(fp)
 100a700:	e0bffb15 	stw	r2,-20(fp)
		const Elf64_Ehdr *ehdr = &einfo->ehdr;
 100a704:	e0bffb17 	ldw	r2,-20(fp)
 100a708:	e0bffc15 	stw	r2,-16(fp)
		const Elf64_Phdr *phdrs = einfo->phdrs;
 100a70c:	e0bffb17 	ldw	r2,-20(fp)
 100a710:	10801117 	ldw	r2,68(r2)
 100a714:	e0bffd15 	stw	r2,-12(fp)

		if (phdrs == NULL)
 100a718:	e0bffd17 	ldw	r2,-12(fp)
 100a71c:	1000021e 	bne	r2,zero,100a728 <elf_get_segment_from_index+0xb4>
			return NULL;
 100a720:	0005883a 	mov	r2,zero
 100a724:	00000d06 	br	100a75c <elf_get_segment_from_index+0xe8>
		if (index < 0 || index >= ehdr->e_phnum)
 100a728:	e0bfff17 	ldw	r2,-4(fp)
 100a72c:	10000516 	blt	r2,zero,100a744 <elf_get_segment_from_index+0xd0>
 100a730:	e0bffc17 	ldw	r2,-16(fp)
 100a734:	10800e0b 	ldhu	r2,56(r2)
 100a738:	10bfffcc 	andi	r2,r2,65535
 100a73c:	e0ffff17 	ldw	r3,-4(fp)
 100a740:	18800216 	blt	r3,r2,100a74c <elf_get_segment_from_index+0xd8>
			return NULL;
 100a744:	0005883a 	mov	r2,zero
 100a748:	00000406 	br	100a75c <elf_get_segment_from_index+0xe8>
		return &phdrs[index];
 100a74c:	e0bfff17 	ldw	r2,-4(fp)
 100a750:	10800e24 	muli	r2,r2,56
 100a754:	e0fffd17 	ldw	r3,-12(fp)
 100a758:	1885883a 	add	r2,r3,r2
	}
}
 100a75c:	e037883a 	mov	sp,fp
 100a760:	dfc00117 	ldw	ra,4(sp)
 100a764:	df000017 	ldw	fp,0(sp)
 100a768:	dec00204 	addi	sp,sp,8
 100a76c:	f800283a 	ret

0100a770 <elf_get_section_from_name>:

static void *elf_get_section_from_name(void *elf_info, const char *name)
{
 100a770:	defff404 	addi	sp,sp,-48
 100a774:	dfc00b15 	stw	ra,44(sp)
 100a778:	df000a15 	stw	fp,40(sp)
 100a77c:	df000a04 	addi	fp,sp,40
 100a780:	e13ffe15 	stw	r4,-8(fp)
 100a784:	e17fff15 	stw	r5,-4(fp)
	unsigned int i;
	const char *name_table;

	if (elf_is_64(elf_info) == 0) {
 100a788:	e13ffe17 	ldw	r4,-8(fp)
 100a78c:	100a0400 	call	100a040 <elf_is_64>
 100a790:	1000291e 	bne	r2,zero,100a838 <elf_get_section_from_name+0xc8>
		struct elf32_info *einfo = elf_info;
 100a794:	e0bffe17 	ldw	r2,-8(fp)
 100a798:	e0bff915 	stw	r2,-28(fp)
		Elf32_Ehdr *ehdr = &einfo->ehdr;
 100a79c:	e0bff917 	ldw	r2,-28(fp)
 100a7a0:	e0bffa15 	stw	r2,-24(fp)
		Elf32_Shdr *shdr = einfo->shdrs;
 100a7a4:	e0bff917 	ldw	r2,-28(fp)
 100a7a8:	10800f17 	ldw	r2,60(r2)
 100a7ac:	e0bff715 	stw	r2,-36(fp)

		name_table = einfo->shstrtab;
 100a7b0:	e0bff917 	ldw	r2,-28(fp)
 100a7b4:	10801017 	ldw	r2,64(r2)
 100a7b8:	e0bffb15 	stw	r2,-20(fp)
		if (shdr == NULL || name_table == NULL)
 100a7bc:	e0bff717 	ldw	r2,-36(fp)
 100a7c0:	10000226 	beq	r2,zero,100a7cc <elf_get_section_from_name+0x5c>
 100a7c4:	e0bffb17 	ldw	r2,-20(fp)
 100a7c8:	1000021e 	bne	r2,zero,100a7d4 <elf_get_section_from_name+0x64>
			return NULL;
 100a7cc:	0005883a 	mov	r2,zero
 100a7d0:	00004206 	br	100a8dc <elf_get_section_from_name+0x16c>
		for (i = 0; i < ehdr->e_shnum; i++, shdr++) {
 100a7d4:	e03ff615 	stw	zero,-40(fp)
 100a7d8:	00001106 	br	100a820 <elf_get_section_from_name+0xb0>
			if (strcmp(name, name_table + shdr->sh_name))
 100a7dc:	e0bff717 	ldw	r2,-36(fp)
 100a7e0:	10800017 	ldw	r2,0(r2)
 100a7e4:	e0fffb17 	ldw	r3,-20(fp)
 100a7e8:	1885883a 	add	r2,r3,r2
 100a7ec:	100b883a 	mov	r5,r2
 100a7f0:	e13fff17 	ldw	r4,-4(fp)
 100a7f4:	1015e600 	call	1015e60 <strcmp>
 100a7f8:	10000726 	beq	r2,zero,100a818 <elf_get_section_from_name+0xa8>
		Elf32_Shdr *shdr = einfo->shdrs;

		name_table = einfo->shstrtab;
		if (shdr == NULL || name_table == NULL)
			return NULL;
		for (i = 0; i < ehdr->e_shnum; i++, shdr++) {
 100a7fc:	e0bff617 	ldw	r2,-40(fp)
 100a800:	10800044 	addi	r2,r2,1
 100a804:	e0bff615 	stw	r2,-40(fp)
 100a808:	e0bff717 	ldw	r2,-36(fp)
 100a80c:	10800a04 	addi	r2,r2,40
 100a810:	e0bff715 	stw	r2,-36(fp)
 100a814:	00000206 	br	100a820 <elf_get_section_from_name+0xb0>
			if (strcmp(name, name_table + shdr->sh_name))
				continue;
			else
				return shdr;
 100a818:	e0bff717 	ldw	r2,-36(fp)
 100a81c:	00002f06 	br	100a8dc <elf_get_section_from_name+0x16c>
		Elf32_Shdr *shdr = einfo->shdrs;

		name_table = einfo->shstrtab;
		if (shdr == NULL || name_table == NULL)
			return NULL;
		for (i = 0; i < ehdr->e_shnum; i++, shdr++) {
 100a820:	e0bffa17 	ldw	r2,-24(fp)
 100a824:	10800c0b 	ldhu	r2,48(r2)
 100a828:	10bfffcc 	andi	r2,r2,65535
 100a82c:	e0fff617 	ldw	r3,-40(fp)
 100a830:	18bfea36 	bltu	r3,r2,100a7dc <__alt_data_end+0xff00a7dc>
 100a834:	00002806 	br	100a8d8 <elf_get_section_from_name+0x168>
				continue;
			else
				return shdr;
		}
	} else {
		struct elf64_info *einfo = elf_info;
 100a838:	e0bffe17 	ldw	r2,-8(fp)
 100a83c:	e0bffc15 	stw	r2,-16(fp)
		Elf64_Ehdr *ehdr = &einfo->ehdr;
 100a840:	e0bffc17 	ldw	r2,-16(fp)
 100a844:	e0bffd15 	stw	r2,-12(fp)
		Elf64_Shdr *shdr = einfo->shdrs;
 100a848:	e0bffc17 	ldw	r2,-16(fp)
 100a84c:	10801217 	ldw	r2,72(r2)
 100a850:	e0bff815 	stw	r2,-32(fp)

		name_table = einfo->shstrtab;
 100a854:	e0bffc17 	ldw	r2,-16(fp)
 100a858:	10801317 	ldw	r2,76(r2)
 100a85c:	e0bffb15 	stw	r2,-20(fp)
		if (shdr == NULL || name_table == NULL)
 100a860:	e0bff817 	ldw	r2,-32(fp)
 100a864:	10000226 	beq	r2,zero,100a870 <elf_get_section_from_name+0x100>
 100a868:	e0bffb17 	ldw	r2,-20(fp)
 100a86c:	1000021e 	bne	r2,zero,100a878 <elf_get_section_from_name+0x108>
			return NULL;
 100a870:	0005883a 	mov	r2,zero
 100a874:	00001906 	br	100a8dc <elf_get_section_from_name+0x16c>
		for (i = 0; i < ehdr->e_shnum; i++, shdr++) {
 100a878:	e03ff615 	stw	zero,-40(fp)
 100a87c:	00001106 	br	100a8c4 <elf_get_section_from_name+0x154>
			if (strcmp(name, name_table + shdr->sh_name))
 100a880:	e0bff817 	ldw	r2,-32(fp)
 100a884:	10800017 	ldw	r2,0(r2)
 100a888:	e0fffb17 	ldw	r3,-20(fp)
 100a88c:	1885883a 	add	r2,r3,r2
 100a890:	100b883a 	mov	r5,r2
 100a894:	e13fff17 	ldw	r4,-4(fp)
 100a898:	1015e600 	call	1015e60 <strcmp>
 100a89c:	10000726 	beq	r2,zero,100a8bc <elf_get_section_from_name+0x14c>
		Elf64_Shdr *shdr = einfo->shdrs;

		name_table = einfo->shstrtab;
		if (shdr == NULL || name_table == NULL)
			return NULL;
		for (i = 0; i < ehdr->e_shnum; i++, shdr++) {
 100a8a0:	e0bff617 	ldw	r2,-40(fp)
 100a8a4:	10800044 	addi	r2,r2,1
 100a8a8:	e0bff615 	stw	r2,-40(fp)
 100a8ac:	e0bff817 	ldw	r2,-32(fp)
 100a8b0:	10801004 	addi	r2,r2,64
 100a8b4:	e0bff815 	stw	r2,-32(fp)
 100a8b8:	00000206 	br	100a8c4 <elf_get_section_from_name+0x154>
			if (strcmp(name, name_table + shdr->sh_name))
				continue;
			else
				return shdr;
 100a8bc:	e0bff817 	ldw	r2,-32(fp)
 100a8c0:	00000606 	br	100a8dc <elf_get_section_from_name+0x16c>
		Elf64_Shdr *shdr = einfo->shdrs;

		name_table = einfo->shstrtab;
		if (shdr == NULL || name_table == NULL)
			return NULL;
		for (i = 0; i < ehdr->e_shnum; i++, shdr++) {
 100a8c4:	e0bffd17 	ldw	r2,-12(fp)
 100a8c8:	10800f0b 	ldhu	r2,60(r2)
 100a8cc:	10bfffcc 	andi	r2,r2,65535
 100a8d0:	e0fff617 	ldw	r3,-40(fp)
 100a8d4:	18bfea36 	bltu	r3,r2,100a880 <__alt_data_end+0xff00a880>
				continue;
			else
				return shdr;
		}
	}
	return NULL;
 100a8d8:	0005883a 	mov	r2,zero
}
 100a8dc:	e037883a 	mov	sp,fp
 100a8e0:	dfc00117 	ldw	ra,4(sp)
 100a8e4:	df000017 	ldw	fp,0(sp)
 100a8e8:	dec00204 	addi	sp,sp,8
 100a8ec:	f800283a 	ret

0100a8f0 <elf_get_section_from_index>:

static void *elf_get_section_from_index(void *elf_info, int index)
{
 100a8f0:	defff604 	addi	sp,sp,-40
 100a8f4:	dfc00915 	stw	ra,36(sp)
 100a8f8:	df000815 	stw	fp,32(sp)
 100a8fc:	df000804 	addi	fp,sp,32
 100a900:	e13ffe15 	stw	r4,-8(fp)
 100a904:	e17fff15 	stw	r5,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100a908:	e13ffe17 	ldw	r4,-8(fp)
 100a90c:	100a0400 	call	100a040 <elf_is_64>
 100a910:	10001a1e 	bne	r2,zero,100a97c <elf_get_section_from_index+0x8c>
		struct elf32_info *einfo = elf_info;
 100a914:	e0bffe17 	ldw	r2,-8(fp)
 100a918:	e0bff815 	stw	r2,-32(fp)
		Elf32_Ehdr *ehdr = &einfo->ehdr;
 100a91c:	e0bff817 	ldw	r2,-32(fp)
 100a920:	e0bff915 	stw	r2,-28(fp)
		Elf32_Shdr *shdr = einfo->shdrs;
 100a924:	e0bff817 	ldw	r2,-32(fp)
 100a928:	10800f17 	ldw	r2,60(r2)
 100a92c:	e0bffa15 	stw	r2,-24(fp)

		if (shdr == NULL)
 100a930:	e0bffa17 	ldw	r2,-24(fp)
 100a934:	1000021e 	bne	r2,zero,100a940 <elf_get_section_from_index+0x50>
			return NULL;
 100a938:	0005883a 	mov	r2,zero
 100a93c:	00002806 	br	100a9e0 <elf_get_section_from_index+0xf0>
		if (index < 0 || index >= ehdr->e_shnum)
 100a940:	e0bfff17 	ldw	r2,-4(fp)
 100a944:	10000516 	blt	r2,zero,100a95c <elf_get_section_from_index+0x6c>
 100a948:	e0bff917 	ldw	r2,-28(fp)
 100a94c:	10800c0b 	ldhu	r2,48(r2)
 100a950:	10bfffcc 	andi	r2,r2,65535
 100a954:	e0ffff17 	ldw	r3,-4(fp)
 100a958:	18800216 	blt	r3,r2,100a964 <elf_get_section_from_index+0x74>
			return NULL;
 100a95c:	0005883a 	mov	r2,zero
 100a960:	00001f06 	br	100a9e0 <elf_get_section_from_index+0xf0>
		return &einfo->shdrs[index];
 100a964:	e0bff817 	ldw	r2,-32(fp)
 100a968:	10c00f17 	ldw	r3,60(r2)
 100a96c:	e0bfff17 	ldw	r2,-4(fp)
 100a970:	10800a24 	muli	r2,r2,40
 100a974:	1885883a 	add	r2,r3,r2
 100a978:	00001906 	br	100a9e0 <elf_get_section_from_index+0xf0>
	} else {
		struct elf64_info *einfo = elf_info;
 100a97c:	e0bffe17 	ldw	r2,-8(fp)
 100a980:	e0bffb15 	stw	r2,-20(fp)
		Elf64_Ehdr *ehdr = &einfo->ehdr;
 100a984:	e0bffb17 	ldw	r2,-20(fp)
 100a988:	e0bffc15 	stw	r2,-16(fp)
		Elf64_Shdr *shdr = einfo->shdrs;
 100a98c:	e0bffb17 	ldw	r2,-20(fp)
 100a990:	10801217 	ldw	r2,72(r2)
 100a994:	e0bffd15 	stw	r2,-12(fp)

		if (shdr == NULL)
 100a998:	e0bffd17 	ldw	r2,-12(fp)
 100a99c:	1000021e 	bne	r2,zero,100a9a8 <elf_get_section_from_index+0xb8>
			return NULL;
 100a9a0:	0005883a 	mov	r2,zero
 100a9a4:	00000e06 	br	100a9e0 <elf_get_section_from_index+0xf0>
		if (index < 0 || index >= ehdr->e_shnum)
 100a9a8:	e0bfff17 	ldw	r2,-4(fp)
 100a9ac:	10000516 	blt	r2,zero,100a9c4 <elf_get_section_from_index+0xd4>
 100a9b0:	e0bffc17 	ldw	r2,-16(fp)
 100a9b4:	10800f0b 	ldhu	r2,60(r2)
 100a9b8:	10bfffcc 	andi	r2,r2,65535
 100a9bc:	e0ffff17 	ldw	r3,-4(fp)
 100a9c0:	18800216 	blt	r3,r2,100a9cc <elf_get_section_from_index+0xdc>
			return NULL;
 100a9c4:	0005883a 	mov	r2,zero
 100a9c8:	00000506 	br	100a9e0 <elf_get_section_from_index+0xf0>
		return &einfo->shdrs[index];
 100a9cc:	e0bffb17 	ldw	r2,-20(fp)
 100a9d0:	10c01217 	ldw	r3,72(r2)
 100a9d4:	e0bfff17 	ldw	r2,-4(fp)
 100a9d8:	100491ba 	slli	r2,r2,6
 100a9dc:	1885883a 	add	r2,r3,r2
	}
}
 100a9e0:	e037883a 	mov	sp,fp
 100a9e4:	dfc00117 	ldw	ra,4(sp)
 100a9e8:	df000017 	ldw	fp,0(sp)
 100a9ec:	dec00204 	addi	sp,sp,8
 100a9f0:	f800283a 	ret

0100a9f4 <elf_parse_section>:
			      metal_phys_addr_t *sh_addr,
			      size_t *sh_offset, size_t *sh_size,
			      unsigned int *sh_link, unsigned int *sh_info,
			      unsigned int *sh_addralign,
			      size_t *sh_entsize)
{
 100a9f4:	defff804 	addi	sp,sp,-32
 100a9f8:	dfc00715 	stw	ra,28(sp)
 100a9fc:	df000615 	stw	fp,24(sp)
 100aa00:	df000604 	addi	fp,sp,24
 100aa04:	e13ffc15 	stw	r4,-16(fp)
 100aa08:	e17ffd15 	stw	r5,-12(fp)
 100aa0c:	e1bffe15 	stw	r6,-8(fp)
 100aa10:	e1ffff15 	stw	r7,-4(fp)
	if (elf_is_64(elf_info) == 0) {
 100aa14:	e13ffc17 	ldw	r4,-16(fp)
 100aa18:	100a0400 	call	100a040 <elf_is_64>
 100aa1c:	1000391e 	bne	r2,zero,100ab04 <elf_parse_section+0x110>
		Elf32_Shdr *shdr = elf_shdr;
 100aa20:	e0bffd17 	ldw	r2,-12(fp)
 100aa24:	e0bffa15 	stw	r2,-24(fp)

		if (sh_type != NULL)
 100aa28:	e0bffe17 	ldw	r2,-8(fp)
 100aa2c:	10000426 	beq	r2,zero,100aa40 <elf_parse_section+0x4c>
			*sh_type = shdr->sh_type;
 100aa30:	e0bffa17 	ldw	r2,-24(fp)
 100aa34:	10c00117 	ldw	r3,4(r2)
 100aa38:	e0bffe17 	ldw	r2,-8(fp)
 100aa3c:	10c00015 	stw	r3,0(r2)
		if (sh_flags != NULL)
 100aa40:	e0bfff17 	ldw	r2,-4(fp)
 100aa44:	10000426 	beq	r2,zero,100aa58 <elf_parse_section+0x64>
			*sh_flags = shdr->sh_flags;
 100aa48:	e0bffa17 	ldw	r2,-24(fp)
 100aa4c:	10c00217 	ldw	r3,8(r2)
 100aa50:	e0bfff17 	ldw	r2,-4(fp)
 100aa54:	10c00015 	stw	r3,0(r2)
		if (sh_addr != NULL)
 100aa58:	e0800217 	ldw	r2,8(fp)
 100aa5c:	10000426 	beq	r2,zero,100aa70 <elf_parse_section+0x7c>
			*sh_addr = (metal_phys_addr_t)shdr->sh_addr;
 100aa60:	e0bffa17 	ldw	r2,-24(fp)
 100aa64:	10c00317 	ldw	r3,12(r2)
 100aa68:	e0800217 	ldw	r2,8(fp)
 100aa6c:	10c00015 	stw	r3,0(r2)
		if (sh_offset != NULL)
 100aa70:	e0800317 	ldw	r2,12(fp)
 100aa74:	10000426 	beq	r2,zero,100aa88 <elf_parse_section+0x94>
			*sh_offset = shdr->sh_offset;
 100aa78:	e0bffa17 	ldw	r2,-24(fp)
 100aa7c:	10c00417 	ldw	r3,16(r2)
 100aa80:	e0800317 	ldw	r2,12(fp)
 100aa84:	10c00015 	stw	r3,0(r2)
		if (sh_size != NULL)
 100aa88:	e0800417 	ldw	r2,16(fp)
 100aa8c:	10000426 	beq	r2,zero,100aaa0 <elf_parse_section+0xac>
			*sh_size = shdr->sh_size;
 100aa90:	e0bffa17 	ldw	r2,-24(fp)
 100aa94:	10c00517 	ldw	r3,20(r2)
 100aa98:	e0800417 	ldw	r2,16(fp)
 100aa9c:	10c00015 	stw	r3,0(r2)
		if (sh_link != NULL)
 100aaa0:	e0800517 	ldw	r2,20(fp)
 100aaa4:	10000426 	beq	r2,zero,100aab8 <elf_parse_section+0xc4>
			*sh_link = shdr->sh_link;
 100aaa8:	e0bffa17 	ldw	r2,-24(fp)
 100aaac:	10c00617 	ldw	r3,24(r2)
 100aab0:	e0800517 	ldw	r2,20(fp)
 100aab4:	10c00015 	stw	r3,0(r2)
		if (sh_info != NULL)
 100aab8:	e0800617 	ldw	r2,24(fp)
 100aabc:	10000426 	beq	r2,zero,100aad0 <elf_parse_section+0xdc>
			*sh_info = shdr->sh_info;
 100aac0:	e0bffa17 	ldw	r2,-24(fp)
 100aac4:	10c00717 	ldw	r3,28(r2)
 100aac8:	e0800617 	ldw	r2,24(fp)
 100aacc:	10c00015 	stw	r3,0(r2)
		if (sh_addralign != NULL)
 100aad0:	e0800717 	ldw	r2,28(fp)
 100aad4:	10000426 	beq	r2,zero,100aae8 <elf_parse_section+0xf4>
			*sh_addralign = shdr->sh_addralign;
 100aad8:	e0bffa17 	ldw	r2,-24(fp)
 100aadc:	10c00817 	ldw	r3,32(r2)
 100aae0:	e0800717 	ldw	r2,28(fp)
 100aae4:	10c00015 	stw	r3,0(r2)
		if (sh_entsize != NULL)
 100aae8:	e0800817 	ldw	r2,32(fp)
 100aaec:	10004926 	beq	r2,zero,100ac14 <elf_parse_section+0x220>
			*sh_entsize = shdr->sh_entsize;
 100aaf0:	e0bffa17 	ldw	r2,-24(fp)
 100aaf4:	10c00917 	ldw	r3,36(r2)
 100aaf8:	e0800817 	ldw	r2,32(fp)
 100aafc:	10c00015 	stw	r3,0(r2)
		if (sh_addralign != NULL)
			*sh_addralign = shdr->sh_addralign;
		if (sh_entsize != NULL)
			*sh_entsize = shdr->sh_entsize;
	}
}
 100ab00:	00004406 	br	100ac14 <elf_parse_section+0x220>
		if (sh_addralign != NULL)
			*sh_addralign = shdr->sh_addralign;
		if (sh_entsize != NULL)
			*sh_entsize = shdr->sh_entsize;
	} else {
		Elf64_Shdr *shdr = elf_shdr;
 100ab04:	e0bffd17 	ldw	r2,-12(fp)
 100ab08:	e0bffb15 	stw	r2,-20(fp)

		if (sh_type != NULL)
 100ab0c:	e0bffe17 	ldw	r2,-8(fp)
 100ab10:	10000426 	beq	r2,zero,100ab24 <elf_parse_section+0x130>
			*sh_type = shdr->sh_type;
 100ab14:	e0bffb17 	ldw	r2,-20(fp)
 100ab18:	10c00117 	ldw	r3,4(r2)
 100ab1c:	e0bffe17 	ldw	r2,-8(fp)
 100ab20:	10c00015 	stw	r3,0(r2)
		if (sh_flags != NULL)
 100ab24:	e0bfff17 	ldw	r2,-4(fp)
 100ab28:	10000626 	beq	r2,zero,100ab44 <elf_parse_section+0x150>
			*sh_flags = shdr->sh_flags;
 100ab2c:	e13ffb17 	ldw	r4,-20(fp)
 100ab30:	20800217 	ldw	r2,8(r4)
 100ab34:	20c00317 	ldw	r3,12(r4)
 100ab38:	1007883a 	mov	r3,r2
 100ab3c:	e0bfff17 	ldw	r2,-4(fp)
 100ab40:	10c00015 	stw	r3,0(r2)
		if (sh_addr != NULL)
 100ab44:	e0800217 	ldw	r2,8(fp)
 100ab48:	10000626 	beq	r2,zero,100ab64 <elf_parse_section+0x170>
			*sh_addr = (metal_phys_addr_t)shdr->sh_addr;
 100ab4c:	e13ffb17 	ldw	r4,-20(fp)
 100ab50:	20800417 	ldw	r2,16(r4)
 100ab54:	20c00517 	ldw	r3,20(r4)
 100ab58:	1007883a 	mov	r3,r2
 100ab5c:	e0800217 	ldw	r2,8(fp)
 100ab60:	10c00015 	stw	r3,0(r2)
		if (sh_offset != NULL)
 100ab64:	e0800317 	ldw	r2,12(fp)
 100ab68:	10000626 	beq	r2,zero,100ab84 <elf_parse_section+0x190>
			*sh_offset = shdr->sh_offset;
 100ab6c:	e13ffb17 	ldw	r4,-20(fp)
 100ab70:	20800617 	ldw	r2,24(r4)
 100ab74:	20c00717 	ldw	r3,28(r4)
 100ab78:	1007883a 	mov	r3,r2
 100ab7c:	e0800317 	ldw	r2,12(fp)
 100ab80:	10c00015 	stw	r3,0(r2)
		if (sh_size != NULL)
 100ab84:	e0800417 	ldw	r2,16(fp)
 100ab88:	10000626 	beq	r2,zero,100aba4 <elf_parse_section+0x1b0>
			*sh_size = shdr->sh_size;
 100ab8c:	e13ffb17 	ldw	r4,-20(fp)
 100ab90:	20800817 	ldw	r2,32(r4)
 100ab94:	20c00917 	ldw	r3,36(r4)
 100ab98:	1007883a 	mov	r3,r2
 100ab9c:	e0800417 	ldw	r2,16(fp)
 100aba0:	10c00015 	stw	r3,0(r2)
		if (sh_link != NULL)
 100aba4:	e0800517 	ldw	r2,20(fp)
 100aba8:	10000426 	beq	r2,zero,100abbc <elf_parse_section+0x1c8>
			*sh_link = shdr->sh_link;
 100abac:	e0bffb17 	ldw	r2,-20(fp)
 100abb0:	10c00a17 	ldw	r3,40(r2)
 100abb4:	e0800517 	ldw	r2,20(fp)
 100abb8:	10c00015 	stw	r3,0(r2)
		if (sh_info != NULL)
 100abbc:	e0800617 	ldw	r2,24(fp)
 100abc0:	10000426 	beq	r2,zero,100abd4 <elf_parse_section+0x1e0>
			*sh_info = shdr->sh_info;
 100abc4:	e0bffb17 	ldw	r2,-20(fp)
 100abc8:	10c00b17 	ldw	r3,44(r2)
 100abcc:	e0800617 	ldw	r2,24(fp)
 100abd0:	10c00015 	stw	r3,0(r2)
		if (sh_addralign != NULL)
 100abd4:	e0800717 	ldw	r2,28(fp)
 100abd8:	10000626 	beq	r2,zero,100abf4 <elf_parse_section+0x200>
			*sh_addralign = shdr->sh_addralign;
 100abdc:	e13ffb17 	ldw	r4,-20(fp)
 100abe0:	20800c17 	ldw	r2,48(r4)
 100abe4:	20c00d17 	ldw	r3,52(r4)
 100abe8:	1007883a 	mov	r3,r2
 100abec:	e0800717 	ldw	r2,28(fp)
 100abf0:	10c00015 	stw	r3,0(r2)
		if (sh_entsize != NULL)
 100abf4:	e0800817 	ldw	r2,32(fp)
 100abf8:	10000626 	beq	r2,zero,100ac14 <elf_parse_section+0x220>
			*sh_entsize = shdr->sh_entsize;
 100abfc:	e13ffb17 	ldw	r4,-20(fp)
 100ac00:	20800e17 	ldw	r2,56(r4)
 100ac04:	20c00f17 	ldw	r3,60(r4)
 100ac08:	1007883a 	mov	r3,r2
 100ac0c:	e0800817 	ldw	r2,32(fp)
 100ac10:	10c00015 	stw	r3,0(r2)
	}
}
 100ac14:	0001883a 	nop
 100ac18:	e037883a 	mov	sp,fp
 100ac1c:	dfc00117 	ldw	ra,4(sp)
 100ac20:	df000017 	ldw	fp,0(sp)
 100ac24:	dec00204 	addi	sp,sp,8
 100ac28:	f800283a 	ret

0100ac2c <elf_next_load_segment>:

static const void *elf_next_load_segment(void *elf_info, int *nseg,
				   metal_phys_addr_t *da,
				   size_t *noffset, size_t *nfsize,
				   size_t *nmsize)
{
 100ac2c:	defff404 	addi	sp,sp,-48
 100ac30:	dfc00b15 	stw	ra,44(sp)
 100ac34:	df000a15 	stw	fp,40(sp)
 100ac38:	df000a04 	addi	fp,sp,40
 100ac3c:	e13ffc15 	stw	r4,-16(fp)
 100ac40:	e17ffd15 	stw	r5,-12(fp)
 100ac44:	e1bffe15 	stw	r6,-8(fp)
 100ac48:	e1ffff15 	stw	r7,-4(fp)
	const void *phdr;
	unsigned int p_type = PT_NULL;
 100ac4c:	e03ffb15 	stw	zero,-20(fp)

	if (elf_info == NULL || nseg == NULL)
 100ac50:	e0bffc17 	ldw	r2,-16(fp)
 100ac54:	10000226 	beq	r2,zero,100ac60 <elf_next_load_segment+0x34>
 100ac58:	e0bffd17 	ldw	r2,-12(fp)
 100ac5c:	10001e1e 	bne	r2,zero,100acd8 <elf_next_load_segment+0xac>
		return NULL;
 100ac60:	0005883a 	mov	r2,zero
 100ac64:	00002006 	br	100ace8 <elf_next_load_segment+0xbc>
	while(p_type != PT_LOAD) {
		phdr = elf_get_segment_from_index(elf_info, *nseg);
 100ac68:	e0bffd17 	ldw	r2,-12(fp)
 100ac6c:	10800017 	ldw	r2,0(r2)
 100ac70:	100b883a 	mov	r5,r2
 100ac74:	e13ffc17 	ldw	r4,-16(fp)
 100ac78:	100a6740 	call	100a674 <elf_get_segment_from_index>
 100ac7c:	e0bffa15 	stw	r2,-24(fp)
		if (phdr == NULL)
 100ac80:	e0bffa17 	ldw	r2,-24(fp)
 100ac84:	1000021e 	bne	r2,zero,100ac90 <elf_next_load_segment+0x64>
			return NULL;
 100ac88:	0005883a 	mov	r2,zero
 100ac8c:	00001606 	br	100ace8 <elf_next_load_segment+0xbc>
		elf_parse_segment(elf_info, phdr, &p_type, noffset,
 100ac90:	e0fffb04 	addi	r3,fp,-20
 100ac94:	e0800317 	ldw	r2,12(fp)
 100ac98:	d8800315 	stw	r2,12(sp)
 100ac9c:	e0800217 	ldw	r2,8(fp)
 100aca0:	d8800215 	stw	r2,8(sp)
 100aca4:	d8000115 	stw	zero,4(sp)
 100aca8:	e0bffe17 	ldw	r2,-8(fp)
 100acac:	d8800015 	stw	r2,0(sp)
 100acb0:	e1ffff17 	ldw	r7,-4(fp)
 100acb4:	180d883a 	mov	r6,r3
 100acb8:	e17ffa17 	ldw	r5,-24(fp)
 100acbc:	e13ffc17 	ldw	r4,-16(fp)
 100acc0:	100a4d40 	call	100a4d4 <elf_parse_segment>
				  da, NULL, nfsize, nmsize);
		*nseg = *nseg + 1;
 100acc4:	e0bffd17 	ldw	r2,-12(fp)
 100acc8:	10800017 	ldw	r2,0(r2)
 100accc:	10c00044 	addi	r3,r2,1
 100acd0:	e0bffd17 	ldw	r2,-12(fp)
 100acd4:	10c00015 	stw	r3,0(r2)
	const void *phdr;
	unsigned int p_type = PT_NULL;

	if (elf_info == NULL || nseg == NULL)
		return NULL;
	while(p_type != PT_LOAD) {
 100acd8:	e0bffb17 	ldw	r2,-20(fp)
 100acdc:	10800058 	cmpnei	r2,r2,1
 100ace0:	103fe11e 	bne	r2,zero,100ac68 <__alt_data_end+0xff00ac68>
			return NULL;
		elf_parse_segment(elf_info, phdr, &p_type, noffset,
				  da, NULL, nfsize, nmsize);
		*nseg = *nseg + 1;
	}
	return phdr;
 100ace4:	e0bffa17 	ldw	r2,-24(fp)
}
 100ace8:	e037883a 	mov	sp,fp
 100acec:	dfc00117 	ldw	ra,4(sp)
 100acf0:	df000017 	ldw	fp,0(sp)
 100acf4:	dec00204 	addi	sp,sp,8
 100acf8:	f800283a 	ret

0100acfc <elf_info_size>:

static size_t elf_info_size(const void *img_data)
{
 100acfc:	defffd04 	addi	sp,sp,-12
 100ad00:	dfc00215 	stw	ra,8(sp)
 100ad04:	df000115 	stw	fp,4(sp)
 100ad08:	df000104 	addi	fp,sp,4
 100ad0c:	e13fff15 	stw	r4,-4(fp)
	if (elf_is_64(img_data) == 0)
 100ad10:	e13fff17 	ldw	r4,-4(fp)
 100ad14:	100a0400 	call	100a040 <elf_is_64>
 100ad18:	1000021e 	bne	r2,zero,100ad24 <elf_info_size+0x28>
		return sizeof(struct elf32_info);
 100ad1c:	00801104 	movi	r2,68
 100ad20:	00000106 	br	100ad28 <elf_info_size+0x2c>
	else
		return sizeof(struct elf64_info);
 100ad24:	00801404 	movi	r2,80
}
 100ad28:	e037883a 	mov	sp,fp
 100ad2c:	dfc00117 	ldw	ra,4(sp)
 100ad30:	df000017 	ldw	fp,0(sp)
 100ad34:	dec00204 	addi	sp,sp,8
 100ad38:	f800283a 	ret

0100ad3c <elf_identify>:

int elf_identify(const void *img_data, size_t len)
{
 100ad3c:	defffc04 	addi	sp,sp,-16
 100ad40:	dfc00315 	stw	ra,12(sp)
 100ad44:	df000215 	stw	fp,8(sp)
 100ad48:	df000204 	addi	fp,sp,8
 100ad4c:	e13ffe15 	stw	r4,-8(fp)
 100ad50:	e17fff15 	stw	r5,-4(fp)
	if (len < SELFMAG || img_data == NULL)
 100ad54:	e0bfff17 	ldw	r2,-4(fp)
 100ad58:	10800130 	cmpltui	r2,r2,4
 100ad5c:	1000021e 	bne	r2,zero,100ad68 <elf_identify+0x2c>
 100ad60:	e0bffe17 	ldw	r2,-8(fp)
 100ad64:	1000021e 	bne	r2,zero,100ad70 <elf_identify+0x34>
		return -RPROC_EINVAL;
 100ad68:	00bfff84 	movi	r2,-2
 100ad6c:	00000906 	br	100ad94 <elf_identify+0x58>
	if (memcmp(img_data, ELFMAG, SELFMAG) != 0)
 100ad70:	01800104 	movi	r6,4
 100ad74:	014040f4 	movhi	r5,259
 100ad78:	29652f04 	addi	r5,r5,-27460
 100ad7c:	e13ffe17 	ldw	r4,-8(fp)
 100ad80:	10158780 	call	1015878 <memcmp>
 100ad84:	10000226 	beq	r2,zero,100ad90 <elf_identify+0x54>
		return -RPROC_EINVAL;
 100ad88:	00bfff84 	movi	r2,-2
 100ad8c:	00000106 	br	100ad94 <elf_identify+0x58>
	else
		return 0;
 100ad90:	0005883a 	mov	r2,zero
}
 100ad94:	e037883a 	mov	sp,fp
 100ad98:	dfc00117 	ldw	ra,4(sp)
 100ad9c:	df000017 	ldw	fp,0(sp)
 100ada0:	dec00204 	addi	sp,sp,8
 100ada4:	f800283a 	ret

0100ada8 <elf_load_header>:

int elf_load_header(const void *img_data, size_t offset, size_t len,
		    void **img_info, int last_load_state,
		    size_t *noffset, size_t *nlen)
{
 100ada8:	deffe204 	addi	sp,sp,-120
 100adac:	dfc01d15 	stw	ra,116(sp)
 100adb0:	df001c15 	stw	fp,112(sp)
 100adb4:	dc001b15 	stw	r16,108(sp)
 100adb8:	df001c04 	addi	fp,sp,112
 100adbc:	e13ffb15 	stw	r4,-20(fp)
 100adc0:	e17ffc15 	stw	r5,-16(fp)
 100adc4:	e1bffd15 	stw	r6,-12(fp)
 100adc8:	e1fffe15 	stw	r7,-8(fp)
	int *load_state;

	metal_assert(noffset != NULL);
 100adcc:	e0800317 	ldw	r2,12(fp)
 100add0:	1000081e 	bne	r2,zero,100adf4 <elf_load_header+0x4c>
 100add4:	01c040f4 	movhi	r7,259
 100add8:	39e53104 	addi	r7,r7,-27452
 100addc:	018040f4 	movhi	r6,259
 100ade0:	31a5a404 	addi	r6,r6,-26992
 100ade4:	014064c4 	movi	r5,403
 100ade8:	010040f4 	movhi	r4,259
 100adec:	21253704 	addi	r4,r4,-27428
 100adf0:	10157a00 	call	10157a0 <__assert_func>
	metal_assert(nlen != NULL);
 100adf4:	e0800417 	ldw	r2,16(fp)
 100adf8:	1000081e 	bne	r2,zero,100ae1c <elf_load_header+0x74>
 100adfc:	01c040f4 	movhi	r7,259
 100ae00:	39e54004 	addi	r7,r7,-27392
 100ae04:	018040f4 	movhi	r6,259
 100ae08:	31a5a404 	addi	r6,r6,-26992
 100ae0c:	01406504 	movi	r5,404
 100ae10:	010040f4 	movhi	r4,259
 100ae14:	21253704 	addi	r4,r4,-27428
 100ae18:	10157a00 	call	10157a0 <__assert_func>
	/* Get ELF header */
	if (last_load_state == ELF_STATE_INIT) {
 100ae1c:	e0800217 	ldw	r2,8(fp)
 100ae20:	1000431e 	bne	r2,zero,100af30 <elf_load_header+0x188>
		size_t tmpsize;

		metal_log(METAL_LOG_DEBUG, "Loading ELF headering\r\n");
 100ae24:	008060f4 	movhi	r2,387
 100ae28:	10baf104 	addi	r2,r2,-5180
 100ae2c:	10800017 	ldw	r2,0(r2)
 100ae30:	108001f0 	cmpltui	r2,r2,7
 100ae34:	10000b1e 	bne	r2,zero,100ae64 <elf_load_header+0xbc>
 100ae38:	008060f4 	movhi	r2,387
 100ae3c:	10baf104 	addi	r2,r2,-5180
 100ae40:	10800117 	ldw	r2,4(r2)
 100ae44:	10000726 	beq	r2,zero,100ae64 <elf_load_header+0xbc>
 100ae48:	008060f4 	movhi	r2,387
 100ae4c:	10baf104 	addi	r2,r2,-5180
 100ae50:	10800117 	ldw	r2,4(r2)
 100ae54:	014040f4 	movhi	r5,259
 100ae58:	29654504 	addi	r5,r5,-27372
 100ae5c:	010001c4 	movi	r4,7
 100ae60:	103ee83a 	callr	r2
		tmpsize = elf_ehdr_size(img_data);
 100ae64:	e13ffb17 	ldw	r4,-20(fp)
 100ae68:	100a08c0 	call	100a08c <elf_ehdr_size>
 100ae6c:	e0bfeb15 	stw	r2,-84(fp)
		if (len < tmpsize) {
 100ae70:	e0fffd17 	ldw	r3,-12(fp)
 100ae74:	e0bfeb17 	ldw	r2,-84(fp)
 100ae78:	1880072e 	bgeu	r3,r2,100ae98 <elf_load_header+0xf0>
			*noffset = 0;
 100ae7c:	e0800317 	ldw	r2,12(fp)
 100ae80:	10000015 	stw	zero,0(r2)
			*nlen = tmpsize;
 100ae84:	e0800417 	ldw	r2,16(fp)
 100ae88:	e0ffeb17 	ldw	r3,-84(fp)
 100ae8c:	10c00015 	stw	r3,0(r2)
			return ELF_STATE_INIT;
 100ae90:	0005883a 	mov	r2,zero
 100ae94:	00018906 	br	100b4bc <elf_load_header+0x714>
		} else {
			size_t infosize = elf_info_size(img_data);
 100ae98:	e13ffb17 	ldw	r4,-20(fp)
 100ae9c:	100acfc0 	call	100acfc <elf_info_size>
 100aea0:	e0bfec15 	stw	r2,-80(fp)

			if (*img_info == NULL) {
 100aea4:	e0bffe17 	ldw	r2,-8(fp)
 100aea8:	10800017 	ldw	r2,0(r2)
 100aeac:	1000101e 	bne	r2,zero,100aef0 <elf_load_header+0x148>
				*img_info = metal_allocate_memory(infosize);
 100aeb0:	e13fec17 	ldw	r4,-80(fp)
 100aeb4:	1009fdc0 	call	1009fdc <metal_allocate_memory>
 100aeb8:	1007883a 	mov	r3,r2
 100aebc:	e0bffe17 	ldw	r2,-8(fp)
 100aec0:	10c00015 	stw	r3,0(r2)
				if (*img_info == NULL)
 100aec4:	e0bffe17 	ldw	r2,-8(fp)
 100aec8:	10800017 	ldw	r2,0(r2)
 100aecc:	1000021e 	bne	r2,zero,100aed8 <elf_load_header+0x130>
					return -RPROC_ENOMEM;
 100aed0:	00bfffc4 	movi	r2,-1
 100aed4:	00017906 	br	100b4bc <elf_load_header+0x714>
				memset(*img_info, 0, infosize);
 100aed8:	e0bffe17 	ldw	r2,-8(fp)
 100aedc:	10800017 	ldw	r2,0(r2)
 100aee0:	e1bfec17 	ldw	r6,-80(fp)
 100aee4:	000b883a 	mov	r5,zero
 100aee8:	1009883a 	mov	r4,r2
 100aeec:	1015a3c0 	call	1015a3c <memset>
			}
			memcpy(*img_info, img_data, tmpsize);
 100aef0:	e0bffe17 	ldw	r2,-8(fp)
 100aef4:	10800017 	ldw	r2,0(r2)
 100aef8:	e1bfeb17 	ldw	r6,-84(fp)
 100aefc:	e17ffb17 	ldw	r5,-20(fp)
 100af00:	1009883a 	mov	r4,r2
 100af04:	10158f40 	call	10158f4 <memcpy>
			load_state = elf_load_state(*img_info);
 100af08:	e0bffe17 	ldw	r2,-8(fp)
 100af0c:	10800017 	ldw	r2,0(r2)
 100af10:	1009883a 	mov	r4,r2
 100af14:	100a47c0 	call	100a47c <elf_load_state>
 100af18:	e0bfed15 	stw	r2,-76(fp)
			*load_state = ELF_STATE_WAIT_FOR_PHDRS;
 100af1c:	e0bfed17 	ldw	r2,-76(fp)
 100af20:	00c04004 	movi	r3,256
 100af24:	10c00015 	stw	r3,0(r2)
			last_load_state = ELF_STATE_WAIT_FOR_PHDRS;
 100af28:	00804004 	movi	r2,256
 100af2c:	e0800215 	stw	r2,8(fp)
		}
	}
	metal_assert(*img_info != NULL);
 100af30:	e0bffe17 	ldw	r2,-8(fp)
 100af34:	10800017 	ldw	r2,0(r2)
 100af38:	1000081e 	bne	r2,zero,100af5c <elf_load_header+0x1b4>
 100af3c:	01c040f4 	movhi	r7,259
 100af40:	39e54b04 	addi	r7,r7,-27348
 100af44:	018040f4 	movhi	r6,259
 100af48:	31a5a404 	addi	r6,r6,-26992
 100af4c:	01406b84 	movi	r5,430
 100af50:	010040f4 	movhi	r4,259
 100af54:	21253704 	addi	r4,r4,-27428
 100af58:	10157a00 	call	10157a0 <__assert_func>
	load_state = elf_load_state(*img_info);
 100af5c:	e0bffe17 	ldw	r2,-8(fp)
 100af60:	10800017 	ldw	r2,0(r2)
 100af64:	1009883a 	mov	r4,r2
 100af68:	100a47c0 	call	100a47c <elf_load_state>
 100af6c:	e0bfed15 	stw	r2,-76(fp)
	if (last_load_state != *load_state)
 100af70:	e0bfed17 	ldw	r2,-76(fp)
 100af74:	10c00017 	ldw	r3,0(r2)
 100af78:	e0800217 	ldw	r2,8(fp)
 100af7c:	18800226 	beq	r3,r2,100af88 <elf_load_header+0x1e0>
		return -RPROC_EINVAL;
 100af80:	00bfff84 	movi	r2,-2
 100af84:	00014d06 	br	100b4bc <elf_load_header+0x714>
	/* Get ELF program headers */
	if (*load_state == ELF_STATE_WAIT_FOR_PHDRS) {
 100af88:	e0bfed17 	ldw	r2,-76(fp)
 100af8c:	10800017 	ldw	r2,0(r2)
 100af90:	10804018 	cmpnei	r2,r2,256
 100af94:	1000541e 	bne	r2,zero,100b0e8 <elf_load_header+0x340>
		size_t phdrs_size;
		size_t phdrs_offset;
		void **phdrs;
		const void *img_phdrs;

		metal_log(METAL_LOG_DEBUG, "Loading ELF program header.\r\n");
 100af98:	008060f4 	movhi	r2,387
 100af9c:	10baf104 	addi	r2,r2,-5180
 100afa0:	10800017 	ldw	r2,0(r2)
 100afa4:	108001f0 	cmpltui	r2,r2,7
 100afa8:	10000b1e 	bne	r2,zero,100afd8 <elf_load_header+0x230>
 100afac:	008060f4 	movhi	r2,387
 100afb0:	10baf104 	addi	r2,r2,-5180
 100afb4:	10800117 	ldw	r2,4(r2)
 100afb8:	10000726 	beq	r2,zero,100afd8 <elf_load_header+0x230>
 100afbc:	008060f4 	movhi	r2,387
 100afc0:	10baf104 	addi	r2,r2,-5180
 100afc4:	10800117 	ldw	r2,4(r2)
 100afc8:	014040f4 	movhi	r5,259
 100afcc:	29655204 	addi	r5,r5,-27320
 100afd0:	010001c4 	movi	r4,7
 100afd4:	103ee83a 	callr	r2
		phdrs_offset = elf_phoff(*img_info);
 100afd8:	e0bffe17 	ldw	r2,-8(fp)
 100afdc:	10800017 	ldw	r2,0(r2)
 100afe0:	1009883a 	mov	r4,r2
 100afe4:	100a0dc0 	call	100a0dc <elf_phoff>
 100afe8:	e0bfee15 	stw	r2,-72(fp)
		phdrs_size = elf_phnum(*img_info) * elf_phentsize(*img_info);
 100afec:	e0bffe17 	ldw	r2,-8(fp)
 100aff0:	10800017 	ldw	r2,0(r2)
 100aff4:	1009883a 	mov	r4,r2
 100aff8:	100a1980 	call	100a198 <elf_phnum>
 100affc:	1021883a 	mov	r16,r2
 100b000:	e0bffe17 	ldw	r2,-8(fp)
 100b004:	10800017 	ldw	r2,0(r2)
 100b008:	1009883a 	mov	r4,r2
 100b00c:	100a1380 	call	100a138 <elf_phentsize>
 100b010:	8085383a 	mul	r2,r16,r2
 100b014:	e0bfef15 	stw	r2,-68(fp)
		if (offset > phdrs_offset ||
 100b018:	e0bffc17 	ldw	r2,-16(fp)
 100b01c:	e0ffee17 	ldw	r3,-72(fp)
 100b020:	18800736 	bltu	r3,r2,100b040 <elf_load_header+0x298>
		    offset + len < phdrs_offset + phdrs_size) {
 100b024:	e0fffc17 	ldw	r3,-16(fp)
 100b028:	e0bffd17 	ldw	r2,-12(fp)
 100b02c:	1887883a 	add	r3,r3,r2
 100b030:	e13fee17 	ldw	r4,-72(fp)
 100b034:	e0bfef17 	ldw	r2,-68(fp)
 100b038:	2085883a 	add	r2,r4,r2
		const void *img_phdrs;

		metal_log(METAL_LOG_DEBUG, "Loading ELF program header.\r\n");
		phdrs_offset = elf_phoff(*img_info);
		phdrs_size = elf_phnum(*img_info) * elf_phentsize(*img_info);
		if (offset > phdrs_offset ||
 100b03c:	1880092e 	bgeu	r3,r2,100b064 <elf_load_header+0x2bc>
		    offset + len < phdrs_offset + phdrs_size) {
			*noffset = phdrs_offset;
 100b040:	e0800317 	ldw	r2,12(fp)
 100b044:	e0ffee17 	ldw	r3,-72(fp)
 100b048:	10c00015 	stw	r3,0(r2)
			*nlen = phdrs_size;
 100b04c:	e0800417 	ldw	r2,16(fp)
 100b050:	e0ffef17 	ldw	r3,-68(fp)
 100b054:	10c00015 	stw	r3,0(r2)
			return *load_state;
 100b058:	e0bfed17 	ldw	r2,-76(fp)
 100b05c:	10800017 	ldw	r2,0(r2)
 100b060:	00011606 	br	100b4bc <elf_load_header+0x714>
		}
		/* calculate the programs headers offset to the image_data */
		phdrs_offset -= offset;
 100b064:	e0ffee17 	ldw	r3,-72(fp)
 100b068:	e0bffc17 	ldw	r2,-16(fp)
 100b06c:	1885c83a 	sub	r2,r3,r2
 100b070:	e0bfee15 	stw	r2,-72(fp)
		img_phdrs = (const char *)img_data + phdrs_offset;
 100b074:	e0fffb17 	ldw	r3,-20(fp)
 100b078:	e0bfee17 	ldw	r2,-72(fp)
 100b07c:	1885883a 	add	r2,r3,r2
 100b080:	e0bff015 	stw	r2,-64(fp)
		phdrs = elf_phtable_ptr(*img_info);
 100b084:	e0bffe17 	ldw	r2,-8(fp)
 100b088:	10800017 	ldw	r2,0(r2)
 100b08c:	1009883a 	mov	r4,r2
 100b090:	100a3740 	call	100a374 <elf_phtable_ptr>
 100b094:	e0bff115 	stw	r2,-60(fp)
		*phdrs = metal_allocate_memory(phdrs_size);
 100b098:	e13fef17 	ldw	r4,-68(fp)
 100b09c:	1009fdc0 	call	1009fdc <metal_allocate_memory>
 100b0a0:	1007883a 	mov	r3,r2
 100b0a4:	e0bff117 	ldw	r2,-60(fp)
 100b0a8:	10c00015 	stw	r3,0(r2)
		if (*phdrs == NULL)
 100b0ac:	e0bff117 	ldw	r2,-60(fp)
 100b0b0:	10800017 	ldw	r2,0(r2)
 100b0b4:	1000021e 	bne	r2,zero,100b0c0 <elf_load_header+0x318>
			return -RPROC_ENOMEM;
 100b0b8:	00bfffc4 	movi	r2,-1
 100b0bc:	0000ff06 	br	100b4bc <elf_load_header+0x714>
		memcpy(*phdrs, img_phdrs, phdrs_size);
 100b0c0:	e0bff117 	ldw	r2,-60(fp)
 100b0c4:	10800017 	ldw	r2,0(r2)
 100b0c8:	e1bfef17 	ldw	r6,-68(fp)
 100b0cc:	e17ff017 	ldw	r5,-64(fp)
 100b0d0:	1009883a 	mov	r4,r2
 100b0d4:	10158f40 	call	10158f4 <memcpy>
		*load_state = ELF_STATE_WAIT_FOR_SHDRS |
 100b0d8:	e0ffed17 	ldw	r3,-76(fp)
 100b0dc:	00800074 	movhi	r2,1
 100b0e0:	10808004 	addi	r2,r2,512
 100b0e4:	18800015 	stw	r2,0(r3)
			       RPROC_LOADER_READY_TO_LOAD;
	}
	/* Get ELF Section Headers */
	if ((*load_state & ELF_STATE_WAIT_FOR_SHDRS) != 0) {
 100b0e8:	e0bfed17 	ldw	r2,-76(fp)
 100b0ec:	10800017 	ldw	r2,0(r2)
 100b0f0:	1080800c 	andi	r2,r2,512
 100b0f4:	10007e26 	beq	r2,zero,100b2f0 <elf_load_header+0x548>
		size_t shdrs_size;
		size_t shdrs_offset;
		void **shdrs;
		const void *img_shdrs;

		metal_log(METAL_LOG_DEBUG, "Loading ELF section header.\r\n");
 100b0f8:	008060f4 	movhi	r2,387
 100b0fc:	10baf104 	addi	r2,r2,-5180
 100b100:	10800017 	ldw	r2,0(r2)
 100b104:	108001f0 	cmpltui	r2,r2,7
 100b108:	10000b1e 	bne	r2,zero,100b138 <elf_load_header+0x390>
 100b10c:	008060f4 	movhi	r2,387
 100b110:	10baf104 	addi	r2,r2,-5180
 100b114:	10800117 	ldw	r2,4(r2)
 100b118:	10000726 	beq	r2,zero,100b138 <elf_load_header+0x390>
 100b11c:	008060f4 	movhi	r2,387
 100b120:	10baf104 	addi	r2,r2,-5180
 100b124:	10800117 	ldw	r2,4(r2)
 100b128:	014040f4 	movhi	r5,259
 100b12c:	29655a04 	addi	r5,r5,-27288
 100b130:	010001c4 	movi	r4,7
 100b134:	103ee83a 	callr	r2
		shdrs_offset = elf_shoff(*img_info);
 100b138:	e0bffe17 	ldw	r2,-8(fp)
 100b13c:	10800017 	ldw	r2,0(r2)
 100b140:	1009883a 	mov	r4,r2
 100b144:	100a1f80 	call	100a1f8 <elf_shoff>
 100b148:	e0bff215 	stw	r2,-56(fp)
		if (elf_shnum(*img_info) == 0) {
 100b14c:	e0bffe17 	ldw	r2,-8(fp)
 100b150:	10800017 	ldw	r2,0(r2)
 100b154:	1009883a 	mov	r4,r2
 100b158:	100a2b40 	call	100a2b4 <elf_shnum>
 100b15c:	10000f1e 	bne	r2,zero,100b19c <elf_load_header+0x3f4>
			*load_state = (*load_state & (~ELF_STATE_MASK)) |
 100b160:	e0bfed17 	ldw	r2,-76(fp)
 100b164:	10800017 	ldw	r2,0(r2)
 100b168:	1007883a 	mov	r3,r2
 100b16c:	00bffff4 	movhi	r2,65535
 100b170:	10803fc4 	addi	r2,r2,255
 100b174:	1884703a 	and	r2,r3,r2
 100b178:	10820014 	ori	r2,r2,2048
 100b17c:	1007883a 	mov	r3,r2
 100b180:	e0bfed17 	ldw	r2,-76(fp)
 100b184:	10c00015 	stw	r3,0(r2)
				       ELF_STATE_HDRS_COMPLETE;
			*nlen = 0;
 100b188:	e0800417 	ldw	r2,16(fp)
 100b18c:	10000015 	stw	zero,0(r2)
			return *load_state;
 100b190:	e0bfed17 	ldw	r2,-76(fp)
 100b194:	10800017 	ldw	r2,0(r2)
 100b198:	0000c806 	br	100b4bc <elf_load_header+0x714>
		}
		shdrs_size = elf_shnum(*img_info) * elf_shentsize(*img_info);
 100b19c:	e0bffe17 	ldw	r2,-8(fp)
 100b1a0:	10800017 	ldw	r2,0(r2)
 100b1a4:	1009883a 	mov	r4,r2
 100b1a8:	100a2b40 	call	100a2b4 <elf_shnum>
 100b1ac:	1021883a 	mov	r16,r2
 100b1b0:	e0bffe17 	ldw	r2,-8(fp)
 100b1b4:	10800017 	ldw	r2,0(r2)
 100b1b8:	1009883a 	mov	r4,r2
 100b1bc:	100a2540 	call	100a254 <elf_shentsize>
 100b1c0:	8085383a 	mul	r2,r16,r2
 100b1c4:	e0bff315 	stw	r2,-52(fp)
		if (offset > shdrs_offset ||
 100b1c8:	e0bffc17 	ldw	r2,-16(fp)
 100b1cc:	e0fff217 	ldw	r3,-56(fp)
 100b1d0:	18800736 	bltu	r3,r2,100b1f0 <elf_load_header+0x448>
		    offset + len < shdrs_offset + shdrs_size) {
 100b1d4:	e0fffc17 	ldw	r3,-16(fp)
 100b1d8:	e0bffd17 	ldw	r2,-12(fp)
 100b1dc:	1887883a 	add	r3,r3,r2
 100b1e0:	e13ff217 	ldw	r4,-56(fp)
 100b1e4:	e0bff317 	ldw	r2,-52(fp)
 100b1e8:	2085883a 	add	r2,r4,r2
				       ELF_STATE_HDRS_COMPLETE;
			*nlen = 0;
			return *load_state;
		}
		shdrs_size = elf_shnum(*img_info) * elf_shentsize(*img_info);
		if (offset > shdrs_offset ||
 100b1ec:	1880092e 	bgeu	r3,r2,100b214 <elf_load_header+0x46c>
		    offset + len < shdrs_offset + shdrs_size) {
			*noffset = shdrs_offset;
 100b1f0:	e0800317 	ldw	r2,12(fp)
 100b1f4:	e0fff217 	ldw	r3,-56(fp)
 100b1f8:	10c00015 	stw	r3,0(r2)
			*nlen = shdrs_size;
 100b1fc:	e0800417 	ldw	r2,16(fp)
 100b200:	e0fff317 	ldw	r3,-52(fp)
 100b204:	10c00015 	stw	r3,0(r2)
			return *load_state;
 100b208:	e0bfed17 	ldw	r2,-76(fp)
 100b20c:	10800017 	ldw	r2,0(r2)
 100b210:	0000aa06 	br	100b4bc <elf_load_header+0x714>
		}
		/* calculate the sections headers offset to the image_data */
		shdrs_offset -= offset;
 100b214:	e0fff217 	ldw	r3,-56(fp)
 100b218:	e0bffc17 	ldw	r2,-16(fp)
 100b21c:	1885c83a 	sub	r2,r3,r2
 100b220:	e0bff215 	stw	r2,-56(fp)
		img_shdrs = (const char *)img_data + shdrs_offset;
 100b224:	e0fffb17 	ldw	r3,-20(fp)
 100b228:	e0bff217 	ldw	r2,-56(fp)
 100b22c:	1885883a 	add	r2,r3,r2
 100b230:	e0bff415 	stw	r2,-48(fp)
		shdrs = elf_shtable_ptr(*img_info);
 100b234:	e0bffe17 	ldw	r2,-8(fp)
 100b238:	10800017 	ldw	r2,0(r2)
 100b23c:	1009883a 	mov	r4,r2
 100b240:	100a3cc0 	call	100a3cc <elf_shtable_ptr>
 100b244:	e0bff515 	stw	r2,-44(fp)
		*shdrs = metal_allocate_memory(shdrs_size);
 100b248:	e13ff317 	ldw	r4,-52(fp)
 100b24c:	1009fdc0 	call	1009fdc <metal_allocate_memory>
 100b250:	1007883a 	mov	r3,r2
 100b254:	e0bff517 	ldw	r2,-44(fp)
 100b258:	10c00015 	stw	r3,0(r2)
		if (*shdrs == NULL)
 100b25c:	e0bff517 	ldw	r2,-44(fp)
 100b260:	10800017 	ldw	r2,0(r2)
 100b264:	1000021e 	bne	r2,zero,100b270 <elf_load_header+0x4c8>
			return -RPROC_ENOMEM;
 100b268:	00bfffc4 	movi	r2,-1
 100b26c:	00009306 	br	100b4bc <elf_load_header+0x714>
		memcpy(*shdrs, img_shdrs, shdrs_size);
 100b270:	e0bff517 	ldw	r2,-44(fp)
 100b274:	10800017 	ldw	r2,0(r2)
 100b278:	e1bff317 	ldw	r6,-52(fp)
 100b27c:	e17ff417 	ldw	r5,-48(fp)
 100b280:	1009883a 	mov	r4,r2
 100b284:	10158f40 	call	10158f4 <memcpy>
		*load_state = (*load_state & (~ELF_STATE_MASK)) |
 100b288:	e0bfed17 	ldw	r2,-76(fp)
 100b28c:	10800017 	ldw	r2,0(r2)
 100b290:	1007883a 	mov	r3,r2
 100b294:	00bffff4 	movhi	r2,65535
 100b298:	10803fc4 	addi	r2,r2,255
 100b29c:	1884703a 	and	r2,r3,r2
 100b2a0:	10810014 	ori	r2,r2,1024
 100b2a4:	1007883a 	mov	r3,r2
 100b2a8:	e0bfed17 	ldw	r2,-76(fp)
 100b2ac:	10c00015 	stw	r3,0(r2)
			       ELF_STATE_WAIT_FOR_SHSTRTAB;
		metal_log(METAL_LOG_DEBUG,
 100b2b0:	008060f4 	movhi	r2,387
 100b2b4:	10baf104 	addi	r2,r2,-5180
 100b2b8:	10800017 	ldw	r2,0(r2)
 100b2bc:	108001f0 	cmpltui	r2,r2,7
 100b2c0:	10000b1e 	bne	r2,zero,100b2f0 <elf_load_header+0x548>
 100b2c4:	008060f4 	movhi	r2,387
 100b2c8:	10baf104 	addi	r2,r2,-5180
 100b2cc:	10800117 	ldw	r2,4(r2)
 100b2d0:	10000726 	beq	r2,zero,100b2f0 <elf_load_header+0x548>
 100b2d4:	008060f4 	movhi	r2,387
 100b2d8:	10baf104 	addi	r2,r2,-5180
 100b2dc:	10800117 	ldw	r2,4(r2)
 100b2e0:	014040f4 	movhi	r5,259
 100b2e4:	29656204 	addi	r5,r5,-27256
 100b2e8:	010001c4 	movi	r4,7
 100b2ec:	103ee83a 	callr	r2
			  "Loading ELF section header complete.\r\n");
	}
	/* Get ELF SHSTRTAB section */
	if ((*load_state & ELF_STATE_WAIT_FOR_SHSTRTAB) != 0) {
 100b2f0:	e0bfed17 	ldw	r2,-76(fp)
 100b2f4:	10800017 	ldw	r2,0(r2)
 100b2f8:	1081000c 	andi	r2,r2,1024
 100b2fc:	10006e26 	beq	r2,zero,100b4b8 <elf_load_header+0x710>
		size_t shstrtab_offset;
		int shstrndx;
		void *shdr;
		void **shstrtab;

		metal_log(METAL_LOG_DEBUG, "Loading ELF shstrtab.\r\n");
 100b300:	008060f4 	movhi	r2,387
 100b304:	10baf104 	addi	r2,r2,-5180
 100b308:	10800017 	ldw	r2,0(r2)
 100b30c:	108001f0 	cmpltui	r2,r2,7
 100b310:	10000b1e 	bne	r2,zero,100b340 <elf_load_header+0x598>
 100b314:	008060f4 	movhi	r2,387
 100b318:	10baf104 	addi	r2,r2,-5180
 100b31c:	10800117 	ldw	r2,4(r2)
 100b320:	10000726 	beq	r2,zero,100b340 <elf_load_header+0x598>
 100b324:	008060f4 	movhi	r2,387
 100b328:	10baf104 	addi	r2,r2,-5180
 100b32c:	10800117 	ldw	r2,4(r2)
 100b330:	014040f4 	movhi	r5,259
 100b334:	29656c04 	addi	r5,r5,-27216
 100b338:	010001c4 	movi	r4,7
 100b33c:	103ee83a 	callr	r2
		shstrndx = elf_shstrndx(*img_info);
 100b340:	e0bffe17 	ldw	r2,-8(fp)
 100b344:	10800017 	ldw	r2,0(r2)
 100b348:	1009883a 	mov	r4,r2
 100b34c:	100a3140 	call	100a314 <elf_shstrndx>
 100b350:	e0bff615 	stw	r2,-40(fp)
		shdr = elf_get_section_from_index(*img_info, shstrndx);
 100b354:	e0bffe17 	ldw	r2,-8(fp)
 100b358:	10800017 	ldw	r2,0(r2)
 100b35c:	e17ff617 	ldw	r5,-40(fp)
 100b360:	1009883a 	mov	r4,r2
 100b364:	100a8f00 	call	100a8f0 <elf_get_section_from_index>
 100b368:	e0bff715 	stw	r2,-36(fp)
		if (shdr == NULL)
 100b36c:	e0bff717 	ldw	r2,-36(fp)
 100b370:	1000021e 	bne	r2,zero,100b37c <elf_load_header+0x5d4>
			return -RPROC_EINVAL;
 100b374:	00bfff84 	movi	r2,-2
 100b378:	00005006 	br	100b4bc <elf_load_header+0x714>
		elf_parse_section(*img_info, shdr, NULL, NULL,
 100b37c:	e0bffe17 	ldw	r2,-8(fp)
 100b380:	10c00017 	ldw	r3,0(r2)
 100b384:	d8000615 	stw	zero,24(sp)
 100b388:	d8000515 	stw	zero,20(sp)
 100b38c:	d8000415 	stw	zero,16(sp)
 100b390:	d8000315 	stw	zero,12(sp)
 100b394:	e0bff904 	addi	r2,fp,-28
 100b398:	d8800215 	stw	r2,8(sp)
 100b39c:	e0bffa04 	addi	r2,fp,-24
 100b3a0:	d8800115 	stw	r2,4(sp)
 100b3a4:	d8000015 	stw	zero,0(sp)
 100b3a8:	000f883a 	mov	r7,zero
 100b3ac:	000d883a 	mov	r6,zero
 100b3b0:	e17ff717 	ldw	r5,-36(fp)
 100b3b4:	1809883a 	mov	r4,r3
 100b3b8:	100a9f40 	call	100a9f4 <elf_parse_section>
				  NULL, &shstrtab_offset,
				  &shstrtab_size, NULL, NULL,
				  NULL, NULL);
		if (offset > shstrtab_offset ||
 100b3bc:	e0fffa17 	ldw	r3,-24(fp)
 100b3c0:	e0bffc17 	ldw	r2,-16(fp)
 100b3c4:	18800736 	bltu	r3,r2,100b3e4 <elf_load_header+0x63c>
		    offset + len < shstrtab_offset + shstrtab_size) {
 100b3c8:	e0fffc17 	ldw	r3,-16(fp)
 100b3cc:	e0bffd17 	ldw	r2,-12(fp)
 100b3d0:	1887883a 	add	r3,r3,r2
 100b3d4:	e13ffa17 	ldw	r4,-24(fp)
 100b3d8:	e0bff917 	ldw	r2,-28(fp)
 100b3dc:	2085883a 	add	r2,r4,r2
			return -RPROC_EINVAL;
		elf_parse_section(*img_info, shdr, NULL, NULL,
				  NULL, &shstrtab_offset,
				  &shstrtab_size, NULL, NULL,
				  NULL, NULL);
		if (offset > shstrtab_offset ||
 100b3e0:	1880092e 	bgeu	r3,r2,100b408 <elf_load_header+0x660>
		    offset + len < shstrtab_offset + shstrtab_size) {
			*noffset = shstrtab_offset;
 100b3e4:	e0fffa17 	ldw	r3,-24(fp)
 100b3e8:	e0800317 	ldw	r2,12(fp)
 100b3ec:	10c00015 	stw	r3,0(r2)
			*nlen = shstrtab_size;
 100b3f0:	e0fff917 	ldw	r3,-28(fp)
 100b3f4:	e0800417 	ldw	r2,16(fp)
 100b3f8:	10c00015 	stw	r3,0(r2)
			return *load_state;
 100b3fc:	e0bfed17 	ldw	r2,-76(fp)
 100b400:	10800017 	ldw	r2,0(r2)
 100b404:	00002d06 	br	100b4bc <elf_load_header+0x714>
		}
		/* Calculate shstrtab section offset to the input image data */
		shstrtab_offset -= offset;
 100b408:	e0fffa17 	ldw	r3,-24(fp)
 100b40c:	e0bffc17 	ldw	r2,-16(fp)
 100b410:	1885c83a 	sub	r2,r3,r2
 100b414:	e0bffa15 	stw	r2,-24(fp)
		shstrtab = elf_shstrtab_ptr(*img_info);
 100b418:	e0bffe17 	ldw	r2,-8(fp)
 100b41c:	10800017 	ldw	r2,0(r2)
 100b420:	1009883a 	mov	r4,r2
 100b424:	100a4240 	call	100a424 <elf_shstrtab_ptr>
 100b428:	e0bff815 	stw	r2,-32(fp)
		*shstrtab = metal_allocate_memory(shstrtab_size);
 100b42c:	e0bff917 	ldw	r2,-28(fp)
 100b430:	1009883a 	mov	r4,r2
 100b434:	1009fdc0 	call	1009fdc <metal_allocate_memory>
 100b438:	1007883a 	mov	r3,r2
 100b43c:	e0bff817 	ldw	r2,-32(fp)
 100b440:	10c00015 	stw	r3,0(r2)
		if (*shstrtab == NULL)
 100b444:	e0bff817 	ldw	r2,-32(fp)
 100b448:	10800017 	ldw	r2,0(r2)
 100b44c:	1000021e 	bne	r2,zero,100b458 <elf_load_header+0x6b0>
			return -RPROC_ENOMEM;
 100b450:	00bfffc4 	movi	r2,-1
 100b454:	00001906 	br	100b4bc <elf_load_header+0x714>
		memcpy(*shstrtab,
 100b458:	e0bff817 	ldw	r2,-32(fp)
 100b45c:	11000017 	ldw	r4,0(r2)
 100b460:	e0bffa17 	ldw	r2,-24(fp)
		       (const char *)img_data + shstrtab_offset,
 100b464:	e0fffb17 	ldw	r3,-20(fp)
 100b468:	1885883a 	add	r2,r3,r2
		shstrtab_offset -= offset;
		shstrtab = elf_shstrtab_ptr(*img_info);
		*shstrtab = metal_allocate_memory(shstrtab_size);
		if (*shstrtab == NULL)
			return -RPROC_ENOMEM;
		memcpy(*shstrtab,
 100b46c:	e0fff917 	ldw	r3,-28(fp)
 100b470:	180d883a 	mov	r6,r3
 100b474:	100b883a 	mov	r5,r2
 100b478:	10158f40 	call	10158f4 <memcpy>
		       (const char *)img_data + shstrtab_offset,
		       shstrtab_size);
		*load_state = (*load_state & (~ELF_STATE_MASK)) |
 100b47c:	e0bfed17 	ldw	r2,-76(fp)
 100b480:	10800017 	ldw	r2,0(r2)
 100b484:	1007883a 	mov	r3,r2
 100b488:	00bffff4 	movhi	r2,65535
 100b48c:	10803fc4 	addi	r2,r2,255
 100b490:	1884703a 	and	r2,r3,r2
 100b494:	10820014 	ori	r2,r2,2048
 100b498:	1007883a 	mov	r3,r2
 100b49c:	e0bfed17 	ldw	r2,-76(fp)
 100b4a0:	10c00015 	stw	r3,0(r2)
			       ELF_STATE_HDRS_COMPLETE;
		*nlen = 0;
 100b4a4:	e0800417 	ldw	r2,16(fp)
 100b4a8:	10000015 	stw	zero,0(r2)
		return *load_state;
 100b4ac:	e0bfed17 	ldw	r2,-76(fp)
 100b4b0:	10800017 	ldw	r2,0(r2)
 100b4b4:	00000106 	br	100b4bc <elf_load_header+0x714>
	}
	return last_load_state;
 100b4b8:	e0800217 	ldw	r2,8(fp)
}
 100b4bc:	e6ffff04 	addi	sp,fp,-4
 100b4c0:	dfc00217 	ldw	ra,8(sp)
 100b4c4:	df000117 	ldw	fp,4(sp)
 100b4c8:	dc000017 	ldw	r16,0(sp)
 100b4cc:	dec00304 	addi	sp,sp,12
 100b4d0:	f800283a 	ret

0100b4d4 <elf_load>:
	     const void *img_data, size_t offset, size_t len,
	     void **img_info, int last_load_state,
	     metal_phys_addr_t *da,
	     size_t *noffset, size_t *nlen,
	     unsigned char *padding, size_t *nmemsize)
{
 100b4d4:	defff104 	addi	sp,sp,-60
 100b4d8:	dfc00e15 	stw	ra,56(sp)
 100b4dc:	df000d15 	stw	fp,52(sp)
 100b4e0:	df000d04 	addi	fp,sp,52
 100b4e4:	e13ffc15 	stw	r4,-16(fp)
 100b4e8:	e17ffd15 	stw	r5,-12(fp)
 100b4ec:	e1bffe15 	stw	r6,-8(fp)
 100b4f0:	e1ffff15 	stw	r7,-4(fp)
	int *load_state;
	const void *phdr;

	(void)rproc;
	metal_assert(da != NULL);
 100b4f4:	e0800417 	ldw	r2,16(fp)
 100b4f8:	1000081e 	bne	r2,zero,100b51c <elf_load+0x48>
 100b4fc:	01c040f4 	movhi	r7,259
 100b500:	39e57204 	addi	r7,r7,-27192
 100b504:	018040f4 	movhi	r6,259
 100b508:	31a5a804 	addi	r6,r6,-26976
 100b50c:	014088c4 	movi	r5,547
 100b510:	010040f4 	movhi	r4,259
 100b514:	21253704 	addi	r4,r4,-27428
 100b518:	10157a00 	call	10157a0 <__assert_func>
	metal_assert(noffset != NULL);
 100b51c:	e0800517 	ldw	r2,20(fp)
 100b520:	1000081e 	bne	r2,zero,100b544 <elf_load+0x70>
 100b524:	01c040f4 	movhi	r7,259
 100b528:	39e53104 	addi	r7,r7,-27452
 100b52c:	018040f4 	movhi	r6,259
 100b530:	31a5a804 	addi	r6,r6,-26976
 100b534:	01408904 	movi	r5,548
 100b538:	010040f4 	movhi	r4,259
 100b53c:	21253704 	addi	r4,r4,-27428
 100b540:	10157a00 	call	10157a0 <__assert_func>
	metal_assert(nlen != NULL);
 100b544:	e0800617 	ldw	r2,24(fp)
 100b548:	1000081e 	bne	r2,zero,100b56c <elf_load+0x98>
 100b54c:	01c040f4 	movhi	r7,259
 100b550:	39e54004 	addi	r7,r7,-27392
 100b554:	018040f4 	movhi	r6,259
 100b558:	31a5a804 	addi	r6,r6,-26976
 100b55c:	01408944 	movi	r5,549
 100b560:	010040f4 	movhi	r4,259
 100b564:	21253704 	addi	r4,r4,-27428
 100b568:	10157a00 	call	10157a0 <__assert_func>
	if ((last_load_state & RPROC_LOADER_MASK) == RPROC_LOADER_NOT_READY) {
 100b56c:	e0800317 	ldw	r2,12(fp)
 100b570:	10803fec 	andhi	r2,r2,255
 100b574:	1000241e 	bne	r2,zero,100b608 <elf_load+0x134>
		metal_log(METAL_LOG_DEBUG,
 100b578:	008060f4 	movhi	r2,387
 100b57c:	10baf104 	addi	r2,r2,-5180
 100b580:	10800017 	ldw	r2,0(r2)
 100b584:	108001f0 	cmpltui	r2,r2,7
 100b588:	10000b1e 	bne	r2,zero,100b5b8 <elf_load+0xe4>
 100b58c:	008060f4 	movhi	r2,387
 100b590:	10baf104 	addi	r2,r2,-5180
 100b594:	10800117 	ldw	r2,4(r2)
 100b598:	10000726 	beq	r2,zero,100b5b8 <elf_load+0xe4>
 100b59c:	008060f4 	movhi	r2,387
 100b5a0:	10baf104 	addi	r2,r2,-5180
 100b5a4:	10800117 	ldw	r2,4(r2)
 100b5a8:	014040f4 	movhi	r5,259
 100b5ac:	29657704 	addi	r5,r5,-27172
 100b5b0:	010001c4 	movi	r4,7
 100b5b4:	103ee83a 	callr	r2
			  "needs to load header first\r\n");
		last_load_state = elf_load_header(img_data, offset, len,
 100b5b8:	e0800617 	ldw	r2,24(fp)
 100b5bc:	d8800215 	stw	r2,8(sp)
 100b5c0:	e0800517 	ldw	r2,20(fp)
 100b5c4:	d8800115 	stw	r2,4(sp)
 100b5c8:	e0800317 	ldw	r2,12(fp)
 100b5cc:	d8800015 	stw	r2,0(sp)
 100b5d0:	e1c00217 	ldw	r7,8(fp)
 100b5d4:	e1bfff17 	ldw	r6,-4(fp)
 100b5d8:	e17ffe17 	ldw	r5,-8(fp)
 100b5dc:	e13ffd17 	ldw	r4,-12(fp)
 100b5e0:	100ada80 	call	100ada8 <elf_load_header>
 100b5e4:	e0800315 	stw	r2,12(fp)
						  img_info, last_load_state,
						  noffset, nlen);
		if ((last_load_state & RPROC_LOADER_MASK) ==
 100b5e8:	e0800317 	ldw	r2,12(fp)
 100b5ec:	10803fec 	andhi	r2,r2,255
 100b5f0:	1000051e 	bne	r2,zero,100b608 <elf_load+0x134>
		    RPROC_LOADER_NOT_READY) {
			*da = RPROC_LOAD_ANYADDR;
 100b5f4:	e0800417 	ldw	r2,16(fp)
 100b5f8:	00ffffc4 	movi	r3,-1
 100b5fc:	10c00015 	stw	r3,0(r2)
			return last_load_state;
 100b600:	e0800317 	ldw	r2,12(fp)
 100b604:	0000be06 	br	100b900 <elf_load+0x42c>
		}
	}
	metal_assert(img_info != NULL && *img_info != NULL);
 100b608:	e0800217 	ldw	r2,8(fp)
 100b60c:	10000326 	beq	r2,zero,100b61c <elf_load+0x148>
 100b610:	e0800217 	ldw	r2,8(fp)
 100b614:	10800017 	ldw	r2,0(r2)
 100b618:	1000081e 	bne	r2,zero,100b63c <elf_load+0x168>
 100b61c:	01c040f4 	movhi	r7,259
 100b620:	39e57f04 	addi	r7,r7,-27140
 100b624:	018040f4 	movhi	r6,259
 100b628:	31a5a804 	addi	r6,r6,-26976
 100b62c:	01408c84 	movi	r5,562
 100b630:	010040f4 	movhi	r4,259
 100b634:	21253704 	addi	r4,r4,-27428
 100b638:	10157a00 	call	10157a0 <__assert_func>
	load_state = elf_load_state(*img_info);
 100b63c:	e0800217 	ldw	r2,8(fp)
 100b640:	10800017 	ldw	r2,0(r2)
 100b644:	1009883a 	mov	r4,r2
 100b648:	100a47c0 	call	100a47c <elf_load_state>
 100b64c:	e0bff615 	stw	r2,-40(fp)
	/* For ELF, segment padding value is 0 */
	if (padding != NULL)
 100b650:	e0800717 	ldw	r2,28(fp)
 100b654:	10000226 	beq	r2,zero,100b660 <elf_load+0x18c>
		*padding = 0;
 100b658:	e0800717 	ldw	r2,28(fp)
 100b65c:	10000005 	stb	zero,0(r2)
	if ((*load_state & RPROC_LOADER_READY_TO_LOAD) != 0) {
 100b660:	e0bff617 	ldw	r2,-40(fp)
 100b664:	10800017 	ldw	r2,0(r2)
 100b668:	1080006c 	andhi	r2,r2,1
 100b66c:	10006b26 	beq	r2,zero,100b81c <elf_load+0x348>
		int nsegment;
		size_t nsegmsize = 0;
 100b670:	e03ffa15 	stw	zero,-24(fp)
		size_t nsize = 0;
 100b674:	e03ffb15 	stw	zero,-20(fp)
		int phnums = 0;
 100b678:	e03ff715 	stw	zero,-36(fp)

		nsegment = *load_state & ELF_NEXT_SEGMENT_MASK;
 100b67c:	e0bff617 	ldw	r2,-40(fp)
 100b680:	10800017 	ldw	r2,0(r2)
 100b684:	10803fcc 	andi	r2,r2,255
 100b688:	e0bff915 	stw	r2,-28(fp)
		phdr = elf_next_load_segment(*img_info, &nsegment, da,
 100b68c:	e0800217 	ldw	r2,8(fp)
 100b690:	10c00017 	ldw	r3,0(r2)
 100b694:	e13ff904 	addi	r4,fp,-28
 100b698:	e0bffa04 	addi	r2,fp,-24
 100b69c:	d8800115 	stw	r2,4(sp)
 100b6a0:	e0bffb04 	addi	r2,fp,-20
 100b6a4:	d8800015 	stw	r2,0(sp)
 100b6a8:	e1c00517 	ldw	r7,20(fp)
 100b6ac:	e1800417 	ldw	r6,16(fp)
 100b6b0:	200b883a 	mov	r5,r4
 100b6b4:	1809883a 	mov	r4,r3
 100b6b8:	100ac2c0 	call	100ac2c <elf_next_load_segment>
 100b6bc:	e0bff815 	stw	r2,-32(fp)
					     noffset, &nsize, &nsegmsize);
		if (phdr == NULL) {
 100b6c0:	e0bff817 	ldw	r2,-32(fp)
 100b6c4:	10001e1e 	bne	r2,zero,100b740 <elf_load+0x26c>
			metal_log(METAL_LOG_DEBUG, "cannot find more segment\r\n");
 100b6c8:	008060f4 	movhi	r2,387
 100b6cc:	10baf104 	addi	r2,r2,-5180
 100b6d0:	10800017 	ldw	r2,0(r2)
 100b6d4:	108001f0 	cmpltui	r2,r2,7
 100b6d8:	10000b1e 	bne	r2,zero,100b708 <elf_load+0x234>
 100b6dc:	008060f4 	movhi	r2,387
 100b6e0:	10baf104 	addi	r2,r2,-5180
 100b6e4:	10800117 	ldw	r2,4(r2)
 100b6e8:	10000726 	beq	r2,zero,100b708 <elf_load+0x234>
 100b6ec:	008060f4 	movhi	r2,387
 100b6f0:	10baf104 	addi	r2,r2,-5180
 100b6f4:	10800117 	ldw	r2,4(r2)
 100b6f8:	014040f4 	movhi	r5,259
 100b6fc:	29658c04 	addi	r5,r5,-27088
 100b700:	010001c4 	movi	r4,7
 100b704:	103ee83a 	callr	r2
			*load_state = (*load_state & (~ELF_NEXT_SEGMENT_MASK)) |
 100b708:	e0bff617 	ldw	r2,-40(fp)
 100b70c:	10800017 	ldw	r2,0(r2)
 100b710:	1007883a 	mov	r3,r2
 100b714:	00bfc004 	movi	r2,-256
 100b718:	1886703a 	and	r3,r3,r2
				      (nsegment & ELF_NEXT_SEGMENT_MASK);
 100b71c:	e0bff917 	ldw	r2,-28(fp)
 100b720:	10803fcc 	andi	r2,r2,255
		nsegment = *load_state & ELF_NEXT_SEGMENT_MASK;
		phdr = elf_next_load_segment(*img_info, &nsegment, da,
					     noffset, &nsize, &nsegmsize);
		if (phdr == NULL) {
			metal_log(METAL_LOG_DEBUG, "cannot find more segment\r\n");
			*load_state = (*load_state & (~ELF_NEXT_SEGMENT_MASK)) |
 100b724:	1884b03a 	or	r2,r3,r2
 100b728:	1007883a 	mov	r3,r2
 100b72c:	e0bff617 	ldw	r2,-40(fp)
 100b730:	10c00015 	stw	r3,0(r2)
				      (nsegment & ELF_NEXT_SEGMENT_MASK);
			return *load_state;
 100b734:	e0bff617 	ldw	r2,-40(fp)
 100b738:	10800017 	ldw	r2,0(r2)
 100b73c:	00007006 	br	100b900 <elf_load+0x42c>
		}
		*nlen = nsize;
 100b740:	e0fffb17 	ldw	r3,-20(fp)
 100b744:	e0800617 	ldw	r2,24(fp)
 100b748:	10c00015 	stw	r3,0(r2)
		*nmemsize = nsegmsize;
 100b74c:	e0fffa17 	ldw	r3,-24(fp)
 100b750:	e0800817 	ldw	r2,32(fp)
 100b754:	10c00015 	stw	r3,0(r2)
		phnums = elf_phnum(*img_info);
 100b758:	e0800217 	ldw	r2,8(fp)
 100b75c:	10800017 	ldw	r2,0(r2)
 100b760:	1009883a 	mov	r4,r2
 100b764:	100a1980 	call	100a198 <elf_phnum>
 100b768:	e0bff715 	stw	r2,-36(fp)
		metal_log(METAL_LOG_DEBUG, "segment: %d, total segs %d\r\n",
 100b76c:	008060f4 	movhi	r2,387
 100b770:	10baf104 	addi	r2,r2,-5180
 100b774:	10800017 	ldw	r2,0(r2)
 100b778:	108001f0 	cmpltui	r2,r2,7
 100b77c:	10000e1e 	bne	r2,zero,100b7b8 <elf_load+0x2e4>
 100b780:	008060f4 	movhi	r2,387
 100b784:	10baf104 	addi	r2,r2,-5180
 100b788:	10800117 	ldw	r2,4(r2)
 100b78c:	10000a26 	beq	r2,zero,100b7b8 <elf_load+0x2e4>
 100b790:	008060f4 	movhi	r2,387
 100b794:	10baf104 	addi	r2,r2,-5180
 100b798:	10800117 	ldw	r2,4(r2)
 100b79c:	e0fff917 	ldw	r3,-28(fp)
 100b7a0:	e1fff717 	ldw	r7,-36(fp)
 100b7a4:	180d883a 	mov	r6,r3
 100b7a8:	014040f4 	movhi	r5,259
 100b7ac:	29659304 	addi	r5,r5,-27060
 100b7b0:	010001c4 	movi	r4,7
 100b7b4:	103ee83a 	callr	r2
			  nsegment, phnums);
		if (nsegment == phnums) {
 100b7b8:	e0fff917 	ldw	r3,-28(fp)
 100b7bc:	e0bff717 	ldw	r2,-36(fp)
 100b7c0:	18800a1e 	bne	r3,r2,100b7ec <elf_load+0x318>
			*load_state = (*load_state & (~RPROC_LOADER_MASK)) |
 100b7c4:	e0bff617 	ldw	r2,-40(fp)
 100b7c8:	10800017 	ldw	r2,0(r2)
 100b7cc:	1007883a 	mov	r3,r2
 100b7d0:	00bfc074 	movhi	r2,65281
 100b7d4:	10bfffc4 	addi	r2,r2,-1
 100b7d8:	1884703a 	and	r2,r3,r2
 100b7dc:	108000b4 	orhi	r2,r2,2
 100b7e0:	1007883a 	mov	r3,r2
 100b7e4:	e0bff617 	ldw	r2,-40(fp)
 100b7e8:	10c00015 	stw	r3,0(r2)
				      RPROC_LOADER_POST_DATA_LOAD;
		}
		*load_state = (*load_state & (~ELF_NEXT_SEGMENT_MASK)) |
 100b7ec:	e0bff617 	ldw	r2,-40(fp)
 100b7f0:	10800017 	ldw	r2,0(r2)
 100b7f4:	1007883a 	mov	r3,r2
 100b7f8:	00bfc004 	movi	r2,-256
 100b7fc:	1886703a 	and	r3,r3,r2
			      (nsegment & ELF_NEXT_SEGMENT_MASK);
 100b800:	e0bff917 	ldw	r2,-28(fp)
 100b804:	10803fcc 	andi	r2,r2,255
			  nsegment, phnums);
		if (nsegment == phnums) {
			*load_state = (*load_state & (~RPROC_LOADER_MASK)) |
				      RPROC_LOADER_POST_DATA_LOAD;
		}
		*load_state = (*load_state & (~ELF_NEXT_SEGMENT_MASK)) |
 100b808:	1884b03a 	or	r2,r3,r2
 100b80c:	1007883a 	mov	r3,r2
 100b810:	e0bff617 	ldw	r2,-40(fp)
 100b814:	10c00015 	stw	r3,0(r2)
 100b818:	00003706 	br	100b8f8 <elf_load+0x424>
			      (nsegment & ELF_NEXT_SEGMENT_MASK);
	} else if ((*load_state & RPROC_LOADER_POST_DATA_LOAD) != 0) {
 100b81c:	e0bff617 	ldw	r2,-40(fp)
 100b820:	10800017 	ldw	r2,0(r2)
 100b824:	108000ac 	andhi	r2,r2,2
 100b828:	10003326 	beq	r2,zero,100b8f8 <elf_load+0x424>
		if ((*load_state & ELF_STATE_HDRS_COMPLETE) == 0) {
 100b82c:	e0bff617 	ldw	r2,-40(fp)
 100b830:	10800017 	ldw	r2,0(r2)
 100b834:	1082000c 	andi	r2,r2,2048
 100b838:	1000231e 	bne	r2,zero,100b8c8 <elf_load+0x3f4>
			last_load_state = elf_load_header(img_data, offset,
 100b83c:	e0800617 	ldw	r2,24(fp)
 100b840:	d8800215 	stw	r2,8(sp)
 100b844:	e0800517 	ldw	r2,20(fp)
 100b848:	d8800115 	stw	r2,4(sp)
 100b84c:	e0800317 	ldw	r2,12(fp)
 100b850:	d8800015 	stw	r2,0(sp)
 100b854:	e1c00217 	ldw	r7,8(fp)
 100b858:	e1bfff17 	ldw	r6,-4(fp)
 100b85c:	e17ffe17 	ldw	r5,-8(fp)
 100b860:	e13ffd17 	ldw	r4,-12(fp)
 100b864:	100ada80 	call	100ada8 <elf_load_header>
 100b868:	e0800315 	stw	r2,12(fp)
							  len, img_info,
							  last_load_state,
							  noffset, nlen);
			if (last_load_state < 0)
 100b86c:	e0800317 	ldw	r2,12(fp)
 100b870:	1000020e 	bge	r2,zero,100b87c <elf_load+0x3a8>
				return last_load_state;
 100b874:	e0800317 	ldw	r2,12(fp)
 100b878:	00002106 	br	100b900 <elf_load+0x42c>
			if ((last_load_state & ELF_STATE_HDRS_COMPLETE) != 0) {
 100b87c:	e0800317 	ldw	r2,12(fp)
 100b880:	1082000c 	andi	r2,r2,2048
 100b884:	10000c26 	beq	r2,zero,100b8b8 <elf_load+0x3e4>
				*load_state = (*load_state &
 100b888:	e0bff617 	ldw	r2,-40(fp)
 100b88c:	10800017 	ldw	r2,0(r2)
 100b890:	1007883a 	mov	r3,r2
 100b894:	00bfc074 	movhi	r2,65281
 100b898:	10bfffc4 	addi	r2,r2,-1
 100b89c:	1884703a 	and	r2,r3,r2
						(~RPROC_LOADER_MASK)) |
 100b8a0:	10800134 	orhi	r2,r2,4
							  last_load_state,
							  noffset, nlen);
			if (last_load_state < 0)
				return last_load_state;
			if ((last_load_state & ELF_STATE_HDRS_COMPLETE) != 0) {
				*load_state = (*load_state &
 100b8a4:	1007883a 	mov	r3,r2
 100b8a8:	e0bff617 	ldw	r2,-40(fp)
 100b8ac:	10c00015 	stw	r3,0(r2)
						(~RPROC_LOADER_MASK)) |
						RPROC_LOADER_LOAD_COMPLETE;
				*nlen = 0;
 100b8b0:	e0800617 	ldw	r2,24(fp)
 100b8b4:	10000015 	stw	zero,0(r2)
			}
			*da = RPROC_LOAD_ANYADDR;
 100b8b8:	e0800417 	ldw	r2,16(fp)
 100b8bc:	00ffffc4 	movi	r3,-1
 100b8c0:	10c00015 	stw	r3,0(r2)
 100b8c4:	00000c06 	br	100b8f8 <elf_load+0x424>
		} else {
		/* TODO: will handle relocate later */
			*nlen = 0;
 100b8c8:	e0800617 	ldw	r2,24(fp)
 100b8cc:	10000015 	stw	zero,0(r2)
			*load_state = (*load_state &
 100b8d0:	e0bff617 	ldw	r2,-40(fp)
 100b8d4:	10800017 	ldw	r2,0(r2)
 100b8d8:	1007883a 	mov	r3,r2
 100b8dc:	00bfc074 	movhi	r2,65281
 100b8e0:	10bfffc4 	addi	r2,r2,-1
 100b8e4:	1884703a 	and	r2,r3,r2
					(~RPROC_LOADER_MASK)) |
 100b8e8:	10800134 	orhi	r2,r2,4
			}
			*da = RPROC_LOAD_ANYADDR;
		} else {
		/* TODO: will handle relocate later */
			*nlen = 0;
			*load_state = (*load_state &
 100b8ec:	1007883a 	mov	r3,r2
 100b8f0:	e0bff617 	ldw	r2,-40(fp)
 100b8f4:	10c00015 	stw	r3,0(r2)
					(~RPROC_LOADER_MASK)) |
					RPROC_LOADER_LOAD_COMPLETE;
		}
	}
	return *load_state;
 100b8f8:	e0bff617 	ldw	r2,-40(fp)
 100b8fc:	10800017 	ldw	r2,0(r2)
}
 100b900:	e037883a 	mov	sp,fp
 100b904:	dfc00117 	ldw	ra,4(sp)
 100b908:	df000017 	ldw	fp,0(sp)
 100b90c:	dec00204 	addi	sp,sp,8
 100b910:	f800283a 	ret

0100b914 <elf_release>:

void elf_release(void *img_info)
{
 100b914:	defffb04 	addi	sp,sp,-20
 100b918:	dfc00415 	stw	ra,16(sp)
 100b91c:	df000315 	stw	fp,12(sp)
 100b920:	df000304 	addi	fp,sp,12
 100b924:	e13fff15 	stw	r4,-4(fp)
	if (img_info == NULL)
 100b928:	e0bfff17 	ldw	r2,-4(fp)
 100b92c:	10003726 	beq	r2,zero,100ba0c <elf_release+0xf8>
		return;
	if (elf_is_64(img_info) == 0) {
 100b930:	e13fff17 	ldw	r4,-4(fp)
 100b934:	100a0400 	call	100a040 <elf_is_64>
 100b938:	10001a1e 	bne	r2,zero,100b9a4 <elf_release+0x90>
		struct elf32_info *elf_info = img_info;
 100b93c:	e0bfff17 	ldw	r2,-4(fp)
 100b940:	e0bffd15 	stw	r2,-12(fp)

		if (elf_info->phdrs != NULL)
 100b944:	e0bffd17 	ldw	r2,-12(fp)
 100b948:	10800e17 	ldw	r2,56(r2)
 100b94c:	10000426 	beq	r2,zero,100b960 <elf_release+0x4c>
			metal_free_memory(elf_info->phdrs);
 100b950:	e0bffd17 	ldw	r2,-12(fp)
 100b954:	10800e17 	ldw	r2,56(r2)
 100b958:	1009883a 	mov	r4,r2
 100b95c:	100a00c0 	call	100a00c <metal_free_memory>
		if (elf_info->shdrs != NULL)
 100b960:	e0bffd17 	ldw	r2,-12(fp)
 100b964:	10800f17 	ldw	r2,60(r2)
 100b968:	10000426 	beq	r2,zero,100b97c <elf_release+0x68>
			metal_free_memory(elf_info->shdrs);
 100b96c:	e0bffd17 	ldw	r2,-12(fp)
 100b970:	10800f17 	ldw	r2,60(r2)
 100b974:	1009883a 	mov	r4,r2
 100b978:	100a00c0 	call	100a00c <metal_free_memory>
		if (elf_info->shstrtab != NULL)
 100b97c:	e0bffd17 	ldw	r2,-12(fp)
 100b980:	10801017 	ldw	r2,64(r2)
 100b984:	10000426 	beq	r2,zero,100b998 <elf_release+0x84>
			metal_free_memory(elf_info->shstrtab);
 100b988:	e0bffd17 	ldw	r2,-12(fp)
 100b98c:	10801017 	ldw	r2,64(r2)
 100b990:	1009883a 	mov	r4,r2
 100b994:	100a00c0 	call	100a00c <metal_free_memory>
		metal_free_memory(img_info);
 100b998:	e13fff17 	ldw	r4,-4(fp)
 100b99c:	100a00c0 	call	100a00c <metal_free_memory>
 100b9a0:	00001b06 	br	100ba10 <elf_release+0xfc>

	} else {
		struct elf64_info *elf_info = img_info;
 100b9a4:	e0bfff17 	ldw	r2,-4(fp)
 100b9a8:	e0bffe15 	stw	r2,-8(fp)

		if (elf_info->phdrs != NULL)
 100b9ac:	e0bffe17 	ldw	r2,-8(fp)
 100b9b0:	10801117 	ldw	r2,68(r2)
 100b9b4:	10000426 	beq	r2,zero,100b9c8 <elf_release+0xb4>
			metal_free_memory(elf_info->phdrs);
 100b9b8:	e0bffe17 	ldw	r2,-8(fp)
 100b9bc:	10801117 	ldw	r2,68(r2)
 100b9c0:	1009883a 	mov	r4,r2
 100b9c4:	100a00c0 	call	100a00c <metal_free_memory>
		if (elf_info->shdrs != NULL)
 100b9c8:	e0bffe17 	ldw	r2,-8(fp)
 100b9cc:	10801217 	ldw	r2,72(r2)
 100b9d0:	10000426 	beq	r2,zero,100b9e4 <elf_release+0xd0>
			metal_free_memory(elf_info->shdrs);
 100b9d4:	e0bffe17 	ldw	r2,-8(fp)
 100b9d8:	10801217 	ldw	r2,72(r2)
 100b9dc:	1009883a 	mov	r4,r2
 100b9e0:	100a00c0 	call	100a00c <metal_free_memory>
		if (elf_info->shstrtab != NULL)
 100b9e4:	e0bffe17 	ldw	r2,-8(fp)
 100b9e8:	10801317 	ldw	r2,76(r2)
 100b9ec:	10000426 	beq	r2,zero,100ba00 <elf_release+0xec>
			metal_free_memory(elf_info->shstrtab);
 100b9f0:	e0bffe17 	ldw	r2,-8(fp)
 100b9f4:	10801317 	ldw	r2,76(r2)
 100b9f8:	1009883a 	mov	r4,r2
 100b9fc:	100a00c0 	call	100a00c <metal_free_memory>
		metal_free_memory(img_info);
 100ba00:	e13fff17 	ldw	r4,-4(fp)
 100ba04:	100a00c0 	call	100a00c <metal_free_memory>
 100ba08:	00000106 	br	100ba10 <elf_release+0xfc>
}

void elf_release(void *img_info)
{
	if (img_info == NULL)
		return;
 100ba0c:	0001883a 	nop
			metal_free_memory(elf_info->shdrs);
		if (elf_info->shstrtab != NULL)
			metal_free_memory(elf_info->shstrtab);
		metal_free_memory(img_info);
	}
}
 100ba10:	e037883a 	mov	sp,fp
 100ba14:	dfc00117 	ldw	ra,4(sp)
 100ba18:	df000017 	ldw	fp,0(sp)
 100ba1c:	dec00204 	addi	sp,sp,8
 100ba20:	f800283a 	ret

0100ba24 <elf_get_entry>:

metal_phys_addr_t elf_get_entry(void *elf_info)
{
 100ba24:	defff804 	addi	sp,sp,-32
 100ba28:	dfc00715 	stw	ra,28(sp)
 100ba2c:	df000615 	stw	fp,24(sp)
 100ba30:	df000604 	addi	fp,sp,24
 100ba34:	e13fff15 	stw	r4,-4(fp)
	if (!elf_info)
 100ba38:	e0bfff17 	ldw	r2,-4(fp)
 100ba3c:	1000021e 	bne	r2,zero,100ba48 <elf_get_entry+0x24>
		return METAL_BAD_PHYS;
 100ba40:	00bfffc4 	movi	r2,-1
 100ba44:	00001206 	br	100ba90 <elf_get_entry+0x6c>

	if (elf_is_64(elf_info) == 0) {
 100ba48:	e13fff17 	ldw	r4,-4(fp)
 100ba4c:	100a0400 	call	100a040 <elf_is_64>
 100ba50:	1000071e 	bne	r2,zero,100ba70 <elf_get_entry+0x4c>
		Elf32_Ehdr *elf_ehdr = elf_info;
 100ba54:	e0bfff17 	ldw	r2,-4(fp)
 100ba58:	e0bffa15 	stw	r2,-24(fp)
		Elf32_Addr e_entry;

		e_entry = elf_ehdr->e_entry;
 100ba5c:	e0bffa17 	ldw	r2,-24(fp)
 100ba60:	10800617 	ldw	r2,24(r2)
 100ba64:	e0bffb15 	stw	r2,-20(fp)
		return (metal_phys_addr_t)e_entry;
 100ba68:	e0bffb17 	ldw	r2,-20(fp)
 100ba6c:	00000806 	br	100ba90 <elf_get_entry+0x6c>
	} else {
		Elf64_Ehdr *elf_ehdr = elf_info;
 100ba70:	e0bfff17 	ldw	r2,-4(fp)
 100ba74:	e0bffc15 	stw	r2,-16(fp)
		Elf64_Addr e_entry;

		e_entry = elf_ehdr->e_entry;
 100ba78:	e0bffc17 	ldw	r2,-16(fp)
 100ba7c:	10c00617 	ldw	r3,24(r2)
 100ba80:	e0fffd15 	stw	r3,-12(fp)
 100ba84:	10800717 	ldw	r2,28(r2)
 100ba88:	e0bffe15 	stw	r2,-8(fp)
		return (metal_phys_addr_t)e_entry;
 100ba8c:	e0bffd17 	ldw	r2,-12(fp)
	}
}
 100ba90:	e037883a 	mov	sp,fp
 100ba94:	dfc00117 	ldw	ra,4(sp)
 100ba98:	df000017 	ldw	fp,0(sp)
 100ba9c:	dec00204 	addi	sp,sp,8
 100baa0:	f800283a 	ret

0100baa4 <elf_locate_rsc_table>:

int elf_locate_rsc_table(void *elf_info, metal_phys_addr_t *da,
			 size_t *offset, size_t *size)
{
 100baa4:	defff004 	addi	sp,sp,-64
 100baa8:	dfc00f15 	stw	ra,60(sp)
 100baac:	df000e15 	stw	fp,56(sp)
 100bab0:	df000e04 	addi	fp,sp,56
 100bab4:	e13ffc15 	stw	r4,-16(fp)
 100bab8:	e17ffd15 	stw	r5,-12(fp)
 100babc:	e1bffe15 	stw	r6,-8(fp)
 100bac0:	e1ffff15 	stw	r7,-4(fp)
	char *sect_name = ".resource_table";
 100bac4:	008040f4 	movhi	r2,259
 100bac8:	10a59b04 	addi	r2,r2,-27028
 100bacc:	e0bff915 	stw	r2,-28(fp)
	void *shdr;
	int *load_state;

	if (elf_info == NULL)
 100bad0:	e0bffc17 	ldw	r2,-16(fp)
 100bad4:	1000021e 	bne	r2,zero,100bae0 <elf_locate_rsc_table+0x3c>
		return -RPROC_EINVAL;
 100bad8:	00bfff84 	movi	r2,-2
 100badc:	00002d06 	br	100bb94 <elf_locate_rsc_table+0xf0>

	load_state = elf_load_state(elf_info);
 100bae0:	e13ffc17 	ldw	r4,-16(fp)
 100bae4:	100a47c0 	call	100a47c <elf_load_state>
 100bae8:	e0bffa15 	stw	r2,-24(fp)
	if ((*load_state & ELF_STATE_HDRS_COMPLETE) == 0)
 100baec:	e0bffa17 	ldw	r2,-24(fp)
 100baf0:	10800017 	ldw	r2,0(r2)
 100baf4:	1082000c 	andi	r2,r2,2048
 100baf8:	1000021e 	bne	r2,zero,100bb04 <elf_locate_rsc_table+0x60>
		return -RPROC_ERR_LOADER_STATE;
 100bafc:	00bffd04 	movi	r2,-12
 100bb00:	00002406 	br	100bb94 <elf_locate_rsc_table+0xf0>
	shdr = elf_get_section_from_name(elf_info, sect_name);
 100bb04:	e17ff917 	ldw	r5,-28(fp)
 100bb08:	e13ffc17 	ldw	r4,-16(fp)
 100bb0c:	100a7700 	call	100a770 <elf_get_section_from_name>
 100bb10:	e0bffb15 	stw	r2,-20(fp)
	if (shdr == NULL) {
 100bb14:	e0bffb17 	ldw	r2,-20(fp)
 100bb18:	10000e1e 	bne	r2,zero,100bb54 <elf_locate_rsc_table+0xb0>
		metal_assert(size != NULL);
 100bb1c:	e0bfff17 	ldw	r2,-4(fp)
 100bb20:	1000081e 	bne	r2,zero,100bb44 <elf_locate_rsc_table+0xa0>
 100bb24:	01c040f4 	movhi	r7,259
 100bb28:	39e59f04 	addi	r7,r7,-27012
 100bb2c:	018040f4 	movhi	r6,259
 100bb30:	31a5ab04 	addi	r6,r6,-26964
 100bb34:	0140aa84 	movi	r5,682
 100bb38:	010040f4 	movhi	r4,259
 100bb3c:	21253704 	addi	r4,r4,-27428
 100bb40:	10157a00 	call	10157a0 <__assert_func>
		*size = 0;
 100bb44:	e0bfff17 	ldw	r2,-4(fp)
 100bb48:	10000015 	stw	zero,0(r2)
		return 0;
 100bb4c:	0005883a 	mov	r2,zero
 100bb50:	00001006 	br	100bb94 <elf_locate_rsc_table+0xf0>
	}
	elf_parse_section(elf_info, shdr, NULL, NULL,
 100bb54:	d8000615 	stw	zero,24(sp)
 100bb58:	d8000515 	stw	zero,20(sp)
 100bb5c:	d8000415 	stw	zero,16(sp)
 100bb60:	d8000315 	stw	zero,12(sp)
 100bb64:	e0bfff17 	ldw	r2,-4(fp)
 100bb68:	d8800215 	stw	r2,8(sp)
 100bb6c:	e0bffe17 	ldw	r2,-8(fp)
 100bb70:	d8800115 	stw	r2,4(sp)
 100bb74:	e0bffd17 	ldw	r2,-12(fp)
 100bb78:	d8800015 	stw	r2,0(sp)
 100bb7c:	000f883a 	mov	r7,zero
 100bb80:	000d883a 	mov	r6,zero
 100bb84:	e17ffb17 	ldw	r5,-20(fp)
 100bb88:	e13ffc17 	ldw	r4,-16(fp)
 100bb8c:	100a9f40 	call	100a9f4 <elf_parse_section>
			  da, offset, size,
			  NULL, NULL, NULL, NULL);
	return 0;
 100bb90:	0005883a 	mov	r2,zero
}
 100bb94:	e037883a 	mov	sp,fp
 100bb98:	dfc00117 	ldw	ra,4(sp)
 100bb9c:	df000017 	ldw	fp,0(sp)
 100bba0:	dec00204 	addi	sp,sp,8
 100bba4:	f800283a 	ret

0100bba8 <elf_get_load_state>:

int elf_get_load_state(void *img_info)
{
 100bba8:	defffc04 	addi	sp,sp,-16
 100bbac:	dfc00315 	stw	ra,12(sp)
 100bbb0:	df000215 	stw	fp,8(sp)
 100bbb4:	df000204 	addi	fp,sp,8
 100bbb8:	e13fff15 	stw	r4,-4(fp)
	int *load_state;

	if (img_info == NULL)
 100bbbc:	e0bfff17 	ldw	r2,-4(fp)
 100bbc0:	1000021e 	bne	r2,zero,100bbcc <elf_get_load_state+0x24>
		return -RPROC_EINVAL;
 100bbc4:	00bfff84 	movi	r2,-2
 100bbc8:	00000506 	br	100bbe0 <elf_get_load_state+0x38>
	load_state = elf_load_state(img_info);
 100bbcc:	e13fff17 	ldw	r4,-4(fp)
 100bbd0:	100a47c0 	call	100a47c <elf_load_state>
 100bbd4:	e0bffe15 	stw	r2,-8(fp)
	return *load_state;
 100bbd8:	e0bffe17 	ldw	r2,-8(fp)
 100bbdc:	10800017 	ldw	r2,0(r2)
}
 100bbe0:	e037883a 	mov	sp,fp
 100bbe4:	dfc00117 	ldw	ra,4(sp)
 100bbe8:	df000017 	ldw	fp,0(sp)
 100bbec:	dec00204 	addi	sp,sp,8
 100bbf0:	f800283a 	ret

0100bbf4 <metal_allocate_memory>:
#ifdef __cplusplus
extern "C" {
#endif

static inline void *metal_allocate_memory(unsigned int size)
{
 100bbf4:	defffd04 	addi	sp,sp,-12
 100bbf8:	dfc00215 	stw	ra,8(sp)
 100bbfc:	df000115 	stw	fp,4(sp)
 100bc00:	df000104 	addi	fp,sp,4
 100bc04:	e13fff15 	stw	r4,-4(fp)
	return (pvPortMalloc(size));
 100bc08:	e13fff17 	ldw	r4,-4(fp)
 100bc0c:	10010b00 	call	10010b0 <pvPortMalloc>
}
 100bc10:	e037883a 	mov	sp,fp
 100bc14:	dfc00117 	ldw	ra,4(sp)
 100bc18:	df000017 	ldw	fp,0(sp)
 100bc1c:	dec00204 	addi	sp,sp,8
 100bc20:	f800283a 	ret

0100bc24 <metal_free_memory>:

static inline void metal_free_memory(void *ptr)
{
 100bc24:	defffd04 	addi	sp,sp,-12
 100bc28:	dfc00215 	stw	ra,8(sp)
 100bc2c:	df000115 	stw	fp,4(sp)
 100bc30:	df000104 	addi	fp,sp,4
 100bc34:	e13fff15 	stw	r4,-4(fp)
	vPortFree(ptr);
 100bc38:	e13fff17 	ldw	r4,-4(fp)
 100bc3c:	10012840 	call	1001284 <vPortFree>
}
 100bc40:	0001883a 	nop
 100bc44:	e037883a 	mov	sp,fp
 100bc48:	dfc00117 	ldw	ra,4(sp)
 100bc4c:	df000017 	ldw	fp,0(sp)
 100bc50:	dec00204 	addi	sp,sp,8
 100bc54:	f800283a 	ret

0100bc58 <metal_bitmap_set_bit>:
#define metal_bit(bit)		(1UL << (bit))

#define metal_bitmap_longs(x)	metal_div_round_up((x), METAL_BITS_PER_ULONG)

static inline void metal_bitmap_set_bit(unsigned long *bitmap, int bit)
{
 100bc58:	defffd04 	addi	sp,sp,-12
 100bc5c:	df000215 	stw	fp,8(sp)
 100bc60:	df000204 	addi	fp,sp,8
 100bc64:	e13ffe15 	stw	r4,-8(fp)
 100bc68:	e17fff15 	stw	r5,-4(fp)
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 100bc6c:	e0bfff17 	ldw	r2,-4(fp)
 100bc70:	1004d17a 	srli	r2,r2,5
 100bc74:	1087883a 	add	r3,r2,r2
 100bc78:	18c7883a 	add	r3,r3,r3
 100bc7c:	1809883a 	mov	r4,r3
 100bc80:	e0fffe17 	ldw	r3,-8(fp)
 100bc84:	1907883a 	add	r3,r3,r4
 100bc88:	1085883a 	add	r2,r2,r2
 100bc8c:	1085883a 	add	r2,r2,r2
 100bc90:	1009883a 	mov	r4,r2
 100bc94:	e0bffe17 	ldw	r2,-8(fp)
 100bc98:	1105883a 	add	r2,r2,r4
 100bc9c:	11000017 	ldw	r4,0(r2)
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 100bca0:	e0bfff17 	ldw	r2,-4(fp)
 100bca4:	108007cc 	andi	r2,r2,31
 100bca8:	01400044 	movi	r5,1
 100bcac:	2884983a 	sll	r2,r5,r2

#define metal_bitmap_longs(x)	metal_div_round_up((x), METAL_BITS_PER_ULONG)

static inline void metal_bitmap_set_bit(unsigned long *bitmap, int bit)
{
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 100bcb0:	2084b03a 	or	r2,r4,r2
 100bcb4:	18800015 	stw	r2,0(r3)
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}
 100bcb8:	0001883a 	nop
 100bcbc:	e037883a 	mov	sp,fp
 100bcc0:	df000017 	ldw	fp,0(sp)
 100bcc4:	dec00104 	addi	sp,sp,4
 100bcc8:	f800283a 	ret

0100bccc <metal_bitmap_is_bit_set>:

static inline int metal_bitmap_is_bit_set(unsigned long *bitmap, int bit)
{
 100bccc:	defffd04 	addi	sp,sp,-12
 100bcd0:	df000215 	stw	fp,8(sp)
 100bcd4:	df000204 	addi	fp,sp,8
 100bcd8:	e13ffe15 	stw	r4,-8(fp)
 100bcdc:	e17fff15 	stw	r5,-4(fp)
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
 100bce0:	e0bfff17 	ldw	r2,-4(fp)
 100bce4:	1004d17a 	srli	r2,r2,5
 100bce8:	1085883a 	add	r2,r2,r2
 100bcec:	1085883a 	add	r2,r2,r2
 100bcf0:	1007883a 	mov	r3,r2
 100bcf4:	e0bffe17 	ldw	r2,-8(fp)
 100bcf8:	10c5883a 	add	r2,r2,r3
 100bcfc:	10c00017 	ldw	r3,0(r2)
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
 100bd00:	e0bfff17 	ldw	r2,-4(fp)
 100bd04:	108007cc 	andi	r2,r2,31
 100bd08:	1884d83a 	srl	r2,r3,r2
 100bd0c:	1080004c 	andi	r2,r2,1
 100bd10:	1004c03a 	cmpne	r2,r2,zero
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}

static inline int metal_bitmap_is_bit_set(unsigned long *bitmap, int bit)
{
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
 100bd14:	10803fcc 	andi	r2,r2,255
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
}
 100bd18:	e037883a 	mov	sp,fp
 100bd1c:	df000017 	ldw	fp,0(sp)
 100bd20:	dec00104 	addi	sp,sp,4
 100bd24:	f800283a 	ret

0100bd28 <metal_bitmap_is_bit_clear>:
	bitmap[bit / METAL_BITS_PER_ULONG] &=
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}

static inline int metal_bitmap_is_bit_clear(unsigned long *bitmap, int bit)
{
 100bd28:	defffc04 	addi	sp,sp,-16
 100bd2c:	dfc00315 	stw	ra,12(sp)
 100bd30:	df000215 	stw	fp,8(sp)
 100bd34:	df000204 	addi	fp,sp,8
 100bd38:	e13ffe15 	stw	r4,-8(fp)
 100bd3c:	e17fff15 	stw	r5,-4(fp)
	return !metal_bitmap_is_bit_set(bitmap, bit);
 100bd40:	e17fff17 	ldw	r5,-4(fp)
 100bd44:	e13ffe17 	ldw	r4,-8(fp)
 100bd48:	100bccc0 	call	100bccc <metal_bitmap_is_bit_set>
 100bd4c:	1005003a 	cmpeq	r2,r2,zero
 100bd50:	10803fcc 	andi	r2,r2,255
}
 100bd54:	e037883a 	mov	sp,fp
 100bd58:	dfc00117 	ldw	ra,4(sp)
 100bd5c:	df000017 	ldw	fp,0(sp)
 100bd60:	dec00204 	addi	sp,sp,8
 100bd64:	f800283a 	ret

0100bd68 <metal_bitmap_next_clear_bit>:
	     (bit) = metal_bitmap_next_set_bit((bitmap), (bit + 1), (max)))

static inline unsigned int
metal_bitmap_next_clear_bit(unsigned long *bitmap, unsigned int start,
			    unsigned int max)
{
 100bd68:	defffa04 	addi	sp,sp,-24
 100bd6c:	dfc00515 	stw	ra,20(sp)
 100bd70:	df000415 	stw	fp,16(sp)
 100bd74:	df000404 	addi	fp,sp,16
 100bd78:	e13ffd15 	stw	r4,-12(fp)
 100bd7c:	e17ffe15 	stw	r5,-8(fp)
 100bd80:	e1bfff15 	stw	r6,-4(fp)
	unsigned int bit;
	for (bit = start;
 100bd84:	e0bffe17 	ldw	r2,-8(fp)
 100bd88:	e0bffc15 	stw	r2,-16(fp)
 100bd8c:	00000306 	br	100bd9c <metal_bitmap_next_clear_bit+0x34>
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
	     bit ++)
 100bd90:	e0bffc17 	ldw	r2,-16(fp)
 100bd94:	10800044 	addi	r2,r2,1
 100bd98:	e0bffc15 	stw	r2,-16(fp)
static inline unsigned int
metal_bitmap_next_clear_bit(unsigned long *bitmap, unsigned int start,
			    unsigned int max)
{
	unsigned int bit;
	for (bit = start;
 100bd9c:	e0fffc17 	ldw	r3,-16(fp)
 100bda0:	e0bfff17 	ldw	r2,-4(fp)
 100bda4:	1880052e 	bgeu	r3,r2,100bdbc <metal_bitmap_next_clear_bit+0x54>
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
 100bda8:	e0bffc17 	ldw	r2,-16(fp)
 100bdac:	100b883a 	mov	r5,r2
 100bdb0:	e13ffd17 	ldw	r4,-12(fp)
 100bdb4:	100bd280 	call	100bd28 <metal_bitmap_is_bit_clear>
 100bdb8:	103ff526 	beq	r2,zero,100bd90 <__alt_data_end+0xff00bd90>
	     bit ++)
		;
	return bit;
 100bdbc:	e0bffc17 	ldw	r2,-16(fp)
}
 100bdc0:	e037883a 	mov	sp,fp
 100bdc4:	dfc00117 	ldw	ra,4(sp)
 100bdc8:	df000017 	ldw	fp,0(sp)
 100bdcc:	dec00204 	addi	sp,sp,8
 100bdd0:	f800283a 	ret

0100bdd4 <metal_list_init>:
 */
#define METAL_DECLARE_LIST(name)			\
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
 100bdd4:	defffe04 	addi	sp,sp,-8
 100bdd8:	df000115 	stw	fp,4(sp)
 100bddc:	df000104 	addi	fp,sp,4
 100bde0:	e13fff15 	stw	r4,-4(fp)
	list->next = list->prev = list;
 100bde4:	e0bfff17 	ldw	r2,-4(fp)
 100bde8:	e0ffff17 	ldw	r3,-4(fp)
 100bdec:	10c00115 	stw	r3,4(r2)
 100bdf0:	e0bfff17 	ldw	r2,-4(fp)
 100bdf4:	10c00117 	ldw	r3,4(r2)
 100bdf8:	e0bfff17 	ldw	r2,-4(fp)
 100bdfc:	10c00015 	stw	r3,0(r2)
}
 100be00:	0001883a 	nop
 100be04:	e037883a 	mov	sp,fp
 100be08:	df000017 	ldw	fp,0(sp)
 100be0c:	dec00104 	addi	sp,sp,4
 100be10:	f800283a 	ret

0100be14 <metal_list_add_before>:

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
 100be14:	defffd04 	addi	sp,sp,-12
 100be18:	df000215 	stw	fp,8(sp)
 100be1c:	df000204 	addi	fp,sp,8
 100be20:	e13ffe15 	stw	r4,-8(fp)
 100be24:	e17fff15 	stw	r5,-4(fp)
	new_node->prev = node->prev;
 100be28:	e0bffe17 	ldw	r2,-8(fp)
 100be2c:	10c00117 	ldw	r3,4(r2)
 100be30:	e0bfff17 	ldw	r2,-4(fp)
 100be34:	10c00115 	stw	r3,4(r2)
	new_node->next = node;
 100be38:	e0bfff17 	ldw	r2,-4(fp)
 100be3c:	e0fffe17 	ldw	r3,-8(fp)
 100be40:	10c00015 	stw	r3,0(r2)
	new_node->next->prev = new_node;
 100be44:	e0bfff17 	ldw	r2,-4(fp)
 100be48:	10800017 	ldw	r2,0(r2)
 100be4c:	e0ffff17 	ldw	r3,-4(fp)
 100be50:	10c00115 	stw	r3,4(r2)
	new_node->prev->next = new_node;
 100be54:	e0bfff17 	ldw	r2,-4(fp)
 100be58:	10800117 	ldw	r2,4(r2)
 100be5c:	e0ffff17 	ldw	r3,-4(fp)
 100be60:	10c00015 	stw	r3,0(r2)
}
 100be64:	0001883a 	nop
 100be68:	e037883a 	mov	sp,fp
 100be6c:	df000017 	ldw	fp,0(sp)
 100be70:	dec00104 	addi	sp,sp,4
 100be74:	f800283a 	ret

0100be78 <metal_list_add_tail>:
	metal_list_add_after(list, node);
}

static inline void metal_list_add_tail(struct metal_list *list,
				       struct metal_list *node)
{
 100be78:	defffc04 	addi	sp,sp,-16
 100be7c:	dfc00315 	stw	ra,12(sp)
 100be80:	df000215 	stw	fp,8(sp)
 100be84:	df000204 	addi	fp,sp,8
 100be88:	e13ffe15 	stw	r4,-8(fp)
 100be8c:	e17fff15 	stw	r5,-4(fp)
	metal_list_add_before(list, node);
 100be90:	e17fff17 	ldw	r5,-4(fp)
 100be94:	e13ffe17 	ldw	r4,-8(fp)
 100be98:	100be140 	call	100be14 <metal_list_add_before>
}
 100be9c:	0001883a 	nop
 100bea0:	e037883a 	mov	sp,fp
 100bea4:	dfc00117 	ldw	ra,4(sp)
 100bea8:	df000017 	ldw	fp,0(sp)
 100beac:	dec00204 	addi	sp,sp,8
 100beb0:	f800283a 	ret

0100beb4 <metal_list_del>:
{
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
 100beb4:	defffe04 	addi	sp,sp,-8
 100beb8:	df000115 	stw	fp,4(sp)
 100bebc:	df000104 	addi	fp,sp,4
 100bec0:	e13fff15 	stw	r4,-4(fp)
	node->next->prev = node->prev;
 100bec4:	e0bfff17 	ldw	r2,-4(fp)
 100bec8:	10800017 	ldw	r2,0(r2)
 100becc:	e0ffff17 	ldw	r3,-4(fp)
 100bed0:	18c00117 	ldw	r3,4(r3)
 100bed4:	10c00115 	stw	r3,4(r2)
	node->prev->next = node->next;
 100bed8:	e0bfff17 	ldw	r2,-4(fp)
 100bedc:	10800117 	ldw	r2,4(r2)
 100bee0:	e0ffff17 	ldw	r3,-4(fp)
 100bee4:	18c00017 	ldw	r3,0(r3)
 100bee8:	10c00015 	stw	r3,0(r2)
	node->next = node->prev = node;
 100beec:	e0bfff17 	ldw	r2,-4(fp)
 100bef0:	e0ffff17 	ldw	r3,-4(fp)
 100bef4:	10c00115 	stw	r3,4(r2)
 100bef8:	e0bfff17 	ldw	r2,-4(fp)
 100befc:	10c00117 	ldw	r3,4(r2)
 100bf00:	e0bfff17 	ldw	r2,-4(fp)
 100bf04:	10c00015 	stw	r3,0(r2)
}
 100bf08:	0001883a 	nop
 100bf0c:	e037883a 	mov	sp,fp
 100bf10:	df000017 	ldw	fp,0(sp)
 100bf14:	dec00104 	addi	sp,sp,4
 100bf18:	f800283a 	ret

0100bf1c <metal_io_virt>:
 * @param[in]	offset	Offset into shared memory segment.
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
 100bf1c:	defffd04 	addi	sp,sp,-12
 100bf20:	df000215 	stw	fp,8(sp)
 100bf24:	df000204 	addi	fp,sp,8
 100bf28:	e13ffe15 	stw	r4,-8(fp)
 100bf2c:	e17fff15 	stw	r5,-4(fp)
	return (io->virt != METAL_BAD_VA && offset < io->size
 100bf30:	e0bffe17 	ldw	r2,-8(fp)
 100bf34:	10800017 	ldw	r2,0(r2)
		? (uint8_t *)io->virt + offset
		: NULL);
 100bf38:	10bfffe0 	cmpeqi	r2,r2,-1
 100bf3c:	1000091e 	bne	r2,zero,100bf64 <metal_io_virt+0x48>
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
	return (io->virt != METAL_BAD_VA && offset < io->size
 100bf40:	e0bffe17 	ldw	r2,-8(fp)
 100bf44:	10800217 	ldw	r2,8(r2)
 100bf48:	e0ffff17 	ldw	r3,-4(fp)
 100bf4c:	1880052e 	bgeu	r3,r2,100bf64 <metal_io_virt+0x48>
		? (uint8_t *)io->virt + offset
 100bf50:	e0bffe17 	ldw	r2,-8(fp)
 100bf54:	10c00017 	ldw	r3,0(r2)
		: NULL);
 100bf58:	e0bfff17 	ldw	r2,-4(fp)
 100bf5c:	1885883a 	add	r2,r3,r2
 100bf60:	00000106 	br	100bf68 <metal_io_virt+0x4c>
 100bf64:	0005883a 	mov	r2,zero
}
 100bf68:	e037883a 	mov	sp,fp
 100bf6c:	df000017 	ldw	fp,0(sp)
 100bf70:	dec00104 	addi	sp,sp,4
 100bf74:	f800283a 	ret

0100bf78 <metal_io_virt_to_offset>:
 * @param[in]	virt	Virtual address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
 100bf78:	defffc04 	addi	sp,sp,-16
 100bf7c:	df000315 	stw	fp,12(sp)
 100bf80:	df000304 	addi	fp,sp,12
 100bf84:	e13ffe15 	stw	r4,-8(fp)
 100bf88:	e17fff15 	stw	r5,-4(fp)
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 100bf8c:	e0bfff17 	ldw	r2,-4(fp)
 100bf90:	e0fffe17 	ldw	r3,-8(fp)
 100bf94:	18c00017 	ldw	r3,0(r3)
 100bf98:	10c5c83a 	sub	r2,r2,r3
 100bf9c:	e0bffd15 	stw	r2,-12(fp)
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 100bfa0:	e0bffe17 	ldw	r2,-8(fp)
 100bfa4:	10800217 	ldw	r2,8(r2)
 100bfa8:	e0fffd17 	ldw	r3,-12(fp)
 100bfac:	1880022e 	bgeu	r3,r2,100bfb8 <metal_io_virt_to_offset+0x40>
 100bfb0:	e0bffd17 	ldw	r2,-12(fp)
 100bfb4:	00000106 	br	100bfbc <metal_io_virt_to_offset+0x44>
 100bfb8:	00bfffc4 	movi	r2,-1
}
 100bfbc:	e037883a 	mov	sp,fp
 100bfc0:	df000017 	ldw	fp,0(sp)
 100bfc4:	dec00104 	addi	sp,sp,4
 100bfc8:	f800283a 	ret

0100bfcc <metal_io_phys>:
 * @return	METAL_BAD_PHYS if offset is out of range, or physical address
 *		of offset.
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
 100bfcc:	defffb04 	addi	sp,sp,-20
 100bfd0:	dfc00415 	stw	ra,16(sp)
 100bfd4:	df000315 	stw	fp,12(sp)
 100bfd8:	df000304 	addi	fp,sp,12
 100bfdc:	e13ffe15 	stw	r4,-8(fp)
 100bfe0:	e17fff15 	stw	r5,-4(fp)
	if (!io->ops.offset_to_phys) {
 100bfe4:	e0bffe17 	ldw	r2,-8(fp)
 100bfe8:	10800c17 	ldw	r2,48(r2)
 100bfec:	1000211e 	bne	r2,zero,100c074 <metal_io_phys+0xa8>
		unsigned long page = (io->page_shift >=
 100bff0:	e0bffe17 	ldw	r2,-8(fp)
 100bff4:	10800317 	ldw	r2,12(r2)
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
 100bff8:	10800828 	cmpgeui	r2,r2,32
 100bffc:	1000051e 	bne	r2,zero,100c014 <metal_io_phys+0x48>
 100c000:	e0bffe17 	ldw	r2,-8(fp)
 100c004:	10800317 	ldw	r2,12(r2)
 100c008:	e0ffff17 	ldw	r3,-4(fp)
 100c00c:	1884d83a 	srl	r2,r3,r2
 100c010:	00000106 	br	100c018 <metal_io_phys+0x4c>
 100c014:	0005883a 	mov	r2,zero
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
 100c018:	e0bffd15 	stw	r2,-12(fp)
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 100c01c:	e0bffe17 	ldw	r2,-8(fp)
 100c020:	10800117 	ldw	r2,4(r2)
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 100c024:	10001126 	beq	r2,zero,100c06c <metal_io_phys+0xa0>
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 100c028:	e0bffe17 	ldw	r2,-8(fp)
 100c02c:	10800217 	ldw	r2,8(r2)
 100c030:	e0ffff17 	ldw	r3,-4(fp)
 100c034:	18800d2e 	bgeu	r3,r2,100c06c <metal_io_phys+0xa0>
			? io->physmap[page] + (offset & io->page_mask)
 100c038:	e0bffe17 	ldw	r2,-8(fp)
 100c03c:	10c00117 	ldw	r3,4(r2)
 100c040:	e0bffd17 	ldw	r2,-12(fp)
 100c044:	1085883a 	add	r2,r2,r2
 100c048:	1085883a 	add	r2,r2,r2
 100c04c:	1885883a 	add	r2,r3,r2
 100c050:	10c00017 	ldw	r3,0(r2)
 100c054:	e0bffe17 	ldw	r2,-8(fp)
 100c058:	11000417 	ldw	r4,16(r2)
 100c05c:	e0bfff17 	ldw	r2,-4(fp)
 100c060:	2084703a 	and	r2,r4,r2
			: METAL_BAD_PHYS);
 100c064:	1885883a 	add	r2,r3,r2
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 100c068:	00000706 	br	100c088 <metal_io_phys+0xbc>
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 100c06c:	00bfffc4 	movi	r2,-1
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 100c070:	00000506 	br	100c088 <metal_io_phys+0xbc>
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
	}

	return io->ops.offset_to_phys(io, offset);
 100c074:	e0bffe17 	ldw	r2,-8(fp)
 100c078:	10800c17 	ldw	r2,48(r2)
 100c07c:	e17fff17 	ldw	r5,-4(fp)
 100c080:	e13ffe17 	ldw	r4,-8(fp)
 100c084:	103ee83a 	callr	r2
}
 100c088:	e037883a 	mov	sp,fp
 100c08c:	dfc00117 	ldw	ra,4(sp)
 100c090:	df000017 	ldw	fp,0(sp)
 100c094:	dec00204 	addi	sp,sp,8
 100c098:	f800283a 	ret

0100c09c <metal_io_phys_to_offset>:
 * @param[in]	phys	Physical address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
 100c09c:	defffb04 	addi	sp,sp,-20
 100c0a0:	dfc00415 	stw	ra,16(sp)
 100c0a4:	df000315 	stw	fp,12(sp)
 100c0a8:	df000304 	addi	fp,sp,12
 100c0ac:	e13ffe15 	stw	r4,-8(fp)
 100c0b0:	e17fff15 	stw	r5,-4(fp)
	if (!io->ops.phys_to_offset) {
 100c0b4:	e0bffe17 	ldw	r2,-8(fp)
 100c0b8:	10800d17 	ldw	r2,52(r2)
 100c0bc:	1000231e 	bne	r2,zero,100c14c <metal_io_phys_to_offset+0xb0>
		unsigned long offset =
			(io->page_mask == (metal_phys_addr_t)(-1) ?
 100c0c0:	e0bffe17 	ldw	r2,-8(fp)
 100c0c4:	10800417 	ldw	r2,16(r2)
			phys - io->physmap[0] :  phys & io->page_mask);
 100c0c8:	10bfffd8 	cmpnei	r2,r2,-1
 100c0cc:	1000061e 	bne	r2,zero,100c0e8 <metal_io_phys_to_offset+0x4c>
 100c0d0:	e0bffe17 	ldw	r2,-8(fp)
 100c0d4:	10800117 	ldw	r2,4(r2)
 100c0d8:	10800017 	ldw	r2,0(r2)
 100c0dc:	e0ffff17 	ldw	r3,-4(fp)
 100c0e0:	1885c83a 	sub	r2,r3,r2
 100c0e4:	00000406 	br	100c0f8 <metal_io_phys_to_offset+0x5c>
 100c0e8:	e0bffe17 	ldw	r2,-8(fp)
 100c0ec:	10c00417 	ldw	r3,16(r2)
 100c0f0:	e0bfff17 	ldw	r2,-4(fp)
 100c0f4:	1884703a 	and	r2,r3,r2
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
	if (!io->ops.phys_to_offset) {
		unsigned long offset =
 100c0f8:	e0bffd15 	stw	r2,-12(fp)
			(io->page_mask == (metal_phys_addr_t)(-1) ?
			phys - io->physmap[0] :  phys & io->page_mask);
		do {
			if (metal_io_phys(io, offset) == phys)
 100c0fc:	e17ffd17 	ldw	r5,-12(fp)
 100c100:	e13ffe17 	ldw	r4,-8(fp)
 100c104:	100bfcc0 	call	100bfcc <metal_io_phys>
 100c108:	1007883a 	mov	r3,r2
 100c10c:	e0bfff17 	ldw	r2,-4(fp)
 100c110:	1880021e 	bne	r3,r2,100c11c <metal_io_phys_to_offset+0x80>
				return offset;
 100c114:	e0bffd17 	ldw	r2,-12(fp)
 100c118:	00001106 	br	100c160 <metal_io_phys_to_offset+0xc4>
			offset += io->page_mask + 1;
 100c11c:	e0bffe17 	ldw	r2,-8(fp)
 100c120:	10c00417 	ldw	r3,16(r2)
 100c124:	e0bffd17 	ldw	r2,-12(fp)
 100c128:	1885883a 	add	r2,r3,r2
 100c12c:	10800044 	addi	r2,r2,1
 100c130:	e0bffd15 	stw	r2,-12(fp)
		} while (offset < io->size);
 100c134:	e0bffe17 	ldw	r2,-8(fp)
 100c138:	10800217 	ldw	r2,8(r2)
 100c13c:	e0fffd17 	ldw	r3,-12(fp)
 100c140:	18bfee36 	bltu	r3,r2,100c0fc <__alt_data_end+0xff00c0fc>
		return METAL_BAD_OFFSET;
 100c144:	00bfffc4 	movi	r2,-1
 100c148:	00000506 	br	100c160 <metal_io_phys_to_offset+0xc4>
	}

	return (*io->ops.phys_to_offset)(io, phys);
 100c14c:	e0bffe17 	ldw	r2,-8(fp)
 100c150:	10800d17 	ldw	r2,52(r2)
 100c154:	e17fff17 	ldw	r5,-4(fp)
 100c158:	e13ffe17 	ldw	r4,-8(fp)
 100c15c:	103ee83a 	callr	r2
}
 100c160:	e037883a 	mov	sp,fp
 100c164:	dfc00117 	ldw	ra,4(sp)
 100c168:	df000017 	ldw	fp,0(sp)
 100c16c:	dec00204 	addi	sp,sp,8
 100c170:	f800283a 	ret

0100c174 <metal_io_phys_to_virt>:
 * @param[in]	phys	Physical address within segment.
 * @return	NULL if out of range, or corresponding virtual address.
 */
static inline void *
metal_io_phys_to_virt(struct metal_io_region *io, metal_phys_addr_t phys)
{
 100c174:	defffc04 	addi	sp,sp,-16
 100c178:	dfc00315 	stw	ra,12(sp)
 100c17c:	df000215 	stw	fp,8(sp)
 100c180:	df000204 	addi	fp,sp,8
 100c184:	e13ffe15 	stw	r4,-8(fp)
 100c188:	e17fff15 	stw	r5,-4(fp)
	return metal_io_virt(io, metal_io_phys_to_offset(io, phys));
 100c18c:	e17fff17 	ldw	r5,-4(fp)
 100c190:	e13ffe17 	ldw	r4,-8(fp)
 100c194:	100c09c0 	call	100c09c <metal_io_phys_to_offset>
 100c198:	100b883a 	mov	r5,r2
 100c19c:	e13ffe17 	ldw	r4,-8(fp)
 100c1a0:	100bf1c0 	call	100bf1c <metal_io_virt>
}
 100c1a4:	e037883a 	mov	sp,fp
 100c1a8:	dfc00117 	ldw	ra,4(sp)
 100c1ac:	df000017 	ldw	fp,0(sp)
 100c1b0:	dec00204 	addi	sp,sp,8
 100c1b4:	f800283a 	ret

0100c1b8 <__metal_mutex_init>:
 * static singleton mutex
 */
#define METAL_MUTEX_DEFINE(m) metal_mutex_t m = METAL_MUTEX_INIT(m)

static inline void __metal_mutex_init(metal_mutex_t *mutex)
{
 100c1b8:	defffe04 	addi	sp,sp,-8
 100c1bc:	df000115 	stw	fp,4(sp)
 100c1c0:	df000104 	addi	fp,sp,4
 100c1c4:	e13fff15 	stw	r4,-4(fp)
	atomic_store(&mutex->v, 0);
 100c1c8:	e0bfff17 	ldw	r2,-4(fp)
 100c1cc:	10000015 	stw	zero,0(r2)
 100c1d0:	0001b03a 	sync
}
 100c1d4:	0001883a 	nop
 100c1d8:	e037883a 	mov	sp,fp
 100c1dc:	df000017 	ldw	fp,0(sp)
 100c1e0:	dec00104 	addi	sp,sp,4
 100c1e4:	f800283a 	ret

0100c1e8 <__metal_mutex_acquire>:
{
	return 1 - atomic_flag_test_and_set(&mutex->v);
}

static inline void __metal_mutex_acquire(metal_mutex_t *mutex)
{
 100c1e8:	defffb04 	addi	sp,sp,-20
 100c1ec:	df000415 	stw	fp,16(sp)
 100c1f0:	df000404 	addi	fp,sp,16
 100c1f4:	e13fff15 	stw	r4,-4(fp)
	while (atomic_flag_test_and_set(&mutex->v)) {
 100c1f8:	0001883a 	nop
 100c1fc:	e0bfff17 	ldw	r2,-4(fp)
 100c200:	e0bffc15 	stw	r2,-16(fp)
 100c204:	e0bffc17 	ldw	r2,-16(fp)
 100c208:	10800017 	ldw	r2,0(r2)
 100c20c:	e0bffd15 	stw	r2,-12(fp)
 100c210:	00800044 	movi	r2,1
 100c214:	e0bffe15 	stw	r2,-8(fp)
 100c218:	e0bfff17 	ldw	r2,-4(fp)
 100c21c:	e0fffe17 	ldw	r3,-8(fp)
 100c220:	10c00015 	stw	r3,0(r2)
 100c224:	e0bffd17 	ldw	r2,-12(fp)
 100c228:	103ff41e 	bne	r2,zero,100c1fc <__alt_data_end+0xff00c1fc>
		;
	}
}
 100c22c:	0001883a 	nop
 100c230:	e037883a 	mov	sp,fp
 100c234:	df000017 	ldw	fp,0(sp)
 100c238:	dec00104 	addi	sp,sp,4
 100c23c:	f800283a 	ret

0100c240 <__metal_mutex_release>:

static inline void __metal_mutex_release(metal_mutex_t *mutex)
{
 100c240:	defffe04 	addi	sp,sp,-8
 100c244:	df000115 	stw	fp,4(sp)
 100c248:	df000104 	addi	fp,sp,4
 100c24c:	e13fff15 	stw	r4,-4(fp)
	atomic_flag_clear(&mutex->v);
 100c250:	e0bfff17 	ldw	r2,-4(fp)
 100c254:	0001b03a 	sync
 100c258:	10000015 	stw	zero,0(r2)
}
 100c25c:	0001883a 	nop
 100c260:	e037883a 	mov	sp,fp
 100c264:	df000017 	ldw	fp,0(sp)
 100c268:	dec00104 	addi	sp,sp,4
 100c26c:	f800283a 	ret

0100c270 <metal_mutex_init>:
/**
 * @brief	Initialize a libmetal mutex.
 * @param[in]	mutex	Mutex to initialize.
 */
static inline void metal_mutex_init(metal_mutex_t *mutex)
{
 100c270:	defffd04 	addi	sp,sp,-12
 100c274:	dfc00215 	stw	ra,8(sp)
 100c278:	df000115 	stw	fp,4(sp)
 100c27c:	df000104 	addi	fp,sp,4
 100c280:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_init(mutex);
 100c284:	e13fff17 	ldw	r4,-4(fp)
 100c288:	100c1b80 	call	100c1b8 <__metal_mutex_init>
}
 100c28c:	0001883a 	nop
 100c290:	e037883a 	mov	sp,fp
 100c294:	dfc00117 	ldw	ra,4(sp)
 100c298:	df000017 	ldw	fp,0(sp)
 100c29c:	dec00204 	addi	sp,sp,8
 100c2a0:	f800283a 	ret

0100c2a4 <metal_mutex_acquire>:
/**
 * @brief	Acquire a mutex 
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
 100c2a4:	defffd04 	addi	sp,sp,-12
 100c2a8:	dfc00215 	stw	ra,8(sp)
 100c2ac:	df000115 	stw	fp,4(sp)
 100c2b0:	df000104 	addi	fp,sp,4
 100c2b4:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_acquire(mutex);
 100c2b8:	e13fff17 	ldw	r4,-4(fp)
 100c2bc:	100c1e80 	call	100c1e8 <__metal_mutex_acquire>
}
 100c2c0:	0001883a 	nop
 100c2c4:	e037883a 	mov	sp,fp
 100c2c8:	dfc00117 	ldw	ra,4(sp)
 100c2cc:	df000017 	ldw	fp,0(sp)
 100c2d0:	dec00204 	addi	sp,sp,8
 100c2d4:	f800283a 	ret

0100c2d8 <metal_mutex_release>:
 * @brief	Release a previously acquired mutex.
 * @param[in]	mutex	Mutex to mutex.
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
 100c2d8:	defffd04 	addi	sp,sp,-12
 100c2dc:	dfc00215 	stw	ra,8(sp)
 100c2e0:	df000115 	stw	fp,4(sp)
 100c2e4:	df000104 	addi	fp,sp,4
 100c2e8:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_release(mutex);
 100c2ec:	e13fff17 	ldw	r4,-4(fp)
 100c2f0:	100c2400 	call	100c240 <__metal_mutex_release>
}
 100c2f4:	0001883a 	nop
 100c2f8:	e037883a 	mov	sp,fp
 100c2fc:	dfc00117 	ldw	ra,4(sp)
 100c300:	df000017 	ldw	fp,0(sp)
 100c304:	dec00204 	addi	sp,sp,8
 100c308:	f800283a 	ret

0100c30c <RPROC_ERR_PTR>:
	else
		return 0;
}

static inline void *RPROC_ERR_PTR(long error)
{
 100c30c:	defffe04 	addi	sp,sp,-8
 100c310:	df000115 	stw	fp,4(sp)
 100c314:	df000104 	addi	fp,sp,4
 100c318:	e13fff15 	stw	r4,-4(fp)
	return (void *)error;
 100c31c:	e0bfff17 	ldw	r2,-4(fp)
}
 100c320:	e037883a 	mov	sp,fp
 100c324:	df000017 	ldw	fp,0(sp)
 100c328:	dec00104 	addi	sp,sp,4
 100c32c:	f800283a 	ret

0100c330 <vring_size>:
 */
#define vring_used_event(vr)	((vr)->avail->ring[(vr)->num])
#define vring_avail_event(vr)	((vr)->used->ring[(vr)->num].event)

static inline int vring_size(unsigned int num, unsigned long align)
{
 100c330:	defffc04 	addi	sp,sp,-16
 100c334:	df000315 	stw	fp,12(sp)
 100c338:	df000304 	addi	fp,sp,12
 100c33c:	e13ffe15 	stw	r4,-8(fp)
 100c340:	e17fff15 	stw	r5,-4(fp)
	int size;

	size = num * sizeof(struct vring_desc);
 100c344:	e0bffe17 	ldw	r2,-8(fp)
 100c348:	1004913a 	slli	r2,r2,4
 100c34c:	e0bffd15 	stw	r2,-12(fp)
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
 100c350:	e0bffe17 	ldw	r2,-8(fp)
 100c354:	108000c4 	addi	r2,r2,3
 100c358:	1085883a 	add	r2,r2,r2
 100c35c:	1007883a 	mov	r3,r2
 100c360:	e0bffd17 	ldw	r2,-12(fp)
 100c364:	1885883a 	add	r2,r3,r2
 100c368:	e0bffd15 	stw	r2,-12(fp)
	    sizeof(uint16_t);
	size = (size + align - 1) & ~(align - 1);
 100c36c:	e0fffd17 	ldw	r3,-12(fp)
 100c370:	e0bfff17 	ldw	r2,-4(fp)
 100c374:	1885883a 	add	r2,r3,r2
 100c378:	10ffffc4 	addi	r3,r2,-1
 100c37c:	e0bfff17 	ldw	r2,-4(fp)
 100c380:	0085c83a 	sub	r2,zero,r2
 100c384:	1884703a 	and	r2,r3,r2
 100c388:	e0bffd15 	stw	r2,-12(fp)
	size += sizeof(struct vring_used) +
	    (num * sizeof(struct vring_used_elem)) + sizeof(uint16_t);
 100c38c:	e0bffe17 	ldw	r2,-8(fp)
 100c390:	100690fa 	slli	r3,r2,3

	size = num * sizeof(struct vring_desc);
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
	    sizeof(uint16_t);
	size = (size + align - 1) & ~(align - 1);
	size += sizeof(struct vring_used) +
 100c394:	e0bffd17 	ldw	r2,-12(fp)
 100c398:	1885883a 	add	r2,r3,r2
 100c39c:	10800184 	addi	r2,r2,6
 100c3a0:	e0bffd15 	stw	r2,-12(fp)
	    (num * sizeof(struct vring_used_elem)) + sizeof(uint16_t);

	return size;
 100c3a4:	e0bffd17 	ldw	r2,-12(fp)
}
 100c3a8:	e037883a 	mov	sp,fp
 100c3ac:	df000017 	ldw	fp,0(sp)
 100c3b0:	dec00104 	addi	sp,sp,4
 100c3b4:	f800283a 	ret

0100c3b8 <remoteproc_check_fw_format>:
/******************************************************************************
 *  static functions
 *****************************************************************************/
static struct loader_ops *
remoteproc_check_fw_format(const void *img_data, size_t img_len)
{
 100c3b8:	defffc04 	addi	sp,sp,-16
 100c3bc:	dfc00315 	stw	ra,12(sp)
 100c3c0:	df000215 	stw	fp,8(sp)
 100c3c4:	df000204 	addi	fp,sp,8
 100c3c8:	e13ffe15 	stw	r4,-8(fp)
 100c3cc:	e17fff15 	stw	r5,-4(fp)
	if (img_len <= 0)
 100c3d0:	e0bfff17 	ldw	r2,-4(fp)
 100c3d4:	1000021e 	bne	r2,zero,100c3e0 <remoteproc_check_fw_format+0x28>
		return NULL;
 100c3d8:	0005883a 	mov	r2,zero
 100c3dc:	00000806 	br	100c400 <remoteproc_check_fw_format+0x48>
	else if (elf_identify(img_data, img_len) == 0)
 100c3e0:	e17fff17 	ldw	r5,-4(fp)
 100c3e4:	e13ffe17 	ldw	r4,-8(fp)
 100c3e8:	100ad3c0 	call	100ad3c <elf_identify>
 100c3ec:	1000031e 	bne	r2,zero,100c3fc <remoteproc_check_fw_format+0x44>
		return &elf_ops;
 100c3f0:	008040f4 	movhi	r2,259
 100c3f4:	10ab7904 	addi	r2,r2,-21020
 100c3f8:	00000106 	br	100c400 <remoteproc_check_fw_format+0x48>
	else
		return NULL;
 100c3fc:	0005883a 	mov	r2,zero
}
 100c400:	e037883a 	mov	sp,fp
 100c404:	dfc00117 	ldw	ra,4(sp)
 100c408:	df000017 	ldw	fp,0(sp)
 100c40c:	dec00204 	addi	sp,sp,8
 100c410:	f800283a 	ret

0100c414 <remoteproc_get_mem>:

static struct remoteproc_mem *
remoteproc_get_mem(struct remoteproc *rproc, const char *name,
		   metal_phys_addr_t pa, metal_phys_addr_t da,
		   void *va, size_t size)
{
 100c414:	defff404 	addi	sp,sp,-48
 100c418:	dfc00b15 	stw	ra,44(sp)
 100c41c:	df000a15 	stw	fp,40(sp)
 100c420:	df000a04 	addi	fp,sp,40
 100c424:	e13ffc15 	stw	r4,-16(fp)
 100c428:	e17ffd15 	stw	r5,-12(fp)
 100c42c:	e1bffe15 	stw	r6,-8(fp)
 100c430:	e1ffff15 	stw	r7,-4(fp)
	struct metal_list *node;
	struct remoteproc_mem *mem;

	metal_list_for_each(&rproc->mems, node) {
 100c434:	e0bffc17 	ldw	r2,-16(fp)
 100c438:	10800417 	ldw	r2,16(r2)
 100c43c:	e0bff615 	stw	r2,-40(fp)
 100c440:	00004806 	br	100c564 <remoteproc_get_mem+0x150>
		mem = metal_container_of(node, struct remoteproc_mem, node);
 100c444:	e0bff617 	ldw	r2,-40(fp)
 100c448:	10bff404 	addi	r2,r2,-48
 100c44c:	e0bff715 	stw	r2,-36(fp)
		if (name) {
 100c450:	e0bffd17 	ldw	r2,-12(fp)
 100c454:	10000926 	beq	r2,zero,100c47c <remoteproc_get_mem+0x68>
			if (!strncmp(name, mem->name, sizeof(mem->name)))
 100c458:	e0bff717 	ldw	r2,-36(fp)
 100c45c:	10800304 	addi	r2,r2,12
 100c460:	01800804 	movi	r6,32
 100c464:	100b883a 	mov	r5,r2
 100c468:	e13ffd17 	ldw	r4,-12(fp)
 100c46c:	101664c0 	call	101664c <strncmp>
 100c470:	1000391e 	bne	r2,zero,100c558 <remoteproc_get_mem+0x144>
				return mem;
 100c474:	e0bff717 	ldw	r2,-36(fp)
 100c478:	00003f06 	br	100c578 <remoteproc_get_mem+0x164>
		} else if (pa != METAL_BAD_PHYS) {
 100c47c:	e0bffe17 	ldw	r2,-8(fp)
 100c480:	10bfffe0 	cmpeqi	r2,r2,-1
 100c484:	1000121e 	bne	r2,zero,100c4d0 <remoteproc_get_mem+0xbc>
			metal_phys_addr_t pa_start, pa_end;

			pa_start = mem->pa;
 100c488:	e0bff717 	ldw	r2,-36(fp)
 100c48c:	10800117 	ldw	r2,4(r2)
 100c490:	e0bff815 	stw	r2,-32(fp)
			pa_end = pa_start + mem->size;
 100c494:	e0bff717 	ldw	r2,-36(fp)
 100c498:	10c00217 	ldw	r3,8(r2)
 100c49c:	e0bff817 	ldw	r2,-32(fp)
 100c4a0:	1885883a 	add	r2,r3,r2
 100c4a4:	e0bff915 	stw	r2,-28(fp)
			if (pa >= pa_start && (pa + size) <= pa_end)
 100c4a8:	e0fffe17 	ldw	r3,-8(fp)
 100c4ac:	e0bff817 	ldw	r2,-32(fp)
 100c4b0:	18802936 	bltu	r3,r2,100c558 <remoteproc_get_mem+0x144>
 100c4b4:	e0fffe17 	ldw	r3,-8(fp)
 100c4b8:	e0800317 	ldw	r2,12(fp)
 100c4bc:	1885883a 	add	r2,r3,r2
 100c4c0:	e0fff917 	ldw	r3,-28(fp)
 100c4c4:	18802436 	bltu	r3,r2,100c558 <remoteproc_get_mem+0x144>
				return mem;
 100c4c8:	e0bff717 	ldw	r2,-36(fp)
 100c4cc:	00002a06 	br	100c578 <remoteproc_get_mem+0x164>
		} else if (da != METAL_BAD_PHYS) {
 100c4d0:	e0bfff17 	ldw	r2,-4(fp)
 100c4d4:	10bfffe0 	cmpeqi	r2,r2,-1
 100c4d8:	1000121e 	bne	r2,zero,100c524 <remoteproc_get_mem+0x110>
			metal_phys_addr_t da_start, da_end;

			da_start = mem->da;
 100c4dc:	e0bff717 	ldw	r2,-36(fp)
 100c4e0:	10800017 	ldw	r2,0(r2)
 100c4e4:	e0bffa15 	stw	r2,-24(fp)
			da_end = da_start + mem->size;
 100c4e8:	e0bff717 	ldw	r2,-36(fp)
 100c4ec:	10c00217 	ldw	r3,8(r2)
 100c4f0:	e0bffa17 	ldw	r2,-24(fp)
 100c4f4:	1885883a 	add	r2,r3,r2
 100c4f8:	e0bffb15 	stw	r2,-20(fp)
			if (da >= da_start && (da + size) <= da_end)
 100c4fc:	e0ffff17 	ldw	r3,-4(fp)
 100c500:	e0bffa17 	ldw	r2,-24(fp)
 100c504:	18801436 	bltu	r3,r2,100c558 <remoteproc_get_mem+0x144>
 100c508:	e0ffff17 	ldw	r3,-4(fp)
 100c50c:	e0800317 	ldw	r2,12(fp)
 100c510:	1885883a 	add	r2,r3,r2
 100c514:	e0fffb17 	ldw	r3,-20(fp)
 100c518:	18800f36 	bltu	r3,r2,100c558 <remoteproc_get_mem+0x144>
				return mem;
 100c51c:	e0bff717 	ldw	r2,-36(fp)
 100c520:	00001506 	br	100c578 <remoteproc_get_mem+0x164>
		} else if (va) {
 100c524:	e0800217 	ldw	r2,8(fp)
 100c528:	10000926 	beq	r2,zero,100c550 <remoteproc_get_mem+0x13c>
			if (metal_io_virt_to_offset(mem->io, va) !=
 100c52c:	e0bff717 	ldw	r2,-36(fp)
 100c530:	10800b17 	ldw	r2,44(r2)
 100c534:	e1400217 	ldw	r5,8(fp)
 100c538:	1009883a 	mov	r4,r2
 100c53c:	100bf780 	call	100bf78 <metal_io_virt_to_offset>
 100c540:	10bfffe0 	cmpeqi	r2,r2,-1
 100c544:	1000041e 	bne	r2,zero,100c558 <remoteproc_get_mem+0x144>
			    METAL_BAD_OFFSET)
				return mem;
 100c548:	e0bff717 	ldw	r2,-36(fp)
 100c54c:	00000a06 	br	100c578 <remoteproc_get_mem+0x164>

		} else {
			return NULL;
 100c550:	0005883a 	mov	r2,zero
 100c554:	00000806 	br	100c578 <remoteproc_get_mem+0x164>
		   void *va, size_t size)
{
	struct metal_list *node;
	struct remoteproc_mem *mem;

	metal_list_for_each(&rproc->mems, node) {
 100c558:	e0bff617 	ldw	r2,-40(fp)
 100c55c:	10800017 	ldw	r2,0(r2)
 100c560:	e0bff615 	stw	r2,-40(fp)
 100c564:	e0bffc17 	ldw	r2,-16(fp)
 100c568:	10c00404 	addi	r3,r2,16
 100c56c:	e0bff617 	ldw	r2,-40(fp)
 100c570:	18bfb41e 	bne	r3,r2,100c444 <__alt_data_end+0xff00c444>

		} else {
			return NULL;
		}
	}
	return NULL;
 100c574:	0005883a 	mov	r2,zero
}
 100c578:	e037883a 	mov	sp,fp
 100c57c:	dfc00117 	ldw	ra,4(sp)
 100c580:	df000017 	ldw	fp,0(sp)
 100c584:	dec00204 	addi	sp,sp,8
 100c588:	f800283a 	ret

0100c58c <remoteproc_datopa>:

static metal_phys_addr_t
remoteproc_datopa(struct remoteproc_mem *mem, metal_phys_addr_t da)
{
 100c58c:	defffc04 	addi	sp,sp,-16
 100c590:	df000315 	stw	fp,12(sp)
 100c594:	df000304 	addi	fp,sp,12
 100c598:	e13ffe15 	stw	r4,-8(fp)
 100c59c:	e17fff15 	stw	r5,-4(fp)
	metal_phys_addr_t pa;

	pa = mem->pa + da - mem->da;
 100c5a0:	e0bffe17 	ldw	r2,-8(fp)
 100c5a4:	10c00117 	ldw	r3,4(r2)
 100c5a8:	e0bfff17 	ldw	r2,-4(fp)
 100c5ac:	1887883a 	add	r3,r3,r2
 100c5b0:	e0bffe17 	ldw	r2,-8(fp)
 100c5b4:	10800017 	ldw	r2,0(r2)
 100c5b8:	1885c83a 	sub	r2,r3,r2
 100c5bc:	e0bffd15 	stw	r2,-12(fp)
	return pa;
 100c5c0:	e0bffd17 	ldw	r2,-12(fp)
}
 100c5c4:	e037883a 	mov	sp,fp
 100c5c8:	df000017 	ldw	fp,0(sp)
 100c5cc:	dec00104 	addi	sp,sp,4
 100c5d0:	f800283a 	ret

0100c5d4 <remoteproc_patoda>:

static metal_phys_addr_t
remoteproc_patoda(struct remoteproc_mem *mem, metal_phys_addr_t pa)
{
 100c5d4:	defffc04 	addi	sp,sp,-16
 100c5d8:	df000315 	stw	fp,12(sp)
 100c5dc:	df000304 	addi	fp,sp,12
 100c5e0:	e13ffe15 	stw	r4,-8(fp)
 100c5e4:	e17fff15 	stw	r5,-4(fp)
	metal_phys_addr_t da;

	da = mem->da + pa - mem->pa;
 100c5e8:	e0bffe17 	ldw	r2,-8(fp)
 100c5ec:	10c00017 	ldw	r3,0(r2)
 100c5f0:	e0bfff17 	ldw	r2,-4(fp)
 100c5f4:	1887883a 	add	r3,r3,r2
 100c5f8:	e0bffe17 	ldw	r2,-8(fp)
 100c5fc:	10800117 	ldw	r2,4(r2)
 100c600:	1885c83a 	sub	r2,r3,r2
 100c604:	e0bffd15 	stw	r2,-12(fp)
	return da;
 100c608:	e0bffd17 	ldw	r2,-12(fp)
}
 100c60c:	e037883a 	mov	sp,fp
 100c610:	df000017 	ldw	fp,0(sp)
 100c614:	dec00104 	addi	sp,sp,4
 100c618:	f800283a 	ret

0100c61c <remoteproc_get_rsc_table>:
static void *remoteproc_get_rsc_table(struct remoteproc *rproc,
				      void *store,
				      struct image_store_ops *store_ops,
				      size_t offset,
				      size_t len)
{
 100c61c:	defff404 	addi	sp,sp,-48
 100c620:	dfc00b15 	stw	ra,44(sp)
 100c624:	df000a15 	stw	fp,40(sp)
 100c628:	df000a04 	addi	fp,sp,40
 100c62c:	e13ffc15 	stw	r4,-16(fp)
 100c630:	e17ffd15 	stw	r5,-12(fp)
 100c634:	e1bffe15 	stw	r6,-8(fp)
 100c638:	e1ffff15 	stw	r7,-4(fp)
	int ret;
	void *rsc_table = NULL;
 100c63c:	e03ff915 	stw	zero,-28(fp)
	const void *img_data;

	/* Copy the resource table to local memory,
	 * the caller should be responsible to release the memory
	 */
	rsc_table = metal_allocate_memory(len);
 100c640:	e1000217 	ldw	r4,8(fp)
 100c644:	100bbf40 	call	100bbf4 <metal_allocate_memory>
 100c648:	e0bff915 	stw	r2,-28(fp)
	if (!rsc_table) {
 100c64c:	e0bff917 	ldw	r2,-28(fp)
 100c650:	1000031e 	bne	r2,zero,100c660 <remoteproc_get_rsc_table+0x44>
		return RPROC_ERR_PTR(-RPROC_ENOMEM);
 100c654:	013fffc4 	movi	r4,-1
 100c658:	100c30c0 	call	100c30c <RPROC_ERR_PTR>
 100c65c:	00004106 	br	100c764 <remoteproc_get_rsc_table+0x148>
	}
	ret = store_ops->load(store, offset, len, &img_data, RPROC_LOAD_ANYADDR,
 100c660:	e0bffe17 	ldw	r2,-8(fp)
 100c664:	10800217 	ldw	r2,8(r2)
 100c668:	e13ffb04 	addi	r4,fp,-20
 100c66c:	00c00044 	movi	r3,1
 100c670:	d8c00215 	stw	r3,8(sp)
 100c674:	d8000115 	stw	zero,4(sp)
 100c678:	00ffffc4 	movi	r3,-1
 100c67c:	d8c00015 	stw	r3,0(sp)
 100c680:	200f883a 	mov	r7,r4
 100c684:	e1800217 	ldw	r6,8(fp)
 100c688:	e17fff17 	ldw	r5,-4(fp)
 100c68c:	e13ffd17 	ldw	r4,-12(fp)
 100c690:	103ee83a 	callr	r2
 100c694:	e0bffa15 	stw	r2,-24(fp)
			      NULL, 1);
	if (ret < 0 || ret < (int)len || img_data == NULL) {
 100c698:	e0bffa17 	ldw	r2,-24(fp)
 100c69c:	10000516 	blt	r2,zero,100c6b4 <remoteproc_get_rsc_table+0x98>
 100c6a0:	e0800217 	ldw	r2,8(fp)
 100c6a4:	e0fffa17 	ldw	r3,-24(fp)
 100c6a8:	18800216 	blt	r3,r2,100c6b4 <remoteproc_get_rsc_table+0x98>
 100c6ac:	e0bffb17 	ldw	r2,-20(fp)
 100c6b0:	1000161e 	bne	r2,zero,100c70c <remoteproc_get_rsc_table+0xf0>
		metal_log(METAL_LOG_ERROR,
 100c6b4:	008060f4 	movhi	r2,387
 100c6b8:	10baf104 	addi	r2,r2,-5180
 100c6bc:	10800017 	ldw	r2,0(r2)
 100c6c0:	108000f0 	cmpltui	r2,r2,3
 100c6c4:	10000d1e 	bne	r2,zero,100c6fc <remoteproc_get_rsc_table+0xe0>
 100c6c8:	008060f4 	movhi	r2,387
 100c6cc:	10baf104 	addi	r2,r2,-5180
 100c6d0:	10800117 	ldw	r2,4(r2)
 100c6d4:	10000926 	beq	r2,zero,100c6fc <remoteproc_get_rsc_table+0xe0>
 100c6d8:	008060f4 	movhi	r2,387
 100c6dc:	10baf104 	addi	r2,r2,-5180
 100c6e0:	10800117 	ldw	r2,4(r2)
 100c6e4:	e1c00217 	ldw	r7,8(fp)
 100c6e8:	e1bfff17 	ldw	r6,-4(fp)
 100c6ec:	014040f4 	movhi	r5,259
 100c6f0:	2965b104 	addi	r5,r5,-26940
 100c6f4:	010000c4 	movi	r4,3
 100c6f8:	103ee83a 	callr	r2
			  "get rsc failed: 0x%llx, 0x%llx\r\n", offset, len);
		rsc_table = RPROC_ERR_PTR(-RPROC_EINVAL);
 100c6fc:	013fff84 	movi	r4,-2
 100c700:	100c30c0 	call	100c30c <RPROC_ERR_PTR>
 100c704:	e0bff915 	stw	r2,-28(fp)
		goto error;
 100c708:	00001306 	br	100c758 <remoteproc_get_rsc_table+0x13c>
	}
	memcpy(rsc_table, img_data, len);
 100c70c:	e0bffb17 	ldw	r2,-20(fp)
 100c710:	e1800217 	ldw	r6,8(fp)
 100c714:	100b883a 	mov	r5,r2
 100c718:	e13ff917 	ldw	r4,-28(fp)
 100c71c:	10158f40 	call	10158f4 <memcpy>

	ret = handle_rsc_table(rproc, rsc_table, len, NULL);
 100c720:	000f883a 	mov	r7,zero
 100c724:	e1800217 	ldw	r6,8(fp)
 100c728:	e17ff917 	ldw	r5,-28(fp)
 100c72c:	e13ffc17 	ldw	r4,-16(fp)
 100c730:	100fbf80 	call	100fbf8 <handle_rsc_table>
 100c734:	e0bffa15 	stw	r2,-24(fp)
	if (ret < 0) {
 100c738:	e0bffa17 	ldw	r2,-24(fp)
 100c73c:	1000040e 	bge	r2,zero,100c750 <remoteproc_get_rsc_table+0x134>
		rsc_table = RPROC_ERR_PTR(ret);
 100c740:	e13ffa17 	ldw	r4,-24(fp)
 100c744:	100c30c0 	call	100c30c <RPROC_ERR_PTR>
 100c748:	e0bff915 	stw	r2,-28(fp)
		goto error;
 100c74c:	00000206 	br	100c758 <remoteproc_get_rsc_table+0x13c>
	}
	return rsc_table;
 100c750:	e0bff917 	ldw	r2,-28(fp)
 100c754:	00000306 	br	100c764 <remoteproc_get_rsc_table+0x148>

error:
	metal_free_memory(rsc_table);
 100c758:	e13ff917 	ldw	r4,-28(fp)
 100c75c:	100bc240 	call	100bc24 <metal_free_memory>
	return rsc_table;
 100c760:	e0bff917 	ldw	r2,-28(fp)
}
 100c764:	e037883a 	mov	sp,fp
 100c768:	dfc00117 	ldw	ra,4(sp)
 100c76c:	df000017 	ldw	fp,0(sp)
 100c770:	dec00204 	addi	sp,sp,8
 100c774:	f800283a 	ret

0100c778 <remoteproc_parse_rsc_table>:

static int remoteproc_parse_rsc_table(struct remoteproc *rproc,
				      struct resource_table *rsc_table,
				      size_t rsc_size)
{
 100c778:	defffa04 	addi	sp,sp,-24
 100c77c:	dfc00515 	stw	ra,20(sp)
 100c780:	df000415 	stw	fp,16(sp)
 100c784:	df000404 	addi	fp,sp,16
 100c788:	e13ffd15 	stw	r4,-12(fp)
 100c78c:	e17ffe15 	stw	r5,-8(fp)
 100c790:	e1bfff15 	stw	r6,-4(fp)
	struct metal_io_region *io;

	io = remoteproc_get_io_with_va(rproc, rsc_table);
 100c794:	e17ffe17 	ldw	r5,-8(fp)
 100c798:	e13ffd17 	ldw	r4,-12(fp)
 100c79c:	100cdac0 	call	100cdac <remoteproc_get_io_with_va>
 100c7a0:	e0bffc15 	stw	r2,-16(fp)
	return handle_rsc_table(rproc, rsc_table, rsc_size, io);
 100c7a4:	e1fffc17 	ldw	r7,-16(fp)
 100c7a8:	e1bfff17 	ldw	r6,-4(fp)
 100c7ac:	e17ffe17 	ldw	r5,-8(fp)
 100c7b0:	e13ffd17 	ldw	r4,-12(fp)
 100c7b4:	100fbf80 	call	100fbf8 <handle_rsc_table>
}
 100c7b8:	e037883a 	mov	sp,fp
 100c7bc:	dfc00117 	ldw	ra,4(sp)
 100c7c0:	df000017 	ldw	fp,0(sp)
 100c7c4:	dec00204 	addi	sp,sp,8
 100c7c8:	f800283a 	ret

0100c7cc <remoteproc_set_rsc_table>:

int remoteproc_set_rsc_table(struct remoteproc *rproc,
			     struct resource_table *rsc_table,
			     size_t rsc_size)
{
 100c7cc:	defff904 	addi	sp,sp,-28
 100c7d0:	dfc00615 	stw	ra,24(sp)
 100c7d4:	df000515 	stw	fp,20(sp)
 100c7d8:	df000504 	addi	fp,sp,20
 100c7dc:	e13ffd15 	stw	r4,-12(fp)
 100c7e0:	e17ffe15 	stw	r5,-8(fp)
 100c7e4:	e1bfff15 	stw	r6,-4(fp)
	int ret;
	struct metal_io_region *io;

	io = remoteproc_get_io_with_va(rproc, rsc_table);
 100c7e8:	e17ffe17 	ldw	r5,-8(fp)
 100c7ec:	e13ffd17 	ldw	r4,-12(fp)
 100c7f0:	100cdac0 	call	100cdac <remoteproc_get_io_with_va>
 100c7f4:	e0bffb15 	stw	r2,-20(fp)
	if (!io)
 100c7f8:	e0bffb17 	ldw	r2,-20(fp)
 100c7fc:	1000021e 	bne	r2,zero,100c808 <remoteproc_set_rsc_table+0x3c>
		return -RPROC_EINVAL;
 100c800:	00bfff84 	movi	r2,-2
 100c804:	00001106 	br	100c84c <remoteproc_set_rsc_table+0x80>
	ret = remoteproc_parse_rsc_table(rproc, rsc_table, rsc_size);
 100c808:	e1bfff17 	ldw	r6,-4(fp)
 100c80c:	e17ffe17 	ldw	r5,-8(fp)
 100c810:	e13ffd17 	ldw	r4,-12(fp)
 100c814:	100c7780 	call	100c778 <remoteproc_parse_rsc_table>
 100c818:	e0bffc15 	stw	r2,-16(fp)
	if (!ret) {
 100c81c:	e0bffc17 	ldw	r2,-16(fp)
 100c820:	1000091e 	bne	r2,zero,100c848 <remoteproc_set_rsc_table+0x7c>
		rproc->rsc_table = rsc_table;
 100c824:	e0bffd17 	ldw	r2,-12(fp)
 100c828:	e0fffe17 	ldw	r3,-8(fp)
 100c82c:	10c00115 	stw	r3,4(r2)
		rproc->rsc_len = rsc_size;
 100c830:	e0bffd17 	ldw	r2,-12(fp)
 100c834:	e0ffff17 	ldw	r3,-4(fp)
 100c838:	10c00215 	stw	r3,8(r2)
		rproc->rsc_io = io;
 100c83c:	e0bffd17 	ldw	r2,-12(fp)
 100c840:	e0fffb17 	ldw	r3,-20(fp)
 100c844:	10c00315 	stw	r3,12(r2)
	}
	return ret;
 100c848:	e0bffc17 	ldw	r2,-16(fp)
}
 100c84c:	e037883a 	mov	sp,fp
 100c850:	dfc00117 	ldw	ra,4(sp)
 100c854:	df000017 	ldw	fp,0(sp)
 100c858:	dec00204 	addi	sp,sp,8
 100c85c:	f800283a 	ret

0100c860 <remoteproc_init>:

struct remoteproc *remoteproc_init(struct remoteproc *rproc,
				   struct remoteproc_ops *ops, void *priv)
{
 100c860:	defffb04 	addi	sp,sp,-20
 100c864:	dfc00415 	stw	ra,16(sp)
 100c868:	df000315 	stw	fp,12(sp)
 100c86c:	df000304 	addi	fp,sp,12
 100c870:	e13ffd15 	stw	r4,-12(fp)
 100c874:	e17ffe15 	stw	r5,-8(fp)
 100c878:	e1bfff15 	stw	r6,-4(fp)
	if (rproc) {
 100c87c:	e0bffd17 	ldw	r2,-12(fp)
 100c880:	10001126 	beq	r2,zero,100c8c8 <remoteproc_init+0x68>
		memset(rproc, 0, sizeof(*rproc));
 100c884:	01800e04 	movi	r6,56
 100c888:	000b883a 	mov	r5,zero
 100c88c:	e13ffd17 	ldw	r4,-12(fp)
 100c890:	1015a3c0 	call	1015a3c <memset>
		rproc->state = RPROC_OFFLINE;
 100c894:	e0bffd17 	ldw	r2,-12(fp)
 100c898:	10000c15 	stw	zero,48(r2)
		metal_mutex_init(&rproc->lock);
 100c89c:	e0bffd17 	ldw	r2,-12(fp)
 100c8a0:	1009883a 	mov	r4,r2
 100c8a4:	100c2700 	call	100c270 <metal_mutex_init>
		metal_list_init(&rproc->mems);
 100c8a8:	e0bffd17 	ldw	r2,-12(fp)
 100c8ac:	10800404 	addi	r2,r2,16
 100c8b0:	1009883a 	mov	r4,r2
 100c8b4:	100bdd40 	call	100bdd4 <metal_list_init>
		metal_list_init(&rproc->vdevs);
 100c8b8:	e0bffd17 	ldw	r2,-12(fp)
 100c8bc:	10800604 	addi	r2,r2,24
 100c8c0:	1009883a 	mov	r4,r2
 100c8c4:	100bdd40 	call	100bdd4 <metal_list_init>
	}
	rproc = ops->init(rproc, ops, priv);
 100c8c8:	e0bffe17 	ldw	r2,-8(fp)
 100c8cc:	10800017 	ldw	r2,0(r2)
 100c8d0:	e1bfff17 	ldw	r6,-4(fp)
 100c8d4:	e17ffe17 	ldw	r5,-8(fp)
 100c8d8:	e13ffd17 	ldw	r4,-12(fp)
 100c8dc:	103ee83a 	callr	r2
 100c8e0:	e0bffd15 	stw	r2,-12(fp)
	return rproc;
 100c8e4:	e0bffd17 	ldw	r2,-12(fp)
}
 100c8e8:	e037883a 	mov	sp,fp
 100c8ec:	dfc00117 	ldw	ra,4(sp)
 100c8f0:	df000017 	ldw	fp,0(sp)
 100c8f4:	dec00204 	addi	sp,sp,8
 100c8f8:	f800283a 	ret

0100c8fc <remoteproc_remove>:

int remoteproc_remove(struct remoteproc *rproc)
{
 100c8fc:	defffc04 	addi	sp,sp,-16
 100c900:	dfc00315 	stw	ra,12(sp)
 100c904:	df000215 	stw	fp,8(sp)
 100c908:	df000204 	addi	fp,sp,8
 100c90c:	e13fff15 	stw	r4,-4(fp)
	int ret;

	if (rproc) {
 100c910:	e0bfff17 	ldw	r2,-4(fp)
 100c914:	10001226 	beq	r2,zero,100c960 <remoteproc_remove+0x64>
		metal_mutex_acquire(&rproc->lock);
 100c918:	e0bfff17 	ldw	r2,-4(fp)
 100c91c:	1009883a 	mov	r4,r2
 100c920:	100c2a40 	call	100c2a4 <metal_mutex_acquire>
		if (rproc->state == RPROC_OFFLINE)
 100c924:	e0bfff17 	ldw	r2,-4(fp)
 100c928:	10800c17 	ldw	r2,48(r2)
 100c92c:	1000061e 	bne	r2,zero,100c948 <remoteproc_remove+0x4c>
			rproc->ops->remove(rproc);
 100c930:	e0bfff17 	ldw	r2,-4(fp)
 100c934:	10800917 	ldw	r2,36(r2)
 100c938:	10800117 	ldw	r2,4(r2)
 100c93c:	e13fff17 	ldw	r4,-4(fp)
 100c940:	103ee83a 	callr	r2
 100c944:	00000206 	br	100c950 <remoteproc_remove+0x54>
		else
			ret = -RPROC_EAGAIN;
 100c948:	00bfff04 	movi	r2,-4
 100c94c:	e0bffe15 	stw	r2,-8(fp)
		metal_mutex_release(&rproc->lock);
 100c950:	e0bfff17 	ldw	r2,-4(fp)
 100c954:	1009883a 	mov	r4,r2
 100c958:	100c2d80 	call	100c2d8 <metal_mutex_release>
 100c95c:	00000206 	br	100c968 <remoteproc_remove+0x6c>
	} else {
		ret = -RPROC_EINVAL;
 100c960:	00bfff84 	movi	r2,-2
 100c964:	e0bffe15 	stw	r2,-8(fp)
	}
	return ret;
 100c968:	e0bffe17 	ldw	r2,-8(fp)
}
 100c96c:	e037883a 	mov	sp,fp
 100c970:	dfc00117 	ldw	ra,4(sp)
 100c974:	df000017 	ldw	fp,0(sp)
 100c978:	dec00204 	addi	sp,sp,8
 100c97c:	f800283a 	ret

0100c980 <remoteproc_config>:

int remoteproc_config(struct remoteproc *rproc, void *data)
{
 100c980:	defffb04 	addi	sp,sp,-20
 100c984:	dfc00415 	stw	ra,16(sp)
 100c988:	df000315 	stw	fp,12(sp)
 100c98c:	df000304 	addi	fp,sp,12
 100c990:	e13ffe15 	stw	r4,-8(fp)
 100c994:	e17fff15 	stw	r5,-4(fp)
	int ret = -RPROC_ENODEV;
 100c998:	00bfff44 	movi	r2,-3
 100c99c:	e0bffd15 	stw	r2,-12(fp)

	if (rproc) {
 100c9a0:	e0bffe17 	ldw	r2,-8(fp)
 100c9a4:	10001c26 	beq	r2,zero,100ca18 <remoteproc_config+0x98>
		metal_mutex_acquire(&rproc->lock);
 100c9a8:	e0bffe17 	ldw	r2,-8(fp)
 100c9ac:	1009883a 	mov	r4,r2
 100c9b0:	100c2a40 	call	100c2a4 <metal_mutex_acquire>
		if (rproc->state == RPROC_OFFLINE) {
 100c9b4:	e0bffe17 	ldw	r2,-8(fp)
 100c9b8:	10800c17 	ldw	r2,48(r2)
 100c9bc:	1000111e 	bne	r2,zero,100ca04 <remoteproc_config+0x84>
			/* configure operation is allowed if the state is
			 * offline or ready. This function can be called
			 * multiple times before start the remote.
			 */
			if (rproc->ops->config)
 100c9c0:	e0bffe17 	ldw	r2,-8(fp)
 100c9c4:	10800917 	ldw	r2,36(r2)
 100c9c8:	10800417 	ldw	r2,16(r2)
 100c9cc:	10000826 	beq	r2,zero,100c9f0 <remoteproc_config+0x70>
				ret = rproc->ops->config(rproc, data);
 100c9d0:	e0bffe17 	ldw	r2,-8(fp)
 100c9d4:	10800917 	ldw	r2,36(r2)
 100c9d8:	10800417 	ldw	r2,16(r2)
 100c9dc:	e17fff17 	ldw	r5,-4(fp)
 100c9e0:	e13ffe17 	ldw	r4,-8(fp)
 100c9e4:	103ee83a 	callr	r2
 100c9e8:	e0bffd15 	stw	r2,-12(fp)
 100c9ec:	00000106 	br	100c9f4 <remoteproc_config+0x74>
			else
				ret = 0;
 100c9f0:	e03ffd15 	stw	zero,-12(fp)
			rproc->state = RPROC_READY;
 100c9f4:	e0bffe17 	ldw	r2,-8(fp)
 100c9f8:	00c00084 	movi	r3,2
 100c9fc:	10c00c15 	stw	r3,48(r2)
 100ca00:	00000206 	br	100ca0c <remoteproc_config+0x8c>
		} else {
			ret = -RPROC_EINVAL;
 100ca04:	00bfff84 	movi	r2,-2
 100ca08:	e0bffd15 	stw	r2,-12(fp)
		}
		metal_mutex_release(&rproc->lock);
 100ca0c:	e0bffe17 	ldw	r2,-8(fp)
 100ca10:	1009883a 	mov	r4,r2
 100ca14:	100c2d80 	call	100c2d8 <metal_mutex_release>
	}
	return ret;
 100ca18:	e0bffd17 	ldw	r2,-12(fp)
}
 100ca1c:	e037883a 	mov	sp,fp
 100ca20:	dfc00117 	ldw	ra,4(sp)
 100ca24:	df000017 	ldw	fp,0(sp)
 100ca28:	dec00204 	addi	sp,sp,8
 100ca2c:	f800283a 	ret

0100ca30 <remoteproc_start>:

int remoteproc_start(struct remoteproc *rproc)
{
 100ca30:	defffc04 	addi	sp,sp,-16
 100ca34:	dfc00315 	stw	ra,12(sp)
 100ca38:	df000215 	stw	fp,8(sp)
 100ca3c:	df000204 	addi	fp,sp,8
 100ca40:	e13fff15 	stw	r4,-4(fp)
	int ret = -RPROC_ENODEV;
 100ca44:	00bfff44 	movi	r2,-3
 100ca48:	e0bffe15 	stw	r2,-8(fp)

	if (rproc) {
 100ca4c:	e0bfff17 	ldw	r2,-4(fp)
 100ca50:	10001626 	beq	r2,zero,100caac <remoteproc_start+0x7c>
		metal_mutex_acquire(&rproc->lock);
 100ca54:	e0bfff17 	ldw	r2,-4(fp)
 100ca58:	1009883a 	mov	r4,r2
 100ca5c:	100c2a40 	call	100c2a4 <metal_mutex_acquire>
		if (rproc->state == RPROC_READY) {
 100ca60:	e0bfff17 	ldw	r2,-4(fp)
 100ca64:	10800c17 	ldw	r2,48(r2)
 100ca68:	10800098 	cmpnei	r2,r2,2
 100ca6c:	10000a1e 	bne	r2,zero,100ca98 <remoteproc_start+0x68>
			ret = rproc->ops->start(rproc);
 100ca70:	e0bfff17 	ldw	r2,-4(fp)
 100ca74:	10800917 	ldw	r2,36(r2)
 100ca78:	10800517 	ldw	r2,20(r2)
 100ca7c:	e13fff17 	ldw	r4,-4(fp)
 100ca80:	103ee83a 	callr	r2
 100ca84:	e0bffe15 	stw	r2,-8(fp)
			rproc->state = RPROC_RUNNING;
 100ca88:	e0bfff17 	ldw	r2,-4(fp)
 100ca8c:	00c000c4 	movi	r3,3
 100ca90:	10c00c15 	stw	r3,48(r2)
 100ca94:	00000206 	br	100caa0 <remoteproc_start+0x70>
		} else {
			ret = -RPROC_EINVAL;
 100ca98:	00bfff84 	movi	r2,-2
 100ca9c:	e0bffe15 	stw	r2,-8(fp)
		}
		metal_mutex_release(&rproc->lock);
 100caa0:	e0bfff17 	ldw	r2,-4(fp)
 100caa4:	1009883a 	mov	r4,r2
 100caa8:	100c2d80 	call	100c2d8 <metal_mutex_release>
	}
	return ret;
 100caac:	e0bffe17 	ldw	r2,-8(fp)
}
 100cab0:	e037883a 	mov	sp,fp
 100cab4:	dfc00117 	ldw	ra,4(sp)
 100cab8:	df000017 	ldw	fp,0(sp)
 100cabc:	dec00204 	addi	sp,sp,8
 100cac0:	f800283a 	ret

0100cac4 <remoteproc_stop>:

int remoteproc_stop(struct remoteproc *rproc)
{
 100cac4:	defffc04 	addi	sp,sp,-16
 100cac8:	dfc00315 	stw	ra,12(sp)
 100cacc:	df000215 	stw	fp,8(sp)
 100cad0:	df000204 	addi	fp,sp,8
 100cad4:	e13fff15 	stw	r4,-4(fp)
	int ret = -RPROC_ENODEV;
 100cad8:	00bfff44 	movi	r2,-3
 100cadc:	e0bffe15 	stw	r2,-8(fp)

	if (rproc) {
 100cae0:	e0bfff17 	ldw	r2,-4(fp)
 100cae4:	10001c26 	beq	r2,zero,100cb58 <remoteproc_stop+0x94>
		metal_mutex_acquire(&rproc->lock);
 100cae8:	e0bfff17 	ldw	r2,-4(fp)
 100caec:	1009883a 	mov	r4,r2
 100caf0:	100c2a40 	call	100c2a4 <metal_mutex_acquire>
		if (rproc->state != RPROC_STOPPED &&
 100caf4:	e0bfff17 	ldw	r2,-4(fp)
 100caf8:	10800c17 	ldw	r2,48(r2)
 100cafc:	108001a0 	cmpeqi	r2,r2,6
 100cb00:	1000111e 	bne	r2,zero,100cb48 <remoteproc_stop+0x84>
		    rproc->state != RPROC_OFFLINE) {
 100cb04:	e0bfff17 	ldw	r2,-4(fp)
 100cb08:	10800c17 	ldw	r2,48(r2)
{
	int ret = -RPROC_ENODEV;

	if (rproc) {
		metal_mutex_acquire(&rproc->lock);
		if (rproc->state != RPROC_STOPPED &&
 100cb0c:	10000e26 	beq	r2,zero,100cb48 <remoteproc_stop+0x84>
		    rproc->state != RPROC_OFFLINE) {
			if (rproc->ops->stop)
 100cb10:	e0bfff17 	ldw	r2,-4(fp)
 100cb14:	10800917 	ldw	r2,36(r2)
 100cb18:	10800617 	ldw	r2,24(r2)
 100cb1c:	10000626 	beq	r2,zero,100cb38 <remoteproc_stop+0x74>
				ret = rproc->ops->stop(rproc);
 100cb20:	e0bfff17 	ldw	r2,-4(fp)
 100cb24:	10800917 	ldw	r2,36(r2)
 100cb28:	10800617 	ldw	r2,24(r2)
 100cb2c:	e13fff17 	ldw	r4,-4(fp)
 100cb30:	103ee83a 	callr	r2
 100cb34:	e0bffe15 	stw	r2,-8(fp)
			rproc->state = RPROC_STOPPED;
 100cb38:	e0bfff17 	ldw	r2,-4(fp)
 100cb3c:	00c00184 	movi	r3,6
 100cb40:	10c00c15 	stw	r3,48(r2)
 100cb44:	00000106 	br	100cb4c <remoteproc_stop+0x88>
		} else {
			ret = 0;
 100cb48:	e03ffe15 	stw	zero,-8(fp)
		}
		metal_mutex_release(&rproc->lock);
 100cb4c:	e0bfff17 	ldw	r2,-4(fp)
 100cb50:	1009883a 	mov	r4,r2
 100cb54:	100c2d80 	call	100c2d8 <metal_mutex_release>
	}
	return ret;
 100cb58:	e0bffe17 	ldw	r2,-8(fp)
}
 100cb5c:	e037883a 	mov	sp,fp
 100cb60:	dfc00117 	ldw	ra,4(sp)
 100cb64:	df000017 	ldw	fp,0(sp)
 100cb68:	dec00204 	addi	sp,sp,8
 100cb6c:	f800283a 	ret

0100cb70 <remoteproc_shutdown>:

int remoteproc_shutdown(struct remoteproc *rproc)
{
 100cb70:	defffc04 	addi	sp,sp,-16
 100cb74:	dfc00315 	stw	ra,12(sp)
 100cb78:	df000215 	stw	fp,8(sp)
 100cb7c:	df000204 	addi	fp,sp,8
 100cb80:	e13fff15 	stw	r4,-4(fp)
	int ret = -RPROC_ENODEV;
 100cb84:	00bfff44 	movi	r2,-3
 100cb88:	e0bffe15 	stw	r2,-8(fp)

	if (rproc) {
 100cb8c:	e0bfff17 	ldw	r2,-4(fp)
 100cb90:	10002826 	beq	r2,zero,100cc34 <remoteproc_shutdown+0xc4>
		ret = 0;
 100cb94:	e03ffe15 	stw	zero,-8(fp)
		metal_mutex_acquire(&rproc->lock);
 100cb98:	e0bfff17 	ldw	r2,-4(fp)
 100cb9c:	1009883a 	mov	r4,r2
 100cba0:	100c2a40 	call	100c2a4 <metal_mutex_acquire>
		if (rproc->state != RPROC_OFFLINE) {
 100cba4:	e0bfff17 	ldw	r2,-4(fp)
 100cba8:	10800c17 	ldw	r2,48(r2)
 100cbac:	10001e26 	beq	r2,zero,100cc28 <remoteproc_shutdown+0xb8>
			if (rproc->state != RPROC_STOPPED) {
 100cbb0:	e0bfff17 	ldw	r2,-4(fp)
 100cbb4:	10800c17 	ldw	r2,48(r2)
 100cbb8:	108001a0 	cmpeqi	r2,r2,6
 100cbbc:	10000a1e 	bne	r2,zero,100cbe8 <remoteproc_shutdown+0x78>
				if (rproc->ops->stop)
 100cbc0:	e0bfff17 	ldw	r2,-4(fp)
 100cbc4:	10800917 	ldw	r2,36(r2)
 100cbc8:	10800617 	ldw	r2,24(r2)
 100cbcc:	10000626 	beq	r2,zero,100cbe8 <remoteproc_shutdown+0x78>
					ret = rproc->ops->stop(rproc);
 100cbd0:	e0bfff17 	ldw	r2,-4(fp)
 100cbd4:	10800917 	ldw	r2,36(r2)
 100cbd8:	10800617 	ldw	r2,24(r2)
 100cbdc:	e13fff17 	ldw	r4,-4(fp)
 100cbe0:	103ee83a 	callr	r2
 100cbe4:	e0bffe15 	stw	r2,-8(fp)
			}
			if (!ret) {
 100cbe8:	e0bffe17 	ldw	r2,-8(fp)
 100cbec:	10000e1e 	bne	r2,zero,100cc28 <remoteproc_shutdown+0xb8>
				if (rproc->ops->shutdown)
 100cbf0:	e0bfff17 	ldw	r2,-4(fp)
 100cbf4:	10800917 	ldw	r2,36(r2)
 100cbf8:	10800717 	ldw	r2,28(r2)
 100cbfc:	10000626 	beq	r2,zero,100cc18 <remoteproc_shutdown+0xa8>
					ret = rproc->ops->shutdown(rproc);
 100cc00:	e0bfff17 	ldw	r2,-4(fp)
 100cc04:	10800917 	ldw	r2,36(r2)
 100cc08:	10800717 	ldw	r2,28(r2)
 100cc0c:	e13fff17 	ldw	r4,-4(fp)
 100cc10:	103ee83a 	callr	r2
 100cc14:	e0bffe15 	stw	r2,-8(fp)
				if (!ret) {
 100cc18:	e0bffe17 	ldw	r2,-8(fp)
 100cc1c:	1000021e 	bne	r2,zero,100cc28 <remoteproc_shutdown+0xb8>
					rproc->state = RPROC_OFFLINE;
 100cc20:	e0bfff17 	ldw	r2,-4(fp)
 100cc24:	10000c15 	stw	zero,48(r2)
				}
			}
		}
		metal_mutex_release(&rproc->lock);
 100cc28:	e0bfff17 	ldw	r2,-4(fp)
 100cc2c:	1009883a 	mov	r4,r2
 100cc30:	100c2d80 	call	100c2d8 <metal_mutex_release>
	}
	return ret;
 100cc34:	e0bffe17 	ldw	r2,-8(fp)
}
 100cc38:	e037883a 	mov	sp,fp
 100cc3c:	dfc00117 	ldw	ra,4(sp)
 100cc40:	df000017 	ldw	fp,0(sp)
 100cc44:	dec00204 	addi	sp,sp,8
 100cc48:	f800283a 	ret

0100cc4c <remoteproc_get_io_with_name>:

struct metal_io_region *
remoteproc_get_io_with_name(struct remoteproc *rproc,
			    const char *name)
{
 100cc4c:	defff904 	addi	sp,sp,-28
 100cc50:	dfc00615 	stw	ra,24(sp)
 100cc54:	df000515 	stw	fp,20(sp)
 100cc58:	df000504 	addi	fp,sp,20
 100cc5c:	e13ffe15 	stw	r4,-8(fp)
 100cc60:	e17fff15 	stw	r5,-4(fp)
	struct remoteproc_mem *mem;

	mem = remoteproc_get_mem(rproc, name,
 100cc64:	d8000115 	stw	zero,4(sp)
 100cc68:	d8000015 	stw	zero,0(sp)
 100cc6c:	01ffffc4 	movi	r7,-1
 100cc70:	01bfffc4 	movi	r6,-1
 100cc74:	e17fff17 	ldw	r5,-4(fp)
 100cc78:	e13ffe17 	ldw	r4,-8(fp)
 100cc7c:	100c4140 	call	100c414 <remoteproc_get_mem>
 100cc80:	e0bffd15 	stw	r2,-12(fp)
				 METAL_BAD_PHYS, METAL_BAD_PHYS, NULL, 0);
	if (mem)
 100cc84:	e0bffd17 	ldw	r2,-12(fp)
 100cc88:	10000326 	beq	r2,zero,100cc98 <remoteproc_get_io_with_name+0x4c>
		return mem->io;
 100cc8c:	e0bffd17 	ldw	r2,-12(fp)
 100cc90:	10800b17 	ldw	r2,44(r2)
 100cc94:	00000106 	br	100cc9c <remoteproc_get_io_with_name+0x50>
	else
		return NULL;
 100cc98:	0005883a 	mov	r2,zero
}
 100cc9c:	e037883a 	mov	sp,fp
 100cca0:	dfc00117 	ldw	ra,4(sp)
 100cca4:	df000017 	ldw	fp,0(sp)
 100cca8:	dec00204 	addi	sp,sp,8
 100ccac:	f800283a 	ret

0100ccb0 <remoteproc_get_io_with_pa>:

struct metal_io_region *
remoteproc_get_io_with_pa(struct remoteproc *rproc,
			  metal_phys_addr_t pa)
{
 100ccb0:	defff904 	addi	sp,sp,-28
 100ccb4:	dfc00615 	stw	ra,24(sp)
 100ccb8:	df000515 	stw	fp,20(sp)
 100ccbc:	df000504 	addi	fp,sp,20
 100ccc0:	e13ffe15 	stw	r4,-8(fp)
 100ccc4:	e17fff15 	stw	r5,-4(fp)
	struct remoteproc_mem *mem;

	mem = remoteproc_get_mem(rproc, NULL, pa, METAL_BAD_PHYS, NULL, 0);
 100ccc8:	d8000115 	stw	zero,4(sp)
 100cccc:	d8000015 	stw	zero,0(sp)
 100ccd0:	01ffffc4 	movi	r7,-1
 100ccd4:	e1bfff17 	ldw	r6,-4(fp)
 100ccd8:	000b883a 	mov	r5,zero
 100ccdc:	e13ffe17 	ldw	r4,-8(fp)
 100cce0:	100c4140 	call	100c414 <remoteproc_get_mem>
 100cce4:	e0bffd15 	stw	r2,-12(fp)
	if (mem)
 100cce8:	e0bffd17 	ldw	r2,-12(fp)
 100ccec:	10000326 	beq	r2,zero,100ccfc <remoteproc_get_io_with_pa+0x4c>
		return mem->io;
 100ccf0:	e0bffd17 	ldw	r2,-12(fp)
 100ccf4:	10800b17 	ldw	r2,44(r2)
 100ccf8:	00000106 	br	100cd00 <remoteproc_get_io_with_pa+0x50>
	else
		return NULL;
 100ccfc:	0005883a 	mov	r2,zero
}
 100cd00:	e037883a 	mov	sp,fp
 100cd04:	dfc00117 	ldw	ra,4(sp)
 100cd08:	df000017 	ldw	fp,0(sp)
 100cd0c:	dec00204 	addi	sp,sp,8
 100cd10:	f800283a 	ret

0100cd14 <remoteproc_get_io_with_da>:

struct metal_io_region *
remoteproc_get_io_with_da(struct remoteproc *rproc,
			  metal_phys_addr_t da,
			  unsigned long *offset)
{
 100cd14:	defff604 	addi	sp,sp,-40
 100cd18:	dfc00915 	stw	ra,36(sp)
 100cd1c:	df000815 	stw	fp,32(sp)
 100cd20:	df000804 	addi	fp,sp,32
 100cd24:	e13ffd15 	stw	r4,-12(fp)
 100cd28:	e17ffe15 	stw	r5,-8(fp)
 100cd2c:	e1bfff15 	stw	r6,-4(fp)
	struct remoteproc_mem *mem;

	mem = remoteproc_get_mem(rproc, NULL, METAL_BAD_PHYS, da, NULL, 0);
 100cd30:	d8000115 	stw	zero,4(sp)
 100cd34:	d8000015 	stw	zero,0(sp)
 100cd38:	e1fffe17 	ldw	r7,-8(fp)
 100cd3c:	01bfffc4 	movi	r6,-1
 100cd40:	000b883a 	mov	r5,zero
 100cd44:	e13ffd17 	ldw	r4,-12(fp)
 100cd48:	100c4140 	call	100c414 <remoteproc_get_mem>
 100cd4c:	e0bffa15 	stw	r2,-24(fp)
	if (mem) {
 100cd50:	e0bffa17 	ldw	r2,-24(fp)
 100cd54:	10000f26 	beq	r2,zero,100cd94 <remoteproc_get_io_with_da+0x80>
		struct metal_io_region *io;
		metal_phys_addr_t pa;

		io = mem->io;
 100cd58:	e0bffa17 	ldw	r2,-24(fp)
 100cd5c:	10800b17 	ldw	r2,44(r2)
 100cd60:	e0bffb15 	stw	r2,-20(fp)
		pa = remoteproc_datopa(mem, da);
 100cd64:	e17ffe17 	ldw	r5,-8(fp)
 100cd68:	e13ffa17 	ldw	r4,-24(fp)
 100cd6c:	100c58c0 	call	100c58c <remoteproc_datopa>
 100cd70:	e0bffc15 	stw	r2,-16(fp)
		*offset = metal_io_phys_to_offset(io, pa);
 100cd74:	e17ffc17 	ldw	r5,-16(fp)
 100cd78:	e13ffb17 	ldw	r4,-20(fp)
 100cd7c:	100c09c0 	call	100c09c <metal_io_phys_to_offset>
 100cd80:	1007883a 	mov	r3,r2
 100cd84:	e0bfff17 	ldw	r2,-4(fp)
 100cd88:	10c00015 	stw	r3,0(r2)
		return io;
 100cd8c:	e0bffb17 	ldw	r2,-20(fp)
 100cd90:	00000106 	br	100cd98 <remoteproc_get_io_with_da+0x84>
	} else {
		return NULL;
 100cd94:	0005883a 	mov	r2,zero
	}
}
 100cd98:	e037883a 	mov	sp,fp
 100cd9c:	dfc00117 	ldw	ra,4(sp)
 100cda0:	df000017 	ldw	fp,0(sp)
 100cda4:	dec00204 	addi	sp,sp,8
 100cda8:	f800283a 	ret

0100cdac <remoteproc_get_io_with_va>:

struct metal_io_region *
remoteproc_get_io_with_va(struct remoteproc *rproc, void *va)
{
 100cdac:	defff904 	addi	sp,sp,-28
 100cdb0:	dfc00615 	stw	ra,24(sp)
 100cdb4:	df000515 	stw	fp,20(sp)
 100cdb8:	df000504 	addi	fp,sp,20
 100cdbc:	e13ffe15 	stw	r4,-8(fp)
 100cdc0:	e17fff15 	stw	r5,-4(fp)
	struct remoteproc_mem *mem;

	mem = remoteproc_get_mem(rproc, NULL, METAL_BAD_PHYS, METAL_BAD_PHYS,
 100cdc4:	d8000115 	stw	zero,4(sp)
 100cdc8:	e0bfff17 	ldw	r2,-4(fp)
 100cdcc:	d8800015 	stw	r2,0(sp)
 100cdd0:	01ffffc4 	movi	r7,-1
 100cdd4:	01bfffc4 	movi	r6,-1
 100cdd8:	000b883a 	mov	r5,zero
 100cddc:	e13ffe17 	ldw	r4,-8(fp)
 100cde0:	100c4140 	call	100c414 <remoteproc_get_mem>
 100cde4:	e0bffd15 	stw	r2,-12(fp)
				 va, 0);
	if (mem)
 100cde8:	e0bffd17 	ldw	r2,-12(fp)
 100cdec:	10000326 	beq	r2,zero,100cdfc <remoteproc_get_io_with_va+0x50>
		return mem->io;
 100cdf0:	e0bffd17 	ldw	r2,-12(fp)
 100cdf4:	10800b17 	ldw	r2,44(r2)
 100cdf8:	00000106 	br	100ce00 <remoteproc_get_io_with_va+0x54>
	else
		return NULL;
 100cdfc:	0005883a 	mov	r2,zero
}
 100ce00:	e037883a 	mov	sp,fp
 100ce04:	dfc00117 	ldw	ra,4(sp)
 100ce08:	df000017 	ldw	fp,0(sp)
 100ce0c:	dec00204 	addi	sp,sp,8
 100ce10:	f800283a 	ret

0100ce14 <remoteproc_mmap>:

void *remoteproc_mmap(struct remoteproc *rproc,
		      metal_phys_addr_t *pa, metal_phys_addr_t *da,
		      size_t size, unsigned int attribute,
		      struct metal_io_region **io)
{
 100ce14:	defff404 	addi	sp,sp,-48
 100ce18:	dfc00b15 	stw	ra,44(sp)
 100ce1c:	df000a15 	stw	fp,40(sp)
 100ce20:	df000a04 	addi	fp,sp,40
 100ce24:	e13ffc15 	stw	r4,-16(fp)
 100ce28:	e17ffd15 	stw	r5,-12(fp)
 100ce2c:	e1bffe15 	stw	r6,-8(fp)
 100ce30:	e1ffff15 	stw	r7,-4(fp)
	void *va = NULL;
 100ce34:	e03ff815 	stw	zero,-32(fp)
	metal_phys_addr_t lpa, lda;
	struct remoteproc_mem *mem;

	if (!rproc)
 100ce38:	e0bffc17 	ldw	r2,-16(fp)
 100ce3c:	1000021e 	bne	r2,zero,100ce48 <remoteproc_mmap+0x34>
		return NULL;
 100ce40:	0005883a 	mov	r2,zero
 100ce44:	00006006 	br	100cfc8 <remoteproc_mmap+0x1b4>
	else if (!pa && !da)
 100ce48:	e0bffd17 	ldw	r2,-12(fp)
 100ce4c:	1000041e 	bne	r2,zero,100ce60 <remoteproc_mmap+0x4c>
 100ce50:	e0bffe17 	ldw	r2,-8(fp)
 100ce54:	1000021e 	bne	r2,zero,100ce60 <remoteproc_mmap+0x4c>
		return NULL;
 100ce58:	0005883a 	mov	r2,zero
 100ce5c:	00005a06 	br	100cfc8 <remoteproc_mmap+0x1b4>
	if (pa)
 100ce60:	e0bffd17 	ldw	r2,-12(fp)
 100ce64:	10000426 	beq	r2,zero,100ce78 <remoteproc_mmap+0x64>
		lpa = *pa;
 100ce68:	e0bffd17 	ldw	r2,-12(fp)
 100ce6c:	10800017 	ldw	r2,0(r2)
 100ce70:	e0bffa15 	stw	r2,-24(fp)
 100ce74:	00000206 	br	100ce80 <remoteproc_mmap+0x6c>
	else
		lpa = METAL_BAD_PHYS;
 100ce78:	00bfffc4 	movi	r2,-1
 100ce7c:	e0bffa15 	stw	r2,-24(fp)
	if (da)
 100ce80:	e0bffe17 	ldw	r2,-8(fp)
 100ce84:	10000426 	beq	r2,zero,100ce98 <remoteproc_mmap+0x84>
		lda =  *da;
 100ce88:	e0bffe17 	ldw	r2,-8(fp)
 100ce8c:	10800017 	ldw	r2,0(r2)
 100ce90:	e0bffb15 	stw	r2,-20(fp)
 100ce94:	00000206 	br	100cea0 <remoteproc_mmap+0x8c>
	else
		lda = METAL_BAD_PHYS;
 100ce98:	00bfffc4 	movi	r2,-1
 100ce9c:	e0bffb15 	stw	r2,-20(fp)
	mem = remoteproc_get_mem(rproc, NULL, lpa, lda, NULL, size);
 100cea0:	e0fffa17 	ldw	r3,-24(fp)
 100cea4:	e13ffb17 	ldw	r4,-20(fp)
 100cea8:	e0bfff17 	ldw	r2,-4(fp)
 100ceac:	d8800115 	stw	r2,4(sp)
 100ceb0:	d8000015 	stw	zero,0(sp)
 100ceb4:	200f883a 	mov	r7,r4
 100ceb8:	180d883a 	mov	r6,r3
 100cebc:	000b883a 	mov	r5,zero
 100cec0:	e13ffc17 	ldw	r4,-16(fp)
 100cec4:	100c4140 	call	100c414 <remoteproc_get_mem>
 100cec8:	e0bff915 	stw	r2,-28(fp)
	if (mem) {
 100cecc:	e0bff917 	ldw	r2,-28(fp)
 100ced0:	10001f26 	beq	r2,zero,100cf50 <remoteproc_mmap+0x13c>
		if (lpa != METAL_BAD_PHYS)
 100ced4:	e0bffa17 	ldw	r2,-24(fp)
 100ced8:	10bfffe0 	cmpeqi	r2,r2,-1
 100cedc:	1000061e 	bne	r2,zero,100cef8 <remoteproc_mmap+0xe4>
			lda = remoteproc_patoda(mem, lpa);
 100cee0:	e0bffa17 	ldw	r2,-24(fp)
 100cee4:	100b883a 	mov	r5,r2
 100cee8:	e13ff917 	ldw	r4,-28(fp)
 100ceec:	100c5d40 	call	100c5d4 <remoteproc_patoda>
 100cef0:	e0bffb15 	stw	r2,-20(fp)
 100cef4:	00000806 	br	100cf18 <remoteproc_mmap+0x104>
		else if (lda != METAL_BAD_PHYS)
 100cef8:	e0bffb17 	ldw	r2,-20(fp)
 100cefc:	10bfffe0 	cmpeqi	r2,r2,-1
 100cf00:	1000051e 	bne	r2,zero,100cf18 <remoteproc_mmap+0x104>
			lpa = remoteproc_datopa(mem, lda);
 100cf04:	e0bffb17 	ldw	r2,-20(fp)
 100cf08:	100b883a 	mov	r5,r2
 100cf0c:	e13ff917 	ldw	r4,-28(fp)
 100cf10:	100c58c0 	call	100c58c <remoteproc_datopa>
 100cf14:	e0bffa15 	stw	r2,-24(fp)
		if (io)
 100cf18:	e0800317 	ldw	r2,12(fp)
 100cf1c:	10000426 	beq	r2,zero,100cf30 <remoteproc_mmap+0x11c>
			*io = mem->io;
 100cf20:	e0bff917 	ldw	r2,-28(fp)
 100cf24:	10c00b17 	ldw	r3,44(r2)
 100cf28:	e0800317 	ldw	r2,12(fp)
 100cf2c:	10c00015 	stw	r3,0(r2)
		va = metal_io_phys_to_virt(mem->io, lpa);
 100cf30:	e0bff917 	ldw	r2,-28(fp)
 100cf34:	10800b17 	ldw	r2,44(r2)
 100cf38:	e0fffa17 	ldw	r3,-24(fp)
 100cf3c:	180b883a 	mov	r5,r3
 100cf40:	1009883a 	mov	r4,r2
 100cf44:	100c1740 	call	100c174 <metal_io_phys_to_virt>
 100cf48:	e0bff815 	stw	r2,-32(fp)
 100cf4c:	00001306 	br	100cf9c <remoteproc_mmap+0x188>
	} else if (rproc->ops->mmap) {
 100cf50:	e0bffc17 	ldw	r2,-16(fp)
 100cf54:	10800917 	ldw	r2,36(r2)
 100cf58:	10800217 	ldw	r2,8(r2)
 100cf5c:	10000f26 	beq	r2,zero,100cf9c <remoteproc_mmap+0x188>
		va = rproc->ops->mmap(rproc, &lpa, &lda, size, attribute, io);
 100cf60:	e0bffc17 	ldw	r2,-16(fp)
 100cf64:	10800917 	ldw	r2,36(r2)
 100cf68:	10800217 	ldw	r2,8(r2)
 100cf6c:	e17ffb04 	addi	r5,fp,-20
 100cf70:	e13ffa04 	addi	r4,fp,-24
 100cf74:	e0c00317 	ldw	r3,12(fp)
 100cf78:	d8c00115 	stw	r3,4(sp)
 100cf7c:	e0c00217 	ldw	r3,8(fp)
 100cf80:	d8c00015 	stw	r3,0(sp)
 100cf84:	e1ffff17 	ldw	r7,-4(fp)
 100cf88:	280d883a 	mov	r6,r5
 100cf8c:	200b883a 	mov	r5,r4
 100cf90:	e13ffc17 	ldw	r4,-16(fp)
 100cf94:	103ee83a 	callr	r2
 100cf98:	e0bff815 	stw	r2,-32(fp)
	}

	if (pa)
 100cf9c:	e0bffd17 	ldw	r2,-12(fp)
 100cfa0:	10000326 	beq	r2,zero,100cfb0 <remoteproc_mmap+0x19c>
		*pa  = lpa;
 100cfa4:	e0fffa17 	ldw	r3,-24(fp)
 100cfa8:	e0bffd17 	ldw	r2,-12(fp)
 100cfac:	10c00015 	stw	r3,0(r2)
	if (da)
 100cfb0:	e0bffe17 	ldw	r2,-8(fp)
 100cfb4:	10000326 	beq	r2,zero,100cfc4 <remoteproc_mmap+0x1b0>
		*da = lda;
 100cfb8:	e0fffb17 	ldw	r3,-20(fp)
 100cfbc:	e0bffe17 	ldw	r2,-8(fp)
 100cfc0:	10c00015 	stw	r3,0(r2)
	return va;
 100cfc4:	e0bff817 	ldw	r2,-32(fp)
}
 100cfc8:	e037883a 	mov	sp,fp
 100cfcc:	dfc00117 	ldw	ra,4(sp)
 100cfd0:	df000017 	ldw	fp,0(sp)
 100cfd4:	dec00204 	addi	sp,sp,8
 100cfd8:	f800283a 	ret

0100cfdc <remoteproc_load>:

int remoteproc_load(struct remoteproc *rproc, const char *path,
		    void *store, struct image_store_ops *store_ops,
		    void **img_info)
{
 100cfdc:	deffdf04 	addi	sp,sp,-132
 100cfe0:	dfc02015 	stw	ra,128(sp)
 100cfe4:	df001f15 	stw	fp,124(sp)
 100cfe8:	df001f04 	addi	fp,sp,124
 100cfec:	e13ffc15 	stw	r4,-16(fp)
 100cff0:	e17ffd15 	stw	r5,-12(fp)
 100cff4:	e1bffe15 	stw	r6,-8(fp)
 100cff8:	e1ffff15 	stw	r7,-4(fp)
	int ret;
	struct loader_ops *loader;
	const void *img_data;
	void *limg_info = NULL;
 100cffc:	e03ff115 	stw	zero,-60(fp)
	size_t offset, noffset;
	size_t len, nlen;
	int last_load_state;
	metal_phys_addr_t da, rsc_da;
	size_t rsc_size = 0;
 100d000:	e03ff715 	stw	zero,-36(fp)
	void *rsc_table = NULL;
 100d004:	e03fec15 	stw	zero,-80(fp)
	struct metal_io_region *io = NULL;
 100d008:	e03ff815 	stw	zero,-32(fp)

	if (!rproc)
 100d00c:	e0bffc17 	ldw	r2,-16(fp)
 100d010:	1000021e 	bne	r2,zero,100d01c <remoteproc_load+0x40>
		return -RPROC_ENODEV;
 100d014:	00bfff44 	movi	r2,-3
 100d018:	00034b06 	br	100dd48 <remoteproc_load+0xd6c>

	metal_mutex_acquire(&rproc->lock);
 100d01c:	e0bffc17 	ldw	r2,-16(fp)
 100d020:	1009883a 	mov	r4,r2
 100d024:	100c2a40 	call	100c2a4 <metal_mutex_acquire>
	metal_log(METAL_LOG_DEBUG, "%s: check remoteproc status\r\n", __func__);
 100d028:	008060f4 	movhi	r2,387
 100d02c:	10baf104 	addi	r2,r2,-5180
 100d030:	10800017 	ldw	r2,0(r2)
 100d034:	108001f0 	cmpltui	r2,r2,7
 100d038:	10000d1e 	bne	r2,zero,100d070 <remoteproc_load+0x94>
 100d03c:	008060f4 	movhi	r2,387
 100d040:	10baf104 	addi	r2,r2,-5180
 100d044:	10800117 	ldw	r2,4(r2)
 100d048:	10000926 	beq	r2,zero,100d070 <remoteproc_load+0x94>
 100d04c:	008060f4 	movhi	r2,387
 100d050:	10baf104 	addi	r2,r2,-5180
 100d054:	10800117 	ldw	r2,4(r2)
 100d058:	018040f4 	movhi	r6,259
 100d05c:	31a71004 	addi	r6,r6,-25536
 100d060:	014040f4 	movhi	r5,259
 100d064:	2965ba04 	addi	r5,r5,-26904
 100d068:	010001c4 	movi	r4,7
 100d06c:	103ee83a 	callr	r2
	/* If remoteproc is not in ready state, cannot load executable */
	if (rproc->state != RPROC_READY && rproc->state != RPROC_CONFIGURED) {
 100d070:	e0bffc17 	ldw	r2,-16(fp)
 100d074:	10800c17 	ldw	r2,48(r2)
 100d078:	108000a0 	cmpeqi	r2,r2,2
 100d07c:	10001c1e 	bne	r2,zero,100d0f0 <remoteproc_load+0x114>
 100d080:	e0bffc17 	ldw	r2,-16(fp)
 100d084:	10800c17 	ldw	r2,48(r2)
 100d088:	10800060 	cmpeqi	r2,r2,1
 100d08c:	1000181e 	bne	r2,zero,100d0f0 <remoteproc_load+0x114>
		metal_log(METAL_LOG_ERROR,
 100d090:	008060f4 	movhi	r2,387
 100d094:	10baf104 	addi	r2,r2,-5180
 100d098:	10800017 	ldw	r2,0(r2)
 100d09c:	108000f0 	cmpltui	r2,r2,3
 100d0a0:	10000e1e 	bne	r2,zero,100d0dc <remoteproc_load+0x100>
 100d0a4:	008060f4 	movhi	r2,387
 100d0a8:	10baf104 	addi	r2,r2,-5180
 100d0ac:	10800117 	ldw	r2,4(r2)
 100d0b0:	10000a26 	beq	r2,zero,100d0dc <remoteproc_load+0x100>
 100d0b4:	008060f4 	movhi	r2,387
 100d0b8:	10baf104 	addi	r2,r2,-5180
 100d0bc:	10800117 	ldw	r2,4(r2)
 100d0c0:	e0fffc17 	ldw	r3,-16(fp)
 100d0c4:	18c00c17 	ldw	r3,48(r3)
 100d0c8:	180d883a 	mov	r6,r3
 100d0cc:	014040f4 	movhi	r5,259
 100d0d0:	2965c204 	addi	r5,r5,-26872
 100d0d4:	010000c4 	movi	r4,3
 100d0d8:	103ee83a 	callr	r2
			  "load failure: invalid rproc state %d.\r\n",
			  rproc->state);
		metal_mutex_release(&rproc->lock);
 100d0dc:	e0bffc17 	ldw	r2,-16(fp)
 100d0e0:	1009883a 	mov	r4,r2
 100d0e4:	100c2d80 	call	100c2d8 <metal_mutex_release>
		return -RPROC_EINVAL;
 100d0e8:	00bfff84 	movi	r2,-2
 100d0ec:	00031606 	br	100dd48 <remoteproc_load+0xd6c>
	}

	if (!store_ops) {
 100d0f0:	e0bfff17 	ldw	r2,-4(fp)
 100d0f4:	1000151e 	bne	r2,zero,100d14c <remoteproc_load+0x170>
		metal_log(METAL_LOG_ERROR,
 100d0f8:	008060f4 	movhi	r2,387
 100d0fc:	10baf104 	addi	r2,r2,-5180
 100d100:	10800017 	ldw	r2,0(r2)
 100d104:	108000f0 	cmpltui	r2,r2,3
 100d108:	10000b1e 	bne	r2,zero,100d138 <remoteproc_load+0x15c>
 100d10c:	008060f4 	movhi	r2,387
 100d110:	10baf104 	addi	r2,r2,-5180
 100d114:	10800117 	ldw	r2,4(r2)
 100d118:	10000726 	beq	r2,zero,100d138 <remoteproc_load+0x15c>
 100d11c:	008060f4 	movhi	r2,387
 100d120:	10baf104 	addi	r2,r2,-5180
 100d124:	10800117 	ldw	r2,4(r2)
 100d128:	014040f4 	movhi	r5,259
 100d12c:	2965cc04 	addi	r5,r5,-26832
 100d130:	010000c4 	movi	r4,3
 100d134:	103ee83a 	callr	r2
			  "load failure: loader ops is not set.\r\n");
		metal_mutex_release(&rproc->lock);
 100d138:	e0bffc17 	ldw	r2,-16(fp)
 100d13c:	1009883a 	mov	r4,r2
 100d140:	100c2d80 	call	100c2d8 <metal_mutex_release>
		return -RPROC_EINVAL;
 100d144:	00bfff84 	movi	r2,-2
 100d148:	0002ff06 	br	100dd48 <remoteproc_load+0xd6c>
	}

	/* Open executable to get ready to parse */
	metal_log(METAL_LOG_DEBUG, "%s: open executable image\r\n", __func__);
 100d14c:	008060f4 	movhi	r2,387
 100d150:	10baf104 	addi	r2,r2,-5180
 100d154:	10800017 	ldw	r2,0(r2)
 100d158:	108001f0 	cmpltui	r2,r2,7
 100d15c:	10000d1e 	bne	r2,zero,100d194 <remoteproc_load+0x1b8>
 100d160:	008060f4 	movhi	r2,387
 100d164:	10baf104 	addi	r2,r2,-5180
 100d168:	10800117 	ldw	r2,4(r2)
 100d16c:	10000926 	beq	r2,zero,100d194 <remoteproc_load+0x1b8>
 100d170:	008060f4 	movhi	r2,387
 100d174:	10baf104 	addi	r2,r2,-5180
 100d178:	10800117 	ldw	r2,4(r2)
 100d17c:	018040f4 	movhi	r6,259
 100d180:	31a71004 	addi	r6,r6,-25536
 100d184:	014040f4 	movhi	r5,259
 100d188:	2965d604 	addi	r5,r5,-26792
 100d18c:	010001c4 	movi	r4,7
 100d190:	103ee83a 	callr	r2
	ret = store_ops->open(store, path, &img_data);
 100d194:	e0bfff17 	ldw	r2,-4(fp)
 100d198:	10800017 	ldw	r2,0(r2)
 100d19c:	e0fff004 	addi	r3,fp,-64
 100d1a0:	180d883a 	mov	r6,r3
 100d1a4:	e17ffd17 	ldw	r5,-12(fp)
 100d1a8:	e13ffe17 	ldw	r4,-8(fp)
 100d1ac:	103ee83a 	callr	r2
 100d1b0:	e0bfe815 	stw	r2,-96(fp)
	if (ret <= 0) {
 100d1b4:	e0bfe817 	ldw	r2,-96(fp)
 100d1b8:	00801616 	blt	zero,r2,100d214 <remoteproc_load+0x238>
		metal_log(METAL_LOG_ERROR,
 100d1bc:	008060f4 	movhi	r2,387
 100d1c0:	10baf104 	addi	r2,r2,-5180
 100d1c4:	10800017 	ldw	r2,0(r2)
 100d1c8:	108000f0 	cmpltui	r2,r2,3
 100d1cc:	10000c1e 	bne	r2,zero,100d200 <remoteproc_load+0x224>
 100d1d0:	008060f4 	movhi	r2,387
 100d1d4:	10baf104 	addi	r2,r2,-5180
 100d1d8:	10800117 	ldw	r2,4(r2)
 100d1dc:	10000826 	beq	r2,zero,100d200 <remoteproc_load+0x224>
 100d1e0:	008060f4 	movhi	r2,387
 100d1e4:	10baf104 	addi	r2,r2,-5180
 100d1e8:	10800117 	ldw	r2,4(r2)
 100d1ec:	e1bfe817 	ldw	r6,-96(fp)
 100d1f0:	014040f4 	movhi	r5,259
 100d1f4:	2965dd04 	addi	r5,r5,-26764
 100d1f8:	010000c4 	movi	r4,3
 100d1fc:	103ee83a 	callr	r2
			  "load failure: failed to open firmware %d.\r\n",
			  ret);
		metal_mutex_release(&rproc->lock);
 100d200:	e0bffc17 	ldw	r2,-16(fp)
 100d204:	1009883a 	mov	r4,r2
 100d208:	100c2d80 	call	100c2d8 <metal_mutex_release>
		return -RPROC_EINVAL;
 100d20c:	00bfff84 	movi	r2,-2
 100d210:	0002cd06 	br	100dd48 <remoteproc_load+0xd6c>
	}
	len = ret;
 100d214:	e0bfe817 	ldw	r2,-96(fp)
 100d218:	e0bfea15 	stw	r2,-88(fp)
	metal_assert(img_data != NULL);
 100d21c:	e0bff017 	ldw	r2,-64(fp)
 100d220:	1000081e 	bne	r2,zero,100d244 <remoteproc_load+0x268>
 100d224:	01c040f4 	movhi	r7,259
 100d228:	39e5e804 	addi	r7,r7,-26720
 100d22c:	018040f4 	movhi	r6,259
 100d230:	31a71004 	addi	r6,r6,-25536
 100d234:	01406a04 	movi	r5,424
 100d238:	010040f4 	movhi	r4,259
 100d23c:	2125ee04 	addi	r4,r4,-26696
 100d240:	10157a00 	call	10157a0 <__assert_func>

	/* Check executable format to select a parser */
	loader = rproc->loader;
 100d244:	e0bffc17 	ldw	r2,-16(fp)
 100d248:	10800b17 	ldw	r2,44(r2)
 100d24c:	e0bfe915 	stw	r2,-92(fp)
	if (!loader) {
 100d250:	e0bfe917 	ldw	r2,-92(fp)
 100d254:	10002f1e 	bne	r2,zero,100d314 <remoteproc_load+0x338>
		metal_log(METAL_LOG_DEBUG, "%s: check loader\r\n", __func__);
 100d258:	008060f4 	movhi	r2,387
 100d25c:	10baf104 	addi	r2,r2,-5180
 100d260:	10800017 	ldw	r2,0(r2)
 100d264:	108001f0 	cmpltui	r2,r2,7
 100d268:	10000d1e 	bne	r2,zero,100d2a0 <remoteproc_load+0x2c4>
 100d26c:	008060f4 	movhi	r2,387
 100d270:	10baf104 	addi	r2,r2,-5180
 100d274:	10800117 	ldw	r2,4(r2)
 100d278:	10000926 	beq	r2,zero,100d2a0 <remoteproc_load+0x2c4>
 100d27c:	008060f4 	movhi	r2,387
 100d280:	10baf104 	addi	r2,r2,-5180
 100d284:	10800117 	ldw	r2,4(r2)
 100d288:	018040f4 	movhi	r6,259
 100d28c:	31a71004 	addi	r6,r6,-25536
 100d290:	014040f4 	movhi	r5,259
 100d294:	2965f704 	addi	r5,r5,-26660
 100d298:	010001c4 	movi	r4,7
 100d29c:	103ee83a 	callr	r2
		loader = remoteproc_check_fw_format(img_data, len);
 100d2a0:	e0bff017 	ldw	r2,-64(fp)
 100d2a4:	e17fea17 	ldw	r5,-88(fp)
 100d2a8:	1009883a 	mov	r4,r2
 100d2ac:	100c3b80 	call	100c3b8 <remoteproc_check_fw_format>
 100d2b0:	e0bfe915 	stw	r2,-92(fp)
		if (!loader) {
 100d2b4:	e0bfe917 	ldw	r2,-92(fp)
 100d2b8:	1000131e 	bne	r2,zero,100d308 <remoteproc_load+0x32c>
			metal_log(METAL_LOG_ERROR,
 100d2bc:	008060f4 	movhi	r2,387
 100d2c0:	10baf104 	addi	r2,r2,-5180
 100d2c4:	10800017 	ldw	r2,0(r2)
 100d2c8:	108000f0 	cmpltui	r2,r2,3
 100d2cc:	10000b1e 	bne	r2,zero,100d2fc <remoteproc_load+0x320>
 100d2d0:	008060f4 	movhi	r2,387
 100d2d4:	10baf104 	addi	r2,r2,-5180
 100d2d8:	10800117 	ldw	r2,4(r2)
 100d2dc:	10000726 	beq	r2,zero,100d2fc <remoteproc_load+0x320>
 100d2e0:	008060f4 	movhi	r2,387
 100d2e4:	10baf104 	addi	r2,r2,-5180
 100d2e8:	10800117 	ldw	r2,4(r2)
 100d2ec:	014040f4 	movhi	r5,259
 100d2f0:	2965fc04 	addi	r5,r5,-26640
 100d2f4:	010000c4 	movi	r4,3
 100d2f8:	103ee83a 	callr	r2
			       "load failure: failed to get store ops.\r\n");
			ret = -RPROC_EINVAL;
 100d2fc:	00bfff84 	movi	r2,-2
 100d300:	e0bfe815 	stw	r2,-96(fp)
			goto error1;
 100d304:	00028806 	br	100dd28 <remoteproc_load+0xd4c>
		}
		rproc->loader = loader;
 100d308:	e0bffc17 	ldw	r2,-16(fp)
 100d30c:	e0ffe917 	ldw	r3,-92(fp)
 100d310:	10c00b15 	stw	r3,44(r2)
	}

	/* Load executable headers */
	metal_log(METAL_LOG_DEBUG, "%s: loading headers\r\n", __func__);
 100d314:	008060f4 	movhi	r2,387
 100d318:	10baf104 	addi	r2,r2,-5180
 100d31c:	10800017 	ldw	r2,0(r2)
 100d320:	108001f0 	cmpltui	r2,r2,7
 100d324:	10000d1e 	bne	r2,zero,100d35c <remoteproc_load+0x380>
 100d328:	008060f4 	movhi	r2,387
 100d32c:	10baf104 	addi	r2,r2,-5180
 100d330:	10800117 	ldw	r2,4(r2)
 100d334:	10000926 	beq	r2,zero,100d35c <remoteproc_load+0x380>
 100d338:	008060f4 	movhi	r2,387
 100d33c:	10baf104 	addi	r2,r2,-5180
 100d340:	10800117 	ldw	r2,4(r2)
 100d344:	018040f4 	movhi	r6,259
 100d348:	31a71004 	addi	r6,r6,-25536
 100d34c:	014040f4 	movhi	r5,259
 100d350:	29660704 	addi	r5,r5,-26596
 100d354:	010001c4 	movi	r4,7
 100d358:	103ee83a 	callr	r2
	offset = 0;
 100d35c:	e03ff215 	stw	zero,-56(fp)
	last_load_state = RPROC_LOADER_NOT_READY;
 100d360:	e03feb15 	stw	zero,-84(fp)
	while(1) {
		ret = loader->load_header(img_data, offset, len,
 100d364:	e0bfe917 	ldw	r2,-92(fp)
 100d368:	10800017 	ldw	r2,0(r2)
 100d36c:	e13ff017 	ldw	r4,-64(fp)
 100d370:	e17ff217 	ldw	r5,-56(fp)
 100d374:	e1bff104 	addi	r6,fp,-60
 100d378:	e0fff404 	addi	r3,fp,-48
 100d37c:	d8c00215 	stw	r3,8(sp)
 100d380:	e0fff304 	addi	r3,fp,-52
 100d384:	d8c00115 	stw	r3,4(sp)
 100d388:	e0ffeb17 	ldw	r3,-84(fp)
 100d38c:	d8c00015 	stw	r3,0(sp)
 100d390:	300f883a 	mov	r7,r6
 100d394:	e1bfea17 	ldw	r6,-88(fp)
 100d398:	103ee83a 	callr	r2
 100d39c:	e0bfe815 	stw	r2,-96(fp)
					  &limg_info, last_load_state,
					  &noffset, &nlen);
		last_load_state = ret;
 100d3a0:	e0bfe817 	ldw	r2,-96(fp)
 100d3a4:	e0bfeb15 	stw	r2,-84(fp)
		metal_log(METAL_LOG_DEBUG,
 100d3a8:	008060f4 	movhi	r2,387
 100d3ac:	10baf104 	addi	r2,r2,-5180
 100d3b0:	10800017 	ldw	r2,0(r2)
 100d3b4:	108001f0 	cmpltui	r2,r2,7
 100d3b8:	1000151e 	bne	r2,zero,100d410 <remoteproc_load+0x434>
 100d3bc:	008060f4 	movhi	r2,387
 100d3c0:	10baf104 	addi	r2,r2,-5180
 100d3c4:	10800117 	ldw	r2,4(r2)
 100d3c8:	10001126 	beq	r2,zero,100d410 <remoteproc_load+0x434>
 100d3cc:	008060f4 	movhi	r2,387
 100d3d0:	10baf104 	addi	r2,r2,-5180
 100d3d4:	10800117 	ldw	r2,4(r2)
 100d3d8:	e17ff217 	ldw	r5,-56(fp)
 100d3dc:	e0fff317 	ldw	r3,-52(fp)
 100d3e0:	e13ff417 	ldw	r4,-48(fp)
 100d3e4:	d9000215 	stw	r4,8(sp)
 100d3e8:	d8c00115 	stw	r3,4(sp)
 100d3ec:	e0ffea17 	ldw	r3,-88(fp)
 100d3f0:	d8c00015 	stw	r3,0(sp)
 100d3f4:	280f883a 	mov	r7,r5
 100d3f8:	018040f4 	movhi	r6,259
 100d3fc:	31a71004 	addi	r6,r6,-25536
 100d400:	014040f4 	movhi	r5,259
 100d404:	29660d04 	addi	r5,r5,-26572
 100d408:	010001c4 	movi	r4,7
 100d40c:	103ee83a 	callr	r2
			  "%s, load header 0x%lx, 0x%x, next 0x%lx, 0x%x\r\n",
			  __func__, offset, len, noffset, nlen);
		if (ret < 0) {
 100d410:	e0bfe817 	ldw	r2,-96(fp)
 100d414:	1000140e 	bge	r2,zero,100d468 <remoteproc_load+0x48c>
			metal_log(METAL_LOG_ERROR,
 100d418:	008060f4 	movhi	r2,387
 100d41c:	10baf104 	addi	r2,r2,-5180
 100d420:	10800017 	ldw	r2,0(r2)
 100d424:	108000f0 	cmpltui	r2,r2,3
 100d428:	1002371e 	bne	r2,zero,100dd08 <remoteproc_load+0xd2c>
 100d42c:	008060f4 	movhi	r2,387
 100d430:	10baf104 	addi	r2,r2,-5180
 100d434:	10800117 	ldw	r2,4(r2)
 100d438:	10023326 	beq	r2,zero,100dd08 <remoteproc_load+0xd2c>
 100d43c:	008060f4 	movhi	r2,387
 100d440:	10baf104 	addi	r2,r2,-5180
 100d444:	10800117 	ldw	r2,4(r2)
 100d448:	e0fff217 	ldw	r3,-56(fp)
 100d44c:	e1ffea17 	ldw	r7,-88(fp)
 100d450:	180d883a 	mov	r6,r3
 100d454:	014040f4 	movhi	r5,259
 100d458:	29661904 	addi	r5,r5,-26524
 100d45c:	010000c4 	movi	r4,3
 100d460:	103ee83a 	callr	r2
				  "load header failed 0x%lx,%d.\r\n",
				  offset, len);

			goto error2;
 100d464:	00022806 	br	100dd08 <remoteproc_load+0xd2c>
		} else if ((ret & RPROC_LOADER_READY_TO_LOAD) != 0) {
 100d468:	e0bfe817 	ldw	r2,-96(fp)
 100d46c:	1080006c 	andhi	r2,r2,1
 100d470:	10000b26 	beq	r2,zero,100d4a0 <remoteproc_load+0x4c4>
			if (nlen == 0)
 100d474:	e0bff417 	ldw	r2,-48(fp)
 100d478:	10003826 	beq	r2,zero,100d55c <remoteproc_load+0x580>
				break;
			else if ((noffset > (offset + len)) &&
 100d47c:	e0fff217 	ldw	r3,-56(fp)
 100d480:	e0bfea17 	ldw	r2,-88(fp)
 100d484:	1887883a 	add	r3,r3,r2
 100d488:	e0bff317 	ldw	r2,-52(fp)
 100d48c:	1880042e 	bgeu	r3,r2,100d4a0 <remoteproc_load+0x4c4>
				 (store_ops->features & SUPPORT_SEEK) == 0) {
 100d490:	e0bfff17 	ldw	r2,-4(fp)
 100d494:	10800317 	ldw	r2,12(r2)
 100d498:	1080004c 	andi	r2,r2,1

			goto error2;
		} else if ((ret & RPROC_LOADER_READY_TO_LOAD) != 0) {
			if (nlen == 0)
				break;
			else if ((noffset > (offset + len)) &&
 100d49c:	10003126 	beq	r2,zero,100d564 <remoteproc_load+0x588>
				 */
				break;
			}
		}
		/* Continue to load headers image data */
		img_data = NULL;
 100d4a0:	e03ff015 	stw	zero,-64(fp)
		ret = store_ops->load(store, noffset, nlen,
 100d4a4:	e0bfff17 	ldw	r2,-4(fp)
 100d4a8:	10800217 	ldw	r2,8(r2)
 100d4ac:	e13ff317 	ldw	r4,-52(fp)
 100d4b0:	e17ff417 	ldw	r5,-48(fp)
 100d4b4:	e1bff004 	addi	r6,fp,-64
 100d4b8:	00c00044 	movi	r3,1
 100d4bc:	d8c00215 	stw	r3,8(sp)
 100d4c0:	d8000115 	stw	zero,4(sp)
 100d4c4:	00ffffc4 	movi	r3,-1
 100d4c8:	d8c00015 	stw	r3,0(sp)
 100d4cc:	300f883a 	mov	r7,r6
 100d4d0:	280d883a 	mov	r6,r5
 100d4d4:	200b883a 	mov	r5,r4
 100d4d8:	e13ffe17 	ldw	r4,-8(fp)
 100d4dc:	103ee83a 	callr	r2
 100d4e0:	e0bfe815 	stw	r2,-96(fp)
				      &img_data,
				      RPROC_LOAD_ANYADDR,
				      NULL, 1);
		if (ret < (int)nlen) {
 100d4e4:	e0bff417 	ldw	r2,-48(fp)
 100d4e8:	1007883a 	mov	r3,r2
 100d4ec:	e0bfe817 	ldw	r2,-96(fp)
 100d4f0:	10c0150e 	bge	r2,r3,100d548 <remoteproc_load+0x56c>
			metal_log(METAL_LOG_ERROR,
 100d4f4:	008060f4 	movhi	r2,387
 100d4f8:	10baf104 	addi	r2,r2,-5180
 100d4fc:	10800017 	ldw	r2,0(r2)
 100d500:	108000f0 	cmpltui	r2,r2,3
 100d504:	1002021e 	bne	r2,zero,100dd10 <remoteproc_load+0xd34>
 100d508:	008060f4 	movhi	r2,387
 100d50c:	10baf104 	addi	r2,r2,-5180
 100d510:	10800117 	ldw	r2,4(r2)
 100d514:	1001fe26 	beq	r2,zero,100dd10 <remoteproc_load+0xd34>
 100d518:	008060f4 	movhi	r2,387
 100d51c:	10baf104 	addi	r2,r2,-5180
 100d520:	10800117 	ldw	r2,4(r2)
 100d524:	e0fff317 	ldw	r3,-52(fp)
 100d528:	e13ff417 	ldw	r4,-48(fp)
 100d52c:	200f883a 	mov	r7,r4
 100d530:	180d883a 	mov	r6,r3
 100d534:	014040f4 	movhi	r5,259
 100d538:	29662104 	addi	r5,r5,-26492
 100d53c:	010000c4 	movi	r4,3
 100d540:	103ee83a 	callr	r2
				  "load image data failed 0x%x,%d\r\n",
				  noffset, nlen);
			goto error2;
 100d544:	0001f206 	br	100dd10 <remoteproc_load+0xd34>
		}
		offset = noffset;
 100d548:	e0bff317 	ldw	r2,-52(fp)
 100d54c:	e0bff215 	stw	r2,-56(fp)
		len = nlen;
 100d550:	e0bff417 	ldw	r2,-48(fp)
 100d554:	e0bfea15 	stw	r2,-88(fp)
	}
 100d558:	003f8206 	br	100d364 <__alt_data_end+0xff00d364>
				  offset, len);

			goto error2;
		} else if ((ret & RPROC_LOADER_READY_TO_LOAD) != 0) {
			if (nlen == 0)
				break;
 100d55c:	0001883a 	nop
 100d560:	00000106 	br	100d568 <remoteproc_load+0x58c>
				 * headers such as ELF section headers which
				 * is usually located to the end of image.
				 * Continue to load binary data to target
				 * memory.
				 */
				break;
 100d564:	0001883a 	nop
			goto error2;
		}
		offset = noffset;
		len = nlen;
	}
	ret = loader->locate_rsc_table(limg_info, &rsc_da, &offset, &rsc_size);
 100d568:	e0bfe917 	ldw	r2,-92(fp)
 100d56c:	10800217 	ldw	r2,8(r2)
 100d570:	e0fff117 	ldw	r3,-60(fp)
 100d574:	e1bff704 	addi	r6,fp,-36
 100d578:	e17ff204 	addi	r5,fp,-56
 100d57c:	e13ff604 	addi	r4,fp,-40
 100d580:	300f883a 	mov	r7,r6
 100d584:	280d883a 	mov	r6,r5
 100d588:	200b883a 	mov	r5,r4
 100d58c:	1809883a 	mov	r4,r3
 100d590:	103ee83a 	callr	r2
 100d594:	e0bfe815 	stw	r2,-96(fp)
	if (ret == 0 && rsc_size > 0) {
 100d598:	e0bfe817 	ldw	r2,-96(fp)
 100d59c:	10000b1e 	bne	r2,zero,100d5cc <remoteproc_load+0x5f0>
 100d5a0:	e0bff717 	ldw	r2,-36(fp)
 100d5a4:	10000926 	beq	r2,zero,100d5cc <remoteproc_load+0x5f0>
		/* parse resource table */
		rsc_table = remoteproc_get_rsc_table(rproc, store, store_ops,
 100d5a8:	e0fff217 	ldw	r3,-56(fp)
 100d5ac:	e0bff717 	ldw	r2,-36(fp)
 100d5b0:	d8800015 	stw	r2,0(sp)
 100d5b4:	180f883a 	mov	r7,r3
 100d5b8:	e1bfff17 	ldw	r6,-4(fp)
 100d5bc:	e17ffe17 	ldw	r5,-8(fp)
 100d5c0:	e13ffc17 	ldw	r4,-16(fp)
 100d5c4:	100c61c0 	call	100c61c <remoteproc_get_rsc_table>
 100d5c8:	e0bfec15 	stw	r2,-80(fp)
						     offset, rsc_size);
	}

	/* load executable data */
	metal_log(METAL_LOG_DEBUG, "%s: load executable data\r\n", __func__);
 100d5cc:	008060f4 	movhi	r2,387
 100d5d0:	10baf104 	addi	r2,r2,-5180
 100d5d4:	10800017 	ldw	r2,0(r2)
 100d5d8:	108001f0 	cmpltui	r2,r2,7
 100d5dc:	10000d1e 	bne	r2,zero,100d614 <remoteproc_load+0x638>
 100d5e0:	008060f4 	movhi	r2,387
 100d5e4:	10baf104 	addi	r2,r2,-5180
 100d5e8:	10800117 	ldw	r2,4(r2)
 100d5ec:	10000926 	beq	r2,zero,100d614 <remoteproc_load+0x638>
 100d5f0:	008060f4 	movhi	r2,387
 100d5f4:	10baf104 	addi	r2,r2,-5180
 100d5f8:	10800117 	ldw	r2,4(r2)
 100d5fc:	018040f4 	movhi	r6,259
 100d600:	31a71004 	addi	r6,r6,-25536
 100d604:	014040f4 	movhi	r5,259
 100d608:	29662a04 	addi	r5,r5,-26456
 100d60c:	010001c4 	movi	r4,7
 100d610:	103ee83a 	callr	r2
	offset = 0;
 100d614:	e03ff215 	stw	zero,-56(fp)
	len = 0;
 100d618:	e03fea15 	stw	zero,-88(fp)
	ret = -RPROC_EINVAL;
 100d61c:	00bfff84 	movi	r2,-2
 100d620:	e0bfe815 	stw	r2,-96(fp)
	while(1) {
		unsigned char padding;
		size_t nmemsize;
		metal_phys_addr_t pa;

		da = RPROC_LOAD_ANYADDR;
 100d624:	00bfffc4 	movi	r2,-1
 100d628:	e0bff515 	stw	r2,-44(fp)
		nlen = 0;
 100d62c:	e03ff415 	stw	zero,-48(fp)
		nmemsize = 0;
 100d630:	e03ffa15 	stw	zero,-24(fp)
		noffset = 0;
 100d634:	e03ff315 	stw	zero,-52(fp)
		ret = loader->load_data(rproc, img_data, offset, len,
 100d638:	e0bfe917 	ldw	r2,-92(fp)
 100d63c:	10800117 	ldw	r2,4(r2)
 100d640:	e13ff017 	ldw	r4,-64(fp)
 100d644:	e17ff217 	ldw	r5,-56(fp)
 100d648:	e0fffa04 	addi	r3,fp,-24
 100d64c:	d8c00615 	stw	r3,24(sp)
 100d650:	e0fff904 	addi	r3,fp,-28
 100d654:	d8c00515 	stw	r3,20(sp)
 100d658:	e0fff404 	addi	r3,fp,-48
 100d65c:	d8c00415 	stw	r3,16(sp)
 100d660:	e0fff304 	addi	r3,fp,-52
 100d664:	d8c00315 	stw	r3,12(sp)
 100d668:	e0fff504 	addi	r3,fp,-44
 100d66c:	d8c00215 	stw	r3,8(sp)
 100d670:	e0ffeb17 	ldw	r3,-84(fp)
 100d674:	d8c00115 	stw	r3,4(sp)
 100d678:	e0fff104 	addi	r3,fp,-60
 100d67c:	d8c00015 	stw	r3,0(sp)
 100d680:	e1ffea17 	ldw	r7,-88(fp)
 100d684:	280d883a 	mov	r6,r5
 100d688:	200b883a 	mov	r5,r4
 100d68c:	e13ffc17 	ldw	r4,-16(fp)
 100d690:	103ee83a 	callr	r2
 100d694:	e0bfe815 	stw	r2,-96(fp)
					&limg_info, last_load_state, &da,
					&noffset, &nlen, &padding, &nmemsize);
		if (ret < 0) {
 100d698:	e0bfe817 	ldw	r2,-96(fp)
 100d69c:	1000150e 	bge	r2,zero,100d6f4 <remoteproc_load+0x718>
			metal_log(METAL_LOG_ERROR,
 100d6a0:	008060f4 	movhi	r2,387
 100d6a4:	10baf104 	addi	r2,r2,-5180
 100d6a8:	10800017 	ldw	r2,0(r2)
 100d6ac:	108000f0 	cmpltui	r2,r2,3
 100d6b0:	10018d1e 	bne	r2,zero,100dce8 <remoteproc_load+0xd0c>
 100d6b4:	008060f4 	movhi	r2,387
 100d6b8:	10baf104 	addi	r2,r2,-5180
 100d6bc:	10800117 	ldw	r2,4(r2)
 100d6c0:	10018926 	beq	r2,zero,100dce8 <remoteproc_load+0xd0c>
 100d6c4:	008060f4 	movhi	r2,387
 100d6c8:	10baf104 	addi	r2,r2,-5180
 100d6cc:	10800117 	ldw	r2,4(r2)
 100d6d0:	e0fff317 	ldw	r3,-52(fp)
 100d6d4:	e13ff417 	ldw	r4,-48(fp)
 100d6d8:	200f883a 	mov	r7,r4
 100d6dc:	180d883a 	mov	r6,r3
 100d6e0:	014040f4 	movhi	r5,259
 100d6e4:	29663104 	addi	r5,r5,-26428
 100d6e8:	010000c4 	movi	r4,3
 100d6ec:	103ee83a 	callr	r2
				  "load data failed,0x%lx,%d\r\n",
				  noffset, nlen);
			goto error3;
 100d6f0:	00017d06 	br	100dce8 <remoteproc_load+0xd0c>
		}
		metal_log(METAL_LOG_DEBUG,
 100d6f4:	008060f4 	movhi	r2,387
 100d6f8:	10baf104 	addi	r2,r2,-5180
 100d6fc:	10800017 	ldw	r2,0(r2)
 100d700:	108001f0 	cmpltui	r2,r2,7
 100d704:	1000131e 	bne	r2,zero,100d754 <remoteproc_load+0x778>
 100d708:	008060f4 	movhi	r2,387
 100d70c:	10baf104 	addi	r2,r2,-5180
 100d710:	10800117 	ldw	r2,4(r2)
 100d714:	10000f26 	beq	r2,zero,100d754 <remoteproc_load+0x778>
 100d718:	008060f4 	movhi	r2,387
 100d71c:	10baf104 	addi	r2,r2,-5180
 100d720:	10800117 	ldw	r2,4(r2)
 100d724:	e1bff517 	ldw	r6,-44(fp)
 100d728:	e1fff317 	ldw	r7,-52(fp)
 100d72c:	e0fff417 	ldw	r3,-48(fp)
 100d730:	e13ffa17 	ldw	r4,-24(fp)
 100d734:	e17fe817 	ldw	r5,-96(fp)
 100d738:	d9400215 	stw	r5,8(sp)
 100d73c:	d9000115 	stw	r4,4(sp)
 100d740:	d8c00015 	stw	r3,0(sp)
 100d744:	014040f4 	movhi	r5,259
 100d748:	29663804 	addi	r5,r5,-26400
 100d74c:	010001c4 	movi	r4,7
 100d750:	103ee83a 	callr	r2
			  "load data: da 0x%lx, offset 0x%lx, len = 0x%lx, memsize = 0x%lx, state 0x%x\r\n",
			  da, noffset, nlen, nmemsize, ret);
		last_load_state = ret;
 100d754:	e0bfe817 	ldw	r2,-96(fp)
 100d758:	e0bfeb15 	stw	r2,-84(fp)
		if (da != RPROC_LOAD_ANYADDR) {
 100d75c:	e0bff517 	ldw	r2,-44(fp)
 100d760:	10bfffe0 	cmpeqi	r2,r2,-1
 100d764:	10006b1e 	bne	r2,zero,100d914 <remoteproc_load+0x938>
			/* Data is supposed to be loaded to target memory */
			img_data = NULL;
 100d768:	e03ff015 	stw	zero,-64(fp)
			/* get the I/O region from remoteproc */
			pa = METAL_BAD_PHYS;
 100d76c:	00bfffc4 	movi	r2,-1
 100d770:	e0bffb15 	stw	r2,-20(fp)
			(void)remoteproc_mmap(rproc, &pa, &da, nmemsize, 0, &io);
 100d774:	e17ffa17 	ldw	r5,-24(fp)
 100d778:	e13ff504 	addi	r4,fp,-44
 100d77c:	e0fffb04 	addi	r3,fp,-20
 100d780:	e0bff804 	addi	r2,fp,-32
 100d784:	d8800115 	stw	r2,4(sp)
 100d788:	d8000015 	stw	zero,0(sp)
 100d78c:	280f883a 	mov	r7,r5
 100d790:	200d883a 	mov	r6,r4
 100d794:	180b883a 	mov	r5,r3
 100d798:	e13ffc17 	ldw	r4,-16(fp)
 100d79c:	100ce140 	call	100ce14 <remoteproc_mmap>
			if (pa == METAL_BAD_PHYS || io == NULL) {
 100d7a0:	e0bffb17 	ldw	r2,-20(fp)
 100d7a4:	10bfffe0 	cmpeqi	r2,r2,-1
 100d7a8:	1000021e 	bne	r2,zero,100d7b4 <remoteproc_load+0x7d8>
 100d7ac:	e0bff817 	ldw	r2,-32(fp)
 100d7b0:	1000151e 	bne	r2,zero,100d808 <remoteproc_load+0x82c>
				metal_log(METAL_LOG_ERROR,
 100d7b4:	008060f4 	movhi	r2,387
 100d7b8:	10baf104 	addi	r2,r2,-5180
 100d7bc:	10800017 	ldw	r2,0(r2)
 100d7c0:	108000f0 	cmpltui	r2,r2,3
 100d7c4:	10000d1e 	bne	r2,zero,100d7fc <remoteproc_load+0x820>
 100d7c8:	008060f4 	movhi	r2,387
 100d7cc:	10baf104 	addi	r2,r2,-5180
 100d7d0:	10800117 	ldw	r2,4(r2)
 100d7d4:	10000926 	beq	r2,zero,100d7fc <remoteproc_load+0x820>
 100d7d8:	008060f4 	movhi	r2,387
 100d7dc:	10baf104 	addi	r2,r2,-5180
 100d7e0:	10800117 	ldw	r2,4(r2)
 100d7e4:	e0fff517 	ldw	r3,-44(fp)
 100d7e8:	180d883a 	mov	r6,r3
 100d7ec:	014040f4 	movhi	r5,259
 100d7f0:	29664c04 	addi	r5,r5,-26320
 100d7f4:	010000c4 	movi	r4,3
 100d7f8:	103ee83a 	callr	r2
					  "load failed, no mapping for 0x%llx.\r\n",
					  da);
				ret = -RPROC_EINVAL;
 100d7fc:	00bfff84 	movi	r2,-2
 100d800:	e0bfe815 	stw	r2,-96(fp)
				goto error3;
 100d804:	00013b06 	br	100dcf4 <remoteproc_load+0xd18>
			}
			if (nlen > 0) {
 100d808:	e0bff417 	ldw	r2,-48(fp)
 100d80c:	10002c26 	beq	r2,zero,100d8c0 <remoteproc_load+0x8e4>
				ret = store_ops->load(store, noffset, nlen,
 100d810:	e0bfff17 	ldw	r2,-4(fp)
 100d814:	10800217 	ldw	r2,8(r2)
 100d818:	e23ff317 	ldw	r8,-52(fp)
 100d81c:	e1bff417 	ldw	r6,-48(fp)
 100d820:	e0fffb17 	ldw	r3,-20(fp)
 100d824:	e13ff817 	ldw	r4,-32(fp)
 100d828:	e1fff004 	addi	r7,fp,-64
 100d82c:	01400044 	movi	r5,1
 100d830:	d9400215 	stw	r5,8(sp)
 100d834:	d9000115 	stw	r4,4(sp)
 100d838:	d8c00015 	stw	r3,0(sp)
 100d83c:	400b883a 	mov	r5,r8
 100d840:	e13ffe17 	ldw	r4,-8(fp)
 100d844:	103ee83a 	callr	r2
 100d848:	e0bfe815 	stw	r2,-96(fp)
						      &img_data, pa, io, 1);
				if (ret != (int)nlen) {
 100d84c:	e0bff417 	ldw	r2,-48(fp)
 100d850:	1007883a 	mov	r3,r2
 100d854:	e0bfe817 	ldw	r2,-96(fp)
 100d858:	10c01926 	beq	r2,r3,100d8c0 <remoteproc_load+0x8e4>
					metal_log(METAL_LOG_ERROR,
 100d85c:	008060f4 	movhi	r2,387
 100d860:	10baf104 	addi	r2,r2,-5180
 100d864:	10800017 	ldw	r2,0(r2)
 100d868:	108000f0 	cmpltui	r2,r2,3
 100d86c:	1000111e 	bne	r2,zero,100d8b4 <remoteproc_load+0x8d8>
 100d870:	008060f4 	movhi	r2,387
 100d874:	10baf104 	addi	r2,r2,-5180
 100d878:	10800117 	ldw	r2,4(r2)
 100d87c:	10000d26 	beq	r2,zero,100d8b4 <remoteproc_load+0x8d8>
 100d880:	008060f4 	movhi	r2,387
 100d884:	10baf104 	addi	r2,r2,-5180
 100d888:	10800117 	ldw	r2,4(r2)
 100d88c:	e13ffb17 	ldw	r4,-20(fp)
 100d890:	e17ff317 	ldw	r5,-52(fp)
 100d894:	e0fff417 	ldw	r3,-48(fp)
 100d898:	d8c00015 	stw	r3,0(sp)
 100d89c:	280f883a 	mov	r7,r5
 100d8a0:	200d883a 	mov	r6,r4
 100d8a4:	014040f4 	movhi	r5,259
 100d8a8:	29665604 	addi	r5,r5,-26280
 100d8ac:	010000c4 	movi	r4,3
 100d8b0:	103ee83a 	callr	r2
						  "load data failed 0x%lx, 0x%lx, 0x%x\r\n",
						  pa, noffset, nlen);
					ret = -RPROC_EINVAL;
 100d8b4:	00bfff84 	movi	r2,-2
 100d8b8:	e0bfe815 	stw	r2,-96(fp)
					goto error3;
 100d8bc:	00010d06 	br	100dcf4 <remoteproc_load+0xd18>
				}
			}
			if (nmemsize > nlen) {
 100d8c0:	e0bffa17 	ldw	r2,-24(fp)
 100d8c4:	e0fff417 	ldw	r3,-48(fp)
 100d8c8:	18bf562e 	bgeu	r3,r2,100d624 <__alt_data_end+0xff00d624>
				size_t tmpoffset;

				tmpoffset = metal_io_phys_to_offset(io,
 100d8cc:	e13ff817 	ldw	r4,-32(fp)
 100d8d0:	e0fffb17 	ldw	r3,-20(fp)
 100d8d4:	e0bff417 	ldw	r2,-48(fp)
 100d8d8:	1885883a 	add	r2,r3,r2
 100d8dc:	100b883a 	mov	r5,r2
 100d8e0:	100c09c0 	call	100c09c <metal_io_phys_to_offset>
 100d8e4:	e0bfed15 	stw	r2,-76(fp)
								    pa + nlen);
				metal_io_block_set(io, tmpoffset,
 100d8e8:	e13ff817 	ldw	r4,-32(fp)
 100d8ec:	e0bff903 	ldbu	r2,-28(fp)
 100d8f0:	11403fcc 	andi	r5,r2,255
						   padding, (nmemsize - nlen));
 100d8f4:	e0fffa17 	ldw	r3,-24(fp)
 100d8f8:	e0bff417 	ldw	r2,-48(fp)
 100d8fc:	1885c83a 	sub	r2,r3,r2
			if (nmemsize > nlen) {
				size_t tmpoffset;

				tmpoffset = metal_io_phys_to_offset(io,
								    pa + nlen);
				metal_io_block_set(io, tmpoffset,
 100d900:	100f883a 	mov	r7,r2
 100d904:	280d883a 	mov	r6,r5
 100d908:	e17fed17 	ldw	r5,-76(fp)
 100d90c:	100854c0 	call	100854c <metal_io_block_set>
 100d910:	003f4406 	br	100d624 <__alt_data_end+0xff00d624>
						   padding, (nmemsize - nlen));
			}
		} else if (nlen != 0) {
 100d914:	e0bff417 	ldw	r2,-48(fp)
 100d918:	10004326 	beq	r2,zero,100da28 <remoteproc_load+0xa4c>
			ret = store_ops->load(store, noffset, nlen,
 100d91c:	e0bfff17 	ldw	r2,-4(fp)
 100d920:	10800217 	ldw	r2,8(r2)
 100d924:	e13ff317 	ldw	r4,-52(fp)
 100d928:	e17ff417 	ldw	r5,-48(fp)
 100d92c:	e1bff004 	addi	r6,fp,-64
 100d930:	00c00044 	movi	r3,1
 100d934:	d8c00215 	stw	r3,8(sp)
 100d938:	d8000115 	stw	zero,4(sp)
 100d93c:	00ffffc4 	movi	r3,-1
 100d940:	d8c00015 	stw	r3,0(sp)
 100d944:	300f883a 	mov	r7,r6
 100d948:	280d883a 	mov	r6,r5
 100d94c:	200b883a 	mov	r5,r4
 100d950:	e13ffe17 	ldw	r4,-8(fp)
 100d954:	103ee83a 	callr	r2
 100d958:	e0bfe815 	stw	r2,-96(fp)
					      &img_data,
					      RPROC_LOAD_ANYADDR,
					      NULL, 1);
			if (ret < (int)nlen) {
 100d95c:	e0bff417 	ldw	r2,-48(fp)
 100d960:	1007883a 	mov	r3,r2
 100d964:	e0bfe817 	ldw	r2,-96(fp)
 100d968:	10c02a0e 	bge	r2,r3,100da14 <remoteproc_load+0xa38>
				if ((last_load_state &
 100d96c:	e0bfeb17 	ldw	r2,-84(fp)
 100d970:	108000ac 	andhi	r2,r2,2
 100d974:	10001126 	beq	r2,zero,100d9bc <remoteproc_load+0x9e0>
				    RPROC_LOADER_POST_DATA_LOAD) != 0) {
					metal_log(METAL_LOG_WARNING,
 100d978:	008060f4 	movhi	r2,387
 100d97c:	10baf104 	addi	r2,r2,-5180
 100d980:	10800017 	ldw	r2,0(r2)
 100d984:	10800130 	cmpltui	r2,r2,4
 100d988:	1000291e 	bne	r2,zero,100da30 <remoteproc_load+0xa54>
 100d98c:	008060f4 	movhi	r2,387
 100d990:	10baf104 	addi	r2,r2,-5180
 100d994:	10800117 	ldw	r2,4(r2)
 100d998:	10002526 	beq	r2,zero,100da30 <remoteproc_load+0xa54>
 100d99c:	008060f4 	movhi	r2,387
 100d9a0:	10baf104 	addi	r2,r2,-5180
 100d9a4:	10800117 	ldw	r2,4(r2)
 100d9a8:	014040f4 	movhi	r5,259
 100d9ac:	29666004 	addi	r5,r5,-26240
 100d9b0:	01000104 	movi	r4,4
 100d9b4:	103ee83a 	callr	r2
						  "not all the headers are loaded\r\n");
					break;
 100d9b8:	00001d06 	br	100da30 <remoteproc_load+0xa54>
				}
				metal_log(METAL_LOG_ERROR,
 100d9bc:	008060f4 	movhi	r2,387
 100d9c0:	10baf104 	addi	r2,r2,-5180
 100d9c4:	10800017 	ldw	r2,0(r2)
 100d9c8:	108000f0 	cmpltui	r2,r2,3
 100d9cc:	1000c81e 	bne	r2,zero,100dcf0 <remoteproc_load+0xd14>
 100d9d0:	008060f4 	movhi	r2,387
 100d9d4:	10baf104 	addi	r2,r2,-5180
 100d9d8:	10800117 	ldw	r2,4(r2)
 100d9dc:	1000c426 	beq	r2,zero,100dcf0 <remoteproc_load+0xd14>
 100d9e0:	008060f4 	movhi	r2,387
 100d9e4:	10baf104 	addi	r2,r2,-5180
 100d9e8:	10800117 	ldw	r2,4(r2)
 100d9ec:	e0fff317 	ldw	r3,-52(fp)
 100d9f0:	e13ff417 	ldw	r4,-48(fp)
 100d9f4:	200f883a 	mov	r7,r4
 100d9f8:	180d883a 	mov	r6,r3
 100d9fc:	014040f4 	movhi	r5,259
 100da00:	29666904 	addi	r5,r5,-26204
 100da04:	010000c4 	movi	r4,3
 100da08:	103ee83a 	callr	r2
					  "post-load image data failed 0x%x,%d\r\n",
					  noffset, nlen);
				goto error3;
 100da0c:	0001883a 	nop
 100da10:	0000b706 	br	100dcf0 <remoteproc_load+0xd14>
			}
			offset = noffset;
 100da14:	e0bff317 	ldw	r2,-52(fp)
 100da18:	e0bff215 	stw	r2,-56(fp)
			len = nlen;
 100da1c:	e0bff417 	ldw	r2,-48(fp)
 100da20:	e0bfea15 	stw	r2,-88(fp)
		} else {
			/* (last_load_state & RPROC_LOADER_LOAD_COMPLETE) != 0 */
			break;
		}
	}
 100da24:	003eff06 	br	100d624 <__alt_data_end+0xff00d624>
			}
			offset = noffset;
			len = nlen;
		} else {
			/* (last_load_state & RPROC_LOADER_LOAD_COMPLETE) != 0 */
			break;
 100da28:	0001883a 	nop
 100da2c:	00000106 	br	100da34 <remoteproc_load+0xa58>
			if (ret < (int)nlen) {
				if ((last_load_state &
				    RPROC_LOADER_POST_DATA_LOAD) != 0) {
					metal_log(METAL_LOG_WARNING,
						  "not all the headers are loaded\r\n");
					break;
 100da30:	0001883a 	nop
			/* (last_load_state & RPROC_LOADER_LOAD_COMPLETE) != 0 */
			break;
		}
	}

	if (rsc_size == 0) {
 100da34:	e0bff717 	ldw	r2,-36(fp)
 100da38:	1000191e 	bne	r2,zero,100daa0 <remoteproc_load+0xac4>
		ret = loader->locate_rsc_table(limg_info, &rsc_da,
 100da3c:	e0bfe917 	ldw	r2,-92(fp)
 100da40:	10800217 	ldw	r2,8(r2)
 100da44:	e0fff117 	ldw	r3,-60(fp)
 100da48:	e1bff704 	addi	r6,fp,-36
 100da4c:	e17ff204 	addi	r5,fp,-56
 100da50:	e13ff604 	addi	r4,fp,-40
 100da54:	300f883a 	mov	r7,r6
 100da58:	280d883a 	mov	r6,r5
 100da5c:	200b883a 	mov	r5,r4
 100da60:	1809883a 	mov	r4,r3
 100da64:	103ee83a 	callr	r2
 100da68:	e0bfe815 	stw	r2,-96(fp)
					       &offset, &rsc_size);
		if (ret == 0 && rsc_size > 0) {
 100da6c:	e0bfe817 	ldw	r2,-96(fp)
 100da70:	10000b1e 	bne	r2,zero,100daa0 <remoteproc_load+0xac4>
 100da74:	e0bff717 	ldw	r2,-36(fp)
 100da78:	10000926 	beq	r2,zero,100daa0 <remoteproc_load+0xac4>
			/* parse resource table */
			rsc_table = remoteproc_get_rsc_table(rproc, store,
 100da7c:	e0fff217 	ldw	r3,-56(fp)
 100da80:	e0bff717 	ldw	r2,-36(fp)
 100da84:	d8800015 	stw	r2,0(sp)
 100da88:	180f883a 	mov	r7,r3
 100da8c:	e1bfff17 	ldw	r6,-4(fp)
 100da90:	e17ffe17 	ldw	r5,-8(fp)
 100da94:	e13ffc17 	ldw	r4,-16(fp)
 100da98:	100c61c0 	call	100c61c <remoteproc_get_rsc_table>
 100da9c:	e0bfec15 	stw	r2,-80(fp)
							     rsc_size);
		}
	}

	/* Update resource table */
	if (rsc_table) {
 100daa0:	e0bfec17 	ldw	r2,-80(fp)
 100daa4:	10005f26 	beq	r2,zero,100dc24 <remoteproc_load+0xc48>
		void *rsc_table_cp = rsc_table;
 100daa8:	e0bfec17 	ldw	r2,-80(fp)
 100daac:	e0bfee15 	stw	r2,-72(fp)

		metal_log(METAL_LOG_DEBUG,
 100dab0:	008060f4 	movhi	r2,387
 100dab4:	10baf104 	addi	r2,r2,-5180
 100dab8:	10800017 	ldw	r2,0(r2)
 100dabc:	108001f0 	cmpltui	r2,r2,7
 100dac0:	10000d1e 	bne	r2,zero,100daf8 <remoteproc_load+0xb1c>
 100dac4:	008060f4 	movhi	r2,387
 100dac8:	10baf104 	addi	r2,r2,-5180
 100dacc:	10800117 	ldw	r2,4(r2)
 100dad0:	10000926 	beq	r2,zero,100daf8 <remoteproc_load+0xb1c>
 100dad4:	008060f4 	movhi	r2,387
 100dad8:	10baf104 	addi	r2,r2,-5180
 100dadc:	10800117 	ldw	r2,4(r2)
 100dae0:	018040f4 	movhi	r6,259
 100dae4:	31a71004 	addi	r6,r6,-25536
 100dae8:	014040f4 	movhi	r5,259
 100daec:	29667304 	addi	r5,r5,-26164
 100daf0:	010001c4 	movi	r4,7
 100daf4:	103ee83a 	callr	r2
			  "%s, update resource table\r\n", __func__);
		rsc_table = remoteproc_mmap(rproc, NULL, &rsc_da,
 100daf8:	e13ff717 	ldw	r4,-36(fp)
 100dafc:	e0fff604 	addi	r3,fp,-40
 100db00:	e0bff804 	addi	r2,fp,-32
 100db04:	d8800115 	stw	r2,4(sp)
 100db08:	d8000015 	stw	zero,0(sp)
 100db0c:	200f883a 	mov	r7,r4
 100db10:	180d883a 	mov	r6,r3
 100db14:	000b883a 	mov	r5,zero
 100db18:	e13ffc17 	ldw	r4,-16(fp)
 100db1c:	100ce140 	call	100ce14 <remoteproc_mmap>
 100db20:	e0bfec15 	stw	r2,-80(fp)
					    rsc_size, 0, &io);
		if (rsc_table) {
 100db24:	e0bfec17 	ldw	r2,-80(fp)
 100db28:	10002b26 	beq	r2,zero,100dbd8 <remoteproc_load+0xbfc>
			size_t rsc_io_offset;

			/* Update resource table */
			rsc_io_offset = metal_io_virt_to_offset(io, rsc_table);
 100db2c:	e0bff817 	ldw	r2,-32(fp)
 100db30:	e17fec17 	ldw	r5,-80(fp)
 100db34:	1009883a 	mov	r4,r2
 100db38:	100bf780 	call	100bf78 <metal_io_virt_to_offset>
 100db3c:	e0bfef15 	stw	r2,-68(fp)
			ret = metal_io_block_write(io, rsc_io_offset,
 100db40:	e0bff817 	ldw	r2,-32(fp)
 100db44:	e0fff717 	ldw	r3,-36(fp)
 100db48:	180f883a 	mov	r7,r3
 100db4c:	e1bfee17 	ldw	r6,-72(fp)
 100db50:	e17fef17 	ldw	r5,-68(fp)
 100db54:	1009883a 	mov	r4,r2
 100db58:	100839c0 	call	100839c <metal_io_block_write>
 100db5c:	e0bfe815 	stw	r2,-96(fp)
						   rsc_table_cp, rsc_size);
			if (ret != (int)rsc_size) {
 100db60:	e0bff717 	ldw	r2,-36(fp)
 100db64:	1007883a 	mov	r3,r2
 100db68:	e0bfe817 	ldw	r2,-96(fp)
 100db6c:	10c01026 	beq	r2,r3,100dbb0 <remoteproc_load+0xbd4>
				metal_log(METAL_LOG_WARNING,
 100db70:	008060f4 	movhi	r2,387
 100db74:	10baf104 	addi	r2,r2,-5180
 100db78:	10800017 	ldw	r2,0(r2)
 100db7c:	10800130 	cmpltui	r2,r2,4
 100db80:	10000b1e 	bne	r2,zero,100dbb0 <remoteproc_load+0xbd4>
 100db84:	008060f4 	movhi	r2,387
 100db88:	10baf104 	addi	r2,r2,-5180
 100db8c:	10800117 	ldw	r2,4(r2)
 100db90:	10000726 	beq	r2,zero,100dbb0 <remoteproc_load+0xbd4>
 100db94:	008060f4 	movhi	r2,387
 100db98:	10baf104 	addi	r2,r2,-5180
 100db9c:	10800117 	ldw	r2,4(r2)
 100dba0:	014040f4 	movhi	r5,259
 100dba4:	29667a04 	addi	r5,r5,-26136
 100dba8:	01000104 	movi	r4,4
 100dbac:	103ee83a 	callr	r2
					  "load: failed to update rsc\r\n");
			}
			rproc->rsc_table = rsc_table;
 100dbb0:	e0bffc17 	ldw	r2,-16(fp)
 100dbb4:	e0ffec17 	ldw	r3,-80(fp)
 100dbb8:	10c00115 	stw	r3,4(r2)
			rproc->rsc_len = rsc_size;
 100dbbc:	e0fff717 	ldw	r3,-36(fp)
 100dbc0:	e0bffc17 	ldw	r2,-16(fp)
 100dbc4:	10c00215 	stw	r3,8(r2)
			rproc->rsc_io = io;
 100dbc8:	e0fff817 	ldw	r3,-32(fp)
 100dbcc:	e0bffc17 	ldw	r2,-16(fp)
 100dbd0:	10c00315 	stw	r3,12(r2)
 100dbd4:	00001006 	br	100dc18 <remoteproc_load+0xc3c>
		} else {
			metal_log(METAL_LOG_WARNING,
 100dbd8:	008060f4 	movhi	r2,387
 100dbdc:	10baf104 	addi	r2,r2,-5180
 100dbe0:	10800017 	ldw	r2,0(r2)
 100dbe4:	10800130 	cmpltui	r2,r2,4
 100dbe8:	10000b1e 	bne	r2,zero,100dc18 <remoteproc_load+0xc3c>
 100dbec:	008060f4 	movhi	r2,387
 100dbf0:	10baf104 	addi	r2,r2,-5180
 100dbf4:	10800117 	ldw	r2,4(r2)
 100dbf8:	10000726 	beq	r2,zero,100dc18 <remoteproc_load+0xc3c>
 100dbfc:	008060f4 	movhi	r2,387
 100dc00:	10baf104 	addi	r2,r2,-5180
 100dc04:	10800117 	ldw	r2,4(r2)
 100dc08:	014040f4 	movhi	r5,259
 100dc0c:	29668204 	addi	r5,r5,-26104
 100dc10:	01000104 	movi	r4,4
 100dc14:	103ee83a 	callr	r2
				  "load: not able to update rsc table.\r\n");
		}
		metal_free_memory(rsc_table_cp);
 100dc18:	e13fee17 	ldw	r4,-72(fp)
 100dc1c:	100bc240 	call	100bc24 <metal_free_memory>
		/* So that the rsc_table will not get released */
		rsc_table = NULL;
 100dc20:	e03fec15 	stw	zero,-80(fp)
	}

	metal_log(METAL_LOG_DEBUG, "%s: successfully load firmware\r\n",
 100dc24:	008060f4 	movhi	r2,387
 100dc28:	10baf104 	addi	r2,r2,-5180
 100dc2c:	10800017 	ldw	r2,0(r2)
 100dc30:	108001f0 	cmpltui	r2,r2,7
 100dc34:	10000d1e 	bne	r2,zero,100dc6c <remoteproc_load+0xc90>
 100dc38:	008060f4 	movhi	r2,387
 100dc3c:	10baf104 	addi	r2,r2,-5180
 100dc40:	10800117 	ldw	r2,4(r2)
 100dc44:	10000926 	beq	r2,zero,100dc6c <remoteproc_load+0xc90>
 100dc48:	008060f4 	movhi	r2,387
 100dc4c:	10baf104 	addi	r2,r2,-5180
 100dc50:	10800117 	ldw	r2,4(r2)
 100dc54:	018040f4 	movhi	r6,259
 100dc58:	31a71004 	addi	r6,r6,-25536
 100dc5c:	014040f4 	movhi	r5,259
 100dc60:	29668c04 	addi	r5,r5,-26064
 100dc64:	010001c4 	movi	r4,7
 100dc68:	103ee83a 	callr	r2
		  __func__);
	/* get entry point from the firmware */
	rproc->bootaddr = loader->get_entry(limg_info);
 100dc6c:	e0bfe917 	ldw	r2,-92(fp)
 100dc70:	10800417 	ldw	r2,16(r2)
 100dc74:	e0fff117 	ldw	r3,-60(fp)
 100dc78:	1809883a 	mov	r4,r3
 100dc7c:	103ee83a 	callr	r2
 100dc80:	1007883a 	mov	r3,r2
 100dc84:	e0bffc17 	ldw	r2,-16(fp)
 100dc88:	10c00a15 	stw	r3,40(r2)
	rproc->state = RPROC_READY;
 100dc8c:	e0bffc17 	ldw	r2,-16(fp)
 100dc90:	00c00084 	movi	r3,2
 100dc94:	10c00c15 	stw	r3,48(r2)

	metal_mutex_release(&rproc->lock);
 100dc98:	e0bffc17 	ldw	r2,-16(fp)
 100dc9c:	1009883a 	mov	r4,r2
 100dca0:	100c2d80 	call	100c2d8 <metal_mutex_release>
	if (img_info)
 100dca4:	e0800217 	ldw	r2,8(fp)
 100dca8:	10000426 	beq	r2,zero,100dcbc <remoteproc_load+0xce0>
		*img_info = limg_info;
 100dcac:	e0fff117 	ldw	r3,-60(fp)
 100dcb0:	e0800217 	ldw	r2,8(fp)
 100dcb4:	10c00015 	stw	r3,0(r2)
 100dcb8:	00000506 	br	100dcd0 <remoteproc_load+0xcf4>
	else
		loader->release(limg_info);
 100dcbc:	e0bfe917 	ldw	r2,-92(fp)
 100dcc0:	10800317 	ldw	r2,12(r2)
 100dcc4:	e0fff117 	ldw	r3,-60(fp)
 100dcc8:	1809883a 	mov	r4,r3
 100dccc:	103ee83a 	callr	r2
	store_ops->close(store);
 100dcd0:	e0bfff17 	ldw	r2,-4(fp)
 100dcd4:	10800117 	ldw	r2,4(r2)
 100dcd8:	e13ffe17 	ldw	r4,-8(fp)
 100dcdc:	103ee83a 	callr	r2
	return 0;
 100dce0:	0005883a 	mov	r2,zero
 100dce4:	00001806 	br	100dd48 <remoteproc_load+0xd6c>
					&noffset, &nlen, &padding, &nmemsize);
		if (ret < 0) {
			metal_log(METAL_LOG_ERROR,
				  "load data failed,0x%lx,%d\r\n",
				  noffset, nlen);
			goto error3;
 100dce8:	0001883a 	nop
 100dcec:	00000106 	br	100dcf4 <remoteproc_load+0xd18>
					break;
				}
				metal_log(METAL_LOG_ERROR,
					  "post-load image data failed 0x%x,%d\r\n",
					  noffset, nlen);
				goto error3;
 100dcf0:	0001883a 	nop
		loader->release(limg_info);
	store_ops->close(store);
	return 0;

error3:
	if (rsc_table)
 100dcf4:	e0bfec17 	ldw	r2,-80(fp)
 100dcf8:	10000626 	beq	r2,zero,100dd14 <remoteproc_load+0xd38>
		metal_free_memory(rsc_table);
 100dcfc:	e13fec17 	ldw	r4,-80(fp)
 100dd00:	100bc240 	call	100bc24 <metal_free_memory>
 100dd04:	00000306 	br	100dd14 <remoteproc_load+0xd38>
		if (ret < 0) {
			metal_log(METAL_LOG_ERROR,
				  "load header failed 0x%lx,%d.\r\n",
				  offset, len);

			goto error2;
 100dd08:	0001883a 	nop
 100dd0c:	00000106 	br	100dd14 <remoteproc_load+0xd38>
				      NULL, 1);
		if (ret < (int)nlen) {
			metal_log(METAL_LOG_ERROR,
				  "load image data failed 0x%x,%d\r\n",
				  noffset, nlen);
			goto error2;
 100dd10:	0001883a 	nop

error3:
	if (rsc_table)
		metal_free_memory(rsc_table);
error2:
	loader->release(limg_info);
 100dd14:	e0bfe917 	ldw	r2,-92(fp)
 100dd18:	10800317 	ldw	r2,12(r2)
 100dd1c:	e0fff117 	ldw	r3,-60(fp)
 100dd20:	1809883a 	mov	r4,r3
 100dd24:	103ee83a 	callr	r2
error1:
	store_ops->close(store);
 100dd28:	e0bfff17 	ldw	r2,-4(fp)
 100dd2c:	10800117 	ldw	r2,4(r2)
 100dd30:	e13ffe17 	ldw	r4,-8(fp)
 100dd34:	103ee83a 	callr	r2
	metal_mutex_release(&rproc->lock);
 100dd38:	e0bffc17 	ldw	r2,-16(fp)
 100dd3c:	1009883a 	mov	r4,r2
 100dd40:	100c2d80 	call	100c2d8 <metal_mutex_release>
	return ret;
 100dd44:	e0bfe817 	ldw	r2,-96(fp)
}
 100dd48:	e037883a 	mov	sp,fp
 100dd4c:	dfc00117 	ldw	ra,4(sp)
 100dd50:	df000017 	ldw	fp,0(sp)
 100dd54:	dec00204 	addi	sp,sp,8
 100dd58:	f800283a 	ret

0100dd5c <remoteproc_load_noblock>:
			    const void *img_data, size_t offset, size_t len,
			    void **img_info,
			    metal_phys_addr_t *pa, struct metal_io_region **io,
			    size_t *noffset, size_t *nlen,
			    size_t *nmlen, unsigned char *padding)
{
 100dd5c:	deffe804 	addi	sp,sp,-96
 100dd60:	dfc01715 	stw	ra,92(sp)
 100dd64:	df001615 	stw	fp,88(sp)
 100dd68:	df001604 	addi	fp,sp,88
 100dd6c:	e13ffc15 	stw	r4,-16(fp)
 100dd70:	e17ffd15 	stw	r5,-12(fp)
 100dd74:	e1bffe15 	stw	r6,-8(fp)
 100dd78:	e1ffff15 	stw	r7,-4(fp)
	int ret;
	struct loader_ops *loader;
	void *limg_info = NULL;
 100dd7c:	e03ff715 	stw	zero,-36(fp)
	int last_load_state;
	metal_phys_addr_t da, rsc_da;
	size_t rsc_size;
	void *rsc_table = NULL, *lrsc_table = NULL;
 100dd80:	e03ff415 	stw	zero,-48(fp)
 100dd84:	e03ff515 	stw	zero,-44(fp)

	if (!rproc)
 100dd88:	e0bffc17 	ldw	r2,-16(fp)
 100dd8c:	1000021e 	bne	r2,zero,100dd98 <remoteproc_load_noblock+0x3c>
		return -RPROC_ENODEV;
 100dd90:	00bfff44 	movi	r2,-3
 100dd94:	00028006 	br	100e798 <remoteproc_load_noblock+0xa3c>

	metal_assert(pa != NULL);
 100dd98:	e0800317 	ldw	r2,12(fp)
 100dd9c:	1000081e 	bne	r2,zero,100ddc0 <remoteproc_load_noblock+0x64>
 100dda0:	01c040f4 	movhi	r7,259
 100dda4:	39e69504 	addi	r7,r7,-26028
 100dda8:	018040f4 	movhi	r6,259
 100ddac:	31a71404 	addi	r6,r6,-25520
 100ddb0:	0140a644 	movi	r5,665
 100ddb4:	010040f4 	movhi	r4,259
 100ddb8:	2125ee04 	addi	r4,r4,-26696
 100ddbc:	10157a00 	call	10157a0 <__assert_func>
	metal_assert(io != NULL);
 100ddc0:	e0800417 	ldw	r2,16(fp)
 100ddc4:	1000081e 	bne	r2,zero,100dde8 <remoteproc_load_noblock+0x8c>
 100ddc8:	01c040f4 	movhi	r7,259
 100ddcc:	39e69a04 	addi	r7,r7,-26008
 100ddd0:	018040f4 	movhi	r6,259
 100ddd4:	31a71404 	addi	r6,r6,-25520
 100ddd8:	0140a684 	movi	r5,666
 100dddc:	010040f4 	movhi	r4,259
 100dde0:	2125ee04 	addi	r4,r4,-26696
 100dde4:	10157a00 	call	10157a0 <__assert_func>
	metal_assert(noffset != NULL);
 100dde8:	e0800517 	ldw	r2,20(fp)
 100ddec:	1000081e 	bne	r2,zero,100de10 <remoteproc_load_noblock+0xb4>
 100ddf0:	01c040f4 	movhi	r7,259
 100ddf4:	39e69f04 	addi	r7,r7,-25988
 100ddf8:	018040f4 	movhi	r6,259
 100ddfc:	31a71404 	addi	r6,r6,-25520
 100de00:	0140a6c4 	movi	r5,667
 100de04:	010040f4 	movhi	r4,259
 100de08:	2125ee04 	addi	r4,r4,-26696
 100de0c:	10157a00 	call	10157a0 <__assert_func>
	metal_assert(nlen != NULL);
 100de10:	e0800617 	ldw	r2,24(fp)
 100de14:	1000081e 	bne	r2,zero,100de38 <remoteproc_load_noblock+0xdc>
 100de18:	01c040f4 	movhi	r7,259
 100de1c:	39e6a504 	addi	r7,r7,-25964
 100de20:	018040f4 	movhi	r6,259
 100de24:	31a71404 	addi	r6,r6,-25520
 100de28:	0140a704 	movi	r5,668
 100de2c:	010040f4 	movhi	r4,259
 100de30:	2125ee04 	addi	r4,r4,-26696
 100de34:	10157a00 	call	10157a0 <__assert_func>
	metal_assert(nmlen != NULL);
 100de38:	e0800717 	ldw	r2,28(fp)
 100de3c:	1000081e 	bne	r2,zero,100de60 <remoteproc_load_noblock+0x104>
 100de40:	01c040f4 	movhi	r7,259
 100de44:	39e6aa04 	addi	r7,r7,-25944
 100de48:	018040f4 	movhi	r6,259
 100de4c:	31a71404 	addi	r6,r6,-25520
 100de50:	0140a744 	movi	r5,669
 100de54:	010040f4 	movhi	r4,259
 100de58:	2125ee04 	addi	r4,r4,-26696
 100de5c:	10157a00 	call	10157a0 <__assert_func>
	metal_assert(padding != NULL);
 100de60:	e0800817 	ldw	r2,32(fp)
 100de64:	1000081e 	bne	r2,zero,100de88 <remoteproc_load_noblock+0x12c>
 100de68:	01c040f4 	movhi	r7,259
 100de6c:	39e6b004 	addi	r7,r7,-25920
 100de70:	018040f4 	movhi	r6,259
 100de74:	31a71404 	addi	r6,r6,-25520
 100de78:	0140a784 	movi	r5,670
 100de7c:	010040f4 	movhi	r4,259
 100de80:	2125ee04 	addi	r4,r4,-26696
 100de84:	10157a00 	call	10157a0 <__assert_func>

	metal_mutex_acquire(&rproc->lock);
 100de88:	e0bffc17 	ldw	r2,-16(fp)
 100de8c:	1009883a 	mov	r4,r2
 100de90:	100c2a40 	call	100c2a4 <metal_mutex_acquire>
	metal_log(METAL_LOG_DEBUG, "%s: check remoteproc status\r\n", __func__);
 100de94:	008060f4 	movhi	r2,387
 100de98:	10baf104 	addi	r2,r2,-5180
 100de9c:	10800017 	ldw	r2,0(r2)
 100dea0:	108001f0 	cmpltui	r2,r2,7
 100dea4:	10000d1e 	bne	r2,zero,100dedc <remoteproc_load_noblock+0x180>
 100dea8:	008060f4 	movhi	r2,387
 100deac:	10baf104 	addi	r2,r2,-5180
 100deb0:	10800117 	ldw	r2,4(r2)
 100deb4:	10000926 	beq	r2,zero,100dedc <remoteproc_load_noblock+0x180>
 100deb8:	008060f4 	movhi	r2,387
 100debc:	10baf104 	addi	r2,r2,-5180
 100dec0:	10800117 	ldw	r2,4(r2)
 100dec4:	018040f4 	movhi	r6,259
 100dec8:	31a71404 	addi	r6,r6,-25520
 100decc:	014040f4 	movhi	r5,259
 100ded0:	2965ba04 	addi	r5,r5,-26904
 100ded4:	010001c4 	movi	r4,7
 100ded8:	103ee83a 	callr	r2
	/* If remoteproc is not in ready state, cannot load executable */
	if (rproc->state != RPROC_READY) {
 100dedc:	e0bffc17 	ldw	r2,-16(fp)
 100dee0:	10800c17 	ldw	r2,48(r2)
 100dee4:	108000a0 	cmpeqi	r2,r2,2
 100dee8:	1000181e 	bne	r2,zero,100df4c <remoteproc_load_noblock+0x1f0>
		metal_log(METAL_LOG_ERROR,
 100deec:	008060f4 	movhi	r2,387
 100def0:	10baf104 	addi	r2,r2,-5180
 100def4:	10800017 	ldw	r2,0(r2)
 100def8:	108000f0 	cmpltui	r2,r2,3
 100defc:	10000e1e 	bne	r2,zero,100df38 <remoteproc_load_noblock+0x1dc>
 100df00:	008060f4 	movhi	r2,387
 100df04:	10baf104 	addi	r2,r2,-5180
 100df08:	10800117 	ldw	r2,4(r2)
 100df0c:	10000a26 	beq	r2,zero,100df38 <remoteproc_load_noblock+0x1dc>
 100df10:	008060f4 	movhi	r2,387
 100df14:	10baf104 	addi	r2,r2,-5180
 100df18:	10800117 	ldw	r2,4(r2)
 100df1c:	e0fffc17 	ldw	r3,-16(fp)
 100df20:	18c00c17 	ldw	r3,48(r3)
 100df24:	180d883a 	mov	r6,r3
 100df28:	014040f4 	movhi	r5,259
 100df2c:	2965c204 	addi	r5,r5,-26872
 100df30:	010000c4 	movi	r4,3
 100df34:	103ee83a 	callr	r2
			  "load failure: invalid rproc state %d.\r\n",
			  rproc->state);
		metal_mutex_release(&rproc->lock);
 100df38:	e0bffc17 	ldw	r2,-16(fp)
 100df3c:	1009883a 	mov	r4,r2
 100df40:	100c2d80 	call	100c2d8 <metal_mutex_release>
		return -RPROC_EINVAL;
 100df44:	00bfff84 	movi	r2,-2
 100df48:	00021306 	br	100e798 <remoteproc_load_noblock+0xa3c>
	}

	/* Check executable format to select a parser */
	loader = rproc->loader;
 100df4c:	e0bffc17 	ldw	r2,-16(fp)
 100df50:	10800b17 	ldw	r2,44(r2)
 100df54:	e0bff215 	stw	r2,-56(fp)
	if (!loader) {
 100df58:	e0bff217 	ldw	r2,-56(fp)
 100df5c:	10004d1e 	bne	r2,zero,100e094 <remoteproc_load_noblock+0x338>
		metal_log(METAL_LOG_DEBUG, "%s: check loader\r\n", __func__);
 100df60:	008060f4 	movhi	r2,387
 100df64:	10baf104 	addi	r2,r2,-5180
 100df68:	10800017 	ldw	r2,0(r2)
 100df6c:	108001f0 	cmpltui	r2,r2,7
 100df70:	10000d1e 	bne	r2,zero,100dfa8 <remoteproc_load_noblock+0x24c>
 100df74:	008060f4 	movhi	r2,387
 100df78:	10baf104 	addi	r2,r2,-5180
 100df7c:	10800117 	ldw	r2,4(r2)
 100df80:	10000926 	beq	r2,zero,100dfa8 <remoteproc_load_noblock+0x24c>
 100df84:	008060f4 	movhi	r2,387
 100df88:	10baf104 	addi	r2,r2,-5180
 100df8c:	10800117 	ldw	r2,4(r2)
 100df90:	018040f4 	movhi	r6,259
 100df94:	31a71404 	addi	r6,r6,-25520
 100df98:	014040f4 	movhi	r5,259
 100df9c:	2965f704 	addi	r5,r5,-26660
 100dfa0:	010001c4 	movi	r4,7
 100dfa4:	103ee83a 	callr	r2
		if (img_data == NULL || offset != 0 || len == 0) {
 100dfa8:	e0bffd17 	ldw	r2,-12(fp)
 100dfac:	10000426 	beq	r2,zero,100dfc0 <remoteproc_load_noblock+0x264>
 100dfb0:	e0bffe17 	ldw	r2,-8(fp)
 100dfb4:	1000021e 	bne	r2,zero,100dfc0 <remoteproc_load_noblock+0x264>
 100dfb8:	e0bfff17 	ldw	r2,-4(fp)
 100dfbc:	1000151e 	bne	r2,zero,100e014 <remoteproc_load_noblock+0x2b8>
			metal_log(METAL_LOG_ERROR,
 100dfc0:	008060f4 	movhi	r2,387
 100dfc4:	10baf104 	addi	r2,r2,-5180
 100dfc8:	10800017 	ldw	r2,0(r2)
 100dfcc:	108000f0 	cmpltui	r2,r2,3
 100dfd0:	10000b1e 	bne	r2,zero,100e000 <remoteproc_load_noblock+0x2a4>
 100dfd4:	008060f4 	movhi	r2,387
 100dfd8:	10baf104 	addi	r2,r2,-5180
 100dfdc:	10800117 	ldw	r2,4(r2)
 100dfe0:	10000726 	beq	r2,zero,100e000 <remoteproc_load_noblock+0x2a4>
 100dfe4:	008060f4 	movhi	r2,387
 100dfe8:	10baf104 	addi	r2,r2,-5180
 100dfec:	10800117 	ldw	r2,4(r2)
 100dff0:	014040f4 	movhi	r5,259
 100dff4:	2966b604 	addi	r5,r5,-25896
 100dff8:	010000c4 	movi	r4,3
 100dffc:	103ee83a 	callr	r2
				  "load failure, invalid inputs, not able to identify image.\r\n");
			metal_mutex_release(&rproc->lock);
 100e000:	e0bffc17 	ldw	r2,-16(fp)
 100e004:	1009883a 	mov	r4,r2
 100e008:	100c2d80 	call	100c2d8 <metal_mutex_release>
			return -RPROC_EINVAL;
 100e00c:	00bfff84 	movi	r2,-2
 100e010:	0001e106 	br	100e798 <remoteproc_load_noblock+0xa3c>
		}
		loader = remoteproc_check_fw_format(img_data, len);
 100e014:	e17fff17 	ldw	r5,-4(fp)
 100e018:	e13ffd17 	ldw	r4,-12(fp)
 100e01c:	100c3b80 	call	100c3b8 <remoteproc_check_fw_format>
 100e020:	e0bff215 	stw	r2,-56(fp)
		if (!loader) {
 100e024:	e0bff217 	ldw	r2,-56(fp)
 100e028:	1000171e 	bne	r2,zero,100e088 <remoteproc_load_noblock+0x32c>
			metal_log(METAL_LOG_ERROR,
 100e02c:	008060f4 	movhi	r2,387
 100e030:	10baf104 	addi	r2,r2,-5180
 100e034:	10800017 	ldw	r2,0(r2)
 100e038:	108000f0 	cmpltui	r2,r2,3
 100e03c:	10000b1e 	bne	r2,zero,100e06c <remoteproc_load_noblock+0x310>
 100e040:	008060f4 	movhi	r2,387
 100e044:	10baf104 	addi	r2,r2,-5180
 100e048:	10800117 	ldw	r2,4(r2)
 100e04c:	10000726 	beq	r2,zero,100e06c <remoteproc_load_noblock+0x310>
 100e050:	008060f4 	movhi	r2,387
 100e054:	10baf104 	addi	r2,r2,-5180
 100e058:	10800117 	ldw	r2,4(r2)
 100e05c:	014040f4 	movhi	r5,259
 100e060:	2966c504 	addi	r5,r5,-25836
 100e064:	010000c4 	movi	r4,3
 100e068:	103ee83a 	callr	r2
			       "load failure: failed to identify image.\r\n");
			ret = -RPROC_EINVAL;
 100e06c:	00bfff84 	movi	r2,-2
 100e070:	e0bff115 	stw	r2,-60(fp)
			metal_mutex_release(&rproc->lock);
 100e074:	e0bffc17 	ldw	r2,-16(fp)
 100e078:	1009883a 	mov	r4,r2
 100e07c:	100c2d80 	call	100c2d8 <metal_mutex_release>
			return -RPROC_EINVAL;
 100e080:	00bfff84 	movi	r2,-2
 100e084:	0001c406 	br	100e798 <remoteproc_load_noblock+0xa3c>
		}
		rproc->loader = loader;
 100e088:	e0bffc17 	ldw	r2,-16(fp)
 100e08c:	e0fff217 	ldw	r3,-56(fp)
 100e090:	10c00b15 	stw	r3,44(r2)
	}
	if (img_info == NULL || *img_info == NULL) {
 100e094:	e0800217 	ldw	r2,8(fp)
 100e098:	10000326 	beq	r2,zero,100e0a8 <remoteproc_load_noblock+0x34c>
 100e09c:	e0800217 	ldw	r2,8(fp)
 100e0a0:	10800017 	ldw	r2,0(r2)
 100e0a4:	1000021e 	bne	r2,zero,100e0b0 <remoteproc_load_noblock+0x354>
		last_load_state = 0;
 100e0a8:	e03ff315 	stw	zero,-52(fp)
 100e0ac:	00002006 	br	100e130 <remoteproc_load_noblock+0x3d4>
	} else {
		limg_info = *img_info;
 100e0b0:	e0800217 	ldw	r2,8(fp)
 100e0b4:	10800017 	ldw	r2,0(r2)
 100e0b8:	e0bff715 	stw	r2,-36(fp)
		last_load_state = loader->get_load_state(limg_info);
 100e0bc:	e0bff217 	ldw	r2,-56(fp)
 100e0c0:	10800517 	ldw	r2,20(r2)
 100e0c4:	e0fff717 	ldw	r3,-36(fp)
 100e0c8:	1809883a 	mov	r4,r3
 100e0cc:	103ee83a 	callr	r2
 100e0d0:	e0bff315 	stw	r2,-52(fp)
		if (last_load_state < 0) {
 100e0d4:	e0bff317 	ldw	r2,-52(fp)
 100e0d8:	1000150e 	bge	r2,zero,100e130 <remoteproc_load_noblock+0x3d4>
			metal_log(METAL_LOG_ERROR,
 100e0dc:	008060f4 	movhi	r2,387
 100e0e0:	10baf104 	addi	r2,r2,-5180
 100e0e4:	10800017 	ldw	r2,0(r2)
 100e0e8:	108000f0 	cmpltui	r2,r2,3
 100e0ec:	10000b1e 	bne	r2,zero,100e11c <remoteproc_load_noblock+0x3c0>
 100e0f0:	008060f4 	movhi	r2,387
 100e0f4:	10baf104 	addi	r2,r2,-5180
 100e0f8:	10800117 	ldw	r2,4(r2)
 100e0fc:	10000726 	beq	r2,zero,100e11c <remoteproc_load_noblock+0x3c0>
 100e100:	008060f4 	movhi	r2,387
 100e104:	10baf104 	addi	r2,r2,-5180
 100e108:	10800117 	ldw	r2,4(r2)
 100e10c:	014040f4 	movhi	r5,259
 100e110:	2966d004 	addi	r5,r5,-25792
 100e114:	010000c4 	movi	r4,3
 100e118:	103ee83a 	callr	r2
				  "load failure, not able get load state.\r\n");
			metal_mutex_release(&rproc->lock);
 100e11c:	e0bffc17 	ldw	r2,-16(fp)
 100e120:	1009883a 	mov	r4,r2
 100e124:	100c2d80 	call	100c2d8 <metal_mutex_release>
			return -RPROC_EINVAL;
 100e128:	00bfff84 	movi	r2,-2
 100e12c:	00019a06 	br	100e798 <remoteproc_load_noblock+0xa3c>
		}
	}
	da = RPROC_LOAD_ANYADDR;
 100e130:	00bfffc4 	movi	r2,-1
 100e134:	e0bff815 	stw	r2,-32(fp)
	*nlen = 0;
 100e138:	e0800617 	ldw	r2,24(fp)
 100e13c:	10000015 	stw	zero,0(r2)
	if ((last_load_state & RPROC_LOADER_READY_TO_LOAD) == 0 &&
 100e140:	e0bff317 	ldw	r2,-52(fp)
 100e144:	1080006c 	andhi	r2,r2,1
 100e148:	10004a1e 	bne	r2,zero,100e274 <remoteproc_load_noblock+0x518>
	    (last_load_state & RPROC_LOADER_LOAD_COMPLETE) == 0) {
 100e14c:	e0bff317 	ldw	r2,-52(fp)
 100e150:	1080012c 	andhi	r2,r2,4
			return -RPROC_EINVAL;
		}
	}
	da = RPROC_LOAD_ANYADDR;
	*nlen = 0;
	if ((last_load_state & RPROC_LOADER_READY_TO_LOAD) == 0 &&
 100e154:	1000471e 	bne	r2,zero,100e274 <remoteproc_load_noblock+0x518>
	    (last_load_state & RPROC_LOADER_LOAD_COMPLETE) == 0) {
		/* Get the mandatory executable headers */
		ret = loader->load_header(img_data, offset, len,
 100e158:	e0bff217 	ldw	r2,-56(fp)
 100e15c:	10800017 	ldw	r2,0(r2)
 100e160:	e13ff704 	addi	r4,fp,-36
 100e164:	e0c00617 	ldw	r3,24(fp)
 100e168:	d8c00215 	stw	r3,8(sp)
 100e16c:	e0c00517 	ldw	r3,20(fp)
 100e170:	d8c00115 	stw	r3,4(sp)
 100e174:	e0fff317 	ldw	r3,-52(fp)
 100e178:	d8c00015 	stw	r3,0(sp)
 100e17c:	200f883a 	mov	r7,r4
 100e180:	e1bfff17 	ldw	r6,-4(fp)
 100e184:	e17ffe17 	ldw	r5,-8(fp)
 100e188:	e13ffd17 	ldw	r4,-12(fp)
 100e18c:	103ee83a 	callr	r2
 100e190:	e0bff115 	stw	r2,-60(fp)
					  &limg_info, last_load_state,
					  noffset, nlen);
		metal_log(METAL_LOG_DEBUG,
 100e194:	008060f4 	movhi	r2,387
 100e198:	10baf104 	addi	r2,r2,-5180
 100e19c:	10800017 	ldw	r2,0(r2)
 100e1a0:	108001f0 	cmpltui	r2,r2,7
 100e1a4:	1000161e 	bne	r2,zero,100e200 <remoteproc_load_noblock+0x4a4>
 100e1a8:	008060f4 	movhi	r2,387
 100e1ac:	10baf104 	addi	r2,r2,-5180
 100e1b0:	10800117 	ldw	r2,4(r2)
 100e1b4:	10001226 	beq	r2,zero,100e200 <remoteproc_load_noblock+0x4a4>
 100e1b8:	008060f4 	movhi	r2,387
 100e1bc:	10baf104 	addi	r2,r2,-5180
 100e1c0:	10800117 	ldw	r2,4(r2)
 100e1c4:	e0c00517 	ldw	r3,20(fp)
 100e1c8:	18c00017 	ldw	r3,0(r3)
 100e1cc:	e1000617 	ldw	r4,24(fp)
 100e1d0:	21000017 	ldw	r4,0(r4)
 100e1d4:	d9000215 	stw	r4,8(sp)
 100e1d8:	d8c00115 	stw	r3,4(sp)
 100e1dc:	e0ffff17 	ldw	r3,-4(fp)
 100e1e0:	d8c00015 	stw	r3,0(sp)
 100e1e4:	e1fffe17 	ldw	r7,-8(fp)
 100e1e8:	018040f4 	movhi	r6,259
 100e1ec:	31a71404 	addi	r6,r6,-25520
 100e1f0:	014040f4 	movhi	r5,259
 100e1f4:	29660d04 	addi	r5,r5,-26572
 100e1f8:	010001c4 	movi	r4,7
 100e1fc:	103ee83a 	callr	r2
			  "%s, load header 0x%lx, 0x%x, next 0x%lx, 0x%x\r\n",
			  __func__, offset, len, *noffset, *nlen);
		if (ret < 0) {
 100e200:	e0bff117 	ldw	r2,-60(fp)
 100e204:	1000130e 	bge	r2,zero,100e254 <remoteproc_load_noblock+0x4f8>
			metal_log(METAL_LOG_ERROR,
 100e208:	008060f4 	movhi	r2,387
 100e20c:	10baf104 	addi	r2,r2,-5180
 100e210:	10800017 	ldw	r2,0(r2)
 100e214:	108000f0 	cmpltui	r2,r2,3
 100e218:	1001531e 	bne	r2,zero,100e768 <remoteproc_load_noblock+0xa0c>
 100e21c:	008060f4 	movhi	r2,387
 100e220:	10baf104 	addi	r2,r2,-5180
 100e224:	10800117 	ldw	r2,4(r2)
 100e228:	10014f26 	beq	r2,zero,100e768 <remoteproc_load_noblock+0xa0c>
 100e22c:	008060f4 	movhi	r2,387
 100e230:	10baf104 	addi	r2,r2,-5180
 100e234:	10800117 	ldw	r2,4(r2)
 100e238:	e1ffff17 	ldw	r7,-4(fp)
 100e23c:	e1bffe17 	ldw	r6,-8(fp)
 100e240:	014040f4 	movhi	r5,259
 100e244:	29661904 	addi	r5,r5,-26524
 100e248:	010000c4 	movi	r4,3
 100e24c:	103ee83a 	callr	r2
				  "load header failed 0x%lx,%d.\r\n",
				  offset, len);
			goto error1;
 100e250:	00014506 	br	100e768 <remoteproc_load_noblock+0xa0c>
		}
		last_load_state = ret;
 100e254:	e0bff117 	ldw	r2,-60(fp)
 100e258:	e0bff315 	stw	r2,-52(fp)
		if (*nlen != 0 &&
 100e25c:	e0800617 	ldw	r2,24(fp)
 100e260:	10800017 	ldw	r2,0(r2)
 100e264:	10000326 	beq	r2,zero,100e274 <remoteproc_load_noblock+0x518>
		    (last_load_state & RPROC_LOADER_READY_TO_LOAD) == 0)
 100e268:	e0bff317 	ldw	r2,-52(fp)
 100e26c:	1080006c 	andhi	r2,r2,1
				  "load header failed 0x%lx,%d.\r\n",
				  offset, len);
			goto error1;
		}
		last_load_state = ret;
		if (*nlen != 0 &&
 100e270:	10012a26 	beq	r2,zero,100e71c <remoteproc_load_noblock+0x9c0>
		    (last_load_state & RPROC_LOADER_READY_TO_LOAD) == 0)
			goto out;
	}
	if ((last_load_state & RPROC_LOADER_READY_TO_LOAD) != 0 ||
 100e274:	e0bff317 	ldw	r2,-52(fp)
 100e278:	1080006c 	andhi	r2,r2,1
 100e27c:	1000031e 	bne	r2,zero,100e28c <remoteproc_load_noblock+0x530>
	    (last_load_state & RPROC_LOADER_POST_DATA_LOAD) != 0) {
 100e280:	e0bff317 	ldw	r2,-52(fp)
 100e284:	108000ac 	andhi	r2,r2,2
		last_load_state = ret;
		if (*nlen != 0 &&
		    (last_load_state & RPROC_LOADER_READY_TO_LOAD) == 0)
			goto out;
	}
	if ((last_load_state & RPROC_LOADER_READY_TO_LOAD) != 0 ||
 100e288:	10007726 	beq	r2,zero,100e468 <remoteproc_load_noblock+0x70c>
	    (last_load_state & RPROC_LOADER_POST_DATA_LOAD) != 0) {
		/* Enough information to know which target memory for
		 * which data.
		 */
		ret = loader->load_data(rproc, img_data, offset, len,
 100e28c:	e0bff217 	ldw	r2,-56(fp)
 100e290:	10800117 	ldw	r2,4(r2)
 100e294:	e0c00717 	ldw	r3,28(fp)
 100e298:	d8c00615 	stw	r3,24(sp)
 100e29c:	e0c00817 	ldw	r3,32(fp)
 100e2a0:	d8c00515 	stw	r3,20(sp)
 100e2a4:	e0c00617 	ldw	r3,24(fp)
 100e2a8:	d8c00415 	stw	r3,16(sp)
 100e2ac:	e0c00517 	ldw	r3,20(fp)
 100e2b0:	d8c00315 	stw	r3,12(sp)
 100e2b4:	e0fff804 	addi	r3,fp,-32
 100e2b8:	d8c00215 	stw	r3,8(sp)
 100e2bc:	e0fff317 	ldw	r3,-52(fp)
 100e2c0:	d8c00115 	stw	r3,4(sp)
 100e2c4:	e0fff704 	addi	r3,fp,-36
 100e2c8:	d8c00015 	stw	r3,0(sp)
 100e2cc:	e1ffff17 	ldw	r7,-4(fp)
 100e2d0:	e1bffe17 	ldw	r6,-8(fp)
 100e2d4:	e17ffd17 	ldw	r5,-12(fp)
 100e2d8:	e13ffc17 	ldw	r4,-16(fp)
 100e2dc:	103ee83a 	callr	r2
 100e2e0:	e0bff115 	stw	r2,-60(fp)
					&limg_info, last_load_state, &da,
					noffset, nlen, padding, nmlen);
		metal_log(METAL_LOG_DEBUG,
 100e2e4:	008060f4 	movhi	r2,387
 100e2e8:	10baf104 	addi	r2,r2,-5180
 100e2ec:	10800017 	ldw	r2,0(r2)
 100e2f0:	108001f0 	cmpltui	r2,r2,7
 100e2f4:	1000161e 	bne	r2,zero,100e350 <remoteproc_load_noblock+0x5f4>
 100e2f8:	008060f4 	movhi	r2,387
 100e2fc:	10baf104 	addi	r2,r2,-5180
 100e300:	10800117 	ldw	r2,4(r2)
 100e304:	10001226 	beq	r2,zero,100e350 <remoteproc_load_noblock+0x5f4>
 100e308:	008060f4 	movhi	r2,387
 100e30c:	10baf104 	addi	r2,r2,-5180
 100e310:	10800117 	ldw	r2,4(r2)
 100e314:	e0c00517 	ldw	r3,20(fp)
 100e318:	18c00017 	ldw	r3,0(r3)
 100e31c:	e1000617 	ldw	r4,24(fp)
 100e320:	21000017 	ldw	r4,0(r4)
 100e324:	d9000215 	stw	r4,8(sp)
 100e328:	d8c00115 	stw	r3,4(sp)
 100e32c:	e0ffff17 	ldw	r3,-4(fp)
 100e330:	d8c00015 	stw	r3,0(sp)
 100e334:	e1fffe17 	ldw	r7,-8(fp)
 100e338:	018040f4 	movhi	r6,259
 100e33c:	31a71404 	addi	r6,r6,-25520
 100e340:	014040f4 	movhi	r5,259
 100e344:	2966db04 	addi	r5,r5,-25748
 100e348:	010001c4 	movi	r4,7
 100e34c:	103ee83a 	callr	r2
			  "%s, load data 0x%lx, 0x%x, next 0x%lx, 0x%x\r\n",
			  __func__, offset, len, *noffset, *nlen);
		if (ret < 0) {
 100e350:	e0bff117 	ldw	r2,-60(fp)
 100e354:	1000130e 	bge	r2,zero,100e3a4 <remoteproc_load_noblock+0x648>
			metal_log(METAL_LOG_ERROR,
 100e358:	008060f4 	movhi	r2,387
 100e35c:	10baf104 	addi	r2,r2,-5180
 100e360:	10800017 	ldw	r2,0(r2)
 100e364:	108000f0 	cmpltui	r2,r2,3
 100e368:	1001011e 	bne	r2,zero,100e770 <remoteproc_load_noblock+0xa14>
 100e36c:	008060f4 	movhi	r2,387
 100e370:	10baf104 	addi	r2,r2,-5180
 100e374:	10800117 	ldw	r2,4(r2)
 100e378:	1000fd26 	beq	r2,zero,100e770 <remoteproc_load_noblock+0xa14>
 100e37c:	008060f4 	movhi	r2,387
 100e380:	10baf104 	addi	r2,r2,-5180
 100e384:	10800117 	ldw	r2,4(r2)
 100e388:	e1ffff17 	ldw	r7,-4(fp)
 100e38c:	e1bffe17 	ldw	r6,-8(fp)
 100e390:	014040f4 	movhi	r5,259
 100e394:	29663104 	addi	r5,r5,-26428
 100e398:	010000c4 	movi	r4,3
 100e39c:	103ee83a 	callr	r2
				  "load data failed,0x%lx,%d\r\n",
				  offset, len);
			goto error1;
 100e3a0:	0000f306 	br	100e770 <remoteproc_load_noblock+0xa14>
		}
		last_load_state = ret;
 100e3a4:	e0bff117 	ldw	r2,-60(fp)
 100e3a8:	e0bff315 	stw	r2,-52(fp)
		if (da != RPROC_LOAD_ANYADDR) {
 100e3ac:	e0bff817 	ldw	r2,-32(fp)
 100e3b0:	10bfffe0 	cmpeqi	r2,r2,-1
 100e3b4:	1000291e 	bne	r2,zero,100e45c <remoteproc_load_noblock+0x700>
			/* get the I/O region from remoteproc */
			*pa = METAL_BAD_PHYS;
 100e3b8:	e0800317 	ldw	r2,12(fp)
 100e3bc:	00ffffc4 	movi	r3,-1
 100e3c0:	10c00015 	stw	r3,0(r2)
			(void)remoteproc_mmap(rproc, pa, &da, *nmlen, 0, io);
 100e3c4:	e0800717 	ldw	r2,28(fp)
 100e3c8:	11000017 	ldw	r4,0(r2)
 100e3cc:	e0fff804 	addi	r3,fp,-32
 100e3d0:	e0800417 	ldw	r2,16(fp)
 100e3d4:	d8800115 	stw	r2,4(sp)
 100e3d8:	d8000015 	stw	zero,0(sp)
 100e3dc:	200f883a 	mov	r7,r4
 100e3e0:	180d883a 	mov	r6,r3
 100e3e4:	e1400317 	ldw	r5,12(fp)
 100e3e8:	e13ffc17 	ldw	r4,-16(fp)
 100e3ec:	100ce140 	call	100ce14 <remoteproc_mmap>
			if (*pa == METAL_BAD_PHYS || io == NULL) {
 100e3f0:	e0800317 	ldw	r2,12(fp)
 100e3f4:	10800017 	ldw	r2,0(r2)
 100e3f8:	10bfffe0 	cmpeqi	r2,r2,-1
 100e3fc:	1000021e 	bne	r2,zero,100e408 <remoteproc_load_noblock+0x6ac>
 100e400:	e0800417 	ldw	r2,16(fp)
 100e404:	1000151e 	bne	r2,zero,100e45c <remoteproc_load_noblock+0x700>
				metal_log(METAL_LOG_ERROR,
 100e408:	008060f4 	movhi	r2,387
 100e40c:	10baf104 	addi	r2,r2,-5180
 100e410:	10800017 	ldw	r2,0(r2)
 100e414:	108000f0 	cmpltui	r2,r2,3
 100e418:	10000d1e 	bne	r2,zero,100e450 <remoteproc_load_noblock+0x6f4>
 100e41c:	008060f4 	movhi	r2,387
 100e420:	10baf104 	addi	r2,r2,-5180
 100e424:	10800117 	ldw	r2,4(r2)
 100e428:	10000926 	beq	r2,zero,100e450 <remoteproc_load_noblock+0x6f4>
 100e42c:	008060f4 	movhi	r2,387
 100e430:	10baf104 	addi	r2,r2,-5180
 100e434:	10800117 	ldw	r2,4(r2)
 100e438:	e0fff817 	ldw	r3,-32(fp)
 100e43c:	180d883a 	mov	r6,r3
 100e440:	014040f4 	movhi	r5,259
 100e444:	29664c04 	addi	r5,r5,-26320
 100e448:	010000c4 	movi	r4,3
 100e44c:	103ee83a 	callr	r2
					  "load failed, no mapping for 0x%llx.\r\n",
					  da);
				ret = -RPROC_EINVAL;
 100e450:	00bfff84 	movi	r2,-2
 100e454:	e0bff115 	stw	r2,-60(fp)
				goto error1;
 100e458:	0000c606 	br	100e774 <remoteproc_load_noblock+0xa18>
			}
		}
		if (*nlen != 0)
 100e45c:	e0800617 	ldw	r2,24(fp)
 100e460:	10800017 	ldw	r2,0(r2)
 100e464:	1000af1e 	bne	r2,zero,100e724 <remoteproc_load_noblock+0x9c8>
			goto out;
	}
	if ((last_load_state & RPROC_LOADER_LOAD_COMPLETE) != 0) {
 100e468:	e0bff317 	ldw	r2,-52(fp)
 100e46c:	1080012c 	andhi	r2,r2,4
 100e470:	1000ad26 	beq	r2,zero,100e728 <remoteproc_load_noblock+0x9cc>
		/* Get resource table */
		size_t rsc_offset;
		size_t rsc_io_offset;

		ret = loader->locate_rsc_table(limg_info, &rsc_da,
 100e474:	e0bff217 	ldw	r2,-56(fp)
 100e478:	10800217 	ldw	r2,8(r2)
 100e47c:	e0fff717 	ldw	r3,-36(fp)
 100e480:	e1bffa04 	addi	r6,fp,-24
 100e484:	e17ffb04 	addi	r5,fp,-20
 100e488:	e13ff904 	addi	r4,fp,-28
 100e48c:	300f883a 	mov	r7,r6
 100e490:	280d883a 	mov	r6,r5
 100e494:	200b883a 	mov	r5,r4
 100e498:	1809883a 	mov	r4,r3
 100e49c:	103ee83a 	callr	r2
 100e4a0:	e0bff115 	stw	r2,-60(fp)
					       &rsc_offset, &rsc_size);
		if (ret == 0 && rsc_size > 0) {
 100e4a4:	e0bff117 	ldw	r2,-60(fp)
 100e4a8:	1000931e 	bne	r2,zero,100e6f8 <remoteproc_load_noblock+0x99c>
 100e4ac:	e0bffa17 	ldw	r2,-24(fp)
 100e4b0:	10009126 	beq	r2,zero,100e6f8 <remoteproc_load_noblock+0x99c>
			lrsc_table = metal_allocate_memory(rsc_size);
 100e4b4:	e0bffa17 	ldw	r2,-24(fp)
 100e4b8:	1009883a 	mov	r4,r2
 100e4bc:	100bbf40 	call	100bbf4 <metal_allocate_memory>
 100e4c0:	e0bff515 	stw	r2,-44(fp)
			if (lrsc_table == NULL) {
 100e4c4:	e0bff517 	ldw	r2,-44(fp)
 100e4c8:	1000031e 	bne	r2,zero,100e4d8 <remoteproc_load_noblock+0x77c>
				ret = -RPROC_ENOMEM;
 100e4cc:	00bfffc4 	movi	r2,-1
 100e4d0:	e0bff115 	stw	r2,-60(fp)
				goto error1;
 100e4d4:	0000a706 	br	100e774 <remoteproc_load_noblock+0xa18>
			}
			rsc_table = remoteproc_mmap(rproc, NULL, &rsc_da,
 100e4d8:	e13ffa17 	ldw	r4,-24(fp)
 100e4dc:	e0fff904 	addi	r3,fp,-28
 100e4e0:	e0800417 	ldw	r2,16(fp)
 100e4e4:	d8800115 	stw	r2,4(sp)
 100e4e8:	d8000015 	stw	zero,0(sp)
 100e4ec:	200f883a 	mov	r7,r4
 100e4f0:	180d883a 	mov	r6,r3
 100e4f4:	000b883a 	mov	r5,zero
 100e4f8:	e13ffc17 	ldw	r4,-16(fp)
 100e4fc:	100ce140 	call	100ce14 <remoteproc_mmap>
 100e500:	e0bff415 	stw	r2,-48(fp)
						    rsc_size, 0, io);
			if (*io == NULL) {
 100e504:	e0800417 	ldw	r2,16(fp)
 100e508:	10800017 	ldw	r2,0(r2)
 100e50c:	1000131e 	bne	r2,zero,100e55c <remoteproc_load_noblock+0x800>
				metal_log(METAL_LOG_ERROR,
 100e510:	008060f4 	movhi	r2,387
 100e514:	10baf104 	addi	r2,r2,-5180
 100e518:	10800017 	ldw	r2,0(r2)
 100e51c:	108000f0 	cmpltui	r2,r2,3
 100e520:	10000b1e 	bne	r2,zero,100e550 <remoteproc_load_noblock+0x7f4>
 100e524:	008060f4 	movhi	r2,387
 100e528:	10baf104 	addi	r2,r2,-5180
 100e52c:	10800117 	ldw	r2,4(r2)
 100e530:	10000726 	beq	r2,zero,100e550 <remoteproc_load_noblock+0x7f4>
 100e534:	008060f4 	movhi	r2,387
 100e538:	10baf104 	addi	r2,r2,-5180
 100e53c:	10800117 	ldw	r2,4(r2)
 100e540:	014040f4 	movhi	r5,259
 100e544:	2966e704 	addi	r5,r5,-25700
 100e548:	010000c4 	movi	r4,3
 100e54c:	103ee83a 	callr	r2
					  "load failed: failed to mmap rsc\r\n");
				metal_free_memory(lrsc_table);
 100e550:	e13ff517 	ldw	r4,-44(fp)
 100e554:	100bc240 	call	100bc24 <metal_free_memory>
				goto error1;
 100e558:	00008606 	br	100e774 <remoteproc_load_noblock+0xa18>
			}
			rsc_io_offset = metal_io_virt_to_offset(*io, rsc_table);
 100e55c:	e0800417 	ldw	r2,16(fp)
 100e560:	10800017 	ldw	r2,0(r2)
 100e564:	e17ff417 	ldw	r5,-48(fp)
 100e568:	1009883a 	mov	r4,r2
 100e56c:	100bf780 	call	100bf78 <metal_io_virt_to_offset>
 100e570:	e0bff615 	stw	r2,-40(fp)
			ret = metal_io_block_read(*io, rsc_io_offset,
 100e574:	e0800417 	ldw	r2,16(fp)
 100e578:	10800017 	ldw	r2,0(r2)
 100e57c:	e0fffa17 	ldw	r3,-24(fp)
 100e580:	180f883a 	mov	r7,r3
 100e584:	e1bff517 	ldw	r6,-44(fp)
 100e588:	e17ff617 	ldw	r5,-40(fp)
 100e58c:	1009883a 	mov	r4,r2
 100e590:	10081e80 	call	10081e8 <metal_io_block_read>
 100e594:	e0bff115 	stw	r2,-60(fp)
						  lrsc_table, rsc_size);
			if (ret != (int)rsc_size) {
 100e598:	e0bffa17 	ldw	r2,-24(fp)
 100e59c:	1007883a 	mov	r3,r2
 100e5a0:	e0bff117 	ldw	r2,-60(fp)
 100e5a4:	10c01326 	beq	r2,r3,100e5f4 <remoteproc_load_noblock+0x898>
				metal_log(METAL_LOG_ERROR,
 100e5a8:	008060f4 	movhi	r2,387
 100e5ac:	10baf104 	addi	r2,r2,-5180
 100e5b0:	10800017 	ldw	r2,0(r2)
 100e5b4:	108000f0 	cmpltui	r2,r2,3
 100e5b8:	10000b1e 	bne	r2,zero,100e5e8 <remoteproc_load_noblock+0x88c>
 100e5bc:	008060f4 	movhi	r2,387
 100e5c0:	10baf104 	addi	r2,r2,-5180
 100e5c4:	10800117 	ldw	r2,4(r2)
 100e5c8:	10000726 	beq	r2,zero,100e5e8 <remoteproc_load_noblock+0x88c>
 100e5cc:	008060f4 	movhi	r2,387
 100e5d0:	10baf104 	addi	r2,r2,-5180
 100e5d4:	10800117 	ldw	r2,4(r2)
 100e5d8:	014040f4 	movhi	r5,259
 100e5dc:	2966f004 	addi	r5,r5,-25664
 100e5e0:	010000c4 	movi	r4,3
 100e5e4:	103ee83a 	callr	r2
					  "load failed: failed to get rsc\r\n");
				metal_free_memory(lrsc_table);
 100e5e8:	e13ff517 	ldw	r4,-44(fp)
 100e5ec:	100bc240 	call	100bc24 <metal_free_memory>
				goto error1;
 100e5f0:	00006006 	br	100e774 <remoteproc_load_noblock+0xa18>
			}
			/* parse resource table */
			ret = remoteproc_parse_rsc_table(rproc, lrsc_table,
 100e5f4:	e0bffa17 	ldw	r2,-24(fp)
 100e5f8:	100d883a 	mov	r6,r2
 100e5fc:	e17ff517 	ldw	r5,-44(fp)
 100e600:	e13ffc17 	ldw	r4,-16(fp)
 100e604:	100c7780 	call	100c778 <remoteproc_parse_rsc_table>
 100e608:	e0bff115 	stw	r2,-60(fp)
							 rsc_size);
			if (ret < 0) {
 100e60c:	e0bff117 	ldw	r2,-60(fp)
 100e610:	1000140e 	bge	r2,zero,100e664 <remoteproc_load_noblock+0x908>
				metal_log(METAL_LOG_ERROR,
 100e614:	008060f4 	movhi	r2,387
 100e618:	10baf104 	addi	r2,r2,-5180
 100e61c:	10800017 	ldw	r2,0(r2)
 100e620:	108000f0 	cmpltui	r2,r2,3
 100e624:	10000b1e 	bne	r2,zero,100e654 <remoteproc_load_noblock+0x8f8>
 100e628:	008060f4 	movhi	r2,387
 100e62c:	10baf104 	addi	r2,r2,-5180
 100e630:	10800117 	ldw	r2,4(r2)
 100e634:	10000726 	beq	r2,zero,100e654 <remoteproc_load_noblock+0x8f8>
 100e638:	008060f4 	movhi	r2,387
 100e63c:	10baf104 	addi	r2,r2,-5180
 100e640:	10800117 	ldw	r2,4(r2)
 100e644:	014040f4 	movhi	r5,259
 100e648:	2966f904 	addi	r5,r5,-25628
 100e64c:	010000c4 	movi	r4,3
 100e650:	103ee83a 	callr	r2
					  "load failed: failed to parse rsc\r\n");
				metal_free_memory(lrsc_table);
 100e654:	e13ff517 	ldw	r4,-44(fp)
 100e658:	100bc240 	call	100bc24 <metal_free_memory>
				goto error1;
 100e65c:	0001883a 	nop
 100e660:	00004406 	br	100e774 <remoteproc_load_noblock+0xa18>
			}
			/* Update resource table */
			ret = metal_io_block_write(*io, rsc_io_offset,
 100e664:	e0800417 	ldw	r2,16(fp)
 100e668:	10800017 	ldw	r2,0(r2)
 100e66c:	e0fffa17 	ldw	r3,-24(fp)
 100e670:	180f883a 	mov	r7,r3
 100e674:	e1bff517 	ldw	r6,-44(fp)
 100e678:	e17ff617 	ldw	r5,-40(fp)
 100e67c:	1009883a 	mov	r4,r2
 100e680:	100839c0 	call	100839c <metal_io_block_write>
 100e684:	e0bff115 	stw	r2,-60(fp)
						  lrsc_table, rsc_size);
			if (ret != (int)rsc_size) {
 100e688:	e0bffa17 	ldw	r2,-24(fp)
 100e68c:	1007883a 	mov	r3,r2
 100e690:	e0bff117 	ldw	r2,-60(fp)
 100e694:	10c01026 	beq	r2,r3,100e6d8 <remoteproc_load_noblock+0x97c>
				metal_log(METAL_LOG_WARNING,
 100e698:	008060f4 	movhi	r2,387
 100e69c:	10baf104 	addi	r2,r2,-5180
 100e6a0:	10800017 	ldw	r2,0(r2)
 100e6a4:	10800130 	cmpltui	r2,r2,4
 100e6a8:	10000b1e 	bne	r2,zero,100e6d8 <remoteproc_load_noblock+0x97c>
 100e6ac:	008060f4 	movhi	r2,387
 100e6b0:	10baf104 	addi	r2,r2,-5180
 100e6b4:	10800117 	ldw	r2,4(r2)
 100e6b8:	10000726 	beq	r2,zero,100e6d8 <remoteproc_load_noblock+0x97c>
 100e6bc:	008060f4 	movhi	r2,387
 100e6c0:	10baf104 	addi	r2,r2,-5180
 100e6c4:	10800117 	ldw	r2,4(r2)
 100e6c8:	014040f4 	movhi	r5,259
 100e6cc:	29670204 	addi	r5,r5,-25592
 100e6d0:	01000104 	movi	r4,4
 100e6d4:	103ee83a 	callr	r2
					  "load executable, failed to update rsc\r\n");
			}
			rproc->rsc_table = rsc_table;
 100e6d8:	e0bffc17 	ldw	r2,-16(fp)
 100e6dc:	e0fff417 	ldw	r3,-48(fp)
 100e6e0:	10c00115 	stw	r3,4(r2)
			rproc->rsc_len = rsc_size;
 100e6e4:	e0fffa17 	ldw	r3,-24(fp)
 100e6e8:	e0bffc17 	ldw	r2,-16(fp)
 100e6ec:	10c00215 	stw	r3,8(r2)
			metal_free_memory(lrsc_table);
 100e6f0:	e13ff517 	ldw	r4,-44(fp)
 100e6f4:	100bc240 	call	100bc24 <metal_free_memory>
		}

		/* get entry point from the firmware */
		rproc->bootaddr = loader->get_entry(limg_info);
 100e6f8:	e0bff217 	ldw	r2,-56(fp)
 100e6fc:	10800417 	ldw	r2,16(r2)
 100e700:	e0fff717 	ldw	r3,-36(fp)
 100e704:	1809883a 	mov	r4,r3
 100e708:	103ee83a 	callr	r2
 100e70c:	1007883a 	mov	r3,r2
 100e710:	e0bffc17 	ldw	r2,-16(fp)
 100e714:	10c00a15 	stw	r3,40(r2)
 100e718:	00000306 	br	100e728 <remoteproc_load_noblock+0x9cc>
			goto error1;
		}
		last_load_state = ret;
		if (*nlen != 0 &&
		    (last_load_state & RPROC_LOADER_READY_TO_LOAD) == 0)
			goto out;
 100e71c:	0001883a 	nop
 100e720:	00000106 	br	100e728 <remoteproc_load_noblock+0x9cc>
				ret = -RPROC_EINVAL;
				goto error1;
			}
		}
		if (*nlen != 0)
			goto out;
 100e724:	0001883a 	nop

		/* get entry point from the firmware */
		rproc->bootaddr = loader->get_entry(limg_info);
	}
out:
	if (img_info != NULL)
 100e728:	e0800217 	ldw	r2,8(fp)
 100e72c:	10000426 	beq	r2,zero,100e740 <remoteproc_load_noblock+0x9e4>
		*img_info = limg_info;
 100e730:	e0fff717 	ldw	r3,-36(fp)
 100e734:	e0800217 	ldw	r2,8(fp)
 100e738:	10c00015 	stw	r3,0(r2)
 100e73c:	00000506 	br	100e754 <remoteproc_load_noblock+0x9f8>
	else
		loader->release(limg_info);
 100e740:	e0bff217 	ldw	r2,-56(fp)
 100e744:	10800317 	ldw	r2,12(r2)
 100e748:	e0fff717 	ldw	r3,-36(fp)
 100e74c:	1809883a 	mov	r4,r3
 100e750:	103ee83a 	callr	r2
	metal_mutex_release(&rproc->lock);
 100e754:	e0bffc17 	ldw	r2,-16(fp)
 100e758:	1009883a 	mov	r4,r2
 100e75c:	100c2d80 	call	100c2d8 <metal_mutex_release>
	return 0;
 100e760:	0005883a 	mov	r2,zero
 100e764:	00000c06 	br	100e798 <remoteproc_load_noblock+0xa3c>
			  __func__, offset, len, *noffset, *nlen);
		if (ret < 0) {
			metal_log(METAL_LOG_ERROR,
				  "load header failed 0x%lx,%d.\r\n",
				  offset, len);
			goto error1;
 100e768:	0001883a 	nop
 100e76c:	00000106 	br	100e774 <remoteproc_load_noblock+0xa18>
			  __func__, offset, len, *noffset, *nlen);
		if (ret < 0) {
			metal_log(METAL_LOG_ERROR,
				  "load data failed,0x%lx,%d\r\n",
				  offset, len);
			goto error1;
 100e770:	0001883a 	nop
		loader->release(limg_info);
	metal_mutex_release(&rproc->lock);
	return 0;

error1:
	loader->release(limg_info);
 100e774:	e0bff217 	ldw	r2,-56(fp)
 100e778:	10800317 	ldw	r2,12(r2)
 100e77c:	e0fff717 	ldw	r3,-36(fp)
 100e780:	1809883a 	mov	r4,r3
 100e784:	103ee83a 	callr	r2
	metal_mutex_release(&rproc->lock);
 100e788:	e0bffc17 	ldw	r2,-16(fp)
 100e78c:	1009883a 	mov	r4,r2
 100e790:	100c2d80 	call	100c2d8 <metal_mutex_release>
	return ret;
 100e794:	e0bff117 	ldw	r2,-60(fp)
}
 100e798:	e037883a 	mov	sp,fp
 100e79c:	dfc00117 	ldw	ra,4(sp)
 100e7a0:	df000017 	ldw	fp,0(sp)
 100e7a4:	dec00204 	addi	sp,sp,8
 100e7a8:	f800283a 	ret

0100e7ac <remoteproc_allocate_id>:

unsigned int remoteproc_allocate_id(struct remoteproc *rproc,
				    unsigned int start,
				    unsigned int end)
{
 100e7ac:	defffa04 	addi	sp,sp,-24
 100e7b0:	dfc00515 	stw	ra,20(sp)
 100e7b4:	df000415 	stw	fp,16(sp)
 100e7b8:	df000404 	addi	fp,sp,16
 100e7bc:	e13ffd15 	stw	r4,-12(fp)
 100e7c0:	e17ffe15 	stw	r5,-8(fp)
 100e7c4:	e1bfff15 	stw	r6,-4(fp)
	unsigned int notifyid;

	if (start == RSC_NOTIFY_ID_ANY)
 100e7c8:	e0bffe17 	ldw	r2,-8(fp)
 100e7cc:	10bfffd8 	cmpnei	r2,r2,-1
 100e7d0:	1000011e 	bne	r2,zero,100e7d8 <remoteproc_allocate_id+0x2c>
		start = 0;
 100e7d4:	e03ffe15 	stw	zero,-8(fp)
	if (end == 0)
 100e7d8:	e0bfff17 	ldw	r2,-4(fp)
 100e7dc:	1000021e 	bne	r2,zero,100e7e8 <remoteproc_allocate_id+0x3c>
		end = METAL_BITS_PER_ULONG;
 100e7e0:	00800804 	movi	r2,32
 100e7e4:	e0bfff15 	stw	r2,-4(fp)

	notifyid = metal_bitmap_next_clear_bit(&rproc->bitmap,
 100e7e8:	e0bffd17 	ldw	r2,-12(fp)
 100e7ec:	10800804 	addi	r2,r2,32
 100e7f0:	e1bfff17 	ldw	r6,-4(fp)
 100e7f4:	e17ffe17 	ldw	r5,-8(fp)
 100e7f8:	1009883a 	mov	r4,r2
 100e7fc:	100bd680 	call	100bd68 <metal_bitmap_next_clear_bit>
 100e800:	e0bffc15 	stw	r2,-16(fp)
					       start, end);
	if (notifyid != end)
 100e804:	e0fffc17 	ldw	r3,-16(fp)
 100e808:	e0bfff17 	ldw	r2,-4(fp)
 100e80c:	18800726 	beq	r3,r2,100e82c <remoteproc_allocate_id+0x80>
		metal_bitmap_set_bit(&rproc->bitmap, notifyid);
 100e810:	e0bffd17 	ldw	r2,-12(fp)
 100e814:	10800804 	addi	r2,r2,32
 100e818:	e0fffc17 	ldw	r3,-16(fp)
 100e81c:	180b883a 	mov	r5,r3
 100e820:	1009883a 	mov	r4,r2
 100e824:	100bc580 	call	100bc58 <metal_bitmap_set_bit>
 100e828:	00000206 	br	100e834 <remoteproc_allocate_id+0x88>
	else
		notifyid = RSC_NOTIFY_ID_ANY;
 100e82c:	00bfffc4 	movi	r2,-1
 100e830:	e0bffc15 	stw	r2,-16(fp)

	return notifyid;
 100e834:	e0bffc17 	ldw	r2,-16(fp)
}
 100e838:	e037883a 	mov	sp,fp
 100e83c:	dfc00117 	ldw	ra,4(sp)
 100e840:	df000017 	ldw	fp,0(sp)
 100e844:	dec00204 	addi	sp,sp,8
 100e848:	f800283a 	ret

0100e84c <remoteproc_virtio_notify>:

static int remoteproc_virtio_notify(void *priv, uint32_t id)
{
 100e84c:	defffb04 	addi	sp,sp,-20
 100e850:	dfc00415 	stw	ra,16(sp)
 100e854:	df000315 	stw	fp,12(sp)
 100e858:	df000304 	addi	fp,sp,12
 100e85c:	e13ffe15 	stw	r4,-8(fp)
 100e860:	e17fff15 	stw	r5,-4(fp)
	struct remoteproc *rproc = priv;
 100e864:	e0bffe17 	ldw	r2,-8(fp)
 100e868:	e0bffd15 	stw	r2,-12(fp)

	return rproc->ops->notify(rproc, id);
 100e86c:	e0bffd17 	ldw	r2,-12(fp)
 100e870:	10800917 	ldw	r2,36(r2)
 100e874:	10800817 	ldw	r2,32(r2)
 100e878:	e17fff17 	ldw	r5,-4(fp)
 100e87c:	e13ffd17 	ldw	r4,-12(fp)
 100e880:	103ee83a 	callr	r2
}
 100e884:	e037883a 	mov	sp,fp
 100e888:	dfc00117 	ldw	ra,4(sp)
 100e88c:	df000017 	ldw	fp,0(sp)
 100e890:	dec00204 	addi	sp,sp,8
 100e894:	f800283a 	ret

0100e898 <remoteproc_create_virtio>:

struct virtio_device *
remoteproc_create_virtio(struct remoteproc *rproc,
			 int vdev_id, unsigned int role,
			 void (*rst_cb)(struct virtio_device *vdev))
{
 100e898:	deffe504 	addi	sp,sp,-108
 100e89c:	dfc01a15 	stw	ra,104(sp)
 100e8a0:	df001915 	stw	fp,100(sp)
 100e8a4:	df001904 	addi	fp,sp,100
 100e8a8:	e13ffc15 	stw	r4,-16(fp)
 100e8ac:	e17ffd15 	stw	r5,-12(fp)
 100e8b0:	e1bffe15 	stw	r6,-8(fp)
 100e8b4:	e1ffff15 	stw	r7,-4(fp)
	size_t vdev_rsc_offset;
	unsigned int notifyid;
	unsigned int num_vrings, i;
	struct metal_list *node;

	metal_assert(rproc);
 100e8b8:	e0bffc17 	ldw	r2,-16(fp)
 100e8bc:	1000081e 	bne	r2,zero,100e8e0 <remoteproc_create_virtio+0x48>
 100e8c0:	01c040f4 	movhi	r7,259
 100e8c4:	39e70c04 	addi	r7,r7,-25552
 100e8c8:	018040f4 	movhi	r6,259
 100e8cc:	31a71a04 	addi	r6,r6,-25496
 100e8d0:	0140dc44 	movi	r5,881
 100e8d4:	010040f4 	movhi	r4,259
 100e8d8:	2125ee04 	addi	r4,r4,-26696
 100e8dc:	10157a00 	call	10157a0 <__assert_func>
	metal_mutex_acquire(&rproc->lock);
 100e8e0:	e0bffc17 	ldw	r2,-16(fp)
 100e8e4:	1009883a 	mov	r4,r2
 100e8e8:	100c2a40 	call	100c2a4 <metal_mutex_acquire>
	rsc_table = rproc->rsc_table;
 100e8ec:	e0bffc17 	ldw	r2,-16(fp)
 100e8f0:	10800117 	ldw	r2,4(r2)
 100e8f4:	e0bfec15 	stw	r2,-80(fp)
	vdev_rsc_io = rproc->rsc_io;
 100e8f8:	e0bffc17 	ldw	r2,-16(fp)
 100e8fc:	10800317 	ldw	r2,12(r2)
 100e900:	e0bfed15 	stw	r2,-76(fp)
	vdev_rsc_offset = find_rsc(rsc_table, RSC_VDEV, vdev_id);
 100e904:	e0bffd17 	ldw	r2,-12(fp)
 100e908:	100d883a 	mov	r6,r2
 100e90c:	014000c4 	movi	r5,3
 100e910:	e13fec17 	ldw	r4,-80(fp)
 100e914:	10103c80 	call	10103c8 <find_rsc>
 100e918:	e0bfee15 	stw	r2,-72(fp)
	if (!vdev_rsc_offset) {
 100e91c:	e0bfee17 	ldw	r2,-72(fp)
 100e920:	1000051e 	bne	r2,zero,100e938 <remoteproc_create_virtio+0xa0>
		metal_mutex_release(&rproc->lock);
 100e924:	e0bffc17 	ldw	r2,-16(fp)
 100e928:	1009883a 	mov	r4,r2
 100e92c:	100c2d80 	call	100c2d8 <metal_mutex_release>
		return NULL;
 100e930:	0005883a 	mov	r2,zero
 100e934:	0000b706 	br	100ec14 <remoteproc_create_virtio+0x37c>
	}
	vdev_rsc = (struct fw_rsc_vdev *)(rsc_table + vdev_rsc_offset);
 100e938:	e0ffec17 	ldw	r3,-80(fp)
 100e93c:	e0bfee17 	ldw	r2,-72(fp)
 100e940:	1885883a 	add	r2,r3,r2
 100e944:	e0bfef15 	stw	r2,-68(fp)
	notifyid = vdev_rsc->notifyid;
 100e948:	e0bfef17 	ldw	r2,-68(fp)
 100e94c:	10c00203 	ldbu	r3,8(r2)
 100e950:	11000243 	ldbu	r4,9(r2)
 100e954:	2008923a 	slli	r4,r4,8
 100e958:	20c6b03a 	or	r3,r4,r3
 100e95c:	11000283 	ldbu	r4,10(r2)
 100e960:	2008943a 	slli	r4,r4,16
 100e964:	20c6b03a 	or	r3,r4,r3
 100e968:	108002c3 	ldbu	r2,11(r2)
 100e96c:	1004963a 	slli	r2,r2,24
 100e970:	10c4b03a 	or	r2,r2,r3
 100e974:	e0bff015 	stw	r2,-64(fp)
	/* Check if the virtio device is already created */
	metal_list_for_each(&rproc->vdevs, node) {
 100e978:	e0bffc17 	ldw	r2,-16(fp)
 100e97c:	10800617 	ldw	r2,24(r2)
 100e980:	e0bfeb15 	stw	r2,-84(fp)
 100e984:	00001006 	br	100e9c8 <remoteproc_create_virtio+0x130>
		rpvdev = metal_container_of(node, struct remoteproc_virtio,
 100e988:	e0bfeb17 	ldw	r2,-84(fp)
 100e98c:	10bff104 	addi	r2,r2,-60
 100e990:	e0bff115 	stw	r2,-60(fp)
					    node);
		if (rpvdev->vdev.notifyid == notifyid) {
 100e994:	e0bff117 	ldw	r2,-60(fp)
 100e998:	10c00417 	ldw	r3,16(r2)
 100e99c:	e0bff017 	ldw	r2,-64(fp)
 100e9a0:	1880061e 	bne	r3,r2,100e9bc <remoteproc_create_virtio+0x124>
			metal_mutex_release(&rproc->lock);
 100e9a4:	e0bffc17 	ldw	r2,-16(fp)
 100e9a8:	1009883a 	mov	r4,r2
 100e9ac:	100c2d80 	call	100c2d8 <metal_mutex_release>
			return &rpvdev->vdev;
 100e9b0:	e0bff117 	ldw	r2,-60(fp)
 100e9b4:	10800404 	addi	r2,r2,16
 100e9b8:	00009606 	br	100ec14 <remoteproc_create_virtio+0x37c>
		return NULL;
	}
	vdev_rsc = (struct fw_rsc_vdev *)(rsc_table + vdev_rsc_offset);
	notifyid = vdev_rsc->notifyid;
	/* Check if the virtio device is already created */
	metal_list_for_each(&rproc->vdevs, node) {
 100e9bc:	e0bfeb17 	ldw	r2,-84(fp)
 100e9c0:	10800017 	ldw	r2,0(r2)
 100e9c4:	e0bfeb15 	stw	r2,-84(fp)
 100e9c8:	e0bffc17 	ldw	r2,-16(fp)
 100e9cc:	10c00604 	addi	r3,r2,24
 100e9d0:	e0bfeb17 	ldw	r2,-84(fp)
 100e9d4:	18bfec1e 	bne	r3,r2,100e988 <__alt_data_end+0xff00e988>
		if (rpvdev->vdev.notifyid == notifyid) {
			metal_mutex_release(&rproc->lock);
			return &rpvdev->vdev;
		}
	}
	vdev = rproc_virtio_create_vdev(role, notifyid,
 100e9d8:	e0bfff17 	ldw	r2,-4(fp)
 100e9dc:	d8800215 	stw	r2,8(sp)
 100e9e0:	00804074 	movhi	r2,257
 100e9e4:	10ba1304 	addi	r2,r2,-6068
 100e9e8:	d8800115 	stw	r2,4(sp)
 100e9ec:	e0bffc17 	ldw	r2,-16(fp)
 100e9f0:	d8800015 	stw	r2,0(sp)
 100e9f4:	e1ffed17 	ldw	r7,-76(fp)
 100e9f8:	e1bfef17 	ldw	r6,-68(fp)
 100e9fc:	e17ff017 	ldw	r5,-64(fp)
 100ea00:	e13ffe17 	ldw	r4,-8(fp)
 100ea04:	100f6b80 	call	100f6b8 <rproc_virtio_create_vdev>
 100ea08:	e0bff215 	stw	r2,-56(fp)
					vdev_rsc, vdev_rsc_io, rproc,
					remoteproc_virtio_notify,
					rst_cb);
	if (!vdev) {
 100ea0c:	e0bff217 	ldw	r2,-56(fp)
 100ea10:	1000051e 	bne	r2,zero,100ea28 <remoteproc_create_virtio+0x190>
		metal_mutex_release(&rproc->lock);
 100ea14:	e0bffc17 	ldw	r2,-16(fp)
 100ea18:	1009883a 	mov	r4,r2
 100ea1c:	100c2d80 	call	100c2d8 <metal_mutex_release>
		return NULL;
 100ea20:	0005883a 	mov	r2,zero
 100ea24:	00007b06 	br	100ec14 <remoteproc_create_virtio+0x37c>
	}

	rproc_virtio_wait_remote_ready(vdev);
 100ea28:	e13ff217 	ldw	r4,-56(fp)
 100ea2c:	100fb440 	call	100fb44 <rproc_virtio_wait_remote_ready>

	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100ea30:	e0bff217 	ldw	r2,-56(fp)
 100ea34:	10bffc04 	addi	r2,r2,-16
 100ea38:	e0bff115 	stw	r2,-60(fp)
	metal_list_add_tail(&rproc->vdevs, &rpvdev->node);
 100ea3c:	e0bffc17 	ldw	r2,-16(fp)
 100ea40:	10c00604 	addi	r3,r2,24
 100ea44:	e0bff117 	ldw	r2,-60(fp)
 100ea48:	10800f04 	addi	r2,r2,60
 100ea4c:	100b883a 	mov	r5,r2
 100ea50:	1809883a 	mov	r4,r3
 100ea54:	100be780 	call	100be78 <metal_list_add_tail>
	num_vrings = vdev_rsc->num_of_vrings;
 100ea58:	e0bfef17 	ldw	r2,-68(fp)
 100ea5c:	10800643 	ldbu	r2,25(r2)
 100ea60:	10803fcc 	andi	r2,r2,255
 100ea64:	e0bff315 	stw	r2,-52(fp)

	/* set the notification id for vrings */
	for (i = 0; i < num_vrings; i++) {
 100ea68:	e03fea15 	stw	zero,-88(fp)
 100ea6c:	00005706 	br	100ebcc <remoteproc_create_virtio+0x334>
		struct metal_io_region *io;
		void *va;
		size_t size;
		int ret;

		vring_rsc = &vdev_rsc->vring[i];
 100ea70:	e0bfea17 	ldw	r2,-88(fp)
 100ea74:	10800524 	muli	r2,r2,20
 100ea78:	10800704 	addi	r2,r2,28
 100ea7c:	e0ffef17 	ldw	r3,-68(fp)
 100ea80:	1885883a 	add	r2,r3,r2
 100ea84:	e0bff415 	stw	r2,-48(fp)
		notifyid = vring_rsc->notifyid;
 100ea88:	e0bff417 	ldw	r2,-48(fp)
 100ea8c:	10c00303 	ldbu	r3,12(r2)
 100ea90:	11000343 	ldbu	r4,13(r2)
 100ea94:	2008923a 	slli	r4,r4,8
 100ea98:	20c6b03a 	or	r3,r4,r3
 100ea9c:	11000383 	ldbu	r4,14(r2)
 100eaa0:	2008943a 	slli	r4,r4,16
 100eaa4:	20c6b03a 	or	r3,r4,r3
 100eaa8:	108003c3 	ldbu	r2,15(r2)
 100eaac:	1004963a 	slli	r2,r2,24
 100eab0:	10c4b03a 	or	r2,r2,r3
 100eab4:	e0bff015 	stw	r2,-64(fp)
		da = vring_rsc->da;
 100eab8:	e0bff417 	ldw	r2,-48(fp)
 100eabc:	10c00003 	ldbu	r3,0(r2)
 100eac0:	11000043 	ldbu	r4,1(r2)
 100eac4:	2008923a 	slli	r4,r4,8
 100eac8:	20c6b03a 	or	r3,r4,r3
 100eacc:	11000083 	ldbu	r4,2(r2)
 100ead0:	2008943a 	slli	r4,r4,16
 100ead4:	20c6b03a 	or	r3,r4,r3
 100ead8:	108000c3 	ldbu	r2,3(r2)
 100eadc:	1004963a 	slli	r2,r2,24
 100eae0:	10c4b03a 	or	r2,r2,r3
 100eae4:	e0bffa15 	stw	r2,-24(fp)
		num_descs = vring_rsc->num;
 100eae8:	e0bff417 	ldw	r2,-48(fp)
 100eaec:	10c00203 	ldbu	r3,8(r2)
 100eaf0:	11000243 	ldbu	r4,9(r2)
 100eaf4:	2008923a 	slli	r4,r4,8
 100eaf8:	20c6b03a 	or	r3,r4,r3
 100eafc:	11000283 	ldbu	r4,10(r2)
 100eb00:	2008943a 	slli	r4,r4,16
 100eb04:	20c6b03a 	or	r3,r4,r3
 100eb08:	108002c3 	ldbu	r2,11(r2)
 100eb0c:	1004963a 	slli	r2,r2,24
 100eb10:	10c4b03a 	or	r2,r2,r3
 100eb14:	e0bff515 	stw	r2,-44(fp)
		align = vring_rsc->align;
 100eb18:	e0bff417 	ldw	r2,-48(fp)
 100eb1c:	10c00103 	ldbu	r3,4(r2)
 100eb20:	11000143 	ldbu	r4,5(r2)
 100eb24:	2008923a 	slli	r4,r4,8
 100eb28:	20c6b03a 	or	r3,r4,r3
 100eb2c:	11000183 	ldbu	r4,6(r2)
 100eb30:	2008943a 	slli	r4,r4,16
 100eb34:	20c6b03a 	or	r3,r4,r3
 100eb38:	108001c3 	ldbu	r2,7(r2)
 100eb3c:	1004963a 	slli	r2,r2,24
 100eb40:	10c4b03a 	or	r2,r2,r3
 100eb44:	e0bff615 	stw	r2,-40(fp)
		size = vring_size(num_descs, align);
 100eb48:	e17ff617 	ldw	r5,-40(fp)
 100eb4c:	e13ff517 	ldw	r4,-44(fp)
 100eb50:	100c3300 	call	100c330 <vring_size>
 100eb54:	e0bff715 	stw	r2,-36(fp)
		va = remoteproc_mmap(rproc, NULL, &da, size, 0, &io);
 100eb58:	e0fffa04 	addi	r3,fp,-24
 100eb5c:	e0bffb04 	addi	r2,fp,-20
 100eb60:	d8800115 	stw	r2,4(sp)
 100eb64:	d8000015 	stw	zero,0(sp)
 100eb68:	e1fff717 	ldw	r7,-36(fp)
 100eb6c:	180d883a 	mov	r6,r3
 100eb70:	000b883a 	mov	r5,zero
 100eb74:	e13ffc17 	ldw	r4,-16(fp)
 100eb78:	100ce140 	call	100ce14 <remoteproc_mmap>
 100eb7c:	e0bff815 	stw	r2,-32(fp)
		if (!va)
 100eb80:	e0bff817 	ldw	r2,-32(fp)
 100eb84:	10001926 	beq	r2,zero,100ebec <remoteproc_create_virtio+0x354>
			goto err1;
		ret = rproc_virtio_init_vring(vdev, i, notifyid,
 100eb88:	e0bffb17 	ldw	r2,-20(fp)
 100eb8c:	e0fff617 	ldw	r3,-40(fp)
 100eb90:	d8c00215 	stw	r3,8(sp)
 100eb94:	e0fff517 	ldw	r3,-44(fp)
 100eb98:	d8c00115 	stw	r3,4(sp)
 100eb9c:	d8800015 	stw	r2,0(sp)
 100eba0:	e1fff817 	ldw	r7,-32(fp)
 100eba4:	e1bff017 	ldw	r6,-64(fp)
 100eba8:	e17fea17 	ldw	r5,-88(fp)
 100ebac:	e13ff217 	ldw	r4,-56(fp)
 100ebb0:	100f9d00 	call	100f9d0 <rproc_virtio_init_vring>
 100ebb4:	e0bff915 	stw	r2,-28(fp)
					      va, io, num_descs, align);
		if (ret)
 100ebb8:	e0bff917 	ldw	r2,-28(fp)
 100ebbc:	10000d1e 	bne	r2,zero,100ebf4 <remoteproc_create_virtio+0x35c>
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
	metal_list_add_tail(&rproc->vdevs, &rpvdev->node);
	num_vrings = vdev_rsc->num_of_vrings;

	/* set the notification id for vrings */
	for (i = 0; i < num_vrings; i++) {
 100ebc0:	e0bfea17 	ldw	r2,-88(fp)
 100ebc4:	10800044 	addi	r2,r2,1
 100ebc8:	e0bfea15 	stw	r2,-88(fp)
 100ebcc:	e0ffea17 	ldw	r3,-88(fp)
 100ebd0:	e0bff317 	ldw	r2,-52(fp)
 100ebd4:	18bfa636 	bltu	r3,r2,100ea70 <__alt_data_end+0xff00ea70>
		ret = rproc_virtio_init_vring(vdev, i, notifyid,
					      va, io, num_descs, align);
		if (ret)
			goto err1;
	}
	metal_mutex_release(&rproc->lock);
 100ebd8:	e0bffc17 	ldw	r2,-16(fp)
 100ebdc:	1009883a 	mov	r4,r2
 100ebe0:	100c2d80 	call	100c2d8 <metal_mutex_release>
	return vdev;
 100ebe4:	e0bff217 	ldw	r2,-56(fp)
 100ebe8:	00000a06 	br	100ec14 <remoteproc_create_virtio+0x37c>
		num_descs = vring_rsc->num;
		align = vring_rsc->align;
		size = vring_size(num_descs, align);
		va = remoteproc_mmap(rproc, NULL, &da, size, 0, &io);
		if (!va)
			goto err1;
 100ebec:	0001883a 	nop
 100ebf0:	00000106 	br	100ebf8 <remoteproc_create_virtio+0x360>
		ret = rproc_virtio_init_vring(vdev, i, notifyid,
					      va, io, num_descs, align);
		if (ret)
			goto err1;
 100ebf4:	0001883a 	nop
	}
	metal_mutex_release(&rproc->lock);
	return vdev;

err1:
	remoteproc_remove_virtio(rproc, vdev);
 100ebf8:	e17ff217 	ldw	r5,-56(fp)
 100ebfc:	e13ffc17 	ldw	r4,-16(fp)
 100ec00:	100ec280 	call	100ec28 <remoteproc_remove_virtio>
	metal_mutex_release(&rproc->lock);
 100ec04:	e0bffc17 	ldw	r2,-16(fp)
 100ec08:	1009883a 	mov	r4,r2
 100ec0c:	100c2d80 	call	100c2d8 <metal_mutex_release>
	return NULL;
 100ec10:	0005883a 	mov	r2,zero
}
 100ec14:	e037883a 	mov	sp,fp
 100ec18:	dfc00117 	ldw	ra,4(sp)
 100ec1c:	df000017 	ldw	fp,0(sp)
 100ec20:	dec00204 	addi	sp,sp,8
 100ec24:	f800283a 	ret

0100ec28 <remoteproc_remove_virtio>:

void remoteproc_remove_virtio(struct remoteproc *rproc,
			      struct virtio_device *vdev)
{
 100ec28:	defffb04 	addi	sp,sp,-20
 100ec2c:	dfc00415 	stw	ra,16(sp)
 100ec30:	df000315 	stw	fp,12(sp)
 100ec34:	df000304 	addi	fp,sp,12
 100ec38:	e13ffe15 	stw	r4,-8(fp)
 100ec3c:	e17fff15 	stw	r5,-4(fp)
	struct remoteproc_virtio *rpvdev;

	(void)rproc;
	metal_assert(vdev);
 100ec40:	e0bfff17 	ldw	r2,-4(fp)
 100ec44:	1000081e 	bne	r2,zero,100ec68 <remoteproc_remove_virtio+0x40>
 100ec48:	01c040f4 	movhi	r7,259
 100ec4c:	39e70e04 	addi	r7,r7,-25544
 100ec50:	018040f4 	movhi	r6,259
 100ec54:	31a72104 	addi	r6,r6,-25468
 100ec58:	0140eec4 	movi	r5,955
 100ec5c:	010040f4 	movhi	r4,259
 100ec60:	2125ee04 	addi	r4,r4,-26696
 100ec64:	10157a00 	call	10157a0 <__assert_func>
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100ec68:	e0bfff17 	ldw	r2,-4(fp)
 100ec6c:	10bffc04 	addi	r2,r2,-16
 100ec70:	e0bffd15 	stw	r2,-12(fp)
	metal_list_del(&rpvdev->node);
 100ec74:	e0bffd17 	ldw	r2,-12(fp)
 100ec78:	10800f04 	addi	r2,r2,60
 100ec7c:	1009883a 	mov	r4,r2
 100ec80:	100beb40 	call	100beb4 <metal_list_del>
	rproc_virtio_remove_vdev(&rpvdev->vdev);
 100ec84:	e0bffd17 	ldw	r2,-12(fp)
 100ec88:	10800404 	addi	r2,r2,16
 100ec8c:	1009883a 	mov	r4,r2
 100ec90:	100f9240 	call	100f924 <rproc_virtio_remove_vdev>
}
 100ec94:	0001883a 	nop
 100ec98:	e037883a 	mov	sp,fp
 100ec9c:	dfc00117 	ldw	ra,4(sp)
 100eca0:	df000017 	ldw	fp,0(sp)
 100eca4:	dec00204 	addi	sp,sp,8
 100eca8:	f800283a 	ret

0100ecac <remoteproc_get_notification>:

int remoteproc_get_notification(struct remoteproc *rproc, uint32_t notifyid)
{
 100ecac:	defff904 	addi	sp,sp,-28
 100ecb0:	dfc00615 	stw	ra,24(sp)
 100ecb4:	df000515 	stw	fp,20(sp)
 100ecb8:	df000504 	addi	fp,sp,20
 100ecbc:	e13ffe15 	stw	r4,-8(fp)
 100ecc0:	e17fff15 	stw	r5,-4(fp)
	struct remoteproc_virtio *rpvdev;
	struct metal_list *node;
	int ret;

	metal_list_for_each(&rproc->vdevs, node) {
 100ecc4:	e0bffe17 	ldw	r2,-8(fp)
 100ecc8:	10800617 	ldw	r2,24(r2)
 100eccc:	e0bffb15 	stw	r2,-20(fp)
 100ecd0:	00001006 	br	100ed14 <remoteproc_get_notification+0x68>
		rpvdev = metal_container_of(node, struct remoteproc_virtio,
 100ecd4:	e0bffb17 	ldw	r2,-20(fp)
 100ecd8:	10bff104 	addi	r2,r2,-60
 100ecdc:	e0bffc15 	stw	r2,-16(fp)
					    node);
		ret = rproc_virtio_notified(&rpvdev->vdev, notifyid);
 100ece0:	e0bffc17 	ldw	r2,-16(fp)
 100ece4:	10800404 	addi	r2,r2,16
 100ece8:	e17fff17 	ldw	r5,-4(fp)
 100ecec:	1009883a 	mov	r4,r2
 100ecf0:	100fa780 	call	100fa78 <rproc_virtio_notified>
 100ecf4:	e0bffd15 	stw	r2,-12(fp)
		if (ret)
 100ecf8:	e0bffd17 	ldw	r2,-12(fp)
 100ecfc:	10000226 	beq	r2,zero,100ed08 <remoteproc_get_notification+0x5c>
			return ret;
 100ed00:	e0bffd17 	ldw	r2,-12(fp)
 100ed04:	00000806 	br	100ed28 <remoteproc_get_notification+0x7c>
{
	struct remoteproc_virtio *rpvdev;
	struct metal_list *node;
	int ret;

	metal_list_for_each(&rproc->vdevs, node) {
 100ed08:	e0bffb17 	ldw	r2,-20(fp)
 100ed0c:	10800017 	ldw	r2,0(r2)
 100ed10:	e0bffb15 	stw	r2,-20(fp)
 100ed14:	e0bffe17 	ldw	r2,-8(fp)
 100ed18:	10c00604 	addi	r3,r2,24
 100ed1c:	e0bffb17 	ldw	r2,-20(fp)
 100ed20:	18bfec1e 	bne	r3,r2,100ecd4 <__alt_data_end+0xff00ecd4>
					    node);
		ret = rproc_virtio_notified(&rpvdev->vdev, notifyid);
		if (ret)
			return ret;
	}
	return 0;
 100ed24:	0005883a 	mov	r2,zero
}
 100ed28:	e037883a 	mov	sp,fp
 100ed2c:	dfc00117 	ldw	ra,4(sp)
 100ed30:	df000017 	ldw	fp,0(sp)
 100ed34:	dec00204 	addi	sp,sp,8
 100ed38:	f800283a 	ret

0100ed3c <metal_io_virt>:
 * @param[in]	offset	Offset into shared memory segment.
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
 100ed3c:	defffd04 	addi	sp,sp,-12
 100ed40:	df000215 	stw	fp,8(sp)
 100ed44:	df000204 	addi	fp,sp,8
 100ed48:	e13ffe15 	stw	r4,-8(fp)
 100ed4c:	e17fff15 	stw	r5,-4(fp)
	return (io->virt != METAL_BAD_VA && offset < io->size
 100ed50:	e0bffe17 	ldw	r2,-8(fp)
 100ed54:	10800017 	ldw	r2,0(r2)
		? (uint8_t *)io->virt + offset
		: NULL);
 100ed58:	10bfffe0 	cmpeqi	r2,r2,-1
 100ed5c:	1000091e 	bne	r2,zero,100ed84 <metal_io_virt+0x48>
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
	return (io->virt != METAL_BAD_VA && offset < io->size
 100ed60:	e0bffe17 	ldw	r2,-8(fp)
 100ed64:	10800217 	ldw	r2,8(r2)
 100ed68:	e0ffff17 	ldw	r3,-4(fp)
 100ed6c:	1880052e 	bgeu	r3,r2,100ed84 <metal_io_virt+0x48>
		? (uint8_t *)io->virt + offset
 100ed70:	e0bffe17 	ldw	r2,-8(fp)
 100ed74:	10c00017 	ldw	r3,0(r2)
		: NULL);
 100ed78:	e0bfff17 	ldw	r2,-4(fp)
 100ed7c:	1885883a 	add	r2,r3,r2
 100ed80:	00000106 	br	100ed88 <metal_io_virt+0x4c>
 100ed84:	0005883a 	mov	r2,zero
}
 100ed88:	e037883a 	mov	sp,fp
 100ed8c:	df000017 	ldw	fp,0(sp)
 100ed90:	dec00104 	addi	sp,sp,4
 100ed94:	f800283a 	ret

0100ed98 <metal_io_virt_to_offset>:
 * @param[in]	virt	Virtual address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
 100ed98:	defffc04 	addi	sp,sp,-16
 100ed9c:	df000315 	stw	fp,12(sp)
 100eda0:	df000304 	addi	fp,sp,12
 100eda4:	e13ffe15 	stw	r4,-8(fp)
 100eda8:	e17fff15 	stw	r5,-4(fp)
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 100edac:	e0bfff17 	ldw	r2,-4(fp)
 100edb0:	e0fffe17 	ldw	r3,-8(fp)
 100edb4:	18c00017 	ldw	r3,0(r3)
 100edb8:	10c5c83a 	sub	r2,r2,r3
 100edbc:	e0bffd15 	stw	r2,-12(fp)
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 100edc0:	e0bffe17 	ldw	r2,-8(fp)
 100edc4:	10800217 	ldw	r2,8(r2)
 100edc8:	e0fffd17 	ldw	r3,-12(fp)
 100edcc:	1880022e 	bgeu	r3,r2,100edd8 <metal_io_virt_to_offset+0x40>
 100edd0:	e0bffd17 	ldw	r2,-12(fp)
 100edd4:	00000106 	br	100eddc <metal_io_virt_to_offset+0x44>
 100edd8:	00bfffc4 	movi	r2,-1
}
 100eddc:	e037883a 	mov	sp,fp
 100ede0:	df000017 	ldw	fp,0(sp)
 100ede4:	dec00104 	addi	sp,sp,4
 100ede8:	f800283a 	ret

0100edec <metal_io_read>:
 * @return	Value.
 */
static inline uint64_t
metal_io_read(struct metal_io_region *io, unsigned long offset,
	      memory_order order, int width)
{
 100edec:	defff704 	addi	sp,sp,-36
 100edf0:	dfc00815 	stw	ra,32(sp)
 100edf4:	df000715 	stw	fp,28(sp)
 100edf8:	dc400615 	stw	r17,24(sp)
 100edfc:	dc000515 	stw	r16,20(sp)
 100ee00:	df000704 	addi	fp,sp,28
 100ee04:	e13ffa15 	stw	r4,-24(fp)
 100ee08:	e17ffb15 	stw	r5,-20(fp)
 100ee0c:	e1bffc15 	stw	r6,-16(fp)
 100ee10:	e1fffd15 	stw	r7,-12(fp)
	void *ptr = metal_io_virt(io, offset);
 100ee14:	e17ffb17 	ldw	r5,-20(fp)
 100ee18:	e13ffa17 	ldw	r4,-24(fp)
 100ee1c:	100ed3c0 	call	100ed3c <metal_io_virt>
 100ee20:	e0bff915 	stw	r2,-28(fp)

	if (io->ops.read)
 100ee24:	e0bffa17 	ldw	r2,-24(fp)
 100ee28:	10800617 	ldw	r2,24(r2)
 100ee2c:	10000a26 	beq	r2,zero,100ee58 <metal_io_read+0x6c>
		return (*io->ops.read)(io, offset, order, width);
 100ee30:	e0bffa17 	ldw	r2,-24(fp)
 100ee34:	10800617 	ldw	r2,24(r2)
 100ee38:	e1fffd17 	ldw	r7,-12(fp)
 100ee3c:	e1bffc17 	ldw	r6,-16(fp)
 100ee40:	e17ffb17 	ldw	r5,-20(fp)
 100ee44:	e13ffa17 	ldw	r4,-24(fp)
 100ee48:	103ee83a 	callr	r2
 100ee4c:	1021883a 	mov	r16,r2
 100ee50:	1823883a 	mov	r17,r3
 100ee54:	00004006 	br	100ef58 <metal_io_read+0x16c>
	else if (ptr && sizeof(atomic_uchar) == width)
 100ee58:	e0bff917 	ldw	r2,-28(fp)
 100ee5c:	10000a26 	beq	r2,zero,100ee88 <metal_io_read+0x9c>
 100ee60:	e0bffd17 	ldw	r2,-12(fp)
 100ee64:	10800058 	cmpnei	r2,r2,1
 100ee68:	1000071e 	bne	r2,zero,100ee88 <metal_io_read+0x9c>
		return atomic_load_explicit((atomic_uchar *)ptr, order);
 100ee6c:	0001b03a 	sync
 100ee70:	e0bff917 	ldw	r2,-28(fp)
 100ee74:	10800003 	ldbu	r2,0(r2)
 100ee78:	10803fcc 	andi	r2,r2,255
 100ee7c:	1021883a 	mov	r16,r2
 100ee80:	0023883a 	mov	r17,zero
 100ee84:	00003406 	br	100ef58 <metal_io_read+0x16c>
	else if (ptr && sizeof(atomic_ushort) == width)
 100ee88:	e0bff917 	ldw	r2,-28(fp)
 100ee8c:	10000a26 	beq	r2,zero,100eeb8 <metal_io_read+0xcc>
 100ee90:	e0bffd17 	ldw	r2,-12(fp)
 100ee94:	10800098 	cmpnei	r2,r2,2
 100ee98:	1000071e 	bne	r2,zero,100eeb8 <metal_io_read+0xcc>
		return atomic_load_explicit((atomic_ushort *)ptr, order);
 100ee9c:	0001b03a 	sync
 100eea0:	e0bff917 	ldw	r2,-28(fp)
 100eea4:	1080000b 	ldhu	r2,0(r2)
 100eea8:	10bfffcc 	andi	r2,r2,65535
 100eeac:	1021883a 	mov	r16,r2
 100eeb0:	0023883a 	mov	r17,zero
 100eeb4:	00002806 	br	100ef58 <metal_io_read+0x16c>
	else if (ptr && sizeof(atomic_uint) == width)
 100eeb8:	e0bff917 	ldw	r2,-28(fp)
 100eebc:	10000926 	beq	r2,zero,100eee4 <metal_io_read+0xf8>
 100eec0:	e0bffd17 	ldw	r2,-12(fp)
 100eec4:	10800118 	cmpnei	r2,r2,4
 100eec8:	1000061e 	bne	r2,zero,100eee4 <metal_io_read+0xf8>
		return atomic_load_explicit((atomic_uint *)ptr, order);
 100eecc:	0001b03a 	sync
 100eed0:	e0bff917 	ldw	r2,-28(fp)
 100eed4:	10800017 	ldw	r2,0(r2)
 100eed8:	1021883a 	mov	r16,r2
 100eedc:	0023883a 	mov	r17,zero
 100eee0:	00001d06 	br	100ef58 <metal_io_read+0x16c>
	else if (ptr && sizeof(atomic_ulong) == width)
 100eee4:	e0bff917 	ldw	r2,-28(fp)
 100eee8:	10000926 	beq	r2,zero,100ef10 <metal_io_read+0x124>
 100eeec:	e0bffd17 	ldw	r2,-12(fp)
 100eef0:	10800118 	cmpnei	r2,r2,4
 100eef4:	1000061e 	bne	r2,zero,100ef10 <metal_io_read+0x124>
		return atomic_load_explicit((atomic_ulong *)ptr, order);
 100eef8:	0001b03a 	sync
 100eefc:	e0bff917 	ldw	r2,-28(fp)
 100ef00:	10800017 	ldw	r2,0(r2)
 100ef04:	1021883a 	mov	r16,r2
 100ef08:	0023883a 	mov	r17,zero
 100ef0c:	00001206 	br	100ef58 <metal_io_read+0x16c>
#ifndef NO_ATOMIC_64_SUPPORT
	else if (ptr && sizeof(atomic_ullong) == width)
 100ef10:	e0bff917 	ldw	r2,-28(fp)
 100ef14:	10000826 	beq	r2,zero,100ef38 <metal_io_read+0x14c>
 100ef18:	e0bffd17 	ldw	r2,-12(fp)
 100ef1c:	10800218 	cmpnei	r2,r2,8
 100ef20:	1000051e 	bne	r2,zero,100ef38 <metal_io_read+0x14c>
		return atomic_load_explicit((atomic_ullong *)ptr, order);
 100ef24:	0001b03a 	sync
 100ef28:	e0bff917 	ldw	r2,-28(fp)
 100ef2c:	14000017 	ldw	r16,0(r2)
 100ef30:	14400117 	ldw	r17,4(r2)
 100ef34:	00000806 	br	100ef58 <metal_io_read+0x16c>
#endif
	metal_assert(0);
 100ef38:	01c040f4 	movhi	r7,259
 100ef3c:	39e72804 	addi	r7,r7,-25440
 100ef40:	018040f4 	movhi	r6,259
 100ef44:	31a75104 	addi	r6,r6,-25276
 100ef48:	01403f84 	movi	r5,254
 100ef4c:	010040f4 	movhi	r4,259
 100ef50:	21272904 	addi	r4,r4,-25436
 100ef54:	10157a00 	call	10157a0 <__assert_func>
 100ef58:	8007883a 	mov	r3,r16
 100ef5c:	8809883a 	mov	r4,r17
	return 0; /* quiet compiler */
}
 100ef60:	1805883a 	mov	r2,r3
 100ef64:	2007883a 	mov	r3,r4
 100ef68:	e6fffe04 	addi	sp,fp,-8
 100ef6c:	dfc00317 	ldw	ra,12(sp)
 100ef70:	df000217 	ldw	fp,8(sp)
 100ef74:	dc400117 	ldw	r17,4(sp)
 100ef78:	dc000017 	ldw	r16,0(sp)
 100ef7c:	dec00404 	addi	sp,sp,16
 100ef80:	f800283a 	ret

0100ef84 <metal_io_write>:
 *			to inline cleanly.
 */
static inline void
metal_io_write(struct metal_io_region *io, unsigned long offset,
	       uint64_t value, memory_order order, int width)
{
 100ef84:	defff704 	addi	sp,sp,-36
 100ef88:	dfc00815 	stw	ra,32(sp)
 100ef8c:	df000715 	stw	fp,28(sp)
 100ef90:	df000704 	addi	fp,sp,28
 100ef94:	e13ffc15 	stw	r4,-16(fp)
 100ef98:	e17ffd15 	stw	r5,-12(fp)
 100ef9c:	e1bffe15 	stw	r6,-8(fp)
 100efa0:	e1ffff15 	stw	r7,-4(fp)
	void *ptr = metal_io_virt(io, offset);
 100efa4:	e17ffd17 	ldw	r5,-12(fp)
 100efa8:	e13ffc17 	ldw	r4,-16(fp)
 100efac:	100ed3c0 	call	100ed3c <metal_io_virt>
 100efb0:	e0bffb15 	stw	r2,-20(fp)
	if (io->ops.write)
 100efb4:	e0bffc17 	ldw	r2,-16(fp)
 100efb8:	10800717 	ldw	r2,28(r2)
 100efbc:	10000c26 	beq	r2,zero,100eff0 <metal_io_write+0x6c>
		(*io->ops.write)(io, offset, value, order, width);
 100efc0:	e0bffc17 	ldw	r2,-16(fp)
 100efc4:	10800717 	ldw	r2,28(r2)
 100efc8:	e0c00317 	ldw	r3,12(fp)
 100efcc:	d8c00115 	stw	r3,4(sp)
 100efd0:	e0c00217 	ldw	r3,8(fp)
 100efd4:	d8c00015 	stw	r3,0(sp)
 100efd8:	e1bffe17 	ldw	r6,-8(fp)
 100efdc:	e1ffff17 	ldw	r7,-4(fp)
 100efe0:	e17ffd17 	ldw	r5,-12(fp)
 100efe4:	e13ffc17 	ldw	r4,-16(fp)
 100efe8:	103ee83a 	callr	r2
	else if (ptr && sizeof(atomic_ullong) == width)
		atomic_store_explicit((atomic_ullong *)ptr, value, order);
#endif
	else
		metal_assert (0);
}
 100efec:	00003e06 	br	100f0e8 <metal_io_write+0x164>
	       uint64_t value, memory_order order, int width)
{
	void *ptr = metal_io_virt(io, offset);
	if (io->ops.write)
		(*io->ops.write)(io, offset, value, order, width);
	else if (ptr && sizeof(atomic_uchar) == width)
 100eff0:	e0bffb17 	ldw	r2,-20(fp)
 100eff4:	10000926 	beq	r2,zero,100f01c <metal_io_write+0x98>
 100eff8:	e0800317 	ldw	r2,12(fp)
 100effc:	10800058 	cmpnei	r2,r2,1
 100f000:	1000061e 	bne	r2,zero,100f01c <metal_io_write+0x98>
		atomic_store_explicit((atomic_uchar *)ptr, value, order);
 100f004:	e0bffe17 	ldw	r2,-8(fp)
 100f008:	1007883a 	mov	r3,r2
 100f00c:	e0bffb17 	ldw	r2,-20(fp)
 100f010:	10c00005 	stb	r3,0(r2)
 100f014:	0001b03a 	sync
 100f018:	00003306 	br	100f0e8 <metal_io_write+0x164>
	else if (ptr && sizeof(atomic_ushort) == width)
 100f01c:	e0bffb17 	ldw	r2,-20(fp)
 100f020:	10000926 	beq	r2,zero,100f048 <metal_io_write+0xc4>
 100f024:	e0800317 	ldw	r2,12(fp)
 100f028:	10800098 	cmpnei	r2,r2,2
 100f02c:	1000061e 	bne	r2,zero,100f048 <metal_io_write+0xc4>
		atomic_store_explicit((atomic_ushort *)ptr, value, order);
 100f030:	e0bffe17 	ldw	r2,-8(fp)
 100f034:	1007883a 	mov	r3,r2
 100f038:	e0bffb17 	ldw	r2,-20(fp)
 100f03c:	10c0000d 	sth	r3,0(r2)
 100f040:	0001b03a 	sync
 100f044:	00002806 	br	100f0e8 <metal_io_write+0x164>
	else if (ptr && sizeof(atomic_uint) == width)
 100f048:	e0bffb17 	ldw	r2,-20(fp)
 100f04c:	10000826 	beq	r2,zero,100f070 <metal_io_write+0xec>
 100f050:	e0800317 	ldw	r2,12(fp)
 100f054:	10800118 	cmpnei	r2,r2,4
 100f058:	1000051e 	bne	r2,zero,100f070 <metal_io_write+0xec>
		atomic_store_explicit((atomic_uint *)ptr, value, order);
 100f05c:	e0fffe17 	ldw	r3,-8(fp)
 100f060:	e0bffb17 	ldw	r2,-20(fp)
 100f064:	10c00015 	stw	r3,0(r2)
 100f068:	0001b03a 	sync
 100f06c:	00001e06 	br	100f0e8 <metal_io_write+0x164>
	else if (ptr && sizeof(atomic_ulong) == width)
 100f070:	e0bffb17 	ldw	r2,-20(fp)
 100f074:	10000826 	beq	r2,zero,100f098 <metal_io_write+0x114>
 100f078:	e0800317 	ldw	r2,12(fp)
 100f07c:	10800118 	cmpnei	r2,r2,4
 100f080:	1000051e 	bne	r2,zero,100f098 <metal_io_write+0x114>
		atomic_store_explicit((atomic_ulong *)ptr, value, order);
 100f084:	e0fffe17 	ldw	r3,-8(fp)
 100f088:	e0bffb17 	ldw	r2,-20(fp)
 100f08c:	10c00015 	stw	r3,0(r2)
 100f090:	0001b03a 	sync
 100f094:	00001406 	br	100f0e8 <metal_io_write+0x164>
#ifndef NO_ATOMIC_64_SUPPORT
	else if (ptr && sizeof(atomic_ullong) == width)
 100f098:	e0bffb17 	ldw	r2,-20(fp)
 100f09c:	10000a26 	beq	r2,zero,100f0c8 <metal_io_write+0x144>
 100f0a0:	e0800317 	ldw	r2,12(fp)
 100f0a4:	10800218 	cmpnei	r2,r2,8
 100f0a8:	1000071e 	bne	r2,zero,100f0c8 <metal_io_write+0x144>
		atomic_store_explicit((atomic_ullong *)ptr, value, order);
 100f0ac:	e0bffb17 	ldw	r2,-20(fp)
 100f0b0:	e0fffe17 	ldw	r3,-8(fp)
 100f0b4:	10c00015 	stw	r3,0(r2)
 100f0b8:	e0ffff17 	ldw	r3,-4(fp)
 100f0bc:	10c00115 	stw	r3,4(r2)
 100f0c0:	0001b03a 	sync
 100f0c4:	00000806 	br	100f0e8 <metal_io_write+0x164>
#endif
	else
		metal_assert (0);
 100f0c8:	01c040f4 	movhi	r7,259
 100f0cc:	39e72804 	addi	r7,r7,-25440
 100f0d0:	018040f4 	movhi	r6,259
 100f0d4:	31a75504 	addi	r6,r6,-25260
 100f0d8:	01404804 	movi	r5,288
 100f0dc:	010040f4 	movhi	r4,259
 100f0e0:	21272904 	addi	r4,r4,-25436
 100f0e4:	10157a00 	call	10157a0 <__assert_func>
}
 100f0e8:	0001883a 	nop
 100f0ec:	e037883a 	mov	sp,fp
 100f0f0:	dfc00117 	ldw	ra,4(sp)
 100f0f4:	df000017 	ldw	fp,0(sp)
 100f0f8:	dec00204 	addi	sp,sp,8
 100f0fc:	f800283a 	ret

0100f100 <metal_allocate_memory>:
#ifdef __cplusplus
extern "C" {
#endif

static inline void *metal_allocate_memory(unsigned int size)
{
 100f100:	defffd04 	addi	sp,sp,-12
 100f104:	dfc00215 	stw	ra,8(sp)
 100f108:	df000115 	stw	fp,4(sp)
 100f10c:	df000104 	addi	fp,sp,4
 100f110:	e13fff15 	stw	r4,-4(fp)
	return (pvPortMalloc(size));
 100f114:	e13fff17 	ldw	r4,-4(fp)
 100f118:	10010b00 	call	10010b0 <pvPortMalloc>
}
 100f11c:	e037883a 	mov	sp,fp
 100f120:	dfc00117 	ldw	ra,4(sp)
 100f124:	df000017 	ldw	fp,0(sp)
 100f128:	dec00204 	addi	sp,sp,8
 100f12c:	f800283a 	ret

0100f130 <metal_free_memory>:

static inline void metal_free_memory(void *ptr)
{
 100f130:	defffd04 	addi	sp,sp,-12
 100f134:	dfc00215 	stw	ra,8(sp)
 100f138:	df000115 	stw	fp,4(sp)
 100f13c:	df000104 	addi	fp,sp,4
 100f140:	e13fff15 	stw	r4,-4(fp)
	vPortFree(ptr);
 100f144:	e13fff17 	ldw	r4,-4(fp)
 100f148:	10012840 	call	1001284 <vPortFree>
}
 100f14c:	0001883a 	nop
 100f150:	e037883a 	mov	sp,fp
 100f154:	dfc00117 	ldw	ra,4(sp)
 100f158:	df000017 	ldw	fp,0(sp)
 100f15c:	dec00204 	addi	sp,sp,8
 100f160:	f800283a 	ret

0100f164 <virtqueue_allocate>:
int virtqueue_enable_cb(struct virtqueue *vq);

void virtqueue_kick(struct virtqueue *vq);

static inline struct virtqueue *virtqueue_allocate(unsigned int num_desc_extra)
{
 100f164:	defffb04 	addi	sp,sp,-20
 100f168:	dfc00415 	stw	ra,16(sp)
 100f16c:	df000315 	stw	fp,12(sp)
 100f170:	df000304 	addi	fp,sp,12
 100f174:	e13fff15 	stw	r4,-4(fp)
	struct virtqueue *vqs;
	uint32_t vq_size = sizeof(struct virtqueue) +
		 num_desc_extra * sizeof(struct vq_desc_extra);
 100f178:	e0bfff17 	ldw	r2,-4(fp)
 100f17c:	100490fa 	slli	r2,r2,3
void virtqueue_kick(struct virtqueue *vq);

static inline struct virtqueue *virtqueue_allocate(unsigned int num_desc_extra)
{
	struct virtqueue *vqs;
	uint32_t vq_size = sizeof(struct virtqueue) +
 100f180:	10800d04 	addi	r2,r2,52
 100f184:	e0bffd15 	stw	r2,-12(fp)
		 num_desc_extra * sizeof(struct vq_desc_extra);

	vqs = metal_allocate_memory(vq_size);
 100f188:	e13ffd17 	ldw	r4,-12(fp)
 100f18c:	100f1000 	call	100f100 <metal_allocate_memory>
 100f190:	e0bffe15 	stw	r2,-8(fp)
	if (vqs) {
 100f194:	e0bffe17 	ldw	r2,-8(fp)
 100f198:	10000426 	beq	r2,zero,100f1ac <virtqueue_allocate+0x48>
		memset(vqs, 0x00, vq_size);
 100f19c:	e1bffd17 	ldw	r6,-12(fp)
 100f1a0:	000b883a 	mov	r5,zero
 100f1a4:	e13ffe17 	ldw	r4,-8(fp)
 100f1a8:	1015a3c0 	call	1015a3c <memset>
	}

	return vqs;
 100f1ac:	e0bffe17 	ldw	r2,-8(fp)
}
 100f1b0:	e037883a 	mov	sp,fp
 100f1b4:	dfc00117 	ldw	ra,4(sp)
 100f1b8:	df000017 	ldw	fp,0(sp)
 100f1bc:	dec00204 	addi	sp,sp,8
 100f1c0:	f800283a 	ret

0100f1c4 <rproc_virtio_virtqueue_notify>:
#include <cpu.h>
#include <utilities.h>
#include <alloc.h>

static void rproc_virtio_virtqueue_notify(struct virtqueue *vq)
{
 100f1c4:	defff904 	addi	sp,sp,-28
 100f1c8:	dfc00615 	stw	ra,24(sp)
 100f1cc:	df000515 	stw	fp,20(sp)
 100f1d0:	df000504 	addi	fp,sp,20
 100f1d4:	e13fff15 	stw	r4,-4(fp)
	struct remoteproc_virtio *rpvdev;
	struct virtio_vring_info *vring_info;
	struct virtio_device *vdev;
	unsigned int vq_id = vq->vq_queue_index;
 100f1d8:	e0bfff17 	ldw	r2,-4(fp)
 100f1dc:	1080020b 	ldhu	r2,8(r2)
 100f1e0:	10bfffcc 	andi	r2,r2,65535
 100f1e4:	e0bffb15 	stw	r2,-20(fp)

	vdev = vq->vq_dev;
 100f1e8:	e0bfff17 	ldw	r2,-4(fp)
 100f1ec:	10800017 	ldw	r2,0(r2)
 100f1f0:	e0bffc15 	stw	r2,-16(fp)
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100f1f4:	e0bffc17 	ldw	r2,-16(fp)
 100f1f8:	10bffc04 	addi	r2,r2,-16
 100f1fc:	e0bffd15 	stw	r2,-12(fp)
	metal_assert(vq_id < vdev->vrings_num);
 100f200:	e0bffc17 	ldw	r2,-16(fp)
 100f204:	10800917 	ldw	r2,36(r2)
 100f208:	e0fffb17 	ldw	r3,-20(fp)
 100f20c:	18800836 	bltu	r3,r2,100f230 <rproc_virtio_virtqueue_notify+0x6c>
 100f210:	01c040f4 	movhi	r7,259
 100f214:	39e72e04 	addi	r7,r7,-25416
 100f218:	018040f4 	movhi	r6,259
 100f21c:	31a74904 	addi	r6,r6,-25308
 100f220:	01400744 	movi	r5,29
 100f224:	010040f4 	movhi	r4,259
 100f228:	21273504 	addi	r4,r4,-25388
 100f22c:	10157a00 	call	10157a0 <__assert_func>
	vring_info = &vdev->vrings_info[vq_id];
 100f230:	e0bffc17 	ldw	r2,-16(fp)
 100f234:	10c00a17 	ldw	r3,40(r2)
 100f238:	e0bffb17 	ldw	r2,-20(fp)
 100f23c:	10800624 	muli	r2,r2,24
 100f240:	1885883a 	add	r2,r3,r2
 100f244:	e0bffe15 	stw	r2,-8(fp)
	rpvdev->notify(rpvdev->priv, vring_info->notifyid);
 100f248:	e0bffd17 	ldw	r2,-12(fp)
 100f24c:	10800317 	ldw	r2,12(r2)
 100f250:	e0fffd17 	ldw	r3,-12(fp)
 100f254:	19000017 	ldw	r4,0(r3)
 100f258:	e0fffe17 	ldw	r3,-8(fp)
 100f25c:	18c00417 	ldw	r3,16(r3)
 100f260:	180b883a 	mov	r5,r3
 100f264:	103ee83a 	callr	r2
}
 100f268:	0001883a 	nop
 100f26c:	e037883a 	mov	sp,fp
 100f270:	dfc00117 	ldw	ra,4(sp)
 100f274:	df000017 	ldw	fp,0(sp)
 100f278:	dec00204 	addi	sp,sp,8
 100f27c:	f800283a 	ret

0100f280 <rproc_virtio_get_status>:

static unsigned char rproc_virtio_get_status(struct virtio_device *vdev)
{
 100f280:	defff904 	addi	sp,sp,-28
 100f284:	dfc00615 	stw	ra,24(sp)
 100f288:	df000515 	stw	fp,20(sp)
 100f28c:	df000504 	addi	fp,sp,20
 100f290:	e13fff15 	stw	r4,-4(fp)
	struct remoteproc_virtio *rpvdev;
	struct fw_rsc_vdev *vdev_rsc;
	struct metal_io_region *io;
	char status;

	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100f294:	e0bfff17 	ldw	r2,-4(fp)
 100f298:	10bffc04 	addi	r2,r2,-16
 100f29c:	e0bffb15 	stw	r2,-20(fp)
	vdev_rsc = rpvdev->vdev_rsc;
 100f2a0:	e0bffb17 	ldw	r2,-20(fp)
 100f2a4:	10800117 	ldw	r2,4(r2)
 100f2a8:	e0bffc15 	stw	r2,-16(fp)
	io = rpvdev->vdev_rsc_io;
 100f2ac:	e0bffb17 	ldw	r2,-20(fp)
 100f2b0:	10800217 	ldw	r2,8(r2)
 100f2b4:	e0bffd15 	stw	r2,-12(fp)
	status = metal_io_read8(io,
 100f2b8:	e0bffc17 	ldw	r2,-16(fp)
 100f2bc:	10800604 	addi	r2,r2,24
 100f2c0:	100b883a 	mov	r5,r2
 100f2c4:	e13ffd17 	ldw	r4,-12(fp)
 100f2c8:	100ed980 	call	100ed98 <metal_io_virt_to_offset>
 100f2cc:	01c00044 	movi	r7,1
 100f2d0:	01800144 	movi	r6,5
 100f2d4:	100b883a 	mov	r5,r2
 100f2d8:	e13ffd17 	ldw	r4,-12(fp)
 100f2dc:	100edec0 	call	100edec <metal_io_read>
 100f2e0:	1009883a 	mov	r4,r2
 100f2e4:	180b883a 	mov	r5,r3
 100f2e8:	e13ffe05 	stb	r4,-8(fp)
				metal_io_virt_to_offset(io, &vdev_rsc->status));
	return status;
 100f2ec:	e0bffe03 	ldbu	r2,-8(fp)
}
 100f2f0:	e037883a 	mov	sp,fp
 100f2f4:	dfc00117 	ldw	ra,4(sp)
 100f2f8:	df000017 	ldw	fp,0(sp)
 100f2fc:	dec00204 	addi	sp,sp,8
 100f300:	f800283a 	ret

0100f304 <rproc_virtio_set_status>:

#ifndef VIRTIO_SLAVE_ONLY
static void rproc_virtio_set_status(struct virtio_device *vdev,
				    unsigned char status)
{
 100f304:	defff504 	addi	sp,sp,-44
 100f308:	dfc00a15 	stw	ra,40(sp)
 100f30c:	df000915 	stw	fp,36(sp)
 100f310:	dc400815 	stw	r17,32(sp)
 100f314:	dc000715 	stw	r16,28(sp)
 100f318:	df000904 	addi	fp,sp,36
 100f31c:	e13ffc15 	stw	r4,-16(fp)
 100f320:	2805883a 	mov	r2,r5
 100f324:	e0bffd05 	stb	r2,-12(fp)
	struct remoteproc_virtio *rpvdev;
	struct fw_rsc_vdev *vdev_rsc;
	struct metal_io_region *io;

	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100f328:	e0bffc17 	ldw	r2,-16(fp)
 100f32c:	10bffc04 	addi	r2,r2,-16
 100f330:	e0bff915 	stw	r2,-28(fp)
	vdev_rsc = rpvdev->vdev_rsc;
 100f334:	e0bff917 	ldw	r2,-28(fp)
 100f338:	10800117 	ldw	r2,4(r2)
 100f33c:	e0bffa15 	stw	r2,-24(fp)
	io = rpvdev->vdev_rsc_io;
 100f340:	e0bff917 	ldw	r2,-28(fp)
 100f344:	10800217 	ldw	r2,8(r2)
 100f348:	e0bffb15 	stw	r2,-20(fp)
	metal_io_write8(io,
 100f34c:	e0bffa17 	ldw	r2,-24(fp)
 100f350:	10800604 	addi	r2,r2,24
 100f354:	100b883a 	mov	r5,r2
 100f358:	e13ffb17 	ldw	r4,-20(fp)
 100f35c:	100ed980 	call	100ed98 <metal_io_virt_to_offset>
 100f360:	1007883a 	mov	r3,r2
 100f364:	e0bffd03 	ldbu	r2,-12(fp)
 100f368:	10803fcc 	andi	r2,r2,255
 100f36c:	1021883a 	mov	r16,r2
 100f370:	0023883a 	mov	r17,zero
 100f374:	00800044 	movi	r2,1
 100f378:	d8800115 	stw	r2,4(sp)
 100f37c:	00800144 	movi	r2,5
 100f380:	d8800015 	stw	r2,0(sp)
 100f384:	800d883a 	mov	r6,r16
 100f388:	880f883a 	mov	r7,r17
 100f38c:	180b883a 	mov	r5,r3
 100f390:	e13ffb17 	ldw	r4,-20(fp)
 100f394:	100ef840 	call	100ef84 <metal_io_write>
			metal_io_virt_to_offset(io, &vdev_rsc->status),
			status);
	rpvdev->notify(rpvdev->priv, vdev->notifyid);
 100f398:	e0bff917 	ldw	r2,-28(fp)
 100f39c:	10800317 	ldw	r2,12(r2)
 100f3a0:	e0fff917 	ldw	r3,-28(fp)
 100f3a4:	19000017 	ldw	r4,0(r3)
 100f3a8:	e0fffc17 	ldw	r3,-16(fp)
 100f3ac:	18c00017 	ldw	r3,0(r3)
 100f3b0:	180b883a 	mov	r5,r3
 100f3b4:	103ee83a 	callr	r2
}
 100f3b8:	0001883a 	nop
 100f3bc:	e6fffe04 	addi	sp,fp,-8
 100f3c0:	dfc00317 	ldw	ra,12(sp)
 100f3c4:	df000217 	ldw	fp,8(sp)
 100f3c8:	dc400117 	ldw	r17,4(sp)
 100f3cc:	dc000017 	ldw	r16,0(sp)
 100f3d0:	dec00404 	addi	sp,sp,16
 100f3d4:	f800283a 	ret

0100f3d8 <rproc_virtio_get_dfeatures>:
#endif

static uint32_t rproc_virtio_get_dfeatures(struct virtio_device *vdev)
{
 100f3d8:	defff904 	addi	sp,sp,-28
 100f3dc:	dfc00615 	stw	ra,24(sp)
 100f3e0:	df000515 	stw	fp,20(sp)
 100f3e4:	df000504 	addi	fp,sp,20
 100f3e8:	e13fff15 	stw	r4,-4(fp)
	struct remoteproc_virtio *rpvdev;
	struct fw_rsc_vdev *vdev_rsc;
	struct metal_io_region *io;
	uint32_t features;

	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100f3ec:	e0bfff17 	ldw	r2,-4(fp)
 100f3f0:	10bffc04 	addi	r2,r2,-16
 100f3f4:	e0bffb15 	stw	r2,-20(fp)
	vdev_rsc = rpvdev->vdev_rsc;
 100f3f8:	e0bffb17 	ldw	r2,-20(fp)
 100f3fc:	10800117 	ldw	r2,4(r2)
 100f400:	e0bffc15 	stw	r2,-16(fp)
	io = rpvdev->vdev_rsc_io;
 100f404:	e0bffb17 	ldw	r2,-20(fp)
 100f408:	10800217 	ldw	r2,8(r2)
 100f40c:	e0bffd15 	stw	r2,-12(fp)
	features = metal_io_read32(io,
 100f410:	e0bffc17 	ldw	r2,-16(fp)
 100f414:	10800304 	addi	r2,r2,12
 100f418:	100b883a 	mov	r5,r2
 100f41c:	e13ffd17 	ldw	r4,-12(fp)
 100f420:	100ed980 	call	100ed98 <metal_io_virt_to_offset>
 100f424:	01c00104 	movi	r7,4
 100f428:	01800144 	movi	r6,5
 100f42c:	100b883a 	mov	r5,r2
 100f430:	e13ffd17 	ldw	r4,-12(fp)
 100f434:	100edec0 	call	100edec <metal_io_read>
 100f438:	1009883a 	mov	r4,r2
 100f43c:	180b883a 	mov	r5,r3
 100f440:	e13ffe15 	stw	r4,-8(fp)
			metal_io_virt_to_offset(io, &vdev_rsc->dfeatures));

	return features;
 100f444:	e0bffe17 	ldw	r2,-8(fp)
}
 100f448:	e037883a 	mov	sp,fp
 100f44c:	dfc00117 	ldw	ra,4(sp)
 100f450:	df000017 	ldw	fp,0(sp)
 100f454:	dec00204 	addi	sp,sp,8
 100f458:	f800283a 	ret

0100f45c <rproc_virtio_get_features>:

static uint32_t rproc_virtio_get_features(struct virtio_device *vdev)
{
 100f45c:	defff804 	addi	sp,sp,-32
 100f460:	dfc00715 	stw	ra,28(sp)
 100f464:	df000615 	stw	fp,24(sp)
 100f468:	df000604 	addi	fp,sp,24
 100f46c:	e13fff15 	stw	r4,-4(fp)
	struct fw_rsc_vdev *vdev_rsc;
	struct metal_io_region *io;
	uint32_t gfeatures;
	uint32_t dfeatures;

	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100f470:	e0bfff17 	ldw	r2,-4(fp)
 100f474:	10bffc04 	addi	r2,r2,-16
 100f478:	e0bffa15 	stw	r2,-24(fp)
	vdev_rsc = rpvdev->vdev_rsc;
 100f47c:	e0bffa17 	ldw	r2,-24(fp)
 100f480:	10800117 	ldw	r2,4(r2)
 100f484:	e0bffb15 	stw	r2,-20(fp)
	io = rpvdev->vdev_rsc_io;
 100f488:	e0bffa17 	ldw	r2,-24(fp)
 100f48c:	10800217 	ldw	r2,8(r2)
 100f490:	e0bffc15 	stw	r2,-16(fp)
	gfeatures = metal_io_read32(io,
 100f494:	e0bffb17 	ldw	r2,-20(fp)
 100f498:	10800404 	addi	r2,r2,16
 100f49c:	100b883a 	mov	r5,r2
 100f4a0:	e13ffc17 	ldw	r4,-16(fp)
 100f4a4:	100ed980 	call	100ed98 <metal_io_virt_to_offset>
 100f4a8:	01c00104 	movi	r7,4
 100f4ac:	01800144 	movi	r6,5
 100f4b0:	100b883a 	mov	r5,r2
 100f4b4:	e13ffc17 	ldw	r4,-16(fp)
 100f4b8:	100edec0 	call	100edec <metal_io_read>
 100f4bc:	1009883a 	mov	r4,r2
 100f4c0:	180b883a 	mov	r5,r3
 100f4c4:	e13ffd15 	stw	r4,-12(fp)
			metal_io_virt_to_offset(io, &vdev_rsc->gfeatures));
	dfeatures = rproc_virtio_get_dfeatures(vdev);
 100f4c8:	e13fff17 	ldw	r4,-4(fp)
 100f4cc:	100f3d80 	call	100f3d8 <rproc_virtio_get_dfeatures>
 100f4d0:	e0bffe15 	stw	r2,-8(fp)

	return dfeatures & gfeatures;
 100f4d4:	e0fffe17 	ldw	r3,-8(fp)
 100f4d8:	e0bffd17 	ldw	r2,-12(fp)
 100f4dc:	1884703a 	and	r2,r3,r2
}
 100f4e0:	e037883a 	mov	sp,fp
 100f4e4:	dfc00117 	ldw	ra,4(sp)
 100f4e8:	df000017 	ldw	fp,0(sp)
 100f4ec:	dec00204 	addi	sp,sp,8
 100f4f0:	f800283a 	ret

0100f4f4 <rproc_virtio_set_features>:

#ifndef VIRTIO_SLAVE_ONLY
static void rproc_virtio_set_features(struct virtio_device *vdev,
				      uint32_t features)
{
 100f4f4:	defff504 	addi	sp,sp,-44
 100f4f8:	dfc00a15 	stw	ra,40(sp)
 100f4fc:	df000915 	stw	fp,36(sp)
 100f500:	dc400815 	stw	r17,32(sp)
 100f504:	dc000715 	stw	r16,28(sp)
 100f508:	df000904 	addi	fp,sp,36
 100f50c:	e13ffc15 	stw	r4,-16(fp)
 100f510:	e17ffd15 	stw	r5,-12(fp)
	struct remoteproc_virtio *rpvdev;
	struct fw_rsc_vdev *vdev_rsc;
	struct metal_io_region *io;

	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100f514:	e0bffc17 	ldw	r2,-16(fp)
 100f518:	10bffc04 	addi	r2,r2,-16
 100f51c:	e0bff915 	stw	r2,-28(fp)
	vdev_rsc = rpvdev->vdev_rsc;
 100f520:	e0bff917 	ldw	r2,-28(fp)
 100f524:	10800117 	ldw	r2,4(r2)
 100f528:	e0bffa15 	stw	r2,-24(fp)
	io = rpvdev->vdev_rsc_io;
 100f52c:	e0bff917 	ldw	r2,-28(fp)
 100f530:	10800217 	ldw	r2,8(r2)
 100f534:	e0bffb15 	stw	r2,-20(fp)
	metal_io_write32(io,
 100f538:	e0bffa17 	ldw	r2,-24(fp)
 100f53c:	10800404 	addi	r2,r2,16
 100f540:	100b883a 	mov	r5,r2
 100f544:	e13ffb17 	ldw	r4,-20(fp)
 100f548:	100ed980 	call	100ed98 <metal_io_virt_to_offset>
 100f54c:	1007883a 	mov	r3,r2
 100f550:	e0bffd17 	ldw	r2,-12(fp)
 100f554:	1021883a 	mov	r16,r2
 100f558:	0023883a 	mov	r17,zero
 100f55c:	00800104 	movi	r2,4
 100f560:	d8800115 	stw	r2,4(sp)
 100f564:	00800144 	movi	r2,5
 100f568:	d8800015 	stw	r2,0(sp)
 100f56c:	800d883a 	mov	r6,r16
 100f570:	880f883a 	mov	r7,r17
 100f574:	180b883a 	mov	r5,r3
 100f578:	e13ffb17 	ldw	r4,-20(fp)
 100f57c:	100ef840 	call	100ef84 <metal_io_write>
			 metal_io_virt_to_offset(io, &vdev_rsc->gfeatures),
			 features);
	rpvdev->notify(rpvdev->priv, vdev->notifyid);
 100f580:	e0bff917 	ldw	r2,-28(fp)
 100f584:	10800317 	ldw	r2,12(r2)
 100f588:	e0fff917 	ldw	r3,-28(fp)
 100f58c:	19000017 	ldw	r4,0(r3)
 100f590:	e0fffc17 	ldw	r3,-16(fp)
 100f594:	18c00017 	ldw	r3,0(r3)
 100f598:	180b883a 	mov	r5,r3
 100f59c:	103ee83a 	callr	r2
}
 100f5a0:	0001883a 	nop
 100f5a4:	e6fffe04 	addi	sp,fp,-8
 100f5a8:	dfc00317 	ldw	ra,12(sp)
 100f5ac:	df000217 	ldw	fp,8(sp)
 100f5b0:	dc400117 	ldw	r17,4(sp)
 100f5b4:	dc000017 	ldw	r16,0(sp)
 100f5b8:	dec00404 	addi	sp,sp,16
 100f5bc:	f800283a 	ret

0100f5c0 <rproc_virtio_negotiate_features>:

static uint32_t rproc_virtio_negotiate_features(struct virtio_device *vdev,
						uint32_t features)
{
 100f5c0:	defffb04 	addi	sp,sp,-20
 100f5c4:	dfc00415 	stw	ra,16(sp)
 100f5c8:	df000315 	stw	fp,12(sp)
 100f5cc:	df000304 	addi	fp,sp,12
 100f5d0:	e13ffe15 	stw	r4,-8(fp)
 100f5d4:	e17fff15 	stw	r5,-4(fp)
	uint32_t dfeatures = rproc_virtio_get_dfeatures(vdev);
 100f5d8:	e13ffe17 	ldw	r4,-8(fp)
 100f5dc:	100f3d80 	call	100f3d8 <rproc_virtio_get_dfeatures>
 100f5e0:	e0bffd15 	stw	r2,-12(fp)
	rproc_virtio_set_features(vdev, dfeatures & features);
 100f5e4:	e0fffd17 	ldw	r3,-12(fp)
 100f5e8:	e0bfff17 	ldw	r2,-4(fp)
 100f5ec:	1884703a 	and	r2,r3,r2
 100f5f0:	100b883a 	mov	r5,r2
 100f5f4:	e13ffe17 	ldw	r4,-8(fp)
 100f5f8:	100f4f40 	call	100f4f4 <rproc_virtio_set_features>
	return 0;
 100f5fc:	0005883a 	mov	r2,zero
}
 100f600:	e037883a 	mov	sp,fp
 100f604:	dfc00117 	ldw	ra,4(sp)
 100f608:	df000017 	ldw	fp,0(sp)
 100f60c:	dec00204 	addi	sp,sp,8
 100f610:	f800283a 	ret

0100f614 <rproc_virtio_read_config>:
#endif

static void rproc_virtio_read_config(struct virtio_device *vdev,
				     uint32_t offset, void *dst, int length)
{
 100f614:	defffb04 	addi	sp,sp,-20
 100f618:	df000415 	stw	fp,16(sp)
 100f61c:	df000404 	addi	fp,sp,16
 100f620:	e13ffc15 	stw	r4,-16(fp)
 100f624:	e17ffd15 	stw	r5,-12(fp)
 100f628:	e1bffe15 	stw	r6,-8(fp)
 100f62c:	e1ffff15 	stw	r7,-4(fp)
	(void)vdev;
	(void)offset;
	(void)dst;
	(void)length;
}
 100f630:	0001883a 	nop
 100f634:	e037883a 	mov	sp,fp
 100f638:	df000017 	ldw	fp,0(sp)
 100f63c:	dec00104 	addi	sp,sp,4
 100f640:	f800283a 	ret

0100f644 <rproc_virtio_write_config>:

#ifndef VIRTIO_SLAVE_ONLY
static void rproc_virtio_write_config(struct virtio_device *vdev,
				      uint32_t offset, void *src, int length)
{
 100f644:	defffb04 	addi	sp,sp,-20
 100f648:	df000415 	stw	fp,16(sp)
 100f64c:	df000404 	addi	fp,sp,16
 100f650:	e13ffc15 	stw	r4,-16(fp)
 100f654:	e17ffd15 	stw	r5,-12(fp)
 100f658:	e1bffe15 	stw	r6,-8(fp)
 100f65c:	e1ffff15 	stw	r7,-4(fp)
	(void)vdev;
	(void)offset;
	(void)src;
	(void)length;
}
 100f660:	0001883a 	nop
 100f664:	e037883a 	mov	sp,fp
 100f668:	df000017 	ldw	fp,0(sp)
 100f66c:	dec00104 	addi	sp,sp,4
 100f670:	f800283a 	ret

0100f674 <rproc_virtio_reset_device>:

static void rproc_virtio_reset_device(struct virtio_device *vdev)
{
 100f674:	defffd04 	addi	sp,sp,-12
 100f678:	dfc00215 	stw	ra,8(sp)
 100f67c:	df000115 	stw	fp,4(sp)
 100f680:	df000104 	addi	fp,sp,4
 100f684:	e13fff15 	stw	r4,-4(fp)
	if (vdev->role == VIRTIO_DEV_MASTER)
 100f688:	e0bfff17 	ldw	r2,-4(fp)
 100f68c:	10800517 	ldw	r2,20(r2)
 100f690:	1000031e 	bne	r2,zero,100f6a0 <rproc_virtio_reset_device+0x2c>
		rproc_virtio_set_status(vdev,
 100f694:	01401004 	movi	r5,64
 100f698:	e13fff17 	ldw	r4,-4(fp)
 100f69c:	100f3040 	call	100f304 <rproc_virtio_set_status>
					VIRTIO_CONFIG_STATUS_NEEDS_RESET);
}
 100f6a0:	0001883a 	nop
 100f6a4:	e037883a 	mov	sp,fp
 100f6a8:	dfc00117 	ldw	ra,4(sp)
 100f6ac:	df000017 	ldw	fp,0(sp)
 100f6b0:	dec00204 	addi	sp,sp,8
 100f6b4:	f800283a 	ret

0100f6b8 <rproc_virtio_create_vdev>:
rproc_virtio_create_vdev(unsigned int role, unsigned int notifyid,
			 void *rsc, struct metal_io_region *rsc_io,
			 void *priv,
			 rpvdev_notify_func notify,
			 virtio_dev_reset_cb rst_cb)
{
 100f6b8:	defff004 	addi	sp,sp,-64
 100f6bc:	dfc00f15 	stw	ra,60(sp)
 100f6c0:	df000e15 	stw	fp,56(sp)
 100f6c4:	df000e04 	addi	fp,sp,56
 100f6c8:	e13ffc15 	stw	r4,-16(fp)
 100f6cc:	e17ffd15 	stw	r5,-12(fp)
 100f6d0:	e1bffe15 	stw	r6,-8(fp)
 100f6d4:	e1ffff15 	stw	r7,-4(fp)
	struct remoteproc_virtio *rpvdev;
	struct virtio_vring_info *vrings_info;
	struct fw_rsc_vdev *vdev_rsc = rsc;
 100f6d8:	e0bffe17 	ldw	r2,-8(fp)
 100f6dc:	e0bff415 	stw	r2,-48(fp)
	struct virtio_device *vdev;
	unsigned int num_vrings = vdev_rsc->num_of_vrings;
 100f6e0:	e0bff417 	ldw	r2,-48(fp)
 100f6e4:	10800643 	ldbu	r2,25(r2)
 100f6e8:	10803fcc 	andi	r2,r2,255
 100f6ec:	e0bff515 	stw	r2,-44(fp)
	unsigned int i;

	rpvdev = metal_allocate_memory(sizeof(*rpvdev));
 100f6f0:	01001104 	movi	r4,68
 100f6f4:	100f1000 	call	100f100 <metal_allocate_memory>
 100f6f8:	e0bff615 	stw	r2,-40(fp)
	if (!rpvdev)
 100f6fc:	e0bff617 	ldw	r2,-40(fp)
 100f700:	1000021e 	bne	r2,zero,100f70c <rproc_virtio_create_vdev+0x54>
		return NULL;
 100f704:	0005883a 	mov	r2,zero
 100f708:	00008106 	br	100f910 <rproc_virtio_create_vdev+0x258>
	vrings_info = metal_allocate_memory(sizeof(*vrings_info) * num_vrings);
 100f70c:	e0bff517 	ldw	r2,-44(fp)
 100f710:	10800624 	muli	r2,r2,24
 100f714:	1009883a 	mov	r4,r2
 100f718:	100f1000 	call	100f100 <metal_allocate_memory>
 100f71c:	e0bff715 	stw	r2,-36(fp)
	if (!vrings_info)
 100f720:	e0bff717 	ldw	r2,-36(fp)
 100f724:	10007626 	beq	r2,zero,100f900 <rproc_virtio_create_vdev+0x248>
		goto err0;
	memset(rpvdev, 0, sizeof(*rpvdev));
 100f728:	01801104 	movi	r6,68
 100f72c:	000b883a 	mov	r5,zero
 100f730:	e13ff617 	ldw	r4,-40(fp)
 100f734:	1015a3c0 	call	1015a3c <memset>
	memset(vrings_info, 0, sizeof(*vrings_info));
 100f738:	01800604 	movi	r6,24
 100f73c:	000b883a 	mov	r5,zero
 100f740:	e13ff717 	ldw	r4,-36(fp)
 100f744:	1015a3c0 	call	1015a3c <memset>
	vdev = &rpvdev->vdev;
 100f748:	e0bff617 	ldw	r2,-40(fp)
 100f74c:	10800404 	addi	r2,r2,16
 100f750:	e0bff815 	stw	r2,-32(fp)

	for (i = 0; i < num_vrings; i++) {
 100f754:	e03ff215 	stw	zero,-56(fp)
 100f758:	00002306 	br	100f7e8 <rproc_virtio_create_vdev+0x130>
		struct virtqueue *vq;
		struct fw_rsc_vdev_vring *vring_rsc;
		unsigned int num_extra_desc = 0;
 100f75c:	e03ff315 	stw	zero,-52(fp)

		vring_rsc = &vdev_rsc->vring[i];
 100f760:	e0bff217 	ldw	r2,-56(fp)
 100f764:	10800524 	muli	r2,r2,20
 100f768:	10800704 	addi	r2,r2,28
 100f76c:	e0fff417 	ldw	r3,-48(fp)
 100f770:	1885883a 	add	r2,r3,r2
 100f774:	e0bff915 	stw	r2,-28(fp)
		if (role == VIRTIO_DEV_MASTER) {
 100f778:	e0bffc17 	ldw	r2,-16(fp)
 100f77c:	10000c1e 	bne	r2,zero,100f7b0 <rproc_virtio_create_vdev+0xf8>
			num_extra_desc = vring_rsc->num;
 100f780:	e0bff917 	ldw	r2,-28(fp)
 100f784:	10c00203 	ldbu	r3,8(r2)
 100f788:	11000243 	ldbu	r4,9(r2)
 100f78c:	2008923a 	slli	r4,r4,8
 100f790:	20c6b03a 	or	r3,r4,r3
 100f794:	11000283 	ldbu	r4,10(r2)
 100f798:	2008943a 	slli	r4,r4,16
 100f79c:	20c6b03a 	or	r3,r4,r3
 100f7a0:	108002c3 	ldbu	r2,11(r2)
 100f7a4:	1004963a 	slli	r2,r2,24
 100f7a8:	10c4b03a 	or	r2,r2,r3
 100f7ac:	e0bff315 	stw	r2,-52(fp)
		}
		vq = virtqueue_allocate(num_extra_desc);
 100f7b0:	e13ff317 	ldw	r4,-52(fp)
 100f7b4:	100f1640 	call	100f164 <virtqueue_allocate>
 100f7b8:	e0bffa15 	stw	r2,-24(fp)
		if (!vq)
 100f7bc:	e0bffa17 	ldw	r2,-24(fp)
 100f7c0:	10003626 	beq	r2,zero,100f89c <rproc_virtio_create_vdev+0x1e4>
			goto err1;
		vrings_info[i].vq = vq;
 100f7c4:	e0bff217 	ldw	r2,-56(fp)
 100f7c8:	10800624 	muli	r2,r2,24
 100f7cc:	e0fff717 	ldw	r3,-36(fp)
 100f7d0:	1885883a 	add	r2,r3,r2
 100f7d4:	e0fffa17 	ldw	r3,-24(fp)
 100f7d8:	10c00015 	stw	r3,0(r2)
		goto err0;
	memset(rpvdev, 0, sizeof(*rpvdev));
	memset(vrings_info, 0, sizeof(*vrings_info));
	vdev = &rpvdev->vdev;

	for (i = 0; i < num_vrings; i++) {
 100f7dc:	e0bff217 	ldw	r2,-56(fp)
 100f7e0:	10800044 	addi	r2,r2,1
 100f7e4:	e0bff215 	stw	r2,-56(fp)
 100f7e8:	e0fff217 	ldw	r3,-56(fp)
 100f7ec:	e0bff517 	ldw	r2,-44(fp)
 100f7f0:	18bfda36 	bltu	r3,r2,100f75c <__alt_data_end+0xff00f75c>
		if (!vq)
			goto err1;
		vrings_info[i].vq = vq;
	}

	rpvdev->notify = notify;
 100f7f4:	e0bff617 	ldw	r2,-40(fp)
 100f7f8:	e0c00317 	ldw	r3,12(fp)
 100f7fc:	10c00315 	stw	r3,12(r2)
	rpvdev->priv = priv;
 100f800:	e0bff617 	ldw	r2,-40(fp)
 100f804:	e0c00217 	ldw	r3,8(fp)
 100f808:	10c00015 	stw	r3,0(r2)
	vdev->vrings_info = vrings_info;
 100f80c:	e0bff817 	ldw	r2,-32(fp)
 100f810:	e0fff717 	ldw	r3,-36(fp)
 100f814:	10c00a15 	stw	r3,40(r2)
	/* Assuming the shared memory has been mapped and registered if
	 * necessary
	 */
	rpvdev->vdev_rsc = vdev_rsc;
 100f818:	e0bff617 	ldw	r2,-40(fp)
 100f81c:	e0fff417 	ldw	r3,-48(fp)
 100f820:	10c00115 	stw	r3,4(r2)
	rpvdev->vdev_rsc_io = rsc_io;
 100f824:	e0bff617 	ldw	r2,-40(fp)
 100f828:	e0ffff17 	ldw	r3,-4(fp)
 100f82c:	10c00215 	stw	r3,8(r2)

	vdev->notifyid = notifyid;
 100f830:	e0bff817 	ldw	r2,-32(fp)
 100f834:	e0fffd17 	ldw	r3,-12(fp)
 100f838:	10c00015 	stw	r3,0(r2)
	vdev->role = role;
 100f83c:	e0bff817 	ldw	r2,-32(fp)
 100f840:	e0fffc17 	ldw	r3,-16(fp)
 100f844:	10c00515 	stw	r3,20(r2)
	vdev->reset_cb = rst_cb;
 100f848:	e0bff817 	ldw	r2,-32(fp)
 100f84c:	e0c00417 	ldw	r3,16(fp)
 100f850:	10c00615 	stw	r3,24(r2)
	vdev->vrings_num = num_vrings;
 100f854:	e0bff817 	ldw	r2,-32(fp)
 100f858:	e0fff517 	ldw	r3,-44(fp)
 100f85c:	10c00915 	stw	r3,36(r2)
	vdev->func = &remoteproc_virtio_dispatch_funcs;
 100f860:	e0fff817 	ldw	r3,-32(fp)
 100f864:	008040f4 	movhi	r2,259
 100f868:	10a74004 	addi	r2,r2,-25344
 100f86c:	18800715 	stw	r2,28(r3)

#ifndef VIRTIO_SLAVE_ONLY
	if (role == VIRTIO_DEV_MASTER) {
 100f870:	e0bffc17 	ldw	r2,-16(fp)
 100f874:	1000061e 	bne	r2,zero,100f890 <rproc_virtio_create_vdev+0x1d8>
		uint32_t dfeatures = rproc_virtio_get_dfeatures(vdev);
 100f878:	e13ff817 	ldw	r4,-32(fp)
 100f87c:	100f3d80 	call	100f3d8 <rproc_virtio_get_dfeatures>
 100f880:	e0bffb15 	stw	r2,-20(fp)
		/* Assume the master support all slave features */
		rproc_virtio_negotiate_features(vdev, dfeatures);
 100f884:	e17ffb17 	ldw	r5,-20(fp)
 100f888:	e13ff817 	ldw	r4,-32(fp)
 100f88c:	100f5c00 	call	100f5c0 <rproc_virtio_negotiate_features>
	}
#endif

	return &rpvdev->vdev;
 100f890:	e0bff617 	ldw	r2,-40(fp)
 100f894:	10800404 	addi	r2,r2,16
 100f898:	00001d06 	br	100f910 <rproc_virtio_create_vdev+0x258>
		if (role == VIRTIO_DEV_MASTER) {
			num_extra_desc = vring_rsc->num;
		}
		vq = virtqueue_allocate(num_extra_desc);
		if (!vq)
			goto err1;
 100f89c:	0001883a 	nop
#endif

	return &rpvdev->vdev;

err1:
	for (i = 0; i < num_vrings; i++) {
 100f8a0:	e03ff215 	stw	zero,-56(fp)
 100f8a4:	00001006 	br	100f8e8 <rproc_virtio_create_vdev+0x230>
		if (vrings_info[i].vq)
 100f8a8:	e0bff217 	ldw	r2,-56(fp)
 100f8ac:	10800624 	muli	r2,r2,24
 100f8b0:	e0fff717 	ldw	r3,-36(fp)
 100f8b4:	1885883a 	add	r2,r3,r2
 100f8b8:	10800017 	ldw	r2,0(r2)
 100f8bc:	10000726 	beq	r2,zero,100f8dc <rproc_virtio_create_vdev+0x224>
			metal_free_memory(vrings_info[i].vq);
 100f8c0:	e0bff217 	ldw	r2,-56(fp)
 100f8c4:	10800624 	muli	r2,r2,24
 100f8c8:	e0fff717 	ldw	r3,-36(fp)
 100f8cc:	1885883a 	add	r2,r3,r2
 100f8d0:	10800017 	ldw	r2,0(r2)
 100f8d4:	1009883a 	mov	r4,r2
 100f8d8:	100f1300 	call	100f130 <metal_free_memory>
#endif

	return &rpvdev->vdev;

err1:
	for (i = 0; i < num_vrings; i++) {
 100f8dc:	e0bff217 	ldw	r2,-56(fp)
 100f8e0:	10800044 	addi	r2,r2,1
 100f8e4:	e0bff215 	stw	r2,-56(fp)
 100f8e8:	e0fff217 	ldw	r3,-56(fp)
 100f8ec:	e0bff517 	ldw	r2,-44(fp)
 100f8f0:	18bfed36 	bltu	r3,r2,100f8a8 <__alt_data_end+0xff00f8a8>
		if (vrings_info[i].vq)
			metal_free_memory(vrings_info[i].vq);
	}
	metal_free_memory(vrings_info);
 100f8f4:	e13ff717 	ldw	r4,-36(fp)
 100f8f8:	100f1300 	call	100f130 <metal_free_memory>
 100f8fc:	00000106 	br	100f904 <rproc_virtio_create_vdev+0x24c>
	rpvdev = metal_allocate_memory(sizeof(*rpvdev));
	if (!rpvdev)
		return NULL;
	vrings_info = metal_allocate_memory(sizeof(*vrings_info) * num_vrings);
	if (!vrings_info)
		goto err0;
 100f900:	0001883a 	nop
		if (vrings_info[i].vq)
			metal_free_memory(vrings_info[i].vq);
	}
	metal_free_memory(vrings_info);
err0:
	metal_free_memory(rpvdev);
 100f904:	e13ff617 	ldw	r4,-40(fp)
 100f908:	100f1300 	call	100f130 <metal_free_memory>
	return NULL;
 100f90c:	0005883a 	mov	r2,zero
}
 100f910:	e037883a 	mov	sp,fp
 100f914:	dfc00117 	ldw	ra,4(sp)
 100f918:	df000017 	ldw	fp,0(sp)
 100f91c:	dec00204 	addi	sp,sp,8
 100f920:	f800283a 	ret

0100f924 <rproc_virtio_remove_vdev>:

void rproc_virtio_remove_vdev(struct virtio_device *vdev)
{
 100f924:	defffa04 	addi	sp,sp,-24
 100f928:	dfc00515 	stw	ra,20(sp)
 100f92c:	df000415 	stw	fp,16(sp)
 100f930:	df000404 	addi	fp,sp,16
 100f934:	e13fff15 	stw	r4,-4(fp)
	struct remoteproc_virtio *rpvdev;
	unsigned int i;

	if (!vdev)
 100f938:	e0bfff17 	ldw	r2,-4(fp)
 100f93c:	10001e26 	beq	r2,zero,100f9b8 <rproc_virtio_remove_vdev+0x94>
		return;
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 100f940:	e0bfff17 	ldw	r2,-4(fp)
 100f944:	10bffc04 	addi	r2,r2,-16
 100f948:	e0bffd15 	stw	r2,-12(fp)
	for (i = 0; i < vdev->vrings_num; i++) {
 100f94c:	e03ffc15 	stw	zero,-16(fp)
 100f950:	00000e06 	br	100f98c <rproc_virtio_remove_vdev+0x68>
		struct virtqueue *vq;

		vq = vdev->vrings_info[i].vq;
 100f954:	e0bfff17 	ldw	r2,-4(fp)
 100f958:	10c00a17 	ldw	r3,40(r2)
 100f95c:	e0bffc17 	ldw	r2,-16(fp)
 100f960:	10800624 	muli	r2,r2,24
 100f964:	1885883a 	add	r2,r3,r2
 100f968:	10800017 	ldw	r2,0(r2)
 100f96c:	e0bffe15 	stw	r2,-8(fp)
		if (vq)
 100f970:	e0bffe17 	ldw	r2,-8(fp)
 100f974:	10000226 	beq	r2,zero,100f980 <rproc_virtio_remove_vdev+0x5c>
			metal_free_memory(vq);
 100f978:	e13ffe17 	ldw	r4,-8(fp)
 100f97c:	100f1300 	call	100f130 <metal_free_memory>
	unsigned int i;

	if (!vdev)
		return;
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
	for (i = 0; i < vdev->vrings_num; i++) {
 100f980:	e0bffc17 	ldw	r2,-16(fp)
 100f984:	10800044 	addi	r2,r2,1
 100f988:	e0bffc15 	stw	r2,-16(fp)
 100f98c:	e0bfff17 	ldw	r2,-4(fp)
 100f990:	10800917 	ldw	r2,36(r2)
 100f994:	e0fffc17 	ldw	r3,-16(fp)
 100f998:	18bfee36 	bltu	r3,r2,100f954 <__alt_data_end+0xff00f954>

		vq = vdev->vrings_info[i].vq;
		if (vq)
			metal_free_memory(vq);
	}
	metal_free_memory(vdev->vrings_info);
 100f99c:	e0bfff17 	ldw	r2,-4(fp)
 100f9a0:	10800a17 	ldw	r2,40(r2)
 100f9a4:	1009883a 	mov	r4,r2
 100f9a8:	100f1300 	call	100f130 <metal_free_memory>
	metal_free_memory(rpvdev);
 100f9ac:	e13ffd17 	ldw	r4,-12(fp)
 100f9b0:	100f1300 	call	100f130 <metal_free_memory>
 100f9b4:	00000106 	br	100f9bc <rproc_virtio_remove_vdev+0x98>
{
	struct remoteproc_virtio *rpvdev;
	unsigned int i;

	if (!vdev)
		return;
 100f9b8:	0001883a 	nop
		if (vq)
			metal_free_memory(vq);
	}
	metal_free_memory(vdev->vrings_info);
	metal_free_memory(rpvdev);
}
 100f9bc:	e037883a 	mov	sp,fp
 100f9c0:	dfc00117 	ldw	ra,4(sp)
 100f9c4:	df000017 	ldw	fp,0(sp)
 100f9c8:	dec00204 	addi	sp,sp,8
 100f9cc:	f800283a 	ret

0100f9d0 <rproc_virtio_init_vring>:

int rproc_virtio_init_vring(struct virtio_device *vdev, unsigned int index,
			    unsigned int notifyid, void *va,
			    struct metal_io_region *io,
			    unsigned int num_descs, unsigned int align)
{
 100f9d0:	defff904 	addi	sp,sp,-28
 100f9d4:	df000615 	stw	fp,24(sp)
 100f9d8:	df000604 	addi	fp,sp,24
 100f9dc:	e13ffc15 	stw	r4,-16(fp)
 100f9e0:	e17ffd15 	stw	r5,-12(fp)
 100f9e4:	e1bffe15 	stw	r6,-8(fp)
 100f9e8:	e1ffff15 	stw	r7,-4(fp)
	struct virtio_vring_info *vring_info;
	unsigned int num_vrings;

	num_vrings = vdev->vrings_num;
 100f9ec:	e0bffc17 	ldw	r2,-16(fp)
 100f9f0:	10800917 	ldw	r2,36(r2)
 100f9f4:	e0bffa15 	stw	r2,-24(fp)
	if (index >= num_vrings)
 100f9f8:	e0fffd17 	ldw	r3,-12(fp)
 100f9fc:	e0bffa17 	ldw	r2,-24(fp)
 100fa00:	18800236 	bltu	r3,r2,100fa0c <rproc_virtio_init_vring+0x3c>
		return -RPROC_EINVAL;
 100fa04:	00bfff84 	movi	r2,-2
 100fa08:	00001706 	br	100fa68 <rproc_virtio_init_vring+0x98>
	vring_info = &vdev->vrings_info[index];
 100fa0c:	e0bffc17 	ldw	r2,-16(fp)
 100fa10:	10c00a17 	ldw	r3,40(r2)
 100fa14:	e0bffd17 	ldw	r2,-12(fp)
 100fa18:	10800624 	muli	r2,r2,24
 100fa1c:	1885883a 	add	r2,r3,r2
 100fa20:	e0bffb15 	stw	r2,-20(fp)
	vring_info->io = io;
 100fa24:	e0bffb17 	ldw	r2,-20(fp)
 100fa28:	e0c00117 	ldw	r3,4(fp)
 100fa2c:	10c00515 	stw	r3,20(r2)
	vring_info->notifyid = notifyid;
 100fa30:	e0bffb17 	ldw	r2,-20(fp)
 100fa34:	e0fffe17 	ldw	r3,-8(fp)
 100fa38:	10c00415 	stw	r3,16(r2)
	vring_info->info.vaddr = va;
 100fa3c:	e0bffb17 	ldw	r2,-20(fp)
 100fa40:	e0ffff17 	ldw	r3,-4(fp)
 100fa44:	10c00115 	stw	r3,4(r2)
	vring_info->info.num_descs = num_descs;
 100fa48:	e0800217 	ldw	r2,8(fp)
 100fa4c:	1007883a 	mov	r3,r2
 100fa50:	e0bffb17 	ldw	r2,-20(fp)
 100fa54:	10c0030d 	sth	r3,12(r2)
	vring_info->info.align = align;
 100fa58:	e0bffb17 	ldw	r2,-20(fp)
 100fa5c:	e0c00317 	ldw	r3,12(fp)
 100fa60:	10c00215 	stw	r3,8(r2)

	return 0;
 100fa64:	0005883a 	mov	r2,zero
}
 100fa68:	e037883a 	mov	sp,fp
 100fa6c:	df000017 	ldw	fp,0(sp)
 100fa70:	dec00104 	addi	sp,sp,4
 100fa74:	f800283a 	ret

0100fa78 <rproc_virtio_notified>:

int rproc_virtio_notified(struct virtio_device *vdev, uint32_t notifyid)
{
 100fa78:	defff804 	addi	sp,sp,-32
 100fa7c:	dfc00715 	stw	ra,28(sp)
 100fa80:	df000615 	stw	fp,24(sp)
 100fa84:	df000604 	addi	fp,sp,24
 100fa88:	e13ffe15 	stw	r4,-8(fp)
 100fa8c:	e17fff15 	stw	r5,-4(fp)
	unsigned int num_vrings, i;
	struct virtio_vring_info *vring_info;
	struct virtqueue *vq;

	if (!vdev)
 100fa90:	e0bffe17 	ldw	r2,-8(fp)
 100fa94:	1000021e 	bne	r2,zero,100faa0 <rproc_virtio_notified+0x28>
		return -RPROC_EINVAL;
 100fa98:	00bfff84 	movi	r2,-2
 100fa9c:	00002406 	br	100fb30 <rproc_virtio_notified+0xb8>
	/* We do nothing for vdev notification in this implementation */
	if (vdev->notifyid == notifyid)
 100faa0:	e0bffe17 	ldw	r2,-8(fp)
 100faa4:	10c00017 	ldw	r3,0(r2)
 100faa8:	e0bfff17 	ldw	r2,-4(fp)
 100faac:	1880021e 	bne	r3,r2,100fab8 <rproc_virtio_notified+0x40>
		return 0;
 100fab0:	0005883a 	mov	r2,zero
 100fab4:	00001e06 	br	100fb30 <rproc_virtio_notified+0xb8>
	num_vrings = vdev->vrings_num;
 100fab8:	e0bffe17 	ldw	r2,-8(fp)
 100fabc:	10800917 	ldw	r2,36(r2)
 100fac0:	e0bffb15 	stw	r2,-20(fp)
	for (i = 0; i < num_vrings; i++) {
 100fac4:	e03ffa15 	stw	zero,-24(fp)
 100fac8:	00001506 	br	100fb20 <rproc_virtio_notified+0xa8>
		vring_info = &vdev->vrings_info[i];
 100facc:	e0bffe17 	ldw	r2,-8(fp)
 100fad0:	10c00a17 	ldw	r3,40(r2)
 100fad4:	e0bffa17 	ldw	r2,-24(fp)
 100fad8:	10800624 	muli	r2,r2,24
 100fadc:	1885883a 	add	r2,r3,r2
 100fae0:	e0bffc15 	stw	r2,-16(fp)
		if (vring_info->notifyid == notifyid ||
 100fae4:	e0bffc17 	ldw	r2,-16(fp)
 100fae8:	10c00417 	ldw	r3,16(r2)
 100faec:	e0bfff17 	ldw	r2,-4(fp)
 100faf0:	18800326 	beq	r3,r2,100fb00 <rproc_virtio_notified+0x88>
 100faf4:	e0bfff17 	ldw	r2,-4(fp)
 100faf8:	10bfffd8 	cmpnei	r2,r2,-1
 100fafc:	1000051e 	bne	r2,zero,100fb14 <rproc_virtio_notified+0x9c>
		    notifyid == RSC_NOTIFY_ID_ANY) {
			vq = vring_info->vq;
 100fb00:	e0bffc17 	ldw	r2,-16(fp)
 100fb04:	10800017 	ldw	r2,0(r2)
 100fb08:	e0bffd15 	stw	r2,-12(fp)
			virtqueue_notification(vq);
 100fb0c:	e13ffd17 	ldw	r4,-12(fp)
 100fb10:	1013d440 	call	1013d44 <virtqueue_notification>
		return -RPROC_EINVAL;
	/* We do nothing for vdev notification in this implementation */
	if (vdev->notifyid == notifyid)
		return 0;
	num_vrings = vdev->vrings_num;
	for (i = 0; i < num_vrings; i++) {
 100fb14:	e0bffa17 	ldw	r2,-24(fp)
 100fb18:	10800044 	addi	r2,r2,1
 100fb1c:	e0bffa15 	stw	r2,-24(fp)
 100fb20:	e0fffa17 	ldw	r3,-24(fp)
 100fb24:	e0bffb17 	ldw	r2,-20(fp)
 100fb28:	18bfe836 	bltu	r3,r2,100facc <__alt_data_end+0xff00facc>
		    notifyid == RSC_NOTIFY_ID_ANY) {
			vq = vring_info->vq;
			virtqueue_notification(vq);
		}
	}
	return 0;
 100fb2c:	0005883a 	mov	r2,zero
}
 100fb30:	e037883a 	mov	sp,fp
 100fb34:	dfc00117 	ldw	ra,4(sp)
 100fb38:	df000017 	ldw	fp,0(sp)
 100fb3c:	dec00204 	addi	sp,sp,8
 100fb40:	f800283a 	ret

0100fb44 <rproc_virtio_wait_remote_ready>:

void rproc_virtio_wait_remote_ready(struct virtio_device *vdev)
{
 100fb44:	defffc04 	addi	sp,sp,-16
 100fb48:	dfc00315 	stw	ra,12(sp)
 100fb4c:	df000215 	stw	fp,8(sp)
 100fb50:	df000204 	addi	fp,sp,8
 100fb54:	e13fff15 	stw	r4,-4(fp)
	/*
	 * No status available for slave. As Master has not to wait
	 * slave action, we can return. Behavior should be updated
	 * in future if a slave status is added.
	 */
	if (vdev->role == VIRTIO_DEV_MASTER)
 100fb58:	e0bfff17 	ldw	r2,-4(fp)
 100fb5c:	10800517 	ldw	r2,20(r2)
 100fb60:	10000826 	beq	r2,zero,100fb84 <rproc_virtio_wait_remote_ready+0x40>
		return;

	while (1) {
		status = rproc_virtio_get_status(vdev);
 100fb64:	e13fff17 	ldw	r4,-4(fp)
 100fb68:	100f2800 	call	100f280 <rproc_virtio_get_status>
 100fb6c:	e0bffe05 	stb	r2,-8(fp)
		if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK)
 100fb70:	e0bffe03 	ldbu	r2,-8(fp)
 100fb74:	1080010c 	andi	r2,r2,4
 100fb78:	1000041e 	bne	r2,zero,100fb8c <rproc_virtio_wait_remote_ready+0x48>
			return;
		metal_cpu_yield();
 100fb7c:	0001883a 	nop
	}
 100fb80:	003ff806 	br	100fb64 <__alt_data_end+0xff00fb64>
	 * No status available for slave. As Master has not to wait
	 * slave action, we can return. Behavior should be updated
	 * in future if a slave status is added.
	 */
	if (vdev->role == VIRTIO_DEV_MASTER)
		return;
 100fb84:	0001883a 	nop
 100fb88:	00000106 	br	100fb90 <rproc_virtio_wait_remote_ready+0x4c>

	while (1) {
		status = rproc_virtio_get_status(vdev);
		if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK)
			return;
 100fb8c:	0001883a 	nop
		metal_cpu_yield();
	}
}
 100fb90:	e037883a 	mov	sp,fp
 100fb94:	dfc00117 	ldw	ra,4(sp)
 100fb98:	df000017 	ldw	fp,0(sp)
 100fb9c:	dec00204 	addi	sp,sp,8
 100fba0:	f800283a 	ret

0100fba4 <metal_io_virt_to_offset>:
 * @param[in]	virt	Virtual address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
 100fba4:	defffc04 	addi	sp,sp,-16
 100fba8:	df000315 	stw	fp,12(sp)
 100fbac:	df000304 	addi	fp,sp,12
 100fbb0:	e13ffe15 	stw	r4,-8(fp)
 100fbb4:	e17fff15 	stw	r5,-4(fp)
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 100fbb8:	e0bfff17 	ldw	r2,-4(fp)
 100fbbc:	e0fffe17 	ldw	r3,-8(fp)
 100fbc0:	18c00017 	ldw	r3,0(r3)
 100fbc4:	10c5c83a 	sub	r2,r2,r3
 100fbc8:	e0bffd15 	stw	r2,-12(fp)
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 100fbcc:	e0bffe17 	ldw	r2,-8(fp)
 100fbd0:	10800217 	ldw	r2,8(r2)
 100fbd4:	e0fffd17 	ldw	r3,-12(fp)
 100fbd8:	1880022e 	bgeu	r3,r2,100fbe4 <metal_io_virt_to_offset+0x40>
 100fbdc:	e0bffd17 	ldw	r2,-12(fp)
 100fbe0:	00000106 	br	100fbe8 <metal_io_virt_to_offset+0x44>
 100fbe4:	00bfffc4 	movi	r2,-1
}
 100fbe8:	e037883a 	mov	sp,fp
 100fbec:	df000017 	ldw	fp,0(sp)
 100fbf0:	dec00104 	addi	sp,sp,4
 100fbf4:	f800283a 	ret

0100fbf8 <handle_rsc_table>:
};

int handle_rsc_table(struct remoteproc *rproc,
		     struct resource_table *rsc_table, size_t size,
		     struct metal_io_region *io)
{
 100fbf8:	defff504 	addi	sp,sp,-44
 100fbfc:	dfc00a15 	stw	ra,40(sp)
 100fc00:	df000915 	stw	fp,36(sp)
 100fc04:	df000904 	addi	fp,sp,36
 100fc08:	e13ffc15 	stw	r4,-16(fp)
 100fc0c:	e17ffd15 	stw	r5,-12(fp)
 100fc10:	e1bffe15 	stw	r6,-8(fp)
 100fc14:	e1ffff15 	stw	r7,-4(fp)
	char *rsc_start;
	unsigned int rsc_type;
	unsigned int idx, offset;
	int status = 0;
 100fc18:	e03ff815 	stw	zero,-32(fp)

	/* Validate rsc table header fields */

	/* Minimum rsc table size */
	if (sizeof(struct resource_table) > size) {
 100fc1c:	e0bffe17 	ldw	r2,-8(fp)
 100fc20:	10800428 	cmpgeui	r2,r2,16
 100fc24:	1000021e 	bne	r2,zero,100fc30 <handle_rsc_table+0x38>
		return -RPROC_ERR_RSC_TAB_TRUNC;
 100fc28:	00bffec4 	movi	r2,-5
 100fc2c:	00009906 	br	100fe94 <handle_rsc_table+0x29c>
	}

	/* Supported version */
	if (rsc_table->ver != RSC_TAB_SUPPORTED_VERSION) {
 100fc30:	e0bffd17 	ldw	r2,-12(fp)
 100fc34:	10c00003 	ldbu	r3,0(r2)
 100fc38:	11000043 	ldbu	r4,1(r2)
 100fc3c:	2008923a 	slli	r4,r4,8
 100fc40:	20c6b03a 	or	r3,r4,r3
 100fc44:	11000083 	ldbu	r4,2(r2)
 100fc48:	2008943a 	slli	r4,r4,16
 100fc4c:	20c6b03a 	or	r3,r4,r3
 100fc50:	108000c3 	ldbu	r2,3(r2)
 100fc54:	1004963a 	slli	r2,r2,24
 100fc58:	10c4b03a 	or	r2,r2,r3
 100fc5c:	10800060 	cmpeqi	r2,r2,1
 100fc60:	1000021e 	bne	r2,zero,100fc6c <handle_rsc_table+0x74>
		return -RPROC_ERR_RSC_TAB_VER;
 100fc64:	00bffe84 	movi	r2,-6
 100fc68:	00008a06 	br	100fe94 <handle_rsc_table+0x29c>
	}

	/* Offset array */
	offset = sizeof(struct resource_table)
		 + rsc_table->num * sizeof(rsc_table->offset[0]);
 100fc6c:	e0bffd17 	ldw	r2,-12(fp)
 100fc70:	10c00103 	ldbu	r3,4(r2)
 100fc74:	11000143 	ldbu	r4,5(r2)
 100fc78:	2008923a 	slli	r4,r4,8
 100fc7c:	20c6b03a 	or	r3,r4,r3
 100fc80:	11000183 	ldbu	r4,6(r2)
 100fc84:	2008943a 	slli	r4,r4,16
 100fc88:	20c6b03a 	or	r3,r4,r3
 100fc8c:	108001c3 	ldbu	r2,7(r2)
 100fc90:	1004963a 	slli	r2,r2,24
 100fc94:	10c4b03a 	or	r2,r2,r3
	if (rsc_table->ver != RSC_TAB_SUPPORTED_VERSION) {
		return -RPROC_ERR_RSC_TAB_VER;
	}

	/* Offset array */
	offset = sizeof(struct resource_table)
 100fc98:	10800104 	addi	r2,r2,4
 100fc9c:	1085883a 	add	r2,r2,r2
 100fca0:	1085883a 	add	r2,r2,r2
 100fca4:	e0bff915 	stw	r2,-28(fp)
		 + rsc_table->num * sizeof(rsc_table->offset[0]);

	if (offset > size) {
 100fca8:	e0bff917 	ldw	r2,-28(fp)
 100fcac:	e0fffe17 	ldw	r3,-8(fp)
 100fcb0:	1880022e 	bgeu	r3,r2,100fcbc <handle_rsc_table+0xc4>
		return -RPROC_ERR_RSC_TAB_TRUNC;
 100fcb4:	00bffec4 	movi	r2,-5
 100fcb8:	00007606 	br	100fe94 <handle_rsc_table+0x29c>
	}

	/* Reserved fields - must be zero */
	if ((rsc_table->reserved[0] != 0 || rsc_table->reserved[1]) != 0) {
 100fcbc:	e0bffd17 	ldw	r2,-12(fp)
 100fcc0:	10c00203 	ldbu	r3,8(r2)
 100fcc4:	11000243 	ldbu	r4,9(r2)
 100fcc8:	2008923a 	slli	r4,r4,8
 100fccc:	20c6b03a 	or	r3,r4,r3
 100fcd0:	11000283 	ldbu	r4,10(r2)
 100fcd4:	2008943a 	slli	r4,r4,16
 100fcd8:	20c6b03a 	or	r3,r4,r3
 100fcdc:	108002c3 	ldbu	r2,11(r2)
 100fce0:	1004963a 	slli	r2,r2,24
 100fce4:	10c4b03a 	or	r2,r2,r3
 100fce8:	10000c1e 	bne	r2,zero,100fd1c <handle_rsc_table+0x124>
 100fcec:	e0bffd17 	ldw	r2,-12(fp)
 100fcf0:	10c00303 	ldbu	r3,12(r2)
 100fcf4:	11000343 	ldbu	r4,13(r2)
 100fcf8:	2008923a 	slli	r4,r4,8
 100fcfc:	20c6b03a 	or	r3,r4,r3
 100fd00:	11000383 	ldbu	r4,14(r2)
 100fd04:	2008943a 	slli	r4,r4,16
 100fd08:	20c6b03a 	or	r3,r4,r3
 100fd0c:	108003c3 	ldbu	r2,15(r2)
 100fd10:	1004963a 	slli	r2,r2,24
 100fd14:	10c4b03a 	or	r2,r2,r3
 100fd18:	10000226 	beq	r2,zero,100fd24 <handle_rsc_table+0x12c>
 100fd1c:	00800044 	movi	r2,1
 100fd20:	00000106 	br	100fd28 <handle_rsc_table+0x130>
 100fd24:	0005883a 	mov	r2,zero
 100fd28:	10000226 	beq	r2,zero,100fd34 <handle_rsc_table+0x13c>
		return -RPROC_ERR_RSC_TAB_RSVD;
 100fd2c:	00bffe44 	movi	r2,-7
 100fd30:	00005806 	br	100fe94 <handle_rsc_table+0x29c>
	}

	/* Loop through the offset array and parse each resource entry */
	for (idx = 0; idx < rsc_table->num; idx++) {
 100fd34:	e03ff715 	stw	zero,-36(fp)
 100fd38:	00004506 	br	100fe50 <handle_rsc_table+0x258>
		rsc_start = (char *)rsc_table;
 100fd3c:	e0bffd17 	ldw	r2,-12(fp)
 100fd40:	e0bffa15 	stw	r2,-24(fp)
		rsc_start += rsc_table->offset[idx];
 100fd44:	e0fffd17 	ldw	r3,-12(fp)
 100fd48:	e0bff717 	ldw	r2,-36(fp)
 100fd4c:	10800104 	addi	r2,r2,4
 100fd50:	1085883a 	add	r2,r2,r2
 100fd54:	1085883a 	add	r2,r2,r2
 100fd58:	1885883a 	add	r2,r3,r2
 100fd5c:	10c00003 	ldbu	r3,0(r2)
 100fd60:	11000043 	ldbu	r4,1(r2)
 100fd64:	2008923a 	slli	r4,r4,8
 100fd68:	20c6b03a 	or	r3,r4,r3
 100fd6c:	11000083 	ldbu	r4,2(r2)
 100fd70:	2008943a 	slli	r4,r4,16
 100fd74:	20c6b03a 	or	r3,r4,r3
 100fd78:	108000c3 	ldbu	r2,3(r2)
 100fd7c:	1004963a 	slli	r2,r2,24
 100fd80:	10c4b03a 	or	r2,r2,r3
 100fd84:	1007883a 	mov	r3,r2
 100fd88:	e0bffa17 	ldw	r2,-24(fp)
 100fd8c:	10c5883a 	add	r2,r2,r3
 100fd90:	e0bffa15 	stw	r2,-24(fp)
		if (io &&
 100fd94:	e0bfff17 	ldw	r2,-4(fp)
 100fd98:	10000726 	beq	r2,zero,100fdb8 <handle_rsc_table+0x1c0>
		    metal_io_virt_to_offset(io, rsc_start) == METAL_BAD_OFFSET)
 100fd9c:	e17ffa17 	ldw	r5,-24(fp)
 100fda0:	e13fff17 	ldw	r4,-4(fp)
 100fda4:	100fba40 	call	100fba4 <metal_io_virt_to_offset>

	/* Loop through the offset array and parse each resource entry */
	for (idx = 0; idx < rsc_table->num; idx++) {
		rsc_start = (char *)rsc_table;
		rsc_start += rsc_table->offset[idx];
		if (io &&
 100fda8:	10bfffd8 	cmpnei	r2,r2,-1
 100fdac:	1000021e 	bne	r2,zero,100fdb8 <handle_rsc_table+0x1c0>
		    metal_io_virt_to_offset(io, rsc_start) == METAL_BAD_OFFSET)
			return -RPROC_ERR_RSC_TAB_TRUNC;
 100fdb0:	00bffec4 	movi	r2,-5
 100fdb4:	00003706 	br	100fe94 <handle_rsc_table+0x29c>
		rsc_type = *((uint32_t *)rsc_start);
 100fdb8:	e0bffa17 	ldw	r2,-24(fp)
 100fdbc:	10800017 	ldw	r2,0(r2)
 100fdc0:	e0bffb15 	stw	r2,-20(fp)
		if (rsc_type < RSC_LAST)
 100fdc4:	e0bffb17 	ldw	r2,-20(fp)
 100fdc8:	10800128 	cmpgeui	r2,r2,4
 100fdcc:	10000c1e 	bne	r2,zero,100fe00 <handle_rsc_table+0x208>
			status = rsc_handler_table[rsc_type](rproc,
 100fdd0:	008040f4 	movhi	r2,259
 100fdd4:	10a75904 	addi	r2,r2,-25244
 100fdd8:	e0fffb17 	ldw	r3,-20(fp)
 100fddc:	18c7883a 	add	r3,r3,r3
 100fde0:	18c7883a 	add	r3,r3,r3
 100fde4:	10c5883a 	add	r2,r2,r3
 100fde8:	10800017 	ldw	r2,0(r2)
 100fdec:	e17ffa17 	ldw	r5,-24(fp)
 100fdf0:	e13ffc17 	ldw	r4,-16(fp)
 100fdf4:	103ee83a 	callr	r2
 100fdf8:	e0bff815 	stw	r2,-32(fp)
 100fdfc:	00000a06 	br	100fe28 <handle_rsc_table+0x230>
							     rsc_start);
		else if (rsc_type >= RSC_VENDOR_START &&
 100fe00:	e0bffb17 	ldw	r2,-20(fp)
 100fe04:	10802030 	cmpltui	r2,r2,128
 100fe08:	1000071e 	bne	r2,zero,100fe28 <handle_rsc_table+0x230>
 100fe0c:	e0bffb17 	ldw	r2,-20(fp)
 100fe10:	10808068 	cmpgeui	r2,r2,513
 100fe14:	1000041e 	bne	r2,zero,100fe28 <handle_rsc_table+0x230>
			 rsc_type <= RSC_VENDOR_END)
			status = handle_vendor_rsc(rproc, rsc_start);
 100fe18:	e17ffa17 	ldw	r5,-24(fp)
 100fe1c:	e13ffc17 	ldw	r4,-16(fp)
 100fe20:	101001c0 	call	101001c <handle_vendor_rsc>
 100fe24:	e0bff815 	stw	r2,-32(fp)
		if (status == -RPROC_ERR_RSC_TAB_NS) {
 100fe28:	e0bff817 	ldw	r2,-32(fp)
 100fe2c:	10bffd58 	cmpnei	r2,r2,-11
 100fe30:	1000021e 	bne	r2,zero,100fe3c <handle_rsc_table+0x244>
			status = 0;
 100fe34:	e03ff815 	stw	zero,-32(fp)
			continue;
 100fe38:	00000206 	br	100fe44 <handle_rsc_table+0x24c>
		}
		else if (status)
 100fe3c:	e0bff817 	ldw	r2,-32(fp)
 100fe40:	1000121e 	bne	r2,zero,100fe8c <handle_rsc_table+0x294>
	if ((rsc_table->reserved[0] != 0 || rsc_table->reserved[1]) != 0) {
		return -RPROC_ERR_RSC_TAB_RSVD;
	}

	/* Loop through the offset array and parse each resource entry */
	for (idx = 0; idx < rsc_table->num; idx++) {
 100fe44:	e0bff717 	ldw	r2,-36(fp)
 100fe48:	10800044 	addi	r2,r2,1
 100fe4c:	e0bff715 	stw	r2,-36(fp)
 100fe50:	e0bffd17 	ldw	r2,-12(fp)
 100fe54:	10c00103 	ldbu	r3,4(r2)
 100fe58:	11000143 	ldbu	r4,5(r2)
 100fe5c:	2008923a 	slli	r4,r4,8
 100fe60:	20c6b03a 	or	r3,r4,r3
 100fe64:	11000183 	ldbu	r4,6(r2)
 100fe68:	2008943a 	slli	r4,r4,16
 100fe6c:	20c6b03a 	or	r3,r4,r3
 100fe70:	108001c3 	ldbu	r2,7(r2)
 100fe74:	1004963a 	slli	r2,r2,24
 100fe78:	10c4b03a 	or	r2,r2,r3
 100fe7c:	1007883a 	mov	r3,r2
 100fe80:	e0bff717 	ldw	r2,-36(fp)
 100fe84:	10ffad36 	bltu	r2,r3,100fd3c <__alt_data_end+0xff00fd3c>
 100fe88:	00000106 	br	100fe90 <handle_rsc_table+0x298>
		if (status == -RPROC_ERR_RSC_TAB_NS) {
			status = 0;
			continue;
		}
		else if (status)
			break;
 100fe8c:	0001883a 	nop
	}

	return status;
 100fe90:	e0bff817 	ldw	r2,-32(fp)
}
 100fe94:	e037883a 	mov	sp,fp
 100fe98:	dfc00117 	ldw	ra,4(sp)
 100fe9c:	df000017 	ldw	fp,0(sp)
 100fea0:	dec00204 	addi	sp,sp,8
 100fea4:	f800283a 	ret

0100fea8 <handle_carve_out_rsc>:
 *
 * @returns - 0 for success, or negative value for failure
 *
 */
int handle_carve_out_rsc(struct remoteproc *rproc, void *rsc)
{
 100fea8:	defff504 	addi	sp,sp,-44
 100feac:	dfc00a15 	stw	ra,40(sp)
 100feb0:	df000915 	stw	fp,36(sp)
 100feb4:	df000904 	addi	fp,sp,36
 100feb8:	e13ffe15 	stw	r4,-8(fp)
 100febc:	e17fff15 	stw	r5,-4(fp)
	struct fw_rsc_carveout *carve_rsc = rsc;
 100fec0:	e0bfff17 	ldw	r2,-4(fp)
 100fec4:	e0bff915 	stw	r2,-28(fp)
	metal_phys_addr_t pa;
	size_t size;
	unsigned int attribute;

	/* Validate resource fields */
	if (!carve_rsc) {
 100fec8:	e0bff917 	ldw	r2,-28(fp)
 100fecc:	1000021e 	bne	r2,zero,100fed8 <handle_carve_out_rsc+0x30>
		return -RPROC_ERR_RSC_TAB_NP;
 100fed0:	00bffd84 	movi	r2,-10
 100fed4:	00004c06 	br	1010008 <handle_carve_out_rsc+0x160>
	}

	if (carve_rsc->reserved) {
 100fed8:	e0bff917 	ldw	r2,-28(fp)
 100fedc:	10c00503 	ldbu	r3,20(r2)
 100fee0:	11000543 	ldbu	r4,21(r2)
 100fee4:	2008923a 	slli	r4,r4,8
 100fee8:	20c6b03a 	or	r3,r4,r3
 100feec:	11000583 	ldbu	r4,22(r2)
 100fef0:	2008943a 	slli	r4,r4,16
 100fef4:	20c6b03a 	or	r3,r4,r3
 100fef8:	108005c3 	ldbu	r2,23(r2)
 100fefc:	1004963a 	slli	r2,r2,24
 100ff00:	10c4b03a 	or	r2,r2,r3
 100ff04:	10000226 	beq	r2,zero,100ff10 <handle_carve_out_rsc+0x68>
		return -RPROC_ERR_RSC_TAB_RSVD;
 100ff08:	00bffe44 	movi	r2,-7
 100ff0c:	00003e06 	br	1010008 <handle_carve_out_rsc+0x160>
	}
	pa = carve_rsc->pa;
 100ff10:	e0bff917 	ldw	r2,-28(fp)
 100ff14:	10c00203 	ldbu	r3,8(r2)
 100ff18:	11000243 	ldbu	r4,9(r2)
 100ff1c:	2008923a 	slli	r4,r4,8
 100ff20:	20c6b03a 	or	r3,r4,r3
 100ff24:	11000283 	ldbu	r4,10(r2)
 100ff28:	2008943a 	slli	r4,r4,16
 100ff2c:	20c6b03a 	or	r3,r4,r3
 100ff30:	108002c3 	ldbu	r2,11(r2)
 100ff34:	1004963a 	slli	r2,r2,24
 100ff38:	10c4b03a 	or	r2,r2,r3
 100ff3c:	e0bffd15 	stw	r2,-12(fp)
	da = carve_rsc->da;
 100ff40:	e0bff917 	ldw	r2,-28(fp)
 100ff44:	10c00103 	ldbu	r3,4(r2)
 100ff48:	11000143 	ldbu	r4,5(r2)
 100ff4c:	2008923a 	slli	r4,r4,8
 100ff50:	20c6b03a 	or	r3,r4,r3
 100ff54:	11000183 	ldbu	r4,6(r2)
 100ff58:	2008943a 	slli	r4,r4,16
 100ff5c:	20c6b03a 	or	r3,r4,r3
 100ff60:	108001c3 	ldbu	r2,7(r2)
 100ff64:	1004963a 	slli	r2,r2,24
 100ff68:	10c4b03a 	or	r2,r2,r3
 100ff6c:	e0bffc15 	stw	r2,-16(fp)
	size = carve_rsc->len;
 100ff70:	e0bff917 	ldw	r2,-28(fp)
 100ff74:	10c00303 	ldbu	r3,12(r2)
 100ff78:	11000343 	ldbu	r4,13(r2)
 100ff7c:	2008923a 	slli	r4,r4,8
 100ff80:	20c6b03a 	or	r3,r4,r3
 100ff84:	11000383 	ldbu	r4,14(r2)
 100ff88:	2008943a 	slli	r4,r4,16
 100ff8c:	20c6b03a 	or	r3,r4,r3
 100ff90:	108003c3 	ldbu	r2,15(r2)
 100ff94:	1004963a 	slli	r2,r2,24
 100ff98:	10c4b03a 	or	r2,r2,r3
 100ff9c:	e0bffa15 	stw	r2,-24(fp)
	attribute = carve_rsc->flags;
 100ffa0:	e0bff917 	ldw	r2,-28(fp)
 100ffa4:	10c00403 	ldbu	r3,16(r2)
 100ffa8:	11000443 	ldbu	r4,17(r2)
 100ffac:	2008923a 	slli	r4,r4,8
 100ffb0:	20c6b03a 	or	r3,r4,r3
 100ffb4:	11000483 	ldbu	r4,18(r2)
 100ffb8:	2008943a 	slli	r4,r4,16
 100ffbc:	20c6b03a 	or	r3,r4,r3
 100ffc0:	108004c3 	ldbu	r2,19(r2)
 100ffc4:	1004963a 	slli	r2,r2,24
 100ffc8:	10c4b03a 	or	r2,r2,r3
 100ffcc:	e0bffb15 	stw	r2,-20(fp)
	if (remoteproc_mmap(rproc, &pa, &da, size, attribute, NULL))
 100ffd0:	e13ffc04 	addi	r4,fp,-16
 100ffd4:	e0fffd04 	addi	r3,fp,-12
 100ffd8:	d8000115 	stw	zero,4(sp)
 100ffdc:	e0bffb17 	ldw	r2,-20(fp)
 100ffe0:	d8800015 	stw	r2,0(sp)
 100ffe4:	e1fffa17 	ldw	r7,-24(fp)
 100ffe8:	200d883a 	mov	r6,r4
 100ffec:	180b883a 	mov	r5,r3
 100fff0:	e13ffe17 	ldw	r4,-8(fp)
 100fff4:	100ce140 	call	100ce14 <remoteproc_mmap>
 100fff8:	10000226 	beq	r2,zero,1010004 <handle_carve_out_rsc+0x15c>
		return 0;
 100fffc:	0005883a 	mov	r2,zero
 1010000:	00000106 	br	1010008 <handle_carve_out_rsc+0x160>
	else
		return -RPROC_EINVAL;
 1010004:	00bfff84 	movi	r2,-2
}
 1010008:	e037883a 	mov	sp,fp
 101000c:	dfc00117 	ldw	ra,4(sp)
 1010010:	df000017 	ldw	fp,0(sp)
 1010014:	dec00204 	addi	sp,sp,8
 1010018:	f800283a 	ret

0101001c <handle_vendor_rsc>:

int handle_vendor_rsc(struct remoteproc *rproc, void *rsc)
{
 101001c:	defffa04 	addi	sp,sp,-24
 1010020:	dfc00515 	stw	ra,20(sp)
 1010024:	df000415 	stw	fp,16(sp)
 1010028:	df000404 	addi	fp,sp,16
 101002c:	e13ffe15 	stw	r4,-8(fp)
 1010030:	e17fff15 	stw	r5,-4(fp)
	if (rproc && rproc->ops->handle_rsc) {
 1010034:	e0bffe17 	ldw	r2,-8(fp)
 1010038:	10001a26 	beq	r2,zero,10100a4 <handle_vendor_rsc+0x88>
 101003c:	e0bffe17 	ldw	r2,-8(fp)
 1010040:	10800917 	ldw	r2,36(r2)
 1010044:	10800317 	ldw	r2,12(r2)
 1010048:	10001626 	beq	r2,zero,10100a4 <handle_vendor_rsc+0x88>
		struct fw_rsc_vendor *vend_rsc = rsc;
 101004c:	e0bfff17 	ldw	r2,-4(fp)
 1010050:	e0bffc15 	stw	r2,-16(fp)
		size_t len = vend_rsc->len;
 1010054:	e0bffc17 	ldw	r2,-16(fp)
 1010058:	10c00103 	ldbu	r3,4(r2)
 101005c:	11000143 	ldbu	r4,5(r2)
 1010060:	2008923a 	slli	r4,r4,8
 1010064:	20c6b03a 	or	r3,r4,r3
 1010068:	11000183 	ldbu	r4,6(r2)
 101006c:	2008943a 	slli	r4,r4,16
 1010070:	20c6b03a 	or	r3,r4,r3
 1010074:	108001c3 	ldbu	r2,7(r2)
 1010078:	1004963a 	slli	r2,r2,24
 101007c:	10c4b03a 	or	r2,r2,r3
 1010080:	e0bffd15 	stw	r2,-12(fp)

		return rproc->ops->handle_rsc(rproc, rsc, len);
 1010084:	e0bffe17 	ldw	r2,-8(fp)
 1010088:	10800917 	ldw	r2,36(r2)
 101008c:	10800317 	ldw	r2,12(r2)
 1010090:	e1bffd17 	ldw	r6,-12(fp)
 1010094:	e17fff17 	ldw	r5,-4(fp)
 1010098:	e13ffe17 	ldw	r4,-8(fp)
 101009c:	103ee83a 	callr	r2
 10100a0:	00000106 	br	10100a8 <handle_vendor_rsc+0x8c>
	}
	return -RPROC_ERR_RSC_TAB_NS;
 10100a4:	00bffd44 	movi	r2,-11
}
 10100a8:	e037883a 	mov	sp,fp
 10100ac:	dfc00117 	ldw	ra,4(sp)
 10100b0:	df000017 	ldw	fp,0(sp)
 10100b4:	dec00204 	addi	sp,sp,8
 10100b8:	f800283a 	ret

010100bc <handle_vdev_rsc>:

int handle_vdev_rsc(struct remoteproc *rproc, void *rsc)
{
 10100bc:	defff704 	addi	sp,sp,-36
 10100c0:	dfc00815 	stw	ra,32(sp)
 10100c4:	df000715 	stw	fp,28(sp)
 10100c8:	df000704 	addi	fp,sp,28
 10100cc:	e13ffe15 	stw	r4,-8(fp)
 10100d0:	e17fff15 	stw	r5,-4(fp)
	struct fw_rsc_vdev *vdev_rsc = rsc;
 10100d4:	e0bfff17 	ldw	r2,-4(fp)
 10100d8:	e0bffa15 	stw	r2,-24(fp)
	unsigned int notifyid, i, num_vrings;

	/* only assign notification IDs but do not initialize vdev */
	notifyid = vdev_rsc->notifyid;
 10100dc:	e0bffa17 	ldw	r2,-24(fp)
 10100e0:	10c00203 	ldbu	r3,8(r2)
 10100e4:	11000243 	ldbu	r4,9(r2)
 10100e8:	2008923a 	slli	r4,r4,8
 10100ec:	20c6b03a 	or	r3,r4,r3
 10100f0:	11000283 	ldbu	r4,10(r2)
 10100f4:	2008943a 	slli	r4,r4,16
 10100f8:	20c6b03a 	or	r3,r4,r3
 10100fc:	108002c3 	ldbu	r2,11(r2)
 1010100:	1004963a 	slli	r2,r2,24
 1010104:	10c4b03a 	or	r2,r2,r3
 1010108:	e0bffb15 	stw	r2,-20(fp)
	notifyid = remoteproc_allocate_id(rproc,
 101010c:	e0bffb17 	ldw	r2,-20(fp)
 1010110:	10800044 	addi	r2,r2,1
 1010114:	100d883a 	mov	r6,r2
 1010118:	e17ffb17 	ldw	r5,-20(fp)
 101011c:	e13ffe17 	ldw	r4,-8(fp)
 1010120:	100e7ac0 	call	100e7ac <remoteproc_allocate_id>
 1010124:	e0bffb15 	stw	r2,-20(fp)
					  notifyid, notifyid + 1);
	if (notifyid != RSC_NOTIFY_ID_ANY)
 1010128:	e0bffb17 	ldw	r2,-20(fp)
 101012c:	10bfffe0 	cmpeqi	r2,r2,-1
 1010130:	1000231e 	bne	r2,zero,10101c0 <handle_vdev_rsc+0x104>
		vdev_rsc->notifyid = notifyid;
 1010134:	e0bffa17 	ldw	r2,-24(fp)
 1010138:	e0fffb17 	ldw	r3,-20(fp)
 101013c:	19403fcc 	andi	r5,r3,255
 1010140:	10c00203 	ldbu	r3,8(r2)
 1010144:	1806703a 	and	r3,r3,zero
 1010148:	1809883a 	mov	r4,r3
 101014c:	2807883a 	mov	r3,r5
 1010150:	20c6b03a 	or	r3,r4,r3
 1010154:	10c00205 	stb	r3,8(r2)
 1010158:	e0fffb17 	ldw	r3,-20(fp)
 101015c:	1806d23a 	srli	r3,r3,8
 1010160:	19403fcc 	andi	r5,r3,255
 1010164:	10c00243 	ldbu	r3,9(r2)
 1010168:	1806703a 	and	r3,r3,zero
 101016c:	1809883a 	mov	r4,r3
 1010170:	2807883a 	mov	r3,r5
 1010174:	20c6b03a 	or	r3,r4,r3
 1010178:	10c00245 	stb	r3,9(r2)
 101017c:	e0fffb17 	ldw	r3,-20(fp)
 1010180:	1806d43a 	srli	r3,r3,16
 1010184:	19403fcc 	andi	r5,r3,255
 1010188:	10c00283 	ldbu	r3,10(r2)
 101018c:	1806703a 	and	r3,r3,zero
 1010190:	1809883a 	mov	r4,r3
 1010194:	2807883a 	mov	r3,r5
 1010198:	20c6b03a 	or	r3,r4,r3
 101019c:	10c00285 	stb	r3,10(r2)
 10101a0:	e0fffb17 	ldw	r3,-20(fp)
 10101a4:	180ad63a 	srli	r5,r3,24
 10101a8:	10c002c3 	ldbu	r3,11(r2)
 10101ac:	1806703a 	and	r3,r3,zero
 10101b0:	1809883a 	mov	r4,r3
 10101b4:	2807883a 	mov	r3,r5
 10101b8:	20c6b03a 	or	r3,r4,r3
 10101bc:	10c002c5 	stb	r3,11(r2)

	num_vrings = vdev_rsc->num_of_vrings;
 10101c0:	e0bffa17 	ldw	r2,-24(fp)
 10101c4:	10800643 	ldbu	r2,25(r2)
 10101c8:	10803fcc 	andi	r2,r2,255
 10101cc:	e0bffc15 	stw	r2,-16(fp)
	for (i = 0; i < num_vrings; i++) {
 10101d0:	e03ff915 	stw	zero,-28(fp)
 10101d4:	00004206 	br	10102e0 <handle_vdev_rsc+0x224>
		struct fw_rsc_vdev_vring *vring_rsc;

		vring_rsc = &vdev_rsc->vring[i];
 10101d8:	e0bff917 	ldw	r2,-28(fp)
 10101dc:	10800524 	muli	r2,r2,20
 10101e0:	10800704 	addi	r2,r2,28
 10101e4:	e0fffa17 	ldw	r3,-24(fp)
 10101e8:	1885883a 	add	r2,r3,r2
 10101ec:	e0bffd15 	stw	r2,-12(fp)
		notifyid = vring_rsc->notifyid;
 10101f0:	e0bffd17 	ldw	r2,-12(fp)
 10101f4:	10c00303 	ldbu	r3,12(r2)
 10101f8:	11000343 	ldbu	r4,13(r2)
 10101fc:	2008923a 	slli	r4,r4,8
 1010200:	20c6b03a 	or	r3,r4,r3
 1010204:	11000383 	ldbu	r4,14(r2)
 1010208:	2008943a 	slli	r4,r4,16
 101020c:	20c6b03a 	or	r3,r4,r3
 1010210:	108003c3 	ldbu	r2,15(r2)
 1010214:	1004963a 	slli	r2,r2,24
 1010218:	10c4b03a 	or	r2,r2,r3
 101021c:	e0bffb15 	stw	r2,-20(fp)
		notifyid = remoteproc_allocate_id(rproc,
 1010220:	e0bffb17 	ldw	r2,-20(fp)
 1010224:	10800044 	addi	r2,r2,1
 1010228:	100d883a 	mov	r6,r2
 101022c:	e17ffb17 	ldw	r5,-20(fp)
 1010230:	e13ffe17 	ldw	r4,-8(fp)
 1010234:	100e7ac0 	call	100e7ac <remoteproc_allocate_id>
 1010238:	e0bffb15 	stw	r2,-20(fp)
						  notifyid,
						  notifyid + 1);
		if (notifyid != RSC_NOTIFY_ID_ANY)
 101023c:	e0bffb17 	ldw	r2,-20(fp)
 1010240:	10bfffe0 	cmpeqi	r2,r2,-1
 1010244:	1000231e 	bne	r2,zero,10102d4 <handle_vdev_rsc+0x218>
			vdev_rsc->notifyid = notifyid;
 1010248:	e0bffa17 	ldw	r2,-24(fp)
 101024c:	e0fffb17 	ldw	r3,-20(fp)
 1010250:	19403fcc 	andi	r5,r3,255
 1010254:	10c00203 	ldbu	r3,8(r2)
 1010258:	1806703a 	and	r3,r3,zero
 101025c:	1809883a 	mov	r4,r3
 1010260:	2807883a 	mov	r3,r5
 1010264:	20c6b03a 	or	r3,r4,r3
 1010268:	10c00205 	stb	r3,8(r2)
 101026c:	e0fffb17 	ldw	r3,-20(fp)
 1010270:	1806d23a 	srli	r3,r3,8
 1010274:	19403fcc 	andi	r5,r3,255
 1010278:	10c00243 	ldbu	r3,9(r2)
 101027c:	1806703a 	and	r3,r3,zero
 1010280:	1809883a 	mov	r4,r3
 1010284:	2807883a 	mov	r3,r5
 1010288:	20c6b03a 	or	r3,r4,r3
 101028c:	10c00245 	stb	r3,9(r2)
 1010290:	e0fffb17 	ldw	r3,-20(fp)
 1010294:	1806d43a 	srli	r3,r3,16
 1010298:	19403fcc 	andi	r5,r3,255
 101029c:	10c00283 	ldbu	r3,10(r2)
 10102a0:	1806703a 	and	r3,r3,zero
 10102a4:	1809883a 	mov	r4,r3
 10102a8:	2807883a 	mov	r3,r5
 10102ac:	20c6b03a 	or	r3,r4,r3
 10102b0:	10c00285 	stb	r3,10(r2)
 10102b4:	e0fffb17 	ldw	r3,-20(fp)
 10102b8:	180ad63a 	srli	r5,r3,24
 10102bc:	10c002c3 	ldbu	r3,11(r2)
 10102c0:	1806703a 	and	r3,r3,zero
 10102c4:	1809883a 	mov	r4,r3
 10102c8:	2807883a 	mov	r3,r5
 10102cc:	20c6b03a 	or	r3,r4,r3
 10102d0:	10c002c5 	stb	r3,11(r2)
					  notifyid, notifyid + 1);
	if (notifyid != RSC_NOTIFY_ID_ANY)
		vdev_rsc->notifyid = notifyid;

	num_vrings = vdev_rsc->num_of_vrings;
	for (i = 0; i < num_vrings; i++) {
 10102d4:	e0bff917 	ldw	r2,-28(fp)
 10102d8:	10800044 	addi	r2,r2,1
 10102dc:	e0bff915 	stw	r2,-28(fp)
 10102e0:	e0fff917 	ldw	r3,-28(fp)
 10102e4:	e0bffc17 	ldw	r2,-16(fp)
 10102e8:	18bfbb36 	bltu	r3,r2,10101d8 <__alt_data_end+0xff0101d8>
						  notifyid + 1);
		if (notifyid != RSC_NOTIFY_ID_ANY)
			vdev_rsc->notifyid = notifyid;
	}

	return 0;
 10102ec:	0005883a 	mov	r2,zero
}
 10102f0:	e037883a 	mov	sp,fp
 10102f4:	dfc00117 	ldw	ra,4(sp)
 10102f8:	df000017 	ldw	fp,0(sp)
 10102fc:	dec00204 	addi	sp,sp,8
 1010300:	f800283a 	ret

01010304 <handle_trace_rsc>:
 *
 * @returns - no service error
 *
 */
int handle_trace_rsc(struct remoteproc *rproc, void *rsc)
{
 1010304:	defffc04 	addi	sp,sp,-16
 1010308:	df000315 	stw	fp,12(sp)
 101030c:	df000304 	addi	fp,sp,12
 1010310:	e13ffe15 	stw	r4,-8(fp)
 1010314:	e17fff15 	stw	r5,-4(fp)
	struct fw_rsc_trace *vdev_rsc = rsc;
 1010318:	e0bfff17 	ldw	r2,-4(fp)
 101031c:	e0bffd15 	stw	r2,-12(fp)
	(void)rproc;

	if (vdev_rsc->da != FW_RSC_U32_ADDR_ANY && vdev_rsc->len != 0)
 1010320:	e0bffd17 	ldw	r2,-12(fp)
 1010324:	10c00103 	ldbu	r3,4(r2)
 1010328:	11000143 	ldbu	r4,5(r2)
 101032c:	2008923a 	slli	r4,r4,8
 1010330:	20c6b03a 	or	r3,r4,r3
 1010334:	11000183 	ldbu	r4,6(r2)
 1010338:	2008943a 	slli	r4,r4,16
 101033c:	20c6b03a 	or	r3,r4,r3
 1010340:	108001c3 	ldbu	r2,7(r2)
 1010344:	1004963a 	slli	r2,r2,24
 1010348:	10c4b03a 	or	r2,r2,r3
 101034c:	10bfffe0 	cmpeqi	r2,r2,-1
 1010350:	10000e1e 	bne	r2,zero,101038c <handle_trace_rsc+0x88>
 1010354:	e0bffd17 	ldw	r2,-12(fp)
 1010358:	10c00203 	ldbu	r3,8(r2)
 101035c:	11000243 	ldbu	r4,9(r2)
 1010360:	2008923a 	slli	r4,r4,8
 1010364:	20c6b03a 	or	r3,r4,r3
 1010368:	11000283 	ldbu	r4,10(r2)
 101036c:	2008943a 	slli	r4,r4,16
 1010370:	20c6b03a 	or	r3,r4,r3
 1010374:	108002c3 	ldbu	r2,11(r2)
 1010378:	1004963a 	slli	r2,r2,24
 101037c:	10c4b03a 	or	r2,r2,r3
 1010380:	10000226 	beq	r2,zero,101038c <handle_trace_rsc+0x88>
		return 0;
 1010384:	0005883a 	mov	r2,zero
 1010388:	00000106 	br	1010390 <handle_trace_rsc+0x8c>
	/* FIXME: master should allocated a memory used by slave */

	return -RPROC_ERR_RSC_TAB_NS;
 101038c:	00bffd44 	movi	r2,-11
}
 1010390:	e037883a 	mov	sp,fp
 1010394:	df000017 	ldw	fp,0(sp)
 1010398:	dec00104 	addi	sp,sp,4
 101039c:	f800283a 	ret

010103a0 <handle_dummy_rsc>:
 *
 * @returns - no service error
 *
 */
static int handle_dummy_rsc(struct remoteproc *rproc, void *rsc)
{
 10103a0:	defffd04 	addi	sp,sp,-12
 10103a4:	df000215 	stw	fp,8(sp)
 10103a8:	df000204 	addi	fp,sp,8
 10103ac:	e13ffe15 	stw	r4,-8(fp)
 10103b0:	e17fff15 	stw	r5,-4(fp)
	(void)rproc;
	(void)rsc;

	return -RPROC_ERR_RSC_TAB_NS;
 10103b4:	00bffd44 	movi	r2,-11
}
 10103b8:	e037883a 	mov	sp,fp
 10103bc:	df000017 	ldw	fp,0(sp)
 10103c0:	dec00104 	addi	sp,sp,4
 10103c4:	f800283a 	ret

010103c8 <find_rsc>:

size_t find_rsc(void *rsc_table, unsigned int rsc_type, unsigned int index)
{
 10103c8:	defff604 	addi	sp,sp,-40
 10103cc:	dfc00915 	stw	ra,36(sp)
 10103d0:	df000815 	stw	fp,32(sp)
 10103d4:	df000804 	addi	fp,sp,32
 10103d8:	e13ffd15 	stw	r4,-12(fp)
 10103dc:	e17ffe15 	stw	r5,-8(fp)
 10103e0:	e1bfff15 	stw	r6,-4(fp)
	struct resource_table *r_table = rsc_table;
 10103e4:	e0bffd17 	ldw	r2,-12(fp)
 10103e8:	e0bffa15 	stw	r2,-24(fp)
	unsigned int i, rsc_index;
	unsigned int lrsc_type;
	char *rsc_start;

	metal_assert(r_table);
 10103ec:	e0bffa17 	ldw	r2,-24(fp)
 10103f0:	1000081e 	bne	r2,zero,1010414 <find_rsc+0x4c>
 10103f4:	01c040f4 	movhi	r7,259
 10103f8:	39e75d04 	addi	r7,r7,-25228
 10103fc:	018040f4 	movhi	r6,259
 1010400:	31a76a04 	addi	r6,r6,-25176
 1010404:	014033c4 	movi	r5,207
 1010408:	010040f4 	movhi	r4,259
 101040c:	21275f04 	addi	r4,r4,-25220
 1010410:	10157a00 	call	10157a0 <__assert_func>
	/* Loop through the offset array and parse each resource entry */
	rsc_index = 0;
 1010414:	e03ff915 	stw	zero,-28(fp)
	for (i = 0; i < r_table->num; i++) {
 1010418:	e03ff815 	stw	zero,-32(fp)
 101041c:	00003506 	br	10104f4 <find_rsc+0x12c>
		rsc_start = (char *)r_table;
 1010420:	e0bffa17 	ldw	r2,-24(fp)
 1010424:	e0bffb15 	stw	r2,-20(fp)
		rsc_start += r_table->offset[i];
 1010428:	e0fffa17 	ldw	r3,-24(fp)
 101042c:	e0bff817 	ldw	r2,-32(fp)
 1010430:	10800104 	addi	r2,r2,4
 1010434:	1085883a 	add	r2,r2,r2
 1010438:	1085883a 	add	r2,r2,r2
 101043c:	1885883a 	add	r2,r3,r2
 1010440:	10c00003 	ldbu	r3,0(r2)
 1010444:	11000043 	ldbu	r4,1(r2)
 1010448:	2008923a 	slli	r4,r4,8
 101044c:	20c6b03a 	or	r3,r4,r3
 1010450:	11000083 	ldbu	r4,2(r2)
 1010454:	2008943a 	slli	r4,r4,16
 1010458:	20c6b03a 	or	r3,r4,r3
 101045c:	108000c3 	ldbu	r2,3(r2)
 1010460:	1004963a 	slli	r2,r2,24
 1010464:	10c4b03a 	or	r2,r2,r3
 1010468:	1007883a 	mov	r3,r2
 101046c:	e0bffb17 	ldw	r2,-20(fp)
 1010470:	10c5883a 	add	r2,r2,r3
 1010474:	e0bffb15 	stw	r2,-20(fp)
		lrsc_type = *((uint32_t *)rsc_start);
 1010478:	e0bffb17 	ldw	r2,-20(fp)
 101047c:	10800017 	ldw	r2,0(r2)
 1010480:	e0bffc15 	stw	r2,-16(fp)
		if (lrsc_type == rsc_type) {
 1010484:	e0fffc17 	ldw	r3,-16(fp)
 1010488:	e0bffe17 	ldw	r2,-8(fp)
 101048c:	1880161e 	bne	r3,r2,10104e8 <find_rsc+0x120>
			if (rsc_index++ == index)
 1010490:	e0bff917 	ldw	r2,-28(fp)
 1010494:	10c00044 	addi	r3,r2,1
 1010498:	e0fff915 	stw	r3,-28(fp)
 101049c:	e0ffff17 	ldw	r3,-4(fp)
 10104a0:	10c0111e 	bne	r2,r3,10104e8 <find_rsc+0x120>
				return r_table->offset[i];
 10104a4:	e0fffa17 	ldw	r3,-24(fp)
 10104a8:	e0bff817 	ldw	r2,-32(fp)
 10104ac:	10800104 	addi	r2,r2,4
 10104b0:	1085883a 	add	r2,r2,r2
 10104b4:	1085883a 	add	r2,r2,r2
 10104b8:	1885883a 	add	r2,r3,r2
 10104bc:	10c00003 	ldbu	r3,0(r2)
 10104c0:	11000043 	ldbu	r4,1(r2)
 10104c4:	2008923a 	slli	r4,r4,8
 10104c8:	20c6b03a 	or	r3,r4,r3
 10104cc:	11000083 	ldbu	r4,2(r2)
 10104d0:	2008943a 	slli	r4,r4,16
 10104d4:	20c6b03a 	or	r3,r4,r3
 10104d8:	108000c3 	ldbu	r2,3(r2)
 10104dc:	1004963a 	slli	r2,r2,24
 10104e0:	10c4b03a 	or	r2,r2,r3
 10104e4:	00001206 	br	1010530 <find_rsc+0x168>
	char *rsc_start;

	metal_assert(r_table);
	/* Loop through the offset array and parse each resource entry */
	rsc_index = 0;
	for (i = 0; i < r_table->num; i++) {
 10104e8:	e0bff817 	ldw	r2,-32(fp)
 10104ec:	10800044 	addi	r2,r2,1
 10104f0:	e0bff815 	stw	r2,-32(fp)
 10104f4:	e0bffa17 	ldw	r2,-24(fp)
 10104f8:	10c00103 	ldbu	r3,4(r2)
 10104fc:	11000143 	ldbu	r4,5(r2)
 1010500:	2008923a 	slli	r4,r4,8
 1010504:	20c6b03a 	or	r3,r4,r3
 1010508:	11000183 	ldbu	r4,6(r2)
 101050c:	2008943a 	slli	r4,r4,16
 1010510:	20c6b03a 	or	r3,r4,r3
 1010514:	108001c3 	ldbu	r2,7(r2)
 1010518:	1004963a 	slli	r2,r2,24
 101051c:	10c4b03a 	or	r2,r2,r3
 1010520:	1007883a 	mov	r3,r2
 1010524:	e0bff817 	ldw	r2,-32(fp)
 1010528:	10ffbd36 	bltu	r2,r3,1010420 <__alt_data_end+0xff010420>
		if (lrsc_type == rsc_type) {
			if (rsc_index++ == index)
				return r_table->offset[i];
		}
	}
	return 0;
 101052c:	0005883a 	mov	r2,zero
}
 1010530:	e037883a 	mov	sp,fp
 1010534:	dfc00117 	ldw	ra,4(sp)
 1010538:	df000017 	ldw	fp,0(sp)
 101053c:	dec00204 	addi	sp,sp,8
 1010540:	f800283a 	ret

01010544 <__metal_mutex_acquire>:
{
	return 1 - atomic_flag_test_and_set(&mutex->v);
}

static inline void __metal_mutex_acquire(metal_mutex_t *mutex)
{
 1010544:	defffb04 	addi	sp,sp,-20
 1010548:	df000415 	stw	fp,16(sp)
 101054c:	df000404 	addi	fp,sp,16
 1010550:	e13fff15 	stw	r4,-4(fp)
	while (atomic_flag_test_and_set(&mutex->v)) {
 1010554:	0001883a 	nop
 1010558:	e0bfff17 	ldw	r2,-4(fp)
 101055c:	e0bffc15 	stw	r2,-16(fp)
 1010560:	e0bffc17 	ldw	r2,-16(fp)
 1010564:	10800017 	ldw	r2,0(r2)
 1010568:	e0bffd15 	stw	r2,-12(fp)
 101056c:	00800044 	movi	r2,1
 1010570:	e0bffe15 	stw	r2,-8(fp)
 1010574:	e0bfff17 	ldw	r2,-4(fp)
 1010578:	e0fffe17 	ldw	r3,-8(fp)
 101057c:	10c00015 	stw	r3,0(r2)
 1010580:	e0bffd17 	ldw	r2,-12(fp)
 1010584:	103ff41e 	bne	r2,zero,1010558 <__alt_data_end+0xff010558>
		;
	}
}
 1010588:	0001883a 	nop
 101058c:	e037883a 	mov	sp,fp
 1010590:	df000017 	ldw	fp,0(sp)
 1010594:	dec00104 	addi	sp,sp,4
 1010598:	f800283a 	ret

0101059c <__metal_mutex_release>:

static inline void __metal_mutex_release(metal_mutex_t *mutex)
{
 101059c:	defffe04 	addi	sp,sp,-8
 10105a0:	df000115 	stw	fp,4(sp)
 10105a4:	df000104 	addi	fp,sp,4
 10105a8:	e13fff15 	stw	r4,-4(fp)
	atomic_flag_clear(&mutex->v);
 10105ac:	e0bfff17 	ldw	r2,-4(fp)
 10105b0:	0001b03a 	sync
 10105b4:	10000015 	stw	zero,0(r2)
}
 10105b8:	0001883a 	nop
 10105bc:	e037883a 	mov	sp,fp
 10105c0:	df000017 	ldw	fp,0(sp)
 10105c4:	dec00104 	addi	sp,sp,4
 10105c8:	f800283a 	ret

010105cc <metal_mutex_acquire>:
/**
 * @brief	Acquire a mutex 
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
 10105cc:	defffd04 	addi	sp,sp,-12
 10105d0:	dfc00215 	stw	ra,8(sp)
 10105d4:	df000115 	stw	fp,4(sp)
 10105d8:	df000104 	addi	fp,sp,4
 10105dc:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_acquire(mutex);
 10105e0:	e13fff17 	ldw	r4,-4(fp)
 10105e4:	10105440 	call	1010544 <__metal_mutex_acquire>
}
 10105e8:	0001883a 	nop
 10105ec:	e037883a 	mov	sp,fp
 10105f0:	dfc00117 	ldw	ra,4(sp)
 10105f4:	df000017 	ldw	fp,0(sp)
 10105f8:	dec00204 	addi	sp,sp,8
 10105fc:	f800283a 	ret

01010600 <metal_mutex_release>:
 * @brief	Release a previously acquired mutex.
 * @param[in]	mutex	Mutex to mutex.
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
 1010600:	defffd04 	addi	sp,sp,-12
 1010604:	dfc00215 	stw	ra,8(sp)
 1010608:	df000115 	stw	fp,4(sp)
 101060c:	df000104 	addi	fp,sp,4
 1010610:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_release(mutex);
 1010614:	e13fff17 	ldw	r4,-4(fp)
 1010618:	101059c0 	call	101059c <__metal_mutex_release>
}
 101061c:	0001883a 	nop
 1010620:	e037883a 	mov	sp,fp
 1010624:	dfc00117 	ldw	ra,4(sp)
 1010628:	df000017 	ldw	fp,0(sp)
 101062c:	dec00204 	addi	sp,sp,8
 1010630:	f800283a 	ret

01010634 <metal_list_add_before>:
	list->next = list->prev = list;
}

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
 1010634:	defffd04 	addi	sp,sp,-12
 1010638:	df000215 	stw	fp,8(sp)
 101063c:	df000204 	addi	fp,sp,8
 1010640:	e13ffe15 	stw	r4,-8(fp)
 1010644:	e17fff15 	stw	r5,-4(fp)
	new_node->prev = node->prev;
 1010648:	e0bffe17 	ldw	r2,-8(fp)
 101064c:	10c00117 	ldw	r3,4(r2)
 1010650:	e0bfff17 	ldw	r2,-4(fp)
 1010654:	10c00115 	stw	r3,4(r2)
	new_node->next = node;
 1010658:	e0bfff17 	ldw	r2,-4(fp)
 101065c:	e0fffe17 	ldw	r3,-8(fp)
 1010660:	10c00015 	stw	r3,0(r2)
	new_node->next->prev = new_node;
 1010664:	e0bfff17 	ldw	r2,-4(fp)
 1010668:	10800017 	ldw	r2,0(r2)
 101066c:	e0ffff17 	ldw	r3,-4(fp)
 1010670:	10c00115 	stw	r3,4(r2)
	new_node->prev->next = new_node;
 1010674:	e0bfff17 	ldw	r2,-4(fp)
 1010678:	10800117 	ldw	r2,4(r2)
 101067c:	e0ffff17 	ldw	r3,-4(fp)
 1010680:	10c00015 	stw	r3,0(r2)
}
 1010684:	0001883a 	nop
 1010688:	e037883a 	mov	sp,fp
 101068c:	df000017 	ldw	fp,0(sp)
 1010690:	dec00104 	addi	sp,sp,4
 1010694:	f800283a 	ret

01010698 <metal_list_add_tail>:
	metal_list_add_after(list, node);
}

static inline void metal_list_add_tail(struct metal_list *list,
				       struct metal_list *node)
{
 1010698:	defffc04 	addi	sp,sp,-16
 101069c:	dfc00315 	stw	ra,12(sp)
 10106a0:	df000215 	stw	fp,8(sp)
 10106a4:	df000204 	addi	fp,sp,8
 10106a8:	e13ffe15 	stw	r4,-8(fp)
 10106ac:	e17fff15 	stw	r5,-4(fp)
	metal_list_add_before(list, node);
 10106b0:	e17fff17 	ldw	r5,-4(fp)
 10106b4:	e13ffe17 	ldw	r4,-8(fp)
 10106b8:	10106340 	call	1010634 <metal_list_add_before>
}
 10106bc:	0001883a 	nop
 10106c0:	e037883a 	mov	sp,fp
 10106c4:	dfc00117 	ldw	ra,4(sp)
 10106c8:	df000017 	ldw	fp,0(sp)
 10106cc:	dec00204 	addi	sp,sp,8
 10106d0:	f800283a 	ret

010106d4 <metal_list_del>:
{
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
 10106d4:	defffe04 	addi	sp,sp,-8
 10106d8:	df000115 	stw	fp,4(sp)
 10106dc:	df000104 	addi	fp,sp,4
 10106e0:	e13fff15 	stw	r4,-4(fp)
	node->next->prev = node->prev;
 10106e4:	e0bfff17 	ldw	r2,-4(fp)
 10106e8:	10800017 	ldw	r2,0(r2)
 10106ec:	e0ffff17 	ldw	r3,-4(fp)
 10106f0:	18c00117 	ldw	r3,4(r3)
 10106f4:	10c00115 	stw	r3,4(r2)
	node->prev->next = node->next;
 10106f8:	e0bfff17 	ldw	r2,-4(fp)
 10106fc:	10800117 	ldw	r2,4(r2)
 1010700:	e0ffff17 	ldw	r3,-4(fp)
 1010704:	18c00017 	ldw	r3,0(r3)
 1010708:	10c00015 	stw	r3,0(r2)
	node->next = node->prev = node;
 101070c:	e0bfff17 	ldw	r2,-4(fp)
 1010710:	e0ffff17 	ldw	r3,-4(fp)
 1010714:	10c00115 	stw	r3,4(r2)
 1010718:	e0bfff17 	ldw	r2,-4(fp)
 101071c:	10c00117 	ldw	r3,4(r2)
 1010720:	e0bfff17 	ldw	r2,-4(fp)
 1010724:	10c00015 	stw	r3,0(r2)
}
 1010728:	0001883a 	nop
 101072c:	e037883a 	mov	sp,fp
 1010730:	df000017 	ldw	fp,0(sp)
 1010734:	dec00104 	addi	sp,sp,4
 1010738:	f800283a 	ret

0101073c <metal_bitmap_set_bit>:
#define metal_bit(bit)		(1UL << (bit))

#define metal_bitmap_longs(x)	metal_div_round_up((x), METAL_BITS_PER_ULONG)

static inline void metal_bitmap_set_bit(unsigned long *bitmap, int bit)
{
 101073c:	defffd04 	addi	sp,sp,-12
 1010740:	df000215 	stw	fp,8(sp)
 1010744:	df000204 	addi	fp,sp,8
 1010748:	e13ffe15 	stw	r4,-8(fp)
 101074c:	e17fff15 	stw	r5,-4(fp)
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 1010750:	e0bfff17 	ldw	r2,-4(fp)
 1010754:	1004d17a 	srli	r2,r2,5
 1010758:	1087883a 	add	r3,r2,r2
 101075c:	18c7883a 	add	r3,r3,r3
 1010760:	1809883a 	mov	r4,r3
 1010764:	e0fffe17 	ldw	r3,-8(fp)
 1010768:	1907883a 	add	r3,r3,r4
 101076c:	1085883a 	add	r2,r2,r2
 1010770:	1085883a 	add	r2,r2,r2
 1010774:	1009883a 	mov	r4,r2
 1010778:	e0bffe17 	ldw	r2,-8(fp)
 101077c:	1105883a 	add	r2,r2,r4
 1010780:	11000017 	ldw	r4,0(r2)
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 1010784:	e0bfff17 	ldw	r2,-4(fp)
 1010788:	108007cc 	andi	r2,r2,31
 101078c:	01400044 	movi	r5,1
 1010790:	2884983a 	sll	r2,r5,r2

#define metal_bitmap_longs(x)	metal_div_round_up((x), METAL_BITS_PER_ULONG)

static inline void metal_bitmap_set_bit(unsigned long *bitmap, int bit)
{
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 1010794:	2084b03a 	or	r2,r4,r2
 1010798:	18800015 	stw	r2,0(r3)
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}
 101079c:	0001883a 	nop
 10107a0:	e037883a 	mov	sp,fp
 10107a4:	df000017 	ldw	fp,0(sp)
 10107a8:	dec00104 	addi	sp,sp,4
 10107ac:	f800283a 	ret

010107b0 <metal_bitmap_is_bit_set>:

static inline int metal_bitmap_is_bit_set(unsigned long *bitmap, int bit)
{
 10107b0:	defffd04 	addi	sp,sp,-12
 10107b4:	df000215 	stw	fp,8(sp)
 10107b8:	df000204 	addi	fp,sp,8
 10107bc:	e13ffe15 	stw	r4,-8(fp)
 10107c0:	e17fff15 	stw	r5,-4(fp)
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
 10107c4:	e0bfff17 	ldw	r2,-4(fp)
 10107c8:	1004d17a 	srli	r2,r2,5
 10107cc:	1085883a 	add	r2,r2,r2
 10107d0:	1085883a 	add	r2,r2,r2
 10107d4:	1007883a 	mov	r3,r2
 10107d8:	e0bffe17 	ldw	r2,-8(fp)
 10107dc:	10c5883a 	add	r2,r2,r3
 10107e0:	10c00017 	ldw	r3,0(r2)
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
 10107e4:	e0bfff17 	ldw	r2,-4(fp)
 10107e8:	108007cc 	andi	r2,r2,31
 10107ec:	1884d83a 	srl	r2,r3,r2
 10107f0:	1080004c 	andi	r2,r2,1
 10107f4:	1004c03a 	cmpne	r2,r2,zero
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}

static inline int metal_bitmap_is_bit_set(unsigned long *bitmap, int bit)
{
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
 10107f8:	10803fcc 	andi	r2,r2,255
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
}
 10107fc:	e037883a 	mov	sp,fp
 1010800:	df000017 	ldw	fp,0(sp)
 1010804:	dec00104 	addi	sp,sp,4
 1010808:	f800283a 	ret

0101080c <metal_bitmap_clear_bit>:

static inline void metal_bitmap_clear_bit(unsigned long *bitmap, int bit)
{
 101080c:	defffd04 	addi	sp,sp,-12
 1010810:	df000215 	stw	fp,8(sp)
 1010814:	df000204 	addi	fp,sp,8
 1010818:	e13ffe15 	stw	r4,-8(fp)
 101081c:	e17fff15 	stw	r5,-4(fp)
	bitmap[bit / METAL_BITS_PER_ULONG] &=
 1010820:	e0bfff17 	ldw	r2,-4(fp)
 1010824:	1004d17a 	srli	r2,r2,5
 1010828:	1087883a 	add	r3,r2,r2
 101082c:	18c7883a 	add	r3,r3,r3
 1010830:	1809883a 	mov	r4,r3
 1010834:	e0fffe17 	ldw	r3,-8(fp)
 1010838:	1907883a 	add	r3,r3,r4
 101083c:	1085883a 	add	r2,r2,r2
 1010840:	1085883a 	add	r2,r2,r2
 1010844:	1009883a 	mov	r4,r2
 1010848:	e0bffe17 	ldw	r2,-8(fp)
 101084c:	1105883a 	add	r2,r2,r4
 1010850:	11000017 	ldw	r4,0(r2)
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 1010854:	e0bfff17 	ldw	r2,-4(fp)
 1010858:	108007cc 	andi	r2,r2,31
 101085c:	01400044 	movi	r5,1
 1010860:	2884983a 	sll	r2,r5,r2
 1010864:	0084303a 	nor	r2,zero,r2
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
}

static inline void metal_bitmap_clear_bit(unsigned long *bitmap, int bit)
{
	bitmap[bit / METAL_BITS_PER_ULONG] &=
 1010868:	2084703a 	and	r2,r4,r2
 101086c:	18800015 	stw	r2,0(r3)
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}
 1010870:	0001883a 	nop
 1010874:	e037883a 	mov	sp,fp
 1010878:	df000017 	ldw	fp,0(sp)
 101087c:	dec00104 	addi	sp,sp,4
 1010880:	f800283a 	ret

01010884 <metal_bitmap_is_bit_clear>:

static inline int metal_bitmap_is_bit_clear(unsigned long *bitmap, int bit)
{
 1010884:	defffc04 	addi	sp,sp,-16
 1010888:	dfc00315 	stw	ra,12(sp)
 101088c:	df000215 	stw	fp,8(sp)
 1010890:	df000204 	addi	fp,sp,8
 1010894:	e13ffe15 	stw	r4,-8(fp)
 1010898:	e17fff15 	stw	r5,-4(fp)
	return !metal_bitmap_is_bit_set(bitmap, bit);
 101089c:	e17fff17 	ldw	r5,-4(fp)
 10108a0:	e13ffe17 	ldw	r4,-8(fp)
 10108a4:	10107b00 	call	10107b0 <metal_bitmap_is_bit_set>
 10108a8:	1005003a 	cmpeq	r2,r2,zero
 10108ac:	10803fcc 	andi	r2,r2,255
}
 10108b0:	e037883a 	mov	sp,fp
 10108b4:	dfc00117 	ldw	ra,4(sp)
 10108b8:	df000017 	ldw	fp,0(sp)
 10108bc:	dec00204 	addi	sp,sp,8
 10108c0:	f800283a 	ret

010108c4 <metal_bitmap_next_clear_bit>:
	     (bit) = metal_bitmap_next_set_bit((bitmap), (bit + 1), (max)))

static inline unsigned int
metal_bitmap_next_clear_bit(unsigned long *bitmap, unsigned int start,
			    unsigned int max)
{
 10108c4:	defffa04 	addi	sp,sp,-24
 10108c8:	dfc00515 	stw	ra,20(sp)
 10108cc:	df000415 	stw	fp,16(sp)
 10108d0:	df000404 	addi	fp,sp,16
 10108d4:	e13ffd15 	stw	r4,-12(fp)
 10108d8:	e17ffe15 	stw	r5,-8(fp)
 10108dc:	e1bfff15 	stw	r6,-4(fp)
	unsigned int bit;
	for (bit = start;
 10108e0:	e0bffe17 	ldw	r2,-8(fp)
 10108e4:	e0bffc15 	stw	r2,-16(fp)
 10108e8:	00000306 	br	10108f8 <metal_bitmap_next_clear_bit+0x34>
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
	     bit ++)
 10108ec:	e0bffc17 	ldw	r2,-16(fp)
 10108f0:	10800044 	addi	r2,r2,1
 10108f4:	e0bffc15 	stw	r2,-16(fp)
static inline unsigned int
metal_bitmap_next_clear_bit(unsigned long *bitmap, unsigned int start,
			    unsigned int max)
{
	unsigned int bit;
	for (bit = start;
 10108f8:	e0fffc17 	ldw	r3,-16(fp)
 10108fc:	e0bfff17 	ldw	r2,-4(fp)
 1010900:	1880052e 	bgeu	r3,r2,1010918 <metal_bitmap_next_clear_bit+0x54>
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
 1010904:	e0bffc17 	ldw	r2,-16(fp)
 1010908:	100b883a 	mov	r5,r2
 101090c:	e13ffd17 	ldw	r4,-12(fp)
 1010910:	10108840 	call	1010884 <metal_bitmap_is_bit_clear>
 1010914:	103ff526 	beq	r2,zero,10108ec <__alt_data_end+0xff0108ec>
	     bit ++)
		;
	return bit;
 1010918:	e0bffc17 	ldw	r2,-16(fp)
}
 101091c:	e037883a 	mov	sp,fp
 1010920:	dfc00117 	ldw	ra,4(sp)
 1010924:	df000017 	ldw	fp,0(sp)
 1010928:	dec00204 	addi	sp,sp,8
 101092c:	f800283a 	ret

01010930 <rpmsg_init_ept>:
static inline void rpmsg_init_ept(struct rpmsg_endpoint *ept,
				  const char *name,
				  uint32_t src, uint32_t dest,
				  rpmsg_ept_cb cb,
				  rpmsg_ns_unbind_cb ns_unbind_cb)
{
 1010930:	defffa04 	addi	sp,sp,-24
 1010934:	dfc00515 	stw	ra,20(sp)
 1010938:	df000415 	stw	fp,16(sp)
 101093c:	df000404 	addi	fp,sp,16
 1010940:	e13ffc15 	stw	r4,-16(fp)
 1010944:	e17ffd15 	stw	r5,-12(fp)
 1010948:	e1bffe15 	stw	r6,-8(fp)
 101094c:	e1ffff15 	stw	r7,-4(fp)
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
 1010950:	e0fffc17 	ldw	r3,-16(fp)
 1010954:	e0bffd17 	ldw	r2,-12(fp)
 1010958:	10000226 	beq	r2,zero,1010964 <rpmsg_init_ept+0x34>
 101095c:	e0bffd17 	ldw	r2,-12(fp)
 1010960:	00000206 	br	101096c <rpmsg_init_ept+0x3c>
 1010964:	008040f4 	movhi	r2,259
 1010968:	10a76d04 	addi	r2,r2,-25164
 101096c:	01800804 	movi	r6,32
 1010970:	100b883a 	mov	r5,r2
 1010974:	1809883a 	mov	r4,r3
 1010978:	101671c0 	call	101671c <strncpy>
	ept->addr = src;
 101097c:	e0bffc17 	ldw	r2,-16(fp)
 1010980:	e0fffe17 	ldw	r3,-8(fp)
 1010984:	10c00915 	stw	r3,36(r2)
	ept->dest_addr = dest;
 1010988:	e0bffc17 	ldw	r2,-16(fp)
 101098c:	e0ffff17 	ldw	r3,-4(fp)
 1010990:	10c00a15 	stw	r3,40(r2)
	ept->cb = cb;
 1010994:	e0bffc17 	ldw	r2,-16(fp)
 1010998:	e0c00217 	ldw	r3,8(fp)
 101099c:	10c00b15 	stw	r3,44(r2)
	ept->ns_unbind_cb = ns_unbind_cb;
 10109a0:	e0bffc17 	ldw	r2,-16(fp)
 10109a4:	e0c00317 	ldw	r3,12(fp)
 10109a8:	10c00c15 	stw	r3,48(r2)
}
 10109ac:	0001883a 	nop
 10109b0:	e037883a 	mov	sp,fp
 10109b4:	dfc00117 	ldw	ra,4(sp)
 10109b8:	df000017 	ldw	fp,0(sp)
 10109bc:	dec00204 	addi	sp,sp,8
 10109c0:	f800283a 	ret

010109c4 <rpmsg_get_address>:
 * @param size   - size of bitmap
 *
 * return - a unique address
 */
static uint32_t rpmsg_get_address(unsigned long *bitmap, int size)
{
 10109c4:	defffa04 	addi	sp,sp,-24
 10109c8:	dfc00515 	stw	ra,20(sp)
 10109cc:	df000415 	stw	fp,16(sp)
 10109d0:	df000404 	addi	fp,sp,16
 10109d4:	e13ffe15 	stw	r4,-8(fp)
 10109d8:	e17fff15 	stw	r5,-4(fp)
	unsigned int addr = RPMSG_ADDR_ANY;
 10109dc:	00bfffc4 	movi	r2,-1
 10109e0:	e0bffc15 	stw	r2,-16(fp)
	unsigned int nextbit;

	nextbit = metal_bitmap_next_clear_bit(bitmap, 0, size);
 10109e4:	e0bfff17 	ldw	r2,-4(fp)
 10109e8:	100d883a 	mov	r6,r2
 10109ec:	000b883a 	mov	r5,zero
 10109f0:	e13ffe17 	ldw	r4,-8(fp)
 10109f4:	10108c40 	call	10108c4 <metal_bitmap_next_clear_bit>
 10109f8:	e0bffd15 	stw	r2,-12(fp)
	if (nextbit < (uint32_t)size) {
 10109fc:	e0bfff17 	ldw	r2,-4(fp)
 1010a00:	e0fffd17 	ldw	r3,-12(fp)
 1010a04:	1880062e 	bgeu	r3,r2,1010a20 <rpmsg_get_address+0x5c>
		addr = nextbit;
 1010a08:	e0bffd17 	ldw	r2,-12(fp)
 1010a0c:	e0bffc15 	stw	r2,-16(fp)
		metal_bitmap_set_bit(bitmap, nextbit);
 1010a10:	e0bffd17 	ldw	r2,-12(fp)
 1010a14:	100b883a 	mov	r5,r2
 1010a18:	e13ffe17 	ldw	r4,-8(fp)
 1010a1c:	101073c0 	call	101073c <metal_bitmap_set_bit>
	}

	return addr;
 1010a20:	e0bffc17 	ldw	r2,-16(fp)
}
 1010a24:	e037883a 	mov	sp,fp
 1010a28:	dfc00117 	ldw	ra,4(sp)
 1010a2c:	df000017 	ldw	fp,0(sp)
 1010a30:	dec00204 	addi	sp,sp,8
 1010a34:	f800283a 	ret

01010a38 <rpmsg_release_address>:
 * @param size   - size of bitmap
 * @param addr   - address to free
 */
static void rpmsg_release_address(unsigned long *bitmap, int size,
				  int addr)
{
 1010a38:	defffb04 	addi	sp,sp,-20
 1010a3c:	dfc00415 	stw	ra,16(sp)
 1010a40:	df000315 	stw	fp,12(sp)
 1010a44:	df000304 	addi	fp,sp,12
 1010a48:	e13ffd15 	stw	r4,-12(fp)
 1010a4c:	e17ffe15 	stw	r5,-8(fp)
 1010a50:	e1bfff15 	stw	r6,-4(fp)
	if (addr < size)
 1010a54:	e0ffff17 	ldw	r3,-4(fp)
 1010a58:	e0bffe17 	ldw	r2,-8(fp)
 1010a5c:	1880030e 	bge	r3,r2,1010a6c <rpmsg_release_address+0x34>
		metal_bitmap_clear_bit(bitmap, addr);
 1010a60:	e17fff17 	ldw	r5,-4(fp)
 1010a64:	e13ffd17 	ldw	r4,-12(fp)
 1010a68:	101080c0 	call	101080c <metal_bitmap_clear_bit>
}
 1010a6c:	0001883a 	nop
 1010a70:	e037883a 	mov	sp,fp
 1010a74:	dfc00117 	ldw	ra,4(sp)
 1010a78:	df000017 	ldw	fp,0(sp)
 1010a7c:	dec00204 	addi	sp,sp,8
 1010a80:	f800283a 	ret

01010a84 <rpmsg_is_address_set>:
 * @param addr   - address to free
 *
 * return - TRUE/FALSE
 */
static int rpmsg_is_address_set(unsigned long *bitmap, int size, int addr)
{
 1010a84:	defffb04 	addi	sp,sp,-20
 1010a88:	dfc00415 	stw	ra,16(sp)
 1010a8c:	df000315 	stw	fp,12(sp)
 1010a90:	df000304 	addi	fp,sp,12
 1010a94:	e13ffd15 	stw	r4,-12(fp)
 1010a98:	e17ffe15 	stw	r5,-8(fp)
 1010a9c:	e1bfff15 	stw	r6,-4(fp)
	if (addr < size)
 1010aa0:	e0ffff17 	ldw	r3,-4(fp)
 1010aa4:	e0bffe17 	ldw	r2,-8(fp)
 1010aa8:	1880040e 	bge	r3,r2,1010abc <rpmsg_is_address_set+0x38>
		return metal_bitmap_is_bit_set(bitmap, addr);
 1010aac:	e17fff17 	ldw	r5,-4(fp)
 1010ab0:	e13ffd17 	ldw	r4,-12(fp)
 1010ab4:	10107b00 	call	10107b0 <metal_bitmap_is_bit_set>
 1010ab8:	00000106 	br	1010ac0 <rpmsg_is_address_set+0x3c>
	else
		return RPMSG_ERR_PARAM;
 1010abc:	00be0b44 	movi	r2,-2003
}
 1010ac0:	e037883a 	mov	sp,fp
 1010ac4:	dfc00117 	ldw	ra,4(sp)
 1010ac8:	df000017 	ldw	fp,0(sp)
 1010acc:	dec00204 	addi	sp,sp,8
 1010ad0:	f800283a 	ret

01010ad4 <rpmsg_set_address>:
 * @param addr   - address to free
 *
 * return - none
 */
static int rpmsg_set_address(unsigned long *bitmap, int size, int addr)
{
 1010ad4:	defffb04 	addi	sp,sp,-20
 1010ad8:	dfc00415 	stw	ra,16(sp)
 1010adc:	df000315 	stw	fp,12(sp)
 1010ae0:	df000304 	addi	fp,sp,12
 1010ae4:	e13ffd15 	stw	r4,-12(fp)
 1010ae8:	e17ffe15 	stw	r5,-8(fp)
 1010aec:	e1bfff15 	stw	r6,-4(fp)
	if (addr < size) {
 1010af0:	e0ffff17 	ldw	r3,-4(fp)
 1010af4:	e0bffe17 	ldw	r2,-8(fp)
 1010af8:	1880050e 	bge	r3,r2,1010b10 <rpmsg_set_address+0x3c>
		metal_bitmap_set_bit(bitmap, addr);
 1010afc:	e17fff17 	ldw	r5,-4(fp)
 1010b00:	e13ffd17 	ldw	r4,-12(fp)
 1010b04:	101073c0 	call	101073c <metal_bitmap_set_bit>
		return RPMSG_SUCCESS;
 1010b08:	0005883a 	mov	r2,zero
 1010b0c:	00000106 	br	1010b14 <rpmsg_set_address+0x40>
	} else {
		return RPMSG_ERR_PARAM;
 1010b10:	00be0b44 	movi	r2,-2003
	}
}
 1010b14:	e037883a 	mov	sp,fp
 1010b18:	dfc00117 	ldw	ra,4(sp)
 1010b1c:	df000017 	ldw	fp,0(sp)
 1010b20:	dec00204 	addi	sp,sp,8
 1010b24:	f800283a 	ret

01010b28 <rpmsg_send_offchannel_raw>:
 *
 */
int rpmsg_send_offchannel_raw(struct rpmsg_endpoint *ept, uint32_t src,
			      uint32_t dst, const void *data, int size,
			      int wait)
{
 1010b28:	defff704 	addi	sp,sp,-36
 1010b2c:	dfc00815 	stw	ra,32(sp)
 1010b30:	df000715 	stw	fp,28(sp)
 1010b34:	df000704 	addi	fp,sp,28
 1010b38:	e13ffc15 	stw	r4,-16(fp)
 1010b3c:	e17ffd15 	stw	r5,-12(fp)
 1010b40:	e1bffe15 	stw	r6,-8(fp)
 1010b44:	e1ffff15 	stw	r7,-4(fp)
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
 1010b48:	e0bffc17 	ldw	r2,-16(fp)
 1010b4c:	10000826 	beq	r2,zero,1010b70 <rpmsg_send_offchannel_raw+0x48>
 1010b50:	e0bffc17 	ldw	r2,-16(fp)
 1010b54:	10800817 	ldw	r2,32(r2)
 1010b58:	10000526 	beq	r2,zero,1010b70 <rpmsg_send_offchannel_raw+0x48>
 1010b5c:	e0bfff17 	ldw	r2,-4(fp)
 1010b60:	10000326 	beq	r2,zero,1010b70 <rpmsg_send_offchannel_raw+0x48>
 1010b64:	e0bffe17 	ldw	r2,-8(fp)
 1010b68:	10bfffd8 	cmpnei	r2,r2,-1
 1010b6c:	1000021e 	bne	r2,zero,1010b78 <rpmsg_send_offchannel_raw+0x50>
		return RPMSG_ERR_PARAM;
 1010b70:	00be0b44 	movi	r2,-2003
 1010b74:	00001306 	br	1010bc4 <rpmsg_send_offchannel_raw+0x9c>

	rdev = ept->rdev;
 1010b78:	e0bffc17 	ldw	r2,-16(fp)
 1010b7c:	10800817 	ldw	r2,32(r2)
 1010b80:	e0bffb15 	stw	r2,-20(fp)

	if (rdev->ops.send_offchannel_raw)
 1010b84:	e0bffb17 	ldw	r2,-20(fp)
 1010b88:	10801817 	ldw	r2,96(r2)
 1010b8c:	10000c26 	beq	r2,zero,1010bc0 <rpmsg_send_offchannel_raw+0x98>
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
 1010b90:	e0bffb17 	ldw	r2,-20(fp)
 1010b94:	10801817 	ldw	r2,96(r2)
 1010b98:	e0c00317 	ldw	r3,12(fp)
 1010b9c:	d8c00115 	stw	r3,4(sp)
 1010ba0:	e0c00217 	ldw	r3,8(fp)
 1010ba4:	d8c00015 	stw	r3,0(sp)
 1010ba8:	e1ffff17 	ldw	r7,-4(fp)
 1010bac:	e1bffe17 	ldw	r6,-8(fp)
 1010bb0:	e17ffd17 	ldw	r5,-12(fp)
 1010bb4:	e13ffb17 	ldw	r4,-20(fp)
 1010bb8:	103ee83a 	callr	r2
 1010bbc:	00000106 	br	1010bc4 <rpmsg_send_offchannel_raw+0x9c>
						      size, wait);

	return RPMSG_ERR_PARAM;
 1010bc0:	00be0b44 	movi	r2,-2003
}
 1010bc4:	e037883a 	mov	sp,fp
 1010bc8:	dfc00117 	ldw	ra,4(sp)
 1010bcc:	df000017 	ldw	fp,0(sp)
 1010bd0:	dec00204 	addi	sp,sp,8
 1010bd4:	f800283a 	ret

01010bd8 <rpmsg_send_ns_message>:

int rpmsg_send_ns_message(struct rpmsg_endpoint *ept, unsigned long flags)
{
 1010bd8:	deffef04 	addi	sp,sp,-68
 1010bdc:	dfc01015 	stw	ra,64(sp)
 1010be0:	df000f15 	stw	fp,60(sp)
 1010be4:	df000f04 	addi	fp,sp,60
 1010be8:	e13ffe15 	stw	r4,-8(fp)
 1010bec:	e17fff15 	stw	r5,-4(fp)
	struct rpmsg_ns_msg ns_msg;
	int ret;

	ns_msg.flags = flags;
 1010bf0:	e0bfff17 	ldw	r2,-4(fp)
 1010bf4:	e0bffd15 	stw	r2,-12(fp)
	ns_msg.addr = ept->addr;
 1010bf8:	e0bffe17 	ldw	r2,-8(fp)
 1010bfc:	10800917 	ldw	r2,36(r2)
 1010c00:	e0bffc15 	stw	r2,-16(fp)
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
 1010c04:	e0fffe17 	ldw	r3,-8(fp)
 1010c08:	e0bff404 	addi	r2,fp,-48
 1010c0c:	01800804 	movi	r6,32
 1010c10:	180b883a 	mov	r5,r3
 1010c14:	1009883a 	mov	r4,r2
 1010c18:	101671c0 	call	101671c <strncpy>
	ret = rpmsg_send_offchannel_raw(ept, ept->addr,
 1010c1c:	e0bffe17 	ldw	r2,-8(fp)
 1010c20:	10c00917 	ldw	r3,36(r2)
 1010c24:	e13ff404 	addi	r4,fp,-48
 1010c28:	00800044 	movi	r2,1
 1010c2c:	d8800115 	stw	r2,4(sp)
 1010c30:	00800a04 	movi	r2,40
 1010c34:	d8800015 	stw	r2,0(sp)
 1010c38:	200f883a 	mov	r7,r4
 1010c3c:	01800d44 	movi	r6,53
 1010c40:	180b883a 	mov	r5,r3
 1010c44:	e13ffe17 	ldw	r4,-8(fp)
 1010c48:	1010b280 	call	1010b28 <rpmsg_send_offchannel_raw>
 1010c4c:	e0bff315 	stw	r2,-52(fp)
					RPMSG_NS_EPT_ADDR,
					&ns_msg, sizeof(ns_msg), true);
	if (ret < 0)
 1010c50:	e0bff317 	ldw	r2,-52(fp)
 1010c54:	1000020e 	bge	r2,zero,1010c60 <rpmsg_send_ns_message+0x88>
		return ret;
 1010c58:	e0bff317 	ldw	r2,-52(fp)
 1010c5c:	00000106 	br	1010c64 <rpmsg_send_ns_message+0x8c>
	else
		return RPMSG_SUCCESS;
 1010c60:	0005883a 	mov	r2,zero
}
 1010c64:	e037883a 	mov	sp,fp
 1010c68:	dfc00117 	ldw	ra,4(sp)
 1010c6c:	df000017 	ldw	fp,0(sp)
 1010c70:	dec00204 	addi	sp,sp,8
 1010c74:	f800283a 	ret

01010c78 <rpmsg_get_endpoint>:

struct rpmsg_endpoint *rpmsg_get_endpoint(struct rpmsg_device *rdev,
					  const char *name, uint32_t addr,
					  uint32_t dest_addr)
{
 1010c78:	defff704 	addi	sp,sp,-36
 1010c7c:	dfc00815 	stw	ra,32(sp)
 1010c80:	df000715 	stw	fp,28(sp)
 1010c84:	df000704 	addi	fp,sp,28
 1010c88:	e13ffc15 	stw	r4,-16(fp)
 1010c8c:	e17ffd15 	stw	r5,-12(fp)
 1010c90:	e1bffe15 	stw	r6,-8(fp)
 1010c94:	e1ffff15 	stw	r7,-4(fp)
	struct metal_list *node;
	struct rpmsg_endpoint *ept;

	metal_list_for_each(&rdev->endpoints, node) {
 1010c98:	e0bffc17 	ldw	r2,-16(fp)
 1010c9c:	10800017 	ldw	r2,0(r2)
 1010ca0:	e0bff915 	stw	r2,-28(fp)
 1010ca4:	00003b06 	br	1010d94 <rpmsg_get_endpoint+0x11c>
		int name_match = 0;
 1010ca8:	e03ffa15 	stw	zero,-24(fp)

		ept = metal_container_of(node, struct rpmsg_endpoint, node);
 1010cac:	e0bff917 	ldw	r2,-28(fp)
 1010cb0:	10bff304 	addi	r2,r2,-52
 1010cb4:	e0bffb15 	stw	r2,-20(fp)
		/* try to get by local address only */
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
 1010cb8:	e0bffe17 	ldw	r2,-8(fp)
 1010cbc:	10bfffe0 	cmpeqi	r2,r2,-1
 1010cc0:	1000061e 	bne	r2,zero,1010cdc <rpmsg_get_endpoint+0x64>
 1010cc4:	e0bffb17 	ldw	r2,-20(fp)
 1010cc8:	10c00917 	ldw	r3,36(r2)
 1010ccc:	e0bffe17 	ldw	r2,-8(fp)
 1010cd0:	1880021e 	bne	r3,r2,1010cdc <rpmsg_get_endpoint+0x64>
			return ept;
 1010cd4:	e0bffb17 	ldw	r2,-20(fp)
 1010cd8:	00003206 	br	1010da4 <rpmsg_get_endpoint+0x12c>
		/* try to find match on local end remote address */
		if (addr == ept->addr && dest_addr == ept->dest_addr)
 1010cdc:	e0bffb17 	ldw	r2,-20(fp)
 1010ce0:	10c00917 	ldw	r3,36(r2)
 1010ce4:	e0bffe17 	ldw	r2,-8(fp)
 1010ce8:	1880061e 	bne	r3,r2,1010d04 <rpmsg_get_endpoint+0x8c>
 1010cec:	e0bffb17 	ldw	r2,-20(fp)
 1010cf0:	10c00a17 	ldw	r3,40(r2)
 1010cf4:	e0bfff17 	ldw	r2,-4(fp)
 1010cf8:	1880021e 	bne	r3,r2,1010d04 <rpmsg_get_endpoint+0x8c>
			return ept;
 1010cfc:	e0bffb17 	ldw	r2,-20(fp)
 1010d00:	00002806 	br	1010da4 <rpmsg_get_endpoint+0x12c>
		/* else use name service and destination address */
		if (name)
 1010d04:	e0bffd17 	ldw	r2,-12(fp)
 1010d08:	10000826 	beq	r2,zero,1010d2c <rpmsg_get_endpoint+0xb4>
			name_match = !strncmp(ept->name, name,
 1010d0c:	e0bffb17 	ldw	r2,-20(fp)
 1010d10:	01800804 	movi	r6,32
 1010d14:	e17ffd17 	ldw	r5,-12(fp)
 1010d18:	1009883a 	mov	r4,r2
 1010d1c:	101664c0 	call	101664c <strncmp>
 1010d20:	1005003a 	cmpeq	r2,r2,zero
 1010d24:	10803fcc 	andi	r2,r2,255
 1010d28:	e0bffa15 	stw	r2,-24(fp)
					      sizeof(ept->name));
		if (!name || !name_match)
 1010d2c:	e0bffd17 	ldw	r2,-12(fp)
 1010d30:	10001426 	beq	r2,zero,1010d84 <rpmsg_get_endpoint+0x10c>
 1010d34:	e0bffa17 	ldw	r2,-24(fp)
 1010d38:	10001226 	beq	r2,zero,1010d84 <rpmsg_get_endpoint+0x10c>
			continue;
		/* destination address is known, equal to ept remote address */
		if (dest_addr != RPMSG_ADDR_ANY && ept->dest_addr == dest_addr)
 1010d3c:	e0bfff17 	ldw	r2,-4(fp)
 1010d40:	10bfffe0 	cmpeqi	r2,r2,-1
 1010d44:	1000061e 	bne	r2,zero,1010d60 <rpmsg_get_endpoint+0xe8>
 1010d48:	e0bffb17 	ldw	r2,-20(fp)
 1010d4c:	10c00a17 	ldw	r3,40(r2)
 1010d50:	e0bfff17 	ldw	r2,-4(fp)
 1010d54:	1880021e 	bne	r3,r2,1010d60 <rpmsg_get_endpoint+0xe8>
			return ept;
 1010d58:	e0bffb17 	ldw	r2,-20(fp)
 1010d5c:	00001106 	br	1010da4 <rpmsg_get_endpoint+0x12c>
		/* ept is registered but not associated to remote ept */
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
 1010d60:	e0bffe17 	ldw	r2,-8(fp)
 1010d64:	10bfffd8 	cmpnei	r2,r2,-1
 1010d68:	1000071e 	bne	r2,zero,1010d88 <rpmsg_get_endpoint+0x110>
 1010d6c:	e0bffb17 	ldw	r2,-20(fp)
 1010d70:	10800a17 	ldw	r2,40(r2)
 1010d74:	10bfffd8 	cmpnei	r2,r2,-1
 1010d78:	1000031e 	bne	r2,zero,1010d88 <rpmsg_get_endpoint+0x110>
			return ept;
 1010d7c:	e0bffb17 	ldw	r2,-20(fp)
 1010d80:	00000806 	br	1010da4 <rpmsg_get_endpoint+0x12c>
		/* else use name service and destination address */
		if (name)
			name_match = !strncmp(ept->name, name,
					      sizeof(ept->name));
		if (!name || !name_match)
			continue;
 1010d84:	0001883a 	nop
					  uint32_t dest_addr)
{
	struct metal_list *node;
	struct rpmsg_endpoint *ept;

	metal_list_for_each(&rdev->endpoints, node) {
 1010d88:	e0bff917 	ldw	r2,-28(fp)
 1010d8c:	10800017 	ldw	r2,0(r2)
 1010d90:	e0bff915 	stw	r2,-28(fp)
 1010d94:	e0fffc17 	ldw	r3,-16(fp)
 1010d98:	e0bff917 	ldw	r2,-28(fp)
 1010d9c:	18bfc21e 	bne	r3,r2,1010ca8 <__alt_data_end+0xff010ca8>
			return ept;
		/* ept is registered but not associated to remote ept */
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
			return ept;
	}
	return NULL;
 1010da0:	0005883a 	mov	r2,zero
}
 1010da4:	e037883a 	mov	sp,fp
 1010da8:	dfc00117 	ldw	ra,4(sp)
 1010dac:	df000017 	ldw	fp,0(sp)
 1010db0:	dec00204 	addi	sp,sp,8
 1010db4:	f800283a 	ret

01010db8 <rpmsg_unregister_endpoint>:

static void rpmsg_unregister_endpoint(struct rpmsg_endpoint *ept)
{
 1010db8:	defffc04 	addi	sp,sp,-16
 1010dbc:	dfc00315 	stw	ra,12(sp)
 1010dc0:	df000215 	stw	fp,8(sp)
 1010dc4:	df000204 	addi	fp,sp,8
 1010dc8:	e13fff15 	stw	r4,-4(fp)
	struct rpmsg_device *rdev;

	if (!ept)
 1010dcc:	e0bfff17 	ldw	r2,-4(fp)
 1010dd0:	10001426 	beq	r2,zero,1010e24 <rpmsg_unregister_endpoint+0x6c>
		return;

	rdev = ept->rdev;
 1010dd4:	e0bfff17 	ldw	r2,-4(fp)
 1010dd8:	10800817 	ldw	r2,32(r2)
 1010ddc:	e0bffe15 	stw	r2,-8(fp)

	if (ept->addr != RPMSG_ADDR_ANY)
 1010de0:	e0bfff17 	ldw	r2,-4(fp)
 1010de4:	10800917 	ldw	r2,36(r2)
 1010de8:	10bfffe0 	cmpeqi	r2,r2,-1
 1010dec:	1000081e 	bne	r2,zero,1010e10 <rpmsg_unregister_endpoint+0x58>
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
 1010df0:	e0bffe17 	ldw	r2,-8(fp)
 1010df4:	10c01204 	addi	r3,r2,72
				      ept->addr);
 1010df8:	e0bfff17 	ldw	r2,-4(fp)
 1010dfc:	10800917 	ldw	r2,36(r2)
		return;

	rdev = ept->rdev;

	if (ept->addr != RPMSG_ADDR_ANY)
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
 1010e00:	100d883a 	mov	r6,r2
 1010e04:	01402004 	movi	r5,128
 1010e08:	1809883a 	mov	r4,r3
 1010e0c:	1010a380 	call	1010a38 <rpmsg_release_address>
				      ept->addr);
	metal_list_del(&ept->node);
 1010e10:	e0bfff17 	ldw	r2,-4(fp)
 1010e14:	10800d04 	addi	r2,r2,52
 1010e18:	1009883a 	mov	r4,r2
 1010e1c:	10106d40 	call	10106d4 <metal_list_del>
 1010e20:	00000106 	br	1010e28 <rpmsg_unregister_endpoint+0x70>
static void rpmsg_unregister_endpoint(struct rpmsg_endpoint *ept)
{
	struct rpmsg_device *rdev;

	if (!ept)
		return;
 1010e24:	0001883a 	nop

	if (ept->addr != RPMSG_ADDR_ANY)
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
				      ept->addr);
	metal_list_del(&ept->node);
}
 1010e28:	e037883a 	mov	sp,fp
 1010e2c:	dfc00117 	ldw	ra,4(sp)
 1010e30:	df000017 	ldw	fp,0(sp)
 1010e34:	dec00204 	addi	sp,sp,8
 1010e38:	f800283a 	ret

01010e3c <rpmsg_register_endpoint>:

void rpmsg_register_endpoint(struct rpmsg_device *rdev,
			     struct rpmsg_endpoint *ept)
{
 1010e3c:	defffc04 	addi	sp,sp,-16
 1010e40:	dfc00315 	stw	ra,12(sp)
 1010e44:	df000215 	stw	fp,8(sp)
 1010e48:	df000204 	addi	fp,sp,8
 1010e4c:	e13ffe15 	stw	r4,-8(fp)
 1010e50:	e17fff15 	stw	r5,-4(fp)
	ept->rdev = rdev;
 1010e54:	e0bfff17 	ldw	r2,-4(fp)
 1010e58:	e0fffe17 	ldw	r3,-8(fp)
 1010e5c:	10c00815 	stw	r3,32(r2)
	metal_list_add_tail(&rdev->endpoints, &ept->node);
 1010e60:	e0fffe17 	ldw	r3,-8(fp)
 1010e64:	e0bfff17 	ldw	r2,-4(fp)
 1010e68:	10800d04 	addi	r2,r2,52
 1010e6c:	100b883a 	mov	r5,r2
 1010e70:	1809883a 	mov	r4,r3
 1010e74:	10106980 	call	1010698 <metal_list_add_tail>
}
 1010e78:	0001883a 	nop
 1010e7c:	e037883a 	mov	sp,fp
 1010e80:	dfc00117 	ldw	ra,4(sp)
 1010e84:	df000017 	ldw	fp,0(sp)
 1010e88:	dec00204 	addi	sp,sp,8
 1010e8c:	f800283a 	ret

01010e90 <rpmsg_create_ept>:

int rpmsg_create_ept(struct rpmsg_endpoint *ept, struct rpmsg_device *rdev,
		     const char *name, uint32_t src, uint32_t dest,
		     rpmsg_ept_cb cb, rpmsg_ns_unbind_cb unbind_cb)
{
 1010e90:	defff604 	addi	sp,sp,-40
 1010e94:	dfc00915 	stw	ra,36(sp)
 1010e98:	df000815 	stw	fp,32(sp)
 1010e9c:	df000804 	addi	fp,sp,32
 1010ea0:	e13ffc15 	stw	r4,-16(fp)
 1010ea4:	e17ffd15 	stw	r5,-12(fp)
 1010ea8:	e1bffe15 	stw	r6,-8(fp)
 1010eac:	e1ffff15 	stw	r7,-4(fp)
	int status = RPMSG_SUCCESS;
 1010eb0:	e03ffa15 	stw	zero,-24(fp)
	uint32_t addr = src;
 1010eb4:	e0bfff17 	ldw	r2,-4(fp)
 1010eb8:	e0bffb15 	stw	r2,-20(fp)

	if (!ept)
 1010ebc:	e0bffc17 	ldw	r2,-16(fp)
 1010ec0:	1000021e 	bne	r2,zero,1010ecc <rpmsg_create_ept+0x3c>
		return RPMSG_ERR_PARAM;
 1010ec4:	00be0b44 	movi	r2,-2003
 1010ec8:	00004e06 	br	1011004 <rpmsg_create_ept+0x174>

	metal_mutex_acquire(&rdev->lock);
 1010ecc:	e0bffd17 	ldw	r2,-12(fp)
 1010ed0:	10801604 	addi	r2,r2,88
 1010ed4:	1009883a 	mov	r4,r2
 1010ed8:	10105cc0 	call	10105cc <metal_mutex_acquire>
	if (src != RPMSG_ADDR_ANY) {
 1010edc:	e0bfff17 	ldw	r2,-4(fp)
 1010ee0:	10bfffe0 	cmpeqi	r2,r2,-1
 1010ee4:	1000161e 	bne	r2,zero,1010f40 <rpmsg_create_ept+0xb0>
		status = rpmsg_is_address_set(rdev->bitmap,
 1010ee8:	e0bffd17 	ldw	r2,-12(fp)
 1010eec:	10801204 	addi	r2,r2,72
 1010ef0:	e0ffff17 	ldw	r3,-4(fp)
 1010ef4:	180d883a 	mov	r6,r3
 1010ef8:	01402004 	movi	r5,128
 1010efc:	1009883a 	mov	r4,r2
 1010f00:	1010a840 	call	1010a84 <rpmsg_is_address_set>
 1010f04:	e0bffa15 	stw	r2,-24(fp)
					      RPMSG_ADDR_BMP_SIZE, src);
		if (!status) {
 1010f08:	e0bffa17 	ldw	r2,-24(fp)
 1010f0c:	1000081e 	bne	r2,zero,1010f30 <rpmsg_create_ept+0xa0>
			/* Mark the address as used in the address bitmap. */
			rpmsg_set_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
 1010f10:	e0bffd17 	ldw	r2,-12(fp)
 1010f14:	10801204 	addi	r2,r2,72
 1010f18:	e0ffff17 	ldw	r3,-4(fp)
 1010f1c:	180d883a 	mov	r6,r3
 1010f20:	01402004 	movi	r5,128
 1010f24:	1009883a 	mov	r4,r2
 1010f28:	1010ad40 	call	1010ad4 <rpmsg_set_address>
 1010f2c:	00000a06 	br	1010f58 <rpmsg_create_ept+0xc8>
					  src);
		} else if (status > 0) {
 1010f30:	e0bffa17 	ldw	r2,-24(fp)
 1010f34:	00802d0e 	bge	zero,r2,1010fec <rpmsg_create_ept+0x15c>
			status = RPMSG_SUCCESS;
 1010f38:	e03ffa15 	stw	zero,-24(fp)
			goto ret_status;
 1010f3c:	00002c06 	br	1010ff0 <rpmsg_create_ept+0x160>
		} else {
			goto ret_status;
		}
	} else {
		addr = rpmsg_get_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE);
 1010f40:	e0bffd17 	ldw	r2,-12(fp)
 1010f44:	10801204 	addi	r2,r2,72
 1010f48:	01402004 	movi	r5,128
 1010f4c:	1009883a 	mov	r4,r2
 1010f50:	10109c40 	call	10109c4 <rpmsg_get_address>
 1010f54:	e0bffb15 	stw	r2,-20(fp)
	}

	rpmsg_init_ept(ept, name, addr, dest, cb, unbind_cb);
 1010f58:	e0800417 	ldw	r2,16(fp)
 1010f5c:	d8800115 	stw	r2,4(sp)
 1010f60:	e0800317 	ldw	r2,12(fp)
 1010f64:	d8800015 	stw	r2,0(sp)
 1010f68:	e1c00217 	ldw	r7,8(fp)
 1010f6c:	e1bffb17 	ldw	r6,-20(fp)
 1010f70:	e17ffe17 	ldw	r5,-8(fp)
 1010f74:	e13ffc17 	ldw	r4,-16(fp)
 1010f78:	10109300 	call	1010930 <rpmsg_init_ept>
	rpmsg_register_endpoint(rdev, ept);
 1010f7c:	e17ffc17 	ldw	r5,-16(fp)
 1010f80:	e13ffd17 	ldw	r4,-12(fp)
 1010f84:	1010e3c0 	call	1010e3c <rpmsg_register_endpoint>

	if (rdev->support_ns && ept->dest_addr == RPMSG_ADDR_ANY) {
 1010f88:	e0bffd17 	ldw	r2,-12(fp)
 1010f8c:	10801903 	ldbu	r2,100(r2)
 1010f90:	10803fcc 	andi	r2,r2,255
 1010f94:	10001626 	beq	r2,zero,1010ff0 <rpmsg_create_ept+0x160>
 1010f98:	e0bffc17 	ldw	r2,-16(fp)
 1010f9c:	10800a17 	ldw	r2,40(r2)
 1010fa0:	10bfffd8 	cmpnei	r2,r2,-1
 1010fa4:	1000121e 	bne	r2,zero,1010ff0 <rpmsg_create_ept+0x160>
		/* Send NS announcement to remote processor */
		metal_mutex_release(&rdev->lock);
 1010fa8:	e0bffd17 	ldw	r2,-12(fp)
 1010fac:	10801604 	addi	r2,r2,88
 1010fb0:	1009883a 	mov	r4,r2
 1010fb4:	10106000 	call	1010600 <metal_mutex_release>
		status = rpmsg_send_ns_message(ept, RPMSG_NS_CREATE);
 1010fb8:	000b883a 	mov	r5,zero
 1010fbc:	e13ffc17 	ldw	r4,-16(fp)
 1010fc0:	1010bd80 	call	1010bd8 <rpmsg_send_ns_message>
 1010fc4:	e0bffa15 	stw	r2,-24(fp)
		metal_mutex_acquire(&rdev->lock);
 1010fc8:	e0bffd17 	ldw	r2,-12(fp)
 1010fcc:	10801604 	addi	r2,r2,88
 1010fd0:	1009883a 	mov	r4,r2
 1010fd4:	10105cc0 	call	10105cc <metal_mutex_acquire>
		if (status)
 1010fd8:	e0bffa17 	ldw	r2,-24(fp)
 1010fdc:	10000426 	beq	r2,zero,1010ff0 <rpmsg_create_ept+0x160>
			rpmsg_unregister_endpoint(ept);
 1010fe0:	e13ffc17 	ldw	r4,-16(fp)
 1010fe4:	1010db80 	call	1010db8 <rpmsg_unregister_endpoint>
 1010fe8:	00000106 	br	1010ff0 <rpmsg_create_ept+0x160>
					  src);
		} else if (status > 0) {
			status = RPMSG_SUCCESS;
			goto ret_status;
		} else {
			goto ret_status;
 1010fec:	0001883a 	nop
		if (status)
			rpmsg_unregister_endpoint(ept);
	}

ret_status:
	metal_mutex_release(&rdev->lock);
 1010ff0:	e0bffd17 	ldw	r2,-12(fp)
 1010ff4:	10801604 	addi	r2,r2,88
 1010ff8:	1009883a 	mov	r4,r2
 1010ffc:	10106000 	call	1010600 <metal_mutex_release>
	return status;
 1011000:	e0bffa17 	ldw	r2,-24(fp)
}
 1011004:	e037883a 	mov	sp,fp
 1011008:	dfc00117 	ldw	ra,4(sp)
 101100c:	df000017 	ldw	fp,0(sp)
 1011010:	dec00204 	addi	sp,sp,8
 1011014:	f800283a 	ret

01011018 <rpmsg_destroy_ept>:
 *
 * @param ept - pointer to endpoint to destroy
 *
 */
void rpmsg_destroy_ept(struct rpmsg_endpoint *ept)
{
 1011018:	defffc04 	addi	sp,sp,-16
 101101c:	dfc00315 	stw	ra,12(sp)
 1011020:	df000215 	stw	fp,8(sp)
 1011024:	df000204 	addi	fp,sp,8
 1011028:	e13fff15 	stw	r4,-4(fp)
	struct rpmsg_device *rdev;

	if (!ept)
 101102c:	e0bfff17 	ldw	r2,-4(fp)
 1011030:	10001f26 	beq	r2,zero,10110b0 <rpmsg_destroy_ept+0x98>
		return;

	rdev = ept->rdev;
 1011034:	e0bfff17 	ldw	r2,-4(fp)
 1011038:	10800817 	ldw	r2,32(r2)
 101103c:	e0bffe15 	stw	r2,-8(fp)
	if (ept->name[0] && rdev->support_ns && ept->addr != RPMSG_NS_EPT_ADDR)
 1011040:	e0bfff17 	ldw	r2,-4(fp)
 1011044:	10800003 	ldbu	r2,0(r2)
 1011048:	10803fcc 	andi	r2,r2,255
 101104c:	1080201c 	xori	r2,r2,128
 1011050:	10bfe004 	addi	r2,r2,-128
 1011054:	10000b26 	beq	r2,zero,1011084 <rpmsg_destroy_ept+0x6c>
 1011058:	e0bffe17 	ldw	r2,-8(fp)
 101105c:	10801903 	ldbu	r2,100(r2)
 1011060:	10803fcc 	andi	r2,r2,255
 1011064:	10000726 	beq	r2,zero,1011084 <rpmsg_destroy_ept+0x6c>
 1011068:	e0bfff17 	ldw	r2,-4(fp)
 101106c:	10800917 	ldw	r2,36(r2)
 1011070:	10800d60 	cmpeqi	r2,r2,53
 1011074:	1000031e 	bne	r2,zero,1011084 <rpmsg_destroy_ept+0x6c>
		(void)rpmsg_send_ns_message(ept, RPMSG_NS_DESTROY);
 1011078:	01400044 	movi	r5,1
 101107c:	e13fff17 	ldw	r4,-4(fp)
 1011080:	1010bd80 	call	1010bd8 <rpmsg_send_ns_message>
	metal_mutex_acquire(&rdev->lock);
 1011084:	e0bffe17 	ldw	r2,-8(fp)
 1011088:	10801604 	addi	r2,r2,88
 101108c:	1009883a 	mov	r4,r2
 1011090:	10105cc0 	call	10105cc <metal_mutex_acquire>
	rpmsg_unregister_endpoint(ept);
 1011094:	e13fff17 	ldw	r4,-4(fp)
 1011098:	1010db80 	call	1010db8 <rpmsg_unregister_endpoint>
	metal_mutex_release(&rdev->lock);
 101109c:	e0bffe17 	ldw	r2,-8(fp)
 10110a0:	10801604 	addi	r2,r2,88
 10110a4:	1009883a 	mov	r4,r2
 10110a8:	10106000 	call	1010600 <metal_mutex_release>
 10110ac:	00000106 	br	10110b4 <rpmsg_destroy_ept+0x9c>
void rpmsg_destroy_ept(struct rpmsg_endpoint *ept)
{
	struct rpmsg_device *rdev;

	if (!ept)
		return;
 10110b0:	0001883a 	nop
	if (ept->name[0] && rdev->support_ns && ept->addr != RPMSG_NS_EPT_ADDR)
		(void)rpmsg_send_ns_message(ept, RPMSG_NS_DESTROY);
	metal_mutex_acquire(&rdev->lock);
	rpmsg_unregister_endpoint(ept);
	metal_mutex_release(&rdev->lock);
}
 10110b4:	e037883a 	mov	sp,fp
 10110b8:	dfc00117 	ldw	ra,4(sp)
 10110bc:	df000017 	ldw	fp,0(sp)
 10110c0:	dec00204 	addi	sp,sp,8
 10110c4:	f800283a 	ret

010110c8 <__metal_sleep_usec>:
#ifdef __cplusplus
extern "C" {
#endif

static inline int __metal_sleep_usec(unsigned int usec)
{
 10110c8:	defffc04 	addi	sp,sp,-16
 10110cc:	dfc00315 	stw	ra,12(sp)
 10110d0:	df000215 	stw	fp,8(sp)
 10110d4:	df000204 	addi	fp,sp,8
 10110d8:	e13fff15 	stw	r4,-4(fp)
	const TickType_t xDelay = usec / portTICK_PERIOD_MS;
 10110dc:	e0bfff17 	ldw	r2,-4(fp)
 10110e0:	e0bffe15 	stw	r2,-8(fp)
	vTaskDelay(xDelay);
 10110e4:	e13ffe17 	ldw	r4,-8(fp)
 10110e8:	1003cbc0 	call	1003cbc <vTaskDelay>
	return 0;
 10110ec:	0005883a 	mov	r2,zero
}
 10110f0:	e037883a 	mov	sp,fp
 10110f4:	dfc00117 	ldw	ra,4(sp)
 10110f8:	df000017 	ldw	fp,0(sp)
 10110fc:	dec00204 	addi	sp,sp,8
 1011100:	f800283a 	ret

01011104 <metal_sleep_usec>:
 *
 * @param[in]  usec      microsecond intervals
 * @return     0 on success, non-zero for failures
 */
static inline int metal_sleep_usec(unsigned int usec)
{
 1011104:	defffd04 	addi	sp,sp,-12
 1011108:	dfc00215 	stw	ra,8(sp)
 101110c:	df000115 	stw	fp,4(sp)
 1011110:	df000104 	addi	fp,sp,4
 1011114:	e13fff15 	stw	r4,-4(fp)
	return __metal_sleep_usec(usec);
 1011118:	e13fff17 	ldw	r4,-4(fp)
 101111c:	10110c80 	call	10110c8 <__metal_sleep_usec>
}
 1011120:	e037883a 	mov	sp,fp
 1011124:	dfc00117 	ldw	ra,4(sp)
 1011128:	df000017 	ldw	fp,0(sp)
 101112c:	dec00204 	addi	sp,sp,8
 1011130:	f800283a 	ret

01011134 <metal_list_init>:
 */
#define METAL_DECLARE_LIST(name)			\
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
 1011134:	defffe04 	addi	sp,sp,-8
 1011138:	df000115 	stw	fp,4(sp)
 101113c:	df000104 	addi	fp,sp,4
 1011140:	e13fff15 	stw	r4,-4(fp)
	list->next = list->prev = list;
 1011144:	e0bfff17 	ldw	r2,-4(fp)
 1011148:	e0ffff17 	ldw	r3,-4(fp)
 101114c:	10c00115 	stw	r3,4(r2)
 1011150:	e0bfff17 	ldw	r2,-4(fp)
 1011154:	10c00117 	ldw	r3,4(r2)
 1011158:	e0bfff17 	ldw	r2,-4(fp)
 101115c:	10c00015 	stw	r3,0(r2)
}
 1011160:	0001883a 	nop
 1011164:	e037883a 	mov	sp,fp
 1011168:	df000017 	ldw	fp,0(sp)
 101116c:	dec00104 	addi	sp,sp,4
 1011170:	f800283a 	ret

01011174 <metal_list_is_empty>:
{
	metal_list_add_before(list, node);
}

static inline int metal_list_is_empty(struct metal_list *list)
{
 1011174:	defffe04 	addi	sp,sp,-8
 1011178:	df000115 	stw	fp,4(sp)
 101117c:	df000104 	addi	fp,sp,4
 1011180:	e13fff15 	stw	r4,-4(fp)
	return list->next == list;
 1011184:	e0bfff17 	ldw	r2,-4(fp)
 1011188:	10c00017 	ldw	r3,0(r2)
 101118c:	e0bfff17 	ldw	r2,-4(fp)
 1011190:	1885003a 	cmpeq	r2,r3,r2
 1011194:	10803fcc 	andi	r2,r2,255
}
 1011198:	e037883a 	mov	sp,fp
 101119c:	df000017 	ldw	fp,0(sp)
 10111a0:	dec00104 	addi	sp,sp,4
 10111a4:	f800283a 	ret

010111a8 <metal_io_virt_to_offset>:
 * @param[in]	virt	Virtual address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
 10111a8:	defffc04 	addi	sp,sp,-16
 10111ac:	df000315 	stw	fp,12(sp)
 10111b0:	df000304 	addi	fp,sp,12
 10111b4:	e13ffe15 	stw	r4,-8(fp)
 10111b8:	e17fff15 	stw	r5,-4(fp)
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 10111bc:	e0bfff17 	ldw	r2,-4(fp)
 10111c0:	e0fffe17 	ldw	r3,-8(fp)
 10111c4:	18c00017 	ldw	r3,0(r3)
 10111c8:	10c5c83a 	sub	r2,r2,r3
 10111cc:	e0bffd15 	stw	r2,-12(fp)
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 10111d0:	e0bffe17 	ldw	r2,-8(fp)
 10111d4:	10800217 	ldw	r2,8(r2)
 10111d8:	e0fffd17 	ldw	r3,-12(fp)
 10111dc:	1880022e 	bgeu	r3,r2,10111e8 <metal_io_virt_to_offset+0x40>
 10111e0:	e0bffd17 	ldw	r2,-12(fp)
 10111e4:	00000106 	br	10111ec <metal_io_virt_to_offset+0x44>
 10111e8:	00bfffc4 	movi	r2,-1
}
 10111ec:	e037883a 	mov	sp,fp
 10111f0:	df000017 	ldw	fp,0(sp)
 10111f4:	dec00104 	addi	sp,sp,4
 10111f8:	f800283a 	ret

010111fc <__metal_mutex_init>:
 * static singleton mutex
 */
#define METAL_MUTEX_DEFINE(m) metal_mutex_t m = METAL_MUTEX_INIT(m)

static inline void __metal_mutex_init(metal_mutex_t *mutex)
{
 10111fc:	defffe04 	addi	sp,sp,-8
 1011200:	df000115 	stw	fp,4(sp)
 1011204:	df000104 	addi	fp,sp,4
 1011208:	e13fff15 	stw	r4,-4(fp)
	atomic_store(&mutex->v, 0);
 101120c:	e0bfff17 	ldw	r2,-4(fp)
 1011210:	10000015 	stw	zero,0(r2)
 1011214:	0001b03a 	sync
}
 1011218:	0001883a 	nop
 101121c:	e037883a 	mov	sp,fp
 1011220:	df000017 	ldw	fp,0(sp)
 1011224:	dec00104 	addi	sp,sp,4
 1011228:	f800283a 	ret

0101122c <__metal_mutex_deinit>:

static inline void __metal_mutex_deinit(metal_mutex_t *mutex)
{
 101122c:	defffe04 	addi	sp,sp,-8
 1011230:	df000115 	stw	fp,4(sp)
 1011234:	df000104 	addi	fp,sp,4
 1011238:	e13fff15 	stw	r4,-4(fp)
	(void)mutex;
}
 101123c:	0001883a 	nop
 1011240:	e037883a 	mov	sp,fp
 1011244:	df000017 	ldw	fp,0(sp)
 1011248:	dec00104 	addi	sp,sp,4
 101124c:	f800283a 	ret

01011250 <__metal_mutex_acquire>:
{
	return 1 - atomic_flag_test_and_set(&mutex->v);
}

static inline void __metal_mutex_acquire(metal_mutex_t *mutex)
{
 1011250:	defffb04 	addi	sp,sp,-20
 1011254:	df000415 	stw	fp,16(sp)
 1011258:	df000404 	addi	fp,sp,16
 101125c:	e13fff15 	stw	r4,-4(fp)
	while (atomic_flag_test_and_set(&mutex->v)) {
 1011260:	0001883a 	nop
 1011264:	e0bfff17 	ldw	r2,-4(fp)
 1011268:	e0bffc15 	stw	r2,-16(fp)
 101126c:	e0bffc17 	ldw	r2,-16(fp)
 1011270:	10800017 	ldw	r2,0(r2)
 1011274:	e0bffd15 	stw	r2,-12(fp)
 1011278:	00800044 	movi	r2,1
 101127c:	e0bffe15 	stw	r2,-8(fp)
 1011280:	e0bfff17 	ldw	r2,-4(fp)
 1011284:	e0fffe17 	ldw	r3,-8(fp)
 1011288:	10c00015 	stw	r3,0(r2)
 101128c:	e0bffd17 	ldw	r2,-12(fp)
 1011290:	103ff41e 	bne	r2,zero,1011264 <__alt_data_end+0xff011264>
		;
	}
}
 1011294:	0001883a 	nop
 1011298:	e037883a 	mov	sp,fp
 101129c:	df000017 	ldw	fp,0(sp)
 10112a0:	dec00104 	addi	sp,sp,4
 10112a4:	f800283a 	ret

010112a8 <__metal_mutex_release>:

static inline void __metal_mutex_release(metal_mutex_t *mutex)
{
 10112a8:	defffe04 	addi	sp,sp,-8
 10112ac:	df000115 	stw	fp,4(sp)
 10112b0:	df000104 	addi	fp,sp,4
 10112b4:	e13fff15 	stw	r4,-4(fp)
	atomic_flag_clear(&mutex->v);
 10112b8:	e0bfff17 	ldw	r2,-4(fp)
 10112bc:	0001b03a 	sync
 10112c0:	10000015 	stw	zero,0(r2)
}
 10112c4:	0001883a 	nop
 10112c8:	e037883a 	mov	sp,fp
 10112cc:	df000017 	ldw	fp,0(sp)
 10112d0:	dec00104 	addi	sp,sp,4
 10112d4:	f800283a 	ret

010112d8 <metal_mutex_init>:
/**
 * @brief	Initialize a libmetal mutex.
 * @param[in]	mutex	Mutex to initialize.
 */
static inline void metal_mutex_init(metal_mutex_t *mutex)
{
 10112d8:	defffd04 	addi	sp,sp,-12
 10112dc:	dfc00215 	stw	ra,8(sp)
 10112e0:	df000115 	stw	fp,4(sp)
 10112e4:	df000104 	addi	fp,sp,4
 10112e8:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_init(mutex);
 10112ec:	e13fff17 	ldw	r4,-4(fp)
 10112f0:	10111fc0 	call	10111fc <__metal_mutex_init>
}
 10112f4:	0001883a 	nop
 10112f8:	e037883a 	mov	sp,fp
 10112fc:	dfc00117 	ldw	ra,4(sp)
 1011300:	df000017 	ldw	fp,0(sp)
 1011304:	dec00204 	addi	sp,sp,8
 1011308:	f800283a 	ret

0101130c <metal_mutex_deinit>:
/**
 * @brief	Deinitialize a libmetal mutex.
 * @param[in]	mutex	Mutex to deinitialize.
 */
static inline void metal_mutex_deinit(metal_mutex_t *mutex)
{
 101130c:	defffd04 	addi	sp,sp,-12
 1011310:	dfc00215 	stw	ra,8(sp)
 1011314:	df000115 	stw	fp,4(sp)
 1011318:	df000104 	addi	fp,sp,4
 101131c:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_deinit(mutex);
 1011320:	e13fff17 	ldw	r4,-4(fp)
 1011324:	101122c0 	call	101122c <__metal_mutex_deinit>
}
 1011328:	0001883a 	nop
 101132c:	e037883a 	mov	sp,fp
 1011330:	dfc00117 	ldw	ra,4(sp)
 1011334:	df000017 	ldw	fp,0(sp)
 1011338:	dec00204 	addi	sp,sp,8
 101133c:	f800283a 	ret

01011340 <metal_mutex_acquire>:
/**
 * @brief	Acquire a mutex 
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
 1011340:	defffd04 	addi	sp,sp,-12
 1011344:	dfc00215 	stw	ra,8(sp)
 1011348:	df000115 	stw	fp,4(sp)
 101134c:	df000104 	addi	fp,sp,4
 1011350:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_acquire(mutex);
 1011354:	e13fff17 	ldw	r4,-4(fp)
 1011358:	10112500 	call	1011250 <__metal_mutex_acquire>
}
 101135c:	0001883a 	nop
 1011360:	e037883a 	mov	sp,fp
 1011364:	dfc00117 	ldw	ra,4(sp)
 1011368:	df000017 	ldw	fp,0(sp)
 101136c:	dec00204 	addi	sp,sp,8
 1011370:	f800283a 	ret

01011374 <metal_mutex_release>:
 * @brief	Release a previously acquired mutex.
 * @param[in]	mutex	Mutex to mutex.
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
 1011374:	defffd04 	addi	sp,sp,-12
 1011378:	dfc00215 	stw	ra,8(sp)
 101137c:	df000115 	stw	fp,4(sp)
 1011380:	df000104 	addi	fp,sp,4
 1011384:	e13fff15 	stw	r4,-4(fp)
	__metal_mutex_release(mutex);
 1011388:	e13fff17 	ldw	r4,-4(fp)
 101138c:	10112a80 	call	10112a8 <__metal_mutex_release>
}
 1011390:	0001883a 	nop
 1011394:	e037883a 	mov	sp,fp
 1011398:	dfc00117 	ldw	ra,4(sp)
 101139c:	df000017 	ldw	fp,0(sp)
 10113a0:	dec00204 	addi	sp,sp,8
 10113a4:	f800283a 	ret

010113a8 <rpmsg_init_ept>:
static inline void rpmsg_init_ept(struct rpmsg_endpoint *ept,
				  const char *name,
				  uint32_t src, uint32_t dest,
				  rpmsg_ept_cb cb,
				  rpmsg_ns_unbind_cb ns_unbind_cb)
{
 10113a8:	defffa04 	addi	sp,sp,-24
 10113ac:	dfc00515 	stw	ra,20(sp)
 10113b0:	df000415 	stw	fp,16(sp)
 10113b4:	df000404 	addi	fp,sp,16
 10113b8:	e13ffc15 	stw	r4,-16(fp)
 10113bc:	e17ffd15 	stw	r5,-12(fp)
 10113c0:	e1bffe15 	stw	r6,-8(fp)
 10113c4:	e1ffff15 	stw	r7,-4(fp)
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
 10113c8:	e0fffc17 	ldw	r3,-16(fp)
 10113cc:	e0bffd17 	ldw	r2,-12(fp)
 10113d0:	10000226 	beq	r2,zero,10113dc <rpmsg_init_ept+0x34>
 10113d4:	e0bffd17 	ldw	r2,-12(fp)
 10113d8:	00000206 	br	10113e4 <rpmsg_init_ept+0x3c>
 10113dc:	008040f4 	movhi	r2,259
 10113e0:	10a76e04 	addi	r2,r2,-25160
 10113e4:	01800804 	movi	r6,32
 10113e8:	100b883a 	mov	r5,r2
 10113ec:	1809883a 	mov	r4,r3
 10113f0:	101671c0 	call	101671c <strncpy>
	ept->addr = src;
 10113f4:	e0bffc17 	ldw	r2,-16(fp)
 10113f8:	e0fffe17 	ldw	r3,-8(fp)
 10113fc:	10c00915 	stw	r3,36(r2)
	ept->dest_addr = dest;
 1011400:	e0bffc17 	ldw	r2,-16(fp)
 1011404:	e0ffff17 	ldw	r3,-4(fp)
 1011408:	10c00a15 	stw	r3,40(r2)
	ept->cb = cb;
 101140c:	e0bffc17 	ldw	r2,-16(fp)
 1011410:	e0c00217 	ldw	r3,8(fp)
 1011414:	10c00b15 	stw	r3,44(r2)
	ept->ns_unbind_cb = ns_unbind_cb;
 1011418:	e0bffc17 	ldw	r2,-16(fp)
 101141c:	e0c00317 	ldw	r3,12(fp)
 1011420:	10c00c15 	stw	r3,48(r2)
}
 1011424:	0001883a 	nop
 1011428:	e037883a 	mov	sp,fp
 101142c:	dfc00117 	ldw	ra,4(sp)
 1011430:	df000017 	ldw	fp,0(sp)
 1011434:	dec00204 	addi	sp,sp,8
 1011438:	f800283a 	ret

0101143c <rpmsg_virtio_get_role>:
#define RPMSG_REMOTE	VIRTIO_DEV_SLAVE
#define RPMSG_MASTER	VIRTIO_DEV_MASTER

static inline unsigned int
rpmsg_virtio_get_role(struct rpmsg_virtio_device *rvdev)
{
 101143c:	defffe04 	addi	sp,sp,-8
 1011440:	df000115 	stw	fp,4(sp)
 1011444:	df000104 	addi	fp,sp,4
 1011448:	e13fff15 	stw	r4,-4(fp)
	return rvdev->vdev->role;
 101144c:	e0bfff17 	ldw	r2,-4(fp)
 1011450:	10801a17 	ldw	r2,104(r2)
 1011454:	10800517 	ldw	r2,20(r2)
}
 1011458:	e037883a 	mov	sp,fp
 101145c:	df000017 	ldw	fp,0(sp)
 1011460:	dec00104 	addi	sp,sp,4
 1011464:	f800283a 	ret

01011468 <rpmsg_virtio_set_status>:

static inline void rpmsg_virtio_set_status(struct rpmsg_virtio_device *rvdev,
					   uint8_t status)
{
 1011468:	defffc04 	addi	sp,sp,-16
 101146c:	dfc00315 	stw	ra,12(sp)
 1011470:	df000215 	stw	fp,8(sp)
 1011474:	df000204 	addi	fp,sp,8
 1011478:	e13ffe15 	stw	r4,-8(fp)
 101147c:	2805883a 	mov	r2,r5
 1011480:	e0bfff05 	stb	r2,-4(fp)
	rvdev->vdev->func->set_status(rvdev->vdev, status);
 1011484:	e0bffe17 	ldw	r2,-8(fp)
 1011488:	10801a17 	ldw	r2,104(r2)
 101148c:	10800717 	ldw	r2,28(r2)
 1011490:	10800117 	ldw	r2,4(r2)
 1011494:	e0fffe17 	ldw	r3,-8(fp)
 1011498:	18c01a17 	ldw	r3,104(r3)
 101149c:	e13fff03 	ldbu	r4,-4(fp)
 10114a0:	200b883a 	mov	r5,r4
 10114a4:	1809883a 	mov	r4,r3
 10114a8:	103ee83a 	callr	r2
}
 10114ac:	0001883a 	nop
 10114b0:	e037883a 	mov	sp,fp
 10114b4:	dfc00117 	ldw	ra,4(sp)
 10114b8:	df000017 	ldw	fp,0(sp)
 10114bc:	dec00204 	addi	sp,sp,8
 10114c0:	f800283a 	ret

010114c4 <rpmsg_virtio_get_status>:

static inline uint8_t rpmsg_virtio_get_status(struct rpmsg_virtio_device *rvdev)
{
 10114c4:	defffd04 	addi	sp,sp,-12
 10114c8:	dfc00215 	stw	ra,8(sp)
 10114cc:	df000115 	stw	fp,4(sp)
 10114d0:	df000104 	addi	fp,sp,4
 10114d4:	e13fff15 	stw	r4,-4(fp)
	return rvdev->vdev->func->get_status(rvdev->vdev);
 10114d8:	e0bfff17 	ldw	r2,-4(fp)
 10114dc:	10801a17 	ldw	r2,104(r2)
 10114e0:	10800717 	ldw	r2,28(r2)
 10114e4:	10800017 	ldw	r2,0(r2)
 10114e8:	e0ffff17 	ldw	r3,-4(fp)
 10114ec:	18c01a17 	ldw	r3,104(r3)
 10114f0:	1809883a 	mov	r4,r3
 10114f4:	103ee83a 	callr	r2
}
 10114f8:	e037883a 	mov	sp,fp
 10114fc:	dfc00117 	ldw	ra,4(sp)
 1011500:	df000017 	ldw	fp,0(sp)
 1011504:	dec00204 	addi	sp,sp,8
 1011508:	f800283a 	ret

0101150c <rpmsg_virtio_get_features>:

static inline uint32_t
rpmsg_virtio_get_features(struct rpmsg_virtio_device *rvdev)
{
 101150c:	defffd04 	addi	sp,sp,-12
 1011510:	dfc00215 	stw	ra,8(sp)
 1011514:	df000115 	stw	fp,4(sp)
 1011518:	df000104 	addi	fp,sp,4
 101151c:	e13fff15 	stw	r4,-4(fp)
	return rvdev->vdev->func->get_features(rvdev->vdev);
 1011520:	e0bfff17 	ldw	r2,-4(fp)
 1011524:	10801a17 	ldw	r2,104(r2)
 1011528:	10800717 	ldw	r2,28(r2)
 101152c:	10800217 	ldw	r2,8(r2)
 1011530:	e0ffff17 	ldw	r3,-4(fp)
 1011534:	18c01a17 	ldw	r3,104(r3)
 1011538:	1809883a 	mov	r4,r3
 101153c:	103ee83a 	callr	r2
}
 1011540:	e037883a 	mov	sp,fp
 1011544:	dfc00117 	ldw	ra,4(sp)
 1011548:	df000017 	ldw	fp,0(sp)
 101154c:	dec00204 	addi	sp,sp,8
 1011550:	f800283a 	ret

01011554 <rpmsg_virtio_create_virtqueues>:
static inline int
rpmsg_virtio_create_virtqueues(struct rpmsg_virtio_device *rvdev,
			       int flags, unsigned int nvqs,
			       const char *names[],
			       vq_callback *callbacks[])
{
 1011554:	defff904 	addi	sp,sp,-28
 1011558:	dfc00615 	stw	ra,24(sp)
 101155c:	df000515 	stw	fp,20(sp)
 1011560:	df000504 	addi	fp,sp,20
 1011564:	e13ffc15 	stw	r4,-16(fp)
 1011568:	e17ffd15 	stw	r5,-12(fp)
 101156c:	e1bffe15 	stw	r6,-8(fp)
 1011570:	e1ffff15 	stw	r7,-4(fp)
	return virtio_create_virtqueues(rvdev->vdev, flags, nvqs, names,
 1011574:	e0bffc17 	ldw	r2,-16(fp)
 1011578:	10c01a17 	ldw	r3,104(r2)
 101157c:	e13ffd17 	ldw	r4,-12(fp)
 1011580:	e0800217 	ldw	r2,8(fp)
 1011584:	d8800015 	stw	r2,0(sp)
 1011588:	e1ffff17 	ldw	r7,-4(fp)
 101158c:	e1bffe17 	ldw	r6,-8(fp)
 1011590:	200b883a 	mov	r5,r4
 1011594:	1809883a 	mov	r4,r3
 1011598:	101284c0 	call	101284c <virtio_create_virtqueues>
					callbacks);
}
 101159c:	e037883a 	mov	sp,fp
 10115a0:	dfc00117 	ldw	ra,4(sp)
 10115a4:	df000017 	ldw	fp,0(sp)
 10115a8:	dec00204 	addi	sp,sp,8
 10115ac:	f800283a 	ret

010115b0 <rpmsg_get_ept_from_addr>:
void rpmsg_register_endpoint(struct rpmsg_device *rdev,
			     struct rpmsg_endpoint *ept);

static inline struct rpmsg_endpoint *
rpmsg_get_ept_from_addr(struct rpmsg_device *rdev, uint32_t addr)
{
 10115b0:	defffc04 	addi	sp,sp,-16
 10115b4:	dfc00315 	stw	ra,12(sp)
 10115b8:	df000215 	stw	fp,8(sp)
 10115bc:	df000204 	addi	fp,sp,8
 10115c0:	e13ffe15 	stw	r4,-8(fp)
 10115c4:	e17fff15 	stw	r5,-4(fp)
	return rpmsg_get_endpoint(rdev, NULL, addr, RPMSG_ADDR_ANY);
 10115c8:	01ffffc4 	movi	r7,-1
 10115cc:	e1bfff17 	ldw	r6,-4(fp)
 10115d0:	000b883a 	mov	r5,zero
 10115d4:	e13ffe17 	ldw	r4,-8(fp)
 10115d8:	1010c780 	call	1010c78 <rpmsg_get_endpoint>
}
 10115dc:	e037883a 	mov	sp,fp
 10115e0:	dfc00117 	ldw	ra,4(sp)
 10115e4:	df000017 	ldw	fp,0(sp)
 10115e8:	dec00204 	addi	sp,sp,8
 10115ec:	f800283a 	ret

010115f0 <rpmsg_virtio_shm_pool_get_buffer>:

#ifndef VIRTIO_SLAVE_ONLY
metal_weak void *
rpmsg_virtio_shm_pool_get_buffer(struct rpmsg_virtio_shm_pool *shpool,
				 size_t size)
{
 10115f0:	defffc04 	addi	sp,sp,-16
 10115f4:	df000315 	stw	fp,12(sp)
 10115f8:	df000304 	addi	fp,sp,12
 10115fc:	e13ffe15 	stw	r4,-8(fp)
 1011600:	e17fff15 	stw	r5,-4(fp)
	void *buffer;

	if (shpool->avail < size)
 1011604:	e0bffe17 	ldw	r2,-8(fp)
 1011608:	10c00117 	ldw	r3,4(r2)
 101160c:	e0bfff17 	ldw	r2,-4(fp)
 1011610:	1880022e 	bgeu	r3,r2,101161c <rpmsg_virtio_shm_pool_get_buffer+0x2c>
		return NULL;
 1011614:	0005883a 	mov	r2,zero
 1011618:	00001006 	br	101165c <rpmsg_virtio_shm_pool_get_buffer+0x6c>
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
 101161c:	e0bffe17 	ldw	r2,-8(fp)
 1011620:	10c00017 	ldw	r3,0(r2)
 1011624:	e0bffe17 	ldw	r2,-8(fp)
 1011628:	11000217 	ldw	r4,8(r2)
 101162c:	e0bffe17 	ldw	r2,-8(fp)
 1011630:	10800117 	ldw	r2,4(r2)
 1011634:	2085c83a 	sub	r2,r4,r2
 1011638:	1885883a 	add	r2,r3,r2
 101163c:	e0bffd15 	stw	r2,-12(fp)
	shpool->avail -= size;
 1011640:	e0bffe17 	ldw	r2,-8(fp)
 1011644:	10c00117 	ldw	r3,4(r2)
 1011648:	e0bfff17 	ldw	r2,-4(fp)
 101164c:	1887c83a 	sub	r3,r3,r2
 1011650:	e0bffe17 	ldw	r2,-8(fp)
 1011654:	10c00115 	stw	r3,4(r2)

	return buffer;
 1011658:	e0bffd17 	ldw	r2,-12(fp)
}
 101165c:	e037883a 	mov	sp,fp
 1011660:	df000017 	ldw	fp,0(sp)
 1011664:	dec00104 	addi	sp,sp,4
 1011668:	f800283a 	ret

0101166c <rpmsg_virtio_init_shm_pool>:
#endif /*!VIRTIO_SLAVE_ONLY*/

void rpmsg_virtio_init_shm_pool(struct rpmsg_virtio_shm_pool *shpool,
				void *shb, size_t size)
{
 101166c:	defffc04 	addi	sp,sp,-16
 1011670:	df000315 	stw	fp,12(sp)
 1011674:	df000304 	addi	fp,sp,12
 1011678:	e13ffd15 	stw	r4,-12(fp)
 101167c:	e17ffe15 	stw	r5,-8(fp)
 1011680:	e1bfff15 	stw	r6,-4(fp)
	if (!shpool)
 1011684:	e0bffd17 	ldw	r2,-12(fp)
 1011688:	10000a26 	beq	r2,zero,10116b4 <rpmsg_virtio_init_shm_pool+0x48>
		return;
	shpool->base = shb;
 101168c:	e0bffd17 	ldw	r2,-12(fp)
 1011690:	e0fffe17 	ldw	r3,-8(fp)
 1011694:	10c00015 	stw	r3,0(r2)
	shpool->size = size;
 1011698:	e0bffd17 	ldw	r2,-12(fp)
 101169c:	e0ffff17 	ldw	r3,-4(fp)
 10116a0:	10c00215 	stw	r3,8(r2)
	shpool->avail = size;
 10116a4:	e0bffd17 	ldw	r2,-12(fp)
 10116a8:	e0ffff17 	ldw	r3,-4(fp)
 10116ac:	10c00115 	stw	r3,4(r2)
 10116b0:	00000106 	br	10116b8 <rpmsg_virtio_init_shm_pool+0x4c>

void rpmsg_virtio_init_shm_pool(struct rpmsg_virtio_shm_pool *shpool,
				void *shb, size_t size)
{
	if (!shpool)
		return;
 10116b4:	0001883a 	nop
	shpool->base = shb;
	shpool->size = size;
	shpool->avail = size;
}
 10116b8:	e037883a 	mov	sp,fp
 10116bc:	df000017 	ldw	fp,0(sp)
 10116c0:	dec00104 	addi	sp,sp,4
 10116c4:	f800283a 	ret

010116c8 <rpmsg_virtio_return_buffer>:
 *
 */
static void rpmsg_virtio_return_buffer(struct rpmsg_virtio_device *rvdev,
				       void *buffer, uint32_t len,
				       uint16_t idx)
{
 10116c8:	defff604 	addi	sp,sp,-40
 10116cc:	dfc00915 	stw	ra,36(sp)
 10116d0:	df000815 	stw	fp,32(sp)
 10116d4:	df000804 	addi	fp,sp,32
 10116d8:	e13ffc15 	stw	r4,-16(fp)
 10116dc:	e17ffd15 	stw	r5,-12(fp)
 10116e0:	e1bffe15 	stw	r6,-8(fp)
 10116e4:	3805883a 	mov	r2,r7
 10116e8:	e0bfff0d 	sth	r2,-4(fp)
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 10116ec:	e13ffc17 	ldw	r4,-16(fp)
 10116f0:	101143c0 	call	101143c <rpmsg_virtio_get_role>
 10116f4:	e0bff915 	stw	r2,-28(fp)
#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 10116f8:	e0bff917 	ldw	r2,-28(fp)
 10116fc:	10000e1e 	bne	r2,zero,1011738 <rpmsg_virtio_return_buffer+0x70>
		struct virtqueue_buf vqbuf;

		(void)idx;
		/* Initialize buffer node */
		vqbuf.buf = buffer;
 1011700:	e0bffd17 	ldw	r2,-12(fp)
 1011704:	e0bffa15 	stw	r2,-24(fp)
		vqbuf.len = len;
 1011708:	e0bffe17 	ldw	r2,-8(fp)
 101170c:	e0bffb15 	stw	r2,-20(fp)
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
 1011710:	e0bffc17 	ldw	r2,-16(fp)
 1011714:	10c01b17 	ldw	r3,108(r2)
 1011718:	e13ffa04 	addi	r4,fp,-24
 101171c:	e0bffd17 	ldw	r2,-12(fp)
 1011720:	d8800015 	stw	r2,0(sp)
 1011724:	01c00044 	movi	r7,1
 1011728:	000d883a 	mov	r6,zero
 101172c:	200b883a 	mov	r5,r4
 1011730:	1809883a 	mov	r4,r3
 1011734:	1012f2c0 	call	1012f2c <virtqueue_add_buffer>
	}
#endif /*VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 1011738:	e0bff917 	ldw	r2,-28(fp)
 101173c:	10800058 	cmpnei	r2,r2,1
 1011740:	1000071e 	bne	r2,zero,1011760 <rpmsg_virtio_return_buffer+0x98>
		(void)buffer;
		virtqueue_add_consumed_buffer(rvdev->rvq, idx, len);
 1011744:	e0bffc17 	ldw	r2,-16(fp)
 1011748:	10801b17 	ldw	r2,108(r2)
 101174c:	e0ffff0b 	ldhu	r3,-4(fp)
 1011750:	e1bffe17 	ldw	r6,-8(fp)
 1011754:	180b883a 	mov	r5,r3
 1011758:	1009883a 	mov	r4,r2
 101175c:	10133580 	call	1013358 <virtqueue_add_consumed_buffer>
	}
#endif /*VIRTIO_MASTER_ONLY*/
}
 1011760:	0001883a 	nop
 1011764:	e037883a 	mov	sp,fp
 1011768:	dfc00117 	ldw	ra,4(sp)
 101176c:	df000017 	ldw	fp,0(sp)
 1011770:	dec00204 	addi	sp,sp,8
 1011774:	f800283a 	ret

01011778 <rpmsg_virtio_enqueue_buffer>:
 * @return - status of function execution
 */
static int rpmsg_virtio_enqueue_buffer(struct rpmsg_virtio_device *rvdev,
				       void *buffer, uint32_t len,
				       uint16_t idx)
{
 1011778:	defff604 	addi	sp,sp,-40
 101177c:	dfc00915 	stw	ra,36(sp)
 1011780:	df000815 	stw	fp,32(sp)
 1011784:	df000804 	addi	fp,sp,32
 1011788:	e13ffc15 	stw	r4,-16(fp)
 101178c:	e17ffd15 	stw	r5,-12(fp)
 1011790:	e1bffe15 	stw	r6,-8(fp)
 1011794:	3805883a 	mov	r2,r7
 1011798:	e0bfff0d 	sth	r2,-4(fp)
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 101179c:	e13ffc17 	ldw	r4,-16(fp)
 10117a0:	101143c0 	call	101143c <rpmsg_virtio_get_role>
 10117a4:	e0bff915 	stw	r2,-28(fp)
#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 10117a8:	e0bff917 	ldw	r2,-28(fp)
 10117ac:	10000f1e 	bne	r2,zero,10117ec <rpmsg_virtio_enqueue_buffer+0x74>
		struct virtqueue_buf vqbuf;
		(void)idx;

		/* Initialize buffer node */
		vqbuf.buf = buffer;
 10117b0:	e0bffd17 	ldw	r2,-12(fp)
 10117b4:	e0bffa15 	stw	r2,-24(fp)
		vqbuf.len = len;
 10117b8:	e0bffe17 	ldw	r2,-8(fp)
 10117bc:	e0bffb15 	stw	r2,-20(fp)
		return virtqueue_add_buffer(rvdev->svq, &vqbuf, 1, 0, buffer);
 10117c0:	e0bffc17 	ldw	r2,-16(fp)
 10117c4:	10c01c17 	ldw	r3,112(r2)
 10117c8:	e13ffa04 	addi	r4,fp,-24
 10117cc:	e0bffd17 	ldw	r2,-12(fp)
 10117d0:	d8800015 	stw	r2,0(sp)
 10117d4:	000f883a 	mov	r7,zero
 10117d8:	01800044 	movi	r6,1
 10117dc:	200b883a 	mov	r5,r4
 10117e0:	1809883a 	mov	r4,r3
 10117e4:	1012f2c0 	call	1012f2c <virtqueue_add_buffer>
 10117e8:	00000c06 	br	101181c <rpmsg_virtio_enqueue_buffer+0xa4>
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 10117ec:	e0bff917 	ldw	r2,-28(fp)
 10117f0:	10800058 	cmpnei	r2,r2,1
 10117f4:	1000081e 	bne	r2,zero,1011818 <rpmsg_virtio_enqueue_buffer+0xa0>
		(void)buffer;
		return virtqueue_add_consumed_buffer(rvdev->svq, idx, len);
 10117f8:	e0bffc17 	ldw	r2,-16(fp)
 10117fc:	10801c17 	ldw	r2,112(r2)
 1011800:	e0ffff0b 	ldhu	r3,-4(fp)
 1011804:	e1bffe17 	ldw	r6,-8(fp)
 1011808:	180b883a 	mov	r5,r3
 101180c:	1009883a 	mov	r4,r2
 1011810:	10133580 	call	1013358 <virtqueue_add_consumed_buffer>
 1011814:	00000106 	br	101181c <rpmsg_virtio_enqueue_buffer+0xa4>
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	return 0;
 1011818:	0005883a 	mov	r2,zero
}
 101181c:	e037883a 	mov	sp,fp
 1011820:	dfc00117 	ldw	ra,4(sp)
 1011824:	df000017 	ldw	fp,0(sp)
 1011828:	dec00204 	addi	sp,sp,8
 101182c:	f800283a 	ret

01011830 <rpmsg_virtio_get_tx_buffer>:
 *
 * return - pointer to buffer.
 */
static void *rpmsg_virtio_get_tx_buffer(struct rpmsg_virtio_device *rvdev,
					uint32_t *len, uint16_t *idx)
{
 1011830:	defff904 	addi	sp,sp,-28
 1011834:	dfc00615 	stw	ra,24(sp)
 1011838:	df000515 	stw	fp,20(sp)
 101183c:	df000504 	addi	fp,sp,20
 1011840:	e13ffd15 	stw	r4,-12(fp)
 1011844:	e17ffe15 	stw	r5,-8(fp)
 1011848:	e1bfff15 	stw	r6,-4(fp)
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 101184c:	e13ffd17 	ldw	r4,-12(fp)
 1011850:	101143c0 	call	101143c <rpmsg_virtio_get_role>
 1011854:	e0bffc15 	stw	r2,-16(fp)
	void *data = NULL;
 1011858:	e03ffb15 	stw	zero,-20(fp)

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 101185c:	e0bffc17 	ldw	r2,-16(fp)
 1011860:	1000121e 	bne	r2,zero,10118ac <rpmsg_virtio_get_tx_buffer+0x7c>
		data = virtqueue_get_buffer(rvdev->svq, len, idx);
 1011864:	e0bffd17 	ldw	r2,-12(fp)
 1011868:	10801c17 	ldw	r2,112(r2)
 101186c:	e1bfff17 	ldw	r6,-4(fp)
 1011870:	e17ffe17 	ldw	r5,-8(fp)
 1011874:	1009883a 	mov	r4,r2
 1011878:	10130300 	call	1013030 <virtqueue_get_buffer>
 101187c:	e0bffb15 	stw	r2,-20(fp)
		if (data == NULL) {
 1011880:	e0bffb17 	ldw	r2,-20(fp)
 1011884:	1000091e 	bne	r2,zero,10118ac <rpmsg_virtio_get_tx_buffer+0x7c>
			data = rpmsg_virtio_shm_pool_get_buffer(rvdev->shpool,
 1011888:	e0bffd17 	ldw	r2,-12(fp)
 101188c:	10801e17 	ldw	r2,120(r2)
 1011890:	01408004 	movi	r5,512
 1011894:	1009883a 	mov	r4,r2
 1011898:	10115f00 	call	10115f0 <rpmsg_virtio_shm_pool_get_buffer>
 101189c:	e0bffb15 	stw	r2,-20(fp)
							RPMSG_BUFFER_SIZE);
			*len = RPMSG_BUFFER_SIZE;
 10118a0:	e0bffe17 	ldw	r2,-8(fp)
 10118a4:	00c08004 	movi	r3,512
 10118a8:	10c00015 	stw	r3,0(r2)
		}
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 10118ac:	e0bffc17 	ldw	r2,-16(fp)
 10118b0:	10800058 	cmpnei	r2,r2,1
 10118b4:	1000071e 	bne	r2,zero,10118d4 <rpmsg_virtio_get_tx_buffer+0xa4>
		data = virtqueue_get_available_buffer(rvdev->svq, idx, len);
 10118b8:	e0bffd17 	ldw	r2,-12(fp)
 10118bc:	10801c17 	ldw	r2,112(r2)
 10118c0:	e1bffe17 	ldw	r6,-8(fp)
 10118c4:	e17fff17 	ldw	r5,-4(fp)
 10118c8:	1009883a 	mov	r4,r2
 10118cc:	10132440 	call	1013244 <virtqueue_get_available_buffer>
 10118d0:	e0bffb15 	stw	r2,-20(fp)
	}
#endif /*!VIRTIO_MASTER_ONLY*/

	return data;
 10118d4:	e0bffb17 	ldw	r2,-20(fp)
}
 10118d8:	e037883a 	mov	sp,fp
 10118dc:	dfc00117 	ldw	ra,4(sp)
 10118e0:	df000017 	ldw	fp,0(sp)
 10118e4:	dec00204 	addi	sp,sp,8
 10118e8:	f800283a 	ret

010118ec <rpmsg_virtio_get_rx_buffer>:
 * @return - pointer to received buffer
 *
 */
static void *rpmsg_virtio_get_rx_buffer(struct rpmsg_virtio_device *rvdev,
					uint32_t *len, uint16_t *idx)
{
 10118ec:	defff904 	addi	sp,sp,-28
 10118f0:	dfc00615 	stw	ra,24(sp)
 10118f4:	df000515 	stw	fp,20(sp)
 10118f8:	df000504 	addi	fp,sp,20
 10118fc:	e13ffd15 	stw	r4,-12(fp)
 1011900:	e17ffe15 	stw	r5,-8(fp)
 1011904:	e1bfff15 	stw	r6,-4(fp)
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 1011908:	e13ffd17 	ldw	r4,-12(fp)
 101190c:	101143c0 	call	101143c <rpmsg_virtio_get_role>
 1011910:	e0bffc15 	stw	r2,-16(fp)
	void *data = NULL;
 1011914:	e03ffb15 	stw	zero,-20(fp)

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 1011918:	e0bffc17 	ldw	r2,-16(fp)
 101191c:	1000071e 	bne	r2,zero,101193c <rpmsg_virtio_get_rx_buffer+0x50>
		data = virtqueue_get_buffer(rvdev->rvq, len, idx);
 1011920:	e0bffd17 	ldw	r2,-12(fp)
 1011924:	10801b17 	ldw	r2,108(r2)
 1011928:	e1bfff17 	ldw	r6,-4(fp)
 101192c:	e17ffe17 	ldw	r5,-8(fp)
 1011930:	1009883a 	mov	r4,r2
 1011934:	10130300 	call	1013030 <virtqueue_get_buffer>
 1011938:	e0bffb15 	stw	r2,-20(fp)
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 101193c:	e0bffc17 	ldw	r2,-16(fp)
 1011940:	10800058 	cmpnei	r2,r2,1
 1011944:	1000071e 	bne	r2,zero,1011964 <rpmsg_virtio_get_rx_buffer+0x78>
		data =
		    virtqueue_get_available_buffer(rvdev->rvq, idx, len);
 1011948:	e0bffd17 	ldw	r2,-12(fp)
 101194c:	10801b17 	ldw	r2,108(r2)
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
		data =
 1011950:	e1bffe17 	ldw	r6,-8(fp)
 1011954:	e17fff17 	ldw	r5,-4(fp)
 1011958:	1009883a 	mov	r4,r2
 101195c:	10132440 	call	1013244 <virtqueue_get_available_buffer>
 1011960:	e0bffb15 	stw	r2,-20(fp)
		    virtqueue_get_available_buffer(rvdev->rvq, idx, len);
	}
#endif /*!VIRTIO_MASTER_ONLY*/

	return data;
 1011964:	e0bffb17 	ldw	r2,-20(fp)
}
 1011968:	e037883a 	mov	sp,fp
 101196c:	dfc00117 	ldw	ra,4(sp)
 1011970:	df000017 	ldw	fp,0(sp)
 1011974:	dec00204 	addi	sp,sp,8
 1011978:	f800283a 	ret

0101197c <rpmsg_virtio_wait_remote_ready>:
#ifndef VIRTIO_MASTER_ONLY
/**
 * check if the remote is ready to start RPMsg communication
 */
static int rpmsg_virtio_wait_remote_ready(struct rpmsg_virtio_device *rvdev)
{
 101197c:	defffc04 	addi	sp,sp,-16
 1011980:	dfc00315 	stw	ra,12(sp)
 1011984:	df000215 	stw	fp,8(sp)
 1011988:	df000204 	addi	fp,sp,8
 101198c:	e13fff15 	stw	r4,-4(fp)
	uint8_t status;

	while (1) {
		status = rpmsg_virtio_get_status(rvdev);
 1011990:	e13fff17 	ldw	r4,-4(fp)
 1011994:	10114c40 	call	10114c4 <rpmsg_virtio_get_status>
 1011998:	e0bffe05 	stb	r2,-8(fp)
		/* Busy wait until the remote is ready */
		if (status & VIRTIO_CONFIG_STATUS_NEEDS_RESET) {
 101199c:	e0bffe03 	ldbu	r2,-8(fp)
 10119a0:	1080100c 	andi	r2,r2,64
 10119a4:	10000426 	beq	r2,zero,10119b8 <rpmsg_virtio_wait_remote_ready+0x3c>
			rpmsg_virtio_set_status(rvdev, 0);
 10119a8:	000b883a 	mov	r5,zero
 10119ac:	e13fff17 	ldw	r4,-4(fp)
 10119b0:	10114680 	call	1011468 <rpmsg_virtio_set_status>
 10119b4:	00000506 	br	10119cc <rpmsg_virtio_wait_remote_ready+0x50>
			/* TODO notify remote processor */
		} else if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK) {
 10119b8:	e0bffe03 	ldbu	r2,-8(fp)
 10119bc:	1080010c 	andi	r2,r2,4
 10119c0:	10000226 	beq	r2,zero,10119cc <rpmsg_virtio_wait_remote_ready+0x50>
			return true;
 10119c4:	00800044 	movi	r2,1
 10119c8:	00000206 	br	10119d4 <rpmsg_virtio_wait_remote_ready+0x58>
		}
		/* TODO: clarify metal_cpu_yield usage*/
		metal_cpu_yield();
 10119cc:	0001883a 	nop
	}
 10119d0:	003fef06 	br	1011990 <__alt_data_end+0xff011990>

	return false;
}
 10119d4:	e037883a 	mov	sp,fp
 10119d8:	dfc00117 	ldw	ra,4(sp)
 10119dc:	df000017 	ldw	fp,0(sp)
 10119e0:	dec00204 	addi	sp,sp,8
 10119e4:	f800283a 	ret

010119e8 <_rpmsg_virtio_get_buffer_size>:
 *
 * @return - buffer size
 *
 */
static int _rpmsg_virtio_get_buffer_size(struct rpmsg_virtio_device *rvdev)
{
 10119e8:	defffb04 	addi	sp,sp,-20
 10119ec:	dfc00415 	stw	ra,16(sp)
 10119f0:	df000315 	stw	fp,12(sp)
 10119f4:	df000304 	addi	fp,sp,12
 10119f8:	e13fff15 	stw	r4,-4(fp)
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 10119fc:	e13fff17 	ldw	r4,-4(fp)
 1011a00:	101143c0 	call	101143c <rpmsg_virtio_get_role>
 1011a04:	e0bffe15 	stw	r2,-8(fp)
	int length = 0;
 1011a08:	e03ffd15 	stw	zero,-12(fp)

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 1011a0c:	e0bffe17 	ldw	r2,-8(fp)
 1011a10:	1000021e 	bne	r2,zero,1011a1c <_rpmsg_virtio_get_buffer_size+0x34>
		/*
		 * If device role is Master then buffers are provided by us,
		 * so just provide the macro.
		 */
		length = RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr);
 1011a14:	00807c04 	movi	r2,496
 1011a18:	e0bffd15 	stw	r2,-12(fp)
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 1011a1c:	e0bffe17 	ldw	r2,-8(fp)
 1011a20:	10800058 	cmpnei	r2,r2,1
 1011a24:	1000091e 	bne	r2,zero,1011a4c <_rpmsg_virtio_get_buffer_size+0x64>
		/*
		 * If other core is Master then buffers are provided by it,
		 * so get the buffer size from the virtqueue.
		 */
		length =
		    (int)virtqueue_get_desc_size(rvdev->svq) -
 1011a28:	e0bfff17 	ldw	r2,-4(fp)
 1011a2c:	10801c17 	ldw	r2,112(r2)
 1011a30:	1009883a 	mov	r4,r2
 1011a34:	10137100 	call	1013710 <virtqueue_get_desc_size>
 1011a38:	10bffc04 	addi	r2,r2,-16
	if (role == RPMSG_REMOTE) {
		/*
		 * If other core is Master then buffers are provided by it,
		 * so get the buffer size from the virtqueue.
		 */
		length =
 1011a3c:	e0bffd15 	stw	r2,-12(fp)
		    (int)virtqueue_get_desc_size(rvdev->svq) -
		    sizeof(struct rpmsg_hdr);
		if (length < 0) {
 1011a40:	e0bffd17 	ldw	r2,-12(fp)
 1011a44:	1000010e 	bge	r2,zero,1011a4c <_rpmsg_virtio_get_buffer_size+0x64>
			length = 0;
 1011a48:	e03ffd15 	stw	zero,-12(fp)
		}
	}
#endif /*!VIRTIO_MASTER_ONLY*/

	return length;
 1011a4c:	e0bffd17 	ldw	r2,-12(fp)
}
 1011a50:	e037883a 	mov	sp,fp
 1011a54:	dfc00117 	ldw	ra,4(sp)
 1011a58:	df000017 	ldw	fp,0(sp)
 1011a5c:	dec00204 	addi	sp,sp,8
 1011a60:	f800283a 	ret

01011a64 <rpmsg_virtio_send_offchannel_raw>:
 */
static int rpmsg_virtio_send_offchannel_raw(struct rpmsg_device *rdev,
					    uint32_t src, uint32_t dst,
					    const void *data,
					    int size, int wait)
{
 1011a64:	deffee04 	addi	sp,sp,-72
 1011a68:	dfc01115 	stw	ra,68(sp)
 1011a6c:	df001015 	stw	fp,64(sp)
 1011a70:	df001004 	addi	fp,sp,64
 1011a74:	e13ffc15 	stw	r4,-16(fp)
 1011a78:	e17ffd15 	stw	r5,-12(fp)
 1011a7c:	e1bffe15 	stw	r6,-8(fp)
 1011a80:	e1ffff15 	stw	r7,-4(fp)
	struct rpmsg_virtio_device *rvdev;
	struct rpmsg_hdr rp_hdr;
	void *buffer = NULL;
 1011a84:	e03ff015 	stw	zero,-64(fp)
	uint32_t buff_len;
	int status;
	struct metal_io_region *io;

	/* Get the associated remote device for channel. */
	rvdev = metal_container_of(rdev, struct rpmsg_virtio_device, rdev);
 1011a88:	e0bffc17 	ldw	r2,-16(fp)
 1011a8c:	e0bff215 	stw	r2,-56(fp)

	status = rpmsg_virtio_get_status(rvdev);
 1011a90:	e13ff217 	ldw	r4,-56(fp)
 1011a94:	10114c40 	call	10114c4 <rpmsg_virtio_get_status>
 1011a98:	10803fcc 	andi	r2,r2,255
 1011a9c:	e0bff315 	stw	r2,-52(fp)
	/* Validate device state */
	if (!(status & VIRTIO_CONFIG_STATUS_DRIVER_OK)) {
 1011aa0:	e0bff317 	ldw	r2,-52(fp)
 1011aa4:	1080010c 	andi	r2,r2,4
 1011aa8:	1000021e 	bne	r2,zero,1011ab4 <rpmsg_virtio_send_offchannel_raw+0x50>
		return RPMSG_ERR_DEV_STATE;
 1011aac:	00be0b04 	movi	r2,-2004
 1011ab0:	00006e06 	br	1011c6c <rpmsg_virtio_send_offchannel_raw+0x208>
	}

	if (wait)
 1011ab4:	e0800317 	ldw	r2,12(fp)
 1011ab8:	10000326 	beq	r2,zero,1011ac8 <rpmsg_virtio_send_offchannel_raw+0x64>
		tick_count = RPMSG_TICK_COUNT / RPMSG_TICKS_PER_INTERVAL;
 1011abc:	008ea604 	movi	r2,15000
 1011ac0:	e0bff115 	stw	r2,-60(fp)
 1011ac4:	00000106 	br	1011acc <rpmsg_virtio_send_offchannel_raw+0x68>
	else
		tick_count = 0;
 1011ac8:	e03ff115 	stw	zero,-60(fp)

	while (1) {
		int avail_size;

		/* Lock the device to enable exclusive access to virtqueues */
		metal_mutex_acquire(&rdev->lock);
 1011acc:	e0bffc17 	ldw	r2,-16(fp)
 1011ad0:	10801604 	addi	r2,r2,88
 1011ad4:	1009883a 	mov	r4,r2
 1011ad8:	10113400 	call	1011340 <metal_mutex_acquire>
		avail_size = _rpmsg_virtio_get_buffer_size(rvdev);
 1011adc:	e13ff217 	ldw	r4,-56(fp)
 1011ae0:	10119e80 	call	10119e8 <_rpmsg_virtio_get_buffer_size>
 1011ae4:	e0bff415 	stw	r2,-48(fp)
		if (size <= avail_size)
 1011ae8:	e0800217 	ldw	r2,8(fp)
 1011aec:	e0fff417 	ldw	r3,-48(fp)
 1011af0:	18800716 	blt	r3,r2,1011b10 <rpmsg_virtio_send_offchannel_raw+0xac>
			buffer = rpmsg_virtio_get_tx_buffer(rvdev, &buff_len,
 1011af4:	e0fffa04 	addi	r3,fp,-24
 1011af8:	e0bffb04 	addi	r2,fp,-20
 1011afc:	180d883a 	mov	r6,r3
 1011b00:	100b883a 	mov	r5,r2
 1011b04:	e13ff217 	ldw	r4,-56(fp)
 1011b08:	10118300 	call	1011830 <rpmsg_virtio_get_tx_buffer>
 1011b0c:	e0bff015 	stw	r2,-64(fp)
							    &idx);
		metal_mutex_release(&rdev->lock);
 1011b10:	e0bffc17 	ldw	r2,-16(fp)
 1011b14:	10801604 	addi	r2,r2,88
 1011b18:	1009883a 	mov	r4,r2
 1011b1c:	10113740 	call	1011374 <metal_mutex_release>
		if (buffer || !tick_count)
 1011b20:	e0bff017 	ldw	r2,-64(fp)
 1011b24:	10000c1e 	bne	r2,zero,1011b58 <rpmsg_virtio_send_offchannel_raw+0xf4>
 1011b28:	e0bff117 	ldw	r2,-60(fp)
 1011b2c:	10000a26 	beq	r2,zero,1011b58 <rpmsg_virtio_send_offchannel_raw+0xf4>
			break;
		if (avail_size != 0)
 1011b30:	e0bff417 	ldw	r2,-48(fp)
 1011b34:	10000226 	beq	r2,zero,1011b40 <rpmsg_virtio_send_offchannel_raw+0xdc>
			return RPMSG_ERR_BUFF_SIZE;
 1011b38:	00be0ac4 	movi	r2,-2005
 1011b3c:	00004b06 	br	1011c6c <rpmsg_virtio_send_offchannel_raw+0x208>
		metal_sleep_usec(RPMSG_TICKS_PER_INTERVAL);
 1011b40:	0100fa04 	movi	r4,1000
 1011b44:	10111040 	call	1011104 <metal_sleep_usec>
		tick_count--;
 1011b48:	e0bff117 	ldw	r2,-60(fp)
 1011b4c:	10bfffc4 	addi	r2,r2,-1
 1011b50:	e0bff115 	stw	r2,-60(fp)
	}
 1011b54:	003fdd06 	br	1011acc <__alt_data_end+0xff011acc>
	if (!buffer)
 1011b58:	e0bff017 	ldw	r2,-64(fp)
 1011b5c:	1000021e 	bne	r2,zero,1011b68 <rpmsg_virtio_send_offchannel_raw+0x104>
		return RPMSG_ERR_NO_BUFF;
 1011b60:	00be0b84 	movi	r2,-2002
 1011b64:	00004106 	br	1011c6c <rpmsg_virtio_send_offchannel_raw+0x208>

	/* Initialize RPMSG header. */
	rp_hdr.dst = dst;
 1011b68:	e0bffe17 	ldw	r2,-8(fp)
 1011b6c:	e0bff715 	stw	r2,-36(fp)
	rp_hdr.src = src;
 1011b70:	e0bffd17 	ldw	r2,-12(fp)
 1011b74:	e0bff615 	stw	r2,-40(fp)
	rp_hdr.len = size;
 1011b78:	e0800217 	ldw	r2,8(fp)
 1011b7c:	e0bff90d 	sth	r2,-28(fp)
	rp_hdr.reserved = 0;
 1011b80:	e03ff815 	stw	zero,-32(fp)

	/* Copy data to rpmsg buffer. */
	io = rvdev->shbuf_io;
 1011b84:	e0bff217 	ldw	r2,-56(fp)
 1011b88:	10801d17 	ldw	r2,116(r2)
 1011b8c:	e0bff515 	stw	r2,-44(fp)
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
 1011b90:	e17ff017 	ldw	r5,-64(fp)
 1011b94:	e13ff517 	ldw	r4,-44(fp)
 1011b98:	10111a80 	call	10111a8 <metal_io_virt_to_offset>
 1011b9c:	1007883a 	mov	r3,r2
 1011ba0:	e0bff604 	addi	r2,fp,-40
 1011ba4:	01c00404 	movi	r7,16
 1011ba8:	100d883a 	mov	r6,r2
 1011bac:	180b883a 	mov	r5,r3
 1011bb0:	e13ff517 	ldw	r4,-44(fp)
 1011bb4:	100839c0 	call	100839c <metal_io_block_write>
 1011bb8:	e0bff315 	stw	r2,-52(fp)
				      &rp_hdr, sizeof(rp_hdr));
	RPMSG_ASSERT(status == sizeof(rp_hdr), "failed to write header\r\n");
 1011bbc:	e0bff317 	ldw	r2,-52(fp)
 1011bc0:	10800420 	cmpeqi	r2,r2,16
 1011bc4:	1000011e 	bne	r2,zero,1011bcc <rpmsg_virtio_send_offchannel_raw+0x168>
 1011bc8:	003fff06 	br	1011bc8 <__alt_data_end+0xff011bc8>

	status = metal_io_block_write(io,
 1011bcc:	e0bff017 	ldw	r2,-64(fp)
 1011bd0:	10800404 	addi	r2,r2,16
 1011bd4:	100b883a 	mov	r5,r2
 1011bd8:	e13ff517 	ldw	r4,-44(fp)
 1011bdc:	10111a80 	call	10111a8 <metal_io_virt_to_offset>
 1011be0:	e1c00217 	ldw	r7,8(fp)
 1011be4:	e1bfff17 	ldw	r6,-4(fp)
 1011be8:	100b883a 	mov	r5,r2
 1011bec:	e13ff517 	ldw	r4,-44(fp)
 1011bf0:	100839c0 	call	100839c <metal_io_block_write>
 1011bf4:	e0bff315 	stw	r2,-52(fp)
				      metal_io_virt_to_offset(io,
				      RPMSG_LOCATE_DATA(buffer)),
				      data, size);
	RPMSG_ASSERT(status == size, "failed to write buffer\r\n");
 1011bf8:	e0fff317 	ldw	r3,-52(fp)
 1011bfc:	e0800217 	ldw	r2,8(fp)
 1011c00:	18800126 	beq	r3,r2,1011c08 <rpmsg_virtio_send_offchannel_raw+0x1a4>
 1011c04:	003fff06 	br	1011c04 <__alt_data_end+0xff011c04>
	metal_mutex_acquire(&rdev->lock);
 1011c08:	e0bffc17 	ldw	r2,-16(fp)
 1011c0c:	10801604 	addi	r2,r2,88
 1011c10:	1009883a 	mov	r4,r2
 1011c14:	10113400 	call	1011340 <metal_mutex_acquire>

	/* Enqueue buffer on virtqueue. */
	status = rpmsg_virtio_enqueue_buffer(rvdev, buffer, buff_len, idx);
 1011c18:	e0bffb17 	ldw	r2,-20(fp)
 1011c1c:	e0fffa0b 	ldhu	r3,-24(fp)
 1011c20:	18ffffcc 	andi	r3,r3,65535
 1011c24:	180f883a 	mov	r7,r3
 1011c28:	100d883a 	mov	r6,r2
 1011c2c:	e17ff017 	ldw	r5,-64(fp)
 1011c30:	e13ff217 	ldw	r4,-56(fp)
 1011c34:	10117780 	call	1011778 <rpmsg_virtio_enqueue_buffer>
 1011c38:	e0bff315 	stw	r2,-52(fp)
	RPMSG_ASSERT(status == VQUEUE_SUCCESS, "failed to enqueue buffer\r\n");
 1011c3c:	e0bff317 	ldw	r2,-52(fp)
 1011c40:	10000126 	beq	r2,zero,1011c48 <rpmsg_virtio_send_offchannel_raw+0x1e4>
 1011c44:	003fff06 	br	1011c44 <__alt_data_end+0xff011c44>
	/* Let the other side know that there is a job to process. */
	virtqueue_kick(rvdev->svq);
 1011c48:	e0bff217 	ldw	r2,-56(fp)
 1011c4c:	10801c17 	ldw	r2,112(r2)
 1011c50:	1009883a 	mov	r4,r2
 1011c54:	10135a00 	call	10135a0 <virtqueue_kick>

	metal_mutex_release(&rdev->lock);
 1011c58:	e0bffc17 	ldw	r2,-16(fp)
 1011c5c:	10801604 	addi	r2,r2,88
 1011c60:	1009883a 	mov	r4,r2
 1011c64:	10113740 	call	1011374 <metal_mutex_release>

	return size;
 1011c68:	e0800217 	ldw	r2,8(fp)
}
 1011c6c:	e037883a 	mov	sp,fp
 1011c70:	dfc00117 	ldw	ra,4(sp)
 1011c74:	df000017 	ldw	fp,0(sp)
 1011c78:	dec00204 	addi	sp,sp,8
 1011c7c:	f800283a 	ret

01011c80 <rpmsg_virtio_tx_callback>:
 * @param vq - pointer to virtqueue on which Tx is has been
 *             completed.
 *
 */
static void rpmsg_virtio_tx_callback(struct virtqueue *vq)
{
 1011c80:	defffe04 	addi	sp,sp,-8
 1011c84:	df000115 	stw	fp,4(sp)
 1011c88:	df000104 	addi	fp,sp,4
 1011c8c:	e13fff15 	stw	r4,-4(fp)
	(void)vq;
}
 1011c90:	0001883a 	nop
 1011c94:	e037883a 	mov	sp,fp
 1011c98:	df000017 	ldw	fp,0(sp)
 1011c9c:	dec00104 	addi	sp,sp,4
 1011ca0:	f800283a 	ret

01011ca4 <rpmsg_virtio_rx_callback>:
 *
 * @param vq - pointer to virtqueue on which messages is received
 *
 */
static void rpmsg_virtio_rx_callback(struct virtqueue *vq)
{
 1011ca4:	defff404 	addi	sp,sp,-48
 1011ca8:	dfc00b15 	stw	ra,44(sp)
 1011cac:	df000a15 	stw	fp,40(sp)
 1011cb0:	df000a04 	addi	fp,sp,40
 1011cb4:	e13fff15 	stw	r4,-4(fp)
	struct virtio_device *vdev = vq->vq_dev;
 1011cb8:	e0bfff17 	ldw	r2,-4(fp)
 1011cbc:	10800017 	ldw	r2,0(r2)
 1011cc0:	e0bff815 	stw	r2,-32(fp)
	struct rpmsg_virtio_device *rvdev = vdev->priv;
 1011cc4:	e0bff817 	ldw	r2,-32(fp)
 1011cc8:	10800817 	ldw	r2,32(r2)
 1011ccc:	e0bff915 	stw	r2,-28(fp)
	struct rpmsg_device *rdev = &rvdev->rdev;
 1011cd0:	e0bff917 	ldw	r2,-28(fp)
 1011cd4:	e0bffa15 	stw	r2,-24(fp)
	struct rpmsg_hdr *rp_hdr;
	uint32_t len;
	uint16_t idx;
	int status;

	metal_mutex_acquire(&rdev->lock);
 1011cd8:	e0bffa17 	ldw	r2,-24(fp)
 1011cdc:	10801604 	addi	r2,r2,88
 1011ce0:	1009883a 	mov	r4,r2
 1011ce4:	10113400 	call	1011340 <metal_mutex_acquire>

	/* Process the received data from remote node */
	rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
 1011ce8:	e0fffe04 	addi	r3,fp,-8
 1011cec:	e0bffd04 	addi	r2,fp,-12
 1011cf0:	180d883a 	mov	r6,r3
 1011cf4:	100b883a 	mov	r5,r2
 1011cf8:	e13ff917 	ldw	r4,-28(fp)
 1011cfc:	10118ec0 	call	10118ec <rpmsg_virtio_get_rx_buffer>
 1011d00:	e0bff715 	stw	r2,-36(fp)

	metal_mutex_release(&rdev->lock);
 1011d04:	e0bffa17 	ldw	r2,-24(fp)
 1011d08:	10801604 	addi	r2,r2,88
 1011d0c:	1009883a 	mov	r4,r2
 1011d10:	10113740 	call	1011374 <metal_mutex_release>

	while (rp_hdr) {
 1011d14:	00006906 	br	1011ebc <rpmsg_virtio_rx_callback+0x218>
		/* Get the channel node from the remote device channels list. */
		metal_mutex_acquire(&rdev->lock);
 1011d18:	e0bffa17 	ldw	r2,-24(fp)
 1011d1c:	10801604 	addi	r2,r2,88
 1011d20:	1009883a 	mov	r4,r2
 1011d24:	10113400 	call	1011340 <metal_mutex_acquire>
		ept = rpmsg_get_ept_from_addr(rdev, rp_hdr->dst);
 1011d28:	e0bff717 	ldw	r2,-36(fp)
 1011d2c:	10c00103 	ldbu	r3,4(r2)
 1011d30:	11000143 	ldbu	r4,5(r2)
 1011d34:	2008923a 	slli	r4,r4,8
 1011d38:	20c6b03a 	or	r3,r4,r3
 1011d3c:	11000183 	ldbu	r4,6(r2)
 1011d40:	2008943a 	slli	r4,r4,16
 1011d44:	20c6b03a 	or	r3,r4,r3
 1011d48:	108001c3 	ldbu	r2,7(r2)
 1011d4c:	1004963a 	slli	r2,r2,24
 1011d50:	10c4b03a 	or	r2,r2,r3
 1011d54:	100b883a 	mov	r5,r2
 1011d58:	e13ffa17 	ldw	r4,-24(fp)
 1011d5c:	10115b00 	call	10115b0 <rpmsg_get_ept_from_addr>
 1011d60:	e0bffb15 	stw	r2,-20(fp)
		metal_mutex_release(&rdev->lock);
 1011d64:	e0bffa17 	ldw	r2,-24(fp)
 1011d68:	10801604 	addi	r2,r2,88
 1011d6c:	1009883a 	mov	r4,r2
 1011d70:	10113740 	call	1011374 <metal_mutex_release>

		if (ept) {
 1011d74:	e0bffb17 	ldw	r2,-20(fp)
 1011d78:	10003326 	beq	r2,zero,1011e48 <rpmsg_virtio_rx_callback+0x1a4>
			if (ept->dest_addr == RPMSG_ADDR_ANY) {
 1011d7c:	e0bffb17 	ldw	r2,-20(fp)
 1011d80:	10800a17 	ldw	r2,40(r2)
 1011d84:	10bfffd8 	cmpnei	r2,r2,-1
 1011d88:	10000e1e 	bne	r2,zero,1011dc4 <rpmsg_virtio_rx_callback+0x120>
				/*
				 * First message received from the remote side,
				 * update channel destination address
				 */
				ept->dest_addr = rp_hdr->src;
 1011d8c:	e0bff717 	ldw	r2,-36(fp)
 1011d90:	10c00003 	ldbu	r3,0(r2)
 1011d94:	11000043 	ldbu	r4,1(r2)
 1011d98:	2008923a 	slli	r4,r4,8
 1011d9c:	20c6b03a 	or	r3,r4,r3
 1011da0:	11000083 	ldbu	r4,2(r2)
 1011da4:	2008943a 	slli	r4,r4,16
 1011da8:	20c6b03a 	or	r3,r4,r3
 1011dac:	108000c3 	ldbu	r2,3(r2)
 1011db0:	1004963a 	slli	r2,r2,24
 1011db4:	10c4b03a 	or	r2,r2,r3
 1011db8:	1007883a 	mov	r3,r2
 1011dbc:	e0bffb17 	ldw	r2,-20(fp)
 1011dc0:	10c00a15 	stw	r3,40(r2)
			}
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
 1011dc4:	e0bffb17 	ldw	r2,-20(fp)
 1011dc8:	10c00b17 	ldw	r3,44(r2)
 1011dcc:	e0bff717 	ldw	r2,-36(fp)
 1011dd0:	12000404 	addi	r8,r2,16
					 rp_hdr->len, rp_hdr->src, ept->priv);
 1011dd4:	e0bff717 	ldw	r2,-36(fp)
 1011dd8:	11000303 	ldbu	r4,12(r2)
 1011ddc:	10800343 	ldbu	r2,13(r2)
 1011de0:	1004923a 	slli	r2,r2,8
 1011de4:	1104b03a 	or	r2,r2,r4
				 * First message received from the remote side,
				 * update channel destination address
				 */
				ept->dest_addr = rp_hdr->src;
			}
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
 1011de8:	11bfffcc 	andi	r6,r2,65535
 1011dec:	e0bff717 	ldw	r2,-36(fp)
 1011df0:	11000003 	ldbu	r4,0(r2)
 1011df4:	11400043 	ldbu	r5,1(r2)
 1011df8:	280a923a 	slli	r5,r5,8
 1011dfc:	2908b03a 	or	r4,r5,r4
 1011e00:	11400083 	ldbu	r5,2(r2)
 1011e04:	280a943a 	slli	r5,r5,16
 1011e08:	2908b03a 	or	r4,r5,r4
 1011e0c:	108000c3 	ldbu	r2,3(r2)
 1011e10:	1004963a 	slli	r2,r2,24
 1011e14:	1104b03a 	or	r2,r2,r4
 1011e18:	1009883a 	mov	r4,r2
 1011e1c:	e0bffb17 	ldw	r2,-20(fp)
 1011e20:	10800f17 	ldw	r2,60(r2)
 1011e24:	d8800015 	stw	r2,0(sp)
 1011e28:	200f883a 	mov	r7,r4
 1011e2c:	400b883a 	mov	r5,r8
 1011e30:	e13ffb17 	ldw	r4,-20(fp)
 1011e34:	183ee83a 	callr	r3
 1011e38:	e0bffc15 	stw	r2,-16(fp)
					 rp_hdr->len, rp_hdr->src, ept->priv);

			RPMSG_ASSERT(status >= 0,
 1011e3c:	e0bffc17 	ldw	r2,-16(fp)
 1011e40:	1000010e 	bge	r2,zero,1011e48 <rpmsg_virtio_rx_callback+0x1a4>
 1011e44:	003fff06 	br	1011e44 <__alt_data_end+0xff011e44>
				     "unexpected callback status\r\n");
		}

		metal_mutex_acquire(&rdev->lock);
 1011e48:	e0bffa17 	ldw	r2,-24(fp)
 1011e4c:	10801604 	addi	r2,r2,88
 1011e50:	1009883a 	mov	r4,r2
 1011e54:	10113400 	call	1011340 <metal_mutex_acquire>

		/* Return used buffers. */
		rpmsg_virtio_return_buffer(rvdev, rp_hdr, len, idx);
 1011e58:	e0bffd17 	ldw	r2,-12(fp)
 1011e5c:	e0fffe0b 	ldhu	r3,-8(fp)
 1011e60:	18ffffcc 	andi	r3,r3,65535
 1011e64:	180f883a 	mov	r7,r3
 1011e68:	100d883a 	mov	r6,r2
 1011e6c:	e17ff717 	ldw	r5,-36(fp)
 1011e70:	e13ff917 	ldw	r4,-28(fp)
 1011e74:	10116c80 	call	10116c8 <rpmsg_virtio_return_buffer>

		rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
 1011e78:	e0fffe04 	addi	r3,fp,-8
 1011e7c:	e0bffd04 	addi	r2,fp,-12
 1011e80:	180d883a 	mov	r6,r3
 1011e84:	100b883a 	mov	r5,r2
 1011e88:	e13ff917 	ldw	r4,-28(fp)
 1011e8c:	10118ec0 	call	10118ec <rpmsg_virtio_get_rx_buffer>
 1011e90:	e0bff715 	stw	r2,-36(fp)
		if (rp_hdr == NULL) {
 1011e94:	e0bff717 	ldw	r2,-36(fp)
 1011e98:	1000041e 	bne	r2,zero,1011eac <rpmsg_virtio_rx_callback+0x208>
			/* tell peer we return some rx buffer */
			virtqueue_kick(rvdev->rvq);
 1011e9c:	e0bff917 	ldw	r2,-28(fp)
 1011ea0:	10801b17 	ldw	r2,108(r2)
 1011ea4:	1009883a 	mov	r4,r2
 1011ea8:	10135a00 	call	10135a0 <virtqueue_kick>
		}
		metal_mutex_release(&rdev->lock);
 1011eac:	e0bffa17 	ldw	r2,-24(fp)
 1011eb0:	10801604 	addi	r2,r2,88
 1011eb4:	1009883a 	mov	r4,r2
 1011eb8:	10113740 	call	1011374 <metal_mutex_release>
	/* Process the received data from remote node */
	rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);

	metal_mutex_release(&rdev->lock);

	while (rp_hdr) {
 1011ebc:	e0bff717 	ldw	r2,-36(fp)
 1011ec0:	103f951e 	bne	r2,zero,1011d18 <__alt_data_end+0xff011d18>
			/* tell peer we return some rx buffer */
			virtqueue_kick(rvdev->rvq);
		}
		metal_mutex_release(&rdev->lock);
	}
}
 1011ec4:	0001883a 	nop
 1011ec8:	e037883a 	mov	sp,fp
 1011ecc:	dfc00117 	ldw	ra,4(sp)
 1011ed0:	df000017 	ldw	fp,0(sp)
 1011ed4:	dec00204 	addi	sp,sp,8
 1011ed8:	f800283a 	ret

01011edc <rpmsg_virtio_ns_callback>:
 *
 * @return - rpmag endpoint callback handled
 */
static int rpmsg_virtio_ns_callback(struct rpmsg_endpoint *ept, void *data,
				    size_t len, uint32_t src, void *priv)
{
 1011edc:	deffec04 	addi	sp,sp,-80
 1011ee0:	dfc01315 	stw	ra,76(sp)
 1011ee4:	df001215 	stw	fp,72(sp)
 1011ee8:	df001204 	addi	fp,sp,72
 1011eec:	e13ffc15 	stw	r4,-16(fp)
 1011ef0:	e17ffd15 	stw	r5,-12(fp)
 1011ef4:	e1bffe15 	stw	r6,-8(fp)
 1011ef8:	e1ffff15 	stw	r7,-4(fp)
	struct rpmsg_device *rdev = ept->rdev;
 1011efc:	e0bffc17 	ldw	r2,-16(fp)
 1011f00:	10800817 	ldw	r2,32(r2)
 1011f04:	e0bfee15 	stw	r2,-72(fp)
	struct rpmsg_virtio_device *rvdev = (struct rpmsg_virtio_device *)rdev;
 1011f08:	e0bfee17 	ldw	r2,-72(fp)
 1011f0c:	e0bfef15 	stw	r2,-68(fp)
	struct metal_io_region *io = rvdev->shbuf_io;
 1011f10:	e0bfef17 	ldw	r2,-68(fp)
 1011f14:	10801d17 	ldw	r2,116(r2)
 1011f18:	e0bff015 	stw	r2,-64(fp)
	char name[RPMSG_NAME_SIZE];

	(void)priv;
	(void)src;

	ns_msg = data;
 1011f1c:	e0bffd17 	ldw	r2,-12(fp)
 1011f20:	e0bff115 	stw	r2,-60(fp)
	if (len != sizeof(*ns_msg))
 1011f24:	e0bffe17 	ldw	r2,-8(fp)
 1011f28:	10800a20 	cmpeqi	r2,r2,40
 1011f2c:	1000021e 	bne	r2,zero,1011f38 <rpmsg_virtio_ns_callback+0x5c>
		/* Returns as the message is corrupted */
		return RPMSG_SUCCESS;
 1011f30:	0005883a 	mov	r2,zero
 1011f34:	00005b06 	br	10120a4 <rpmsg_virtio_ns_callback+0x1c8>
	metal_io_block_read(io,
			    metal_io_virt_to_offset(io, ns_msg->name),
 1011f38:	e0bff117 	ldw	r2,-60(fp)

	ns_msg = data;
	if (len != sizeof(*ns_msg))
		/* Returns as the message is corrupted */
		return RPMSG_SUCCESS;
	metal_io_block_read(io,
 1011f3c:	100b883a 	mov	r5,r2
 1011f40:	e13ff017 	ldw	r4,-64(fp)
 1011f44:	10111a80 	call	10111a8 <metal_io_virt_to_offset>
 1011f48:	1007883a 	mov	r3,r2
 1011f4c:	e0bff404 	addi	r2,fp,-48
 1011f50:	01c00804 	movi	r7,32
 1011f54:	100d883a 	mov	r6,r2
 1011f58:	180b883a 	mov	r5,r3
 1011f5c:	e13ff017 	ldw	r4,-64(fp)
 1011f60:	10081e80 	call	10081e8 <metal_io_block_read>
			    metal_io_virt_to_offset(io, ns_msg->name),
			    &name, sizeof(name));
	dest = ns_msg->addr;
 1011f64:	e0bff117 	ldw	r2,-60(fp)
 1011f68:	10c00803 	ldbu	r3,32(r2)
 1011f6c:	11000843 	ldbu	r4,33(r2)
 1011f70:	2008923a 	slli	r4,r4,8
 1011f74:	20c6b03a 	or	r3,r4,r3
 1011f78:	11000883 	ldbu	r4,34(r2)
 1011f7c:	2008943a 	slli	r4,r4,16
 1011f80:	20c6b03a 	or	r3,r4,r3
 1011f84:	108008c3 	ldbu	r2,35(r2)
 1011f88:	1004963a 	slli	r2,r2,24
 1011f8c:	10c4b03a 	or	r2,r2,r3
 1011f90:	e0bff215 	stw	r2,-56(fp)

	/* check if a Ept has been locally registered */
	metal_mutex_acquire(&rdev->lock);
 1011f94:	e0bfee17 	ldw	r2,-72(fp)
 1011f98:	10801604 	addi	r2,r2,88
 1011f9c:	1009883a 	mov	r4,r2
 1011fa0:	10113400 	call	1011340 <metal_mutex_acquire>
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
 1011fa4:	e0bff404 	addi	r2,fp,-48
 1011fa8:	e1fff217 	ldw	r7,-56(fp)
 1011fac:	01bfffc4 	movi	r6,-1
 1011fb0:	100b883a 	mov	r5,r2
 1011fb4:	e13fee17 	ldw	r4,-72(fp)
 1011fb8:	1010c780 	call	1010c78 <rpmsg_get_endpoint>
 1011fbc:	e0bff315 	stw	r2,-52(fp)

	if (ns_msg->flags & RPMSG_NS_DESTROY) {
 1011fc0:	e0bff117 	ldw	r2,-60(fp)
 1011fc4:	10c00903 	ldbu	r3,36(r2)
 1011fc8:	11000943 	ldbu	r4,37(r2)
 1011fcc:	2008923a 	slli	r4,r4,8
 1011fd0:	20c6b03a 	or	r3,r4,r3
 1011fd4:	11000983 	ldbu	r4,38(r2)
 1011fd8:	2008943a 	slli	r4,r4,16
 1011fdc:	20c6b03a 	or	r3,r4,r3
 1011fe0:	108009c3 	ldbu	r2,39(r2)
 1011fe4:	1004963a 	slli	r2,r2,24
 1011fe8:	10c4b03a 	or	r2,r2,r3
 1011fec:	1080004c 	andi	r2,r2,1
 1011ff0:	10001326 	beq	r2,zero,1012040 <rpmsg_virtio_ns_callback+0x164>
		if (_ept)
 1011ff4:	e0bff317 	ldw	r2,-52(fp)
 1011ff8:	10000326 	beq	r2,zero,1012008 <rpmsg_virtio_ns_callback+0x12c>
			_ept->dest_addr = RPMSG_ADDR_ANY;
 1011ffc:	e0bff317 	ldw	r2,-52(fp)
 1012000:	00ffffc4 	movi	r3,-1
 1012004:	10c00a15 	stw	r3,40(r2)
		metal_mutex_release(&rdev->lock);
 1012008:	e0bfee17 	ldw	r2,-72(fp)
 101200c:	10801604 	addi	r2,r2,88
 1012010:	1009883a 	mov	r4,r2
 1012014:	10113740 	call	1011374 <metal_mutex_release>
		if (_ept && _ept->ns_unbind_cb)
 1012018:	e0bff317 	ldw	r2,-52(fp)
 101201c:	10002026 	beq	r2,zero,10120a0 <rpmsg_virtio_ns_callback+0x1c4>
 1012020:	e0bff317 	ldw	r2,-52(fp)
 1012024:	10800c17 	ldw	r2,48(r2)
 1012028:	10001d26 	beq	r2,zero,10120a0 <rpmsg_virtio_ns_callback+0x1c4>
			_ept->ns_unbind_cb(ept);
 101202c:	e0bff317 	ldw	r2,-52(fp)
 1012030:	10800c17 	ldw	r2,48(r2)
 1012034:	e13ffc17 	ldw	r4,-16(fp)
 1012038:	103ee83a 	callr	r2
 101203c:	00001806 	br	10120a0 <rpmsg_virtio_ns_callback+0x1c4>
	} else {
		if (!_ept) {
 1012040:	e0bff317 	ldw	r2,-52(fp)
 1012044:	10000f1e 	bne	r2,zero,1012084 <rpmsg_virtio_ns_callback+0x1a8>
			 * send callback to application, that can
			 * - create the associated endpoints.
			 * - store information for future use.
			 * - just ignore the request as service not supported.
			 */
			metal_mutex_release(&rdev->lock);
 1012048:	e0bfee17 	ldw	r2,-72(fp)
 101204c:	10801604 	addi	r2,r2,88
 1012050:	1009883a 	mov	r4,r2
 1012054:	10113740 	call	1011374 <metal_mutex_release>
			if (rdev->ns_bind_cb)
 1012058:	e0bfee17 	ldw	r2,-72(fp)
 101205c:	10801717 	ldw	r2,92(r2)
 1012060:	10000f26 	beq	r2,zero,10120a0 <rpmsg_virtio_ns_callback+0x1c4>
				rdev->ns_bind_cb(rdev, name, dest);
 1012064:	e0bfee17 	ldw	r2,-72(fp)
 1012068:	10801717 	ldw	r2,92(r2)
 101206c:	e0fff404 	addi	r3,fp,-48
 1012070:	e1bff217 	ldw	r6,-56(fp)
 1012074:	180b883a 	mov	r5,r3
 1012078:	e13fee17 	ldw	r4,-72(fp)
 101207c:	103ee83a 	callr	r2
 1012080:	00000706 	br	10120a0 <rpmsg_virtio_ns_callback+0x1c4>
		} else {
			_ept->dest_addr = dest;
 1012084:	e0bff317 	ldw	r2,-52(fp)
 1012088:	e0fff217 	ldw	r3,-56(fp)
 101208c:	10c00a15 	stw	r3,40(r2)
			metal_mutex_release(&rdev->lock);
 1012090:	e0bfee17 	ldw	r2,-72(fp)
 1012094:	10801604 	addi	r2,r2,88
 1012098:	1009883a 	mov	r4,r2
 101209c:	10113740 	call	1011374 <metal_mutex_release>
		}
	}

	return RPMSG_SUCCESS;
 10120a0:	0005883a 	mov	r2,zero
}
 10120a4:	e037883a 	mov	sp,fp
 10120a8:	dfc00117 	ldw	ra,4(sp)
 10120ac:	df000017 	ldw	fp,0(sp)
 10120b0:	dec00204 	addi	sp,sp,8
 10120b4:	f800283a 	ret

010120b8 <rpmsg_virtio_get_buffer_size>:

int rpmsg_virtio_get_buffer_size(struct rpmsg_device *rdev)
{
 10120b8:	defffb04 	addi	sp,sp,-20
 10120bc:	dfc00415 	stw	ra,16(sp)
 10120c0:	df000315 	stw	fp,12(sp)
 10120c4:	df000304 	addi	fp,sp,12
 10120c8:	e13fff15 	stw	r4,-4(fp)
	int size;
	struct rpmsg_virtio_device *rvdev;

	if (!rdev)
 10120cc:	e0bfff17 	ldw	r2,-4(fp)
 10120d0:	1000021e 	bne	r2,zero,10120dc <rpmsg_virtio_get_buffer_size+0x24>
		return RPMSG_ERR_PARAM;
 10120d4:	00be0b44 	movi	r2,-2003
 10120d8:	00000e06 	br	1012114 <rpmsg_virtio_get_buffer_size+0x5c>
	metal_mutex_acquire(&rdev->lock);
 10120dc:	e0bfff17 	ldw	r2,-4(fp)
 10120e0:	10801604 	addi	r2,r2,88
 10120e4:	1009883a 	mov	r4,r2
 10120e8:	10113400 	call	1011340 <metal_mutex_acquire>
	rvdev = (struct rpmsg_virtio_device *)rdev;
 10120ec:	e0bfff17 	ldw	r2,-4(fp)
 10120f0:	e0bffd15 	stw	r2,-12(fp)
	size = _rpmsg_virtio_get_buffer_size(rvdev);
 10120f4:	e13ffd17 	ldw	r4,-12(fp)
 10120f8:	10119e80 	call	10119e8 <_rpmsg_virtio_get_buffer_size>
 10120fc:	e0bffe15 	stw	r2,-8(fp)
	metal_mutex_release(&rdev->lock);
 1012100:	e0bfff17 	ldw	r2,-4(fp)
 1012104:	10801604 	addi	r2,r2,88
 1012108:	1009883a 	mov	r4,r2
 101210c:	10113740 	call	1011374 <metal_mutex_release>
	return size;
 1012110:	e0bffe17 	ldw	r2,-8(fp)
}
 1012114:	e037883a 	mov	sp,fp
 1012118:	dfc00117 	ldw	ra,4(sp)
 101211c:	df000017 	ldw	fp,0(sp)
 1012120:	dec00204 	addi	sp,sp,8
 1012124:	f800283a 	ret

01012128 <rpmsg_init_vdev>:
int rpmsg_init_vdev(struct rpmsg_virtio_device *rvdev,
		    struct virtio_device *vdev,
		    rpmsg_ns_bind_cb ns_bind_cb,
		    struct metal_io_region *shm_io,
		    struct rpmsg_virtio_shm_pool *shpool)
{
 1012128:	deffe704 	addi	sp,sp,-100
 101212c:	dfc01815 	stw	ra,96(sp)
 1012130:	df001715 	stw	fp,92(sp)
 1012134:	dcc01615 	stw	r19,88(sp)
 1012138:	dc801515 	stw	r18,84(sp)
 101213c:	dc401415 	stw	r17,80(sp)
 1012140:	dc001315 	stw	r16,76(sp)
 1012144:	df001704 	addi	fp,sp,92
 1012148:	e13ff815 	stw	r4,-32(fp)
 101214c:	e17ff915 	stw	r5,-28(fp)
 1012150:	e1bffa15 	stw	r6,-24(fp)
 1012154:	e1fffb15 	stw	r7,-20(fp)
	const char *vq_names[RPMSG_NUM_VRINGS];
	vq_callback *callback[RPMSG_NUM_VRINGS];
	int status;
	unsigned int i, role;

	rdev = &rvdev->rdev;
 1012158:	e0bff817 	ldw	r2,-32(fp)
 101215c:	e0bfee15 	stw	r2,-72(fp)
	memset(rdev, 0, sizeof(*rdev));
 1012160:	01801a04 	movi	r6,104
 1012164:	000b883a 	mov	r5,zero
 1012168:	e13fee17 	ldw	r4,-72(fp)
 101216c:	1015a3c0 	call	1015a3c <memset>
	metal_mutex_init(&rdev->lock);
 1012170:	e0bfee17 	ldw	r2,-72(fp)
 1012174:	10801604 	addi	r2,r2,88
 1012178:	1009883a 	mov	r4,r2
 101217c:	10112d80 	call	10112d8 <metal_mutex_init>
	rvdev->vdev = vdev;
 1012180:	e0bff817 	ldw	r2,-32(fp)
 1012184:	e0fff917 	ldw	r3,-28(fp)
 1012188:	10c01a15 	stw	r3,104(r2)
	rdev->ns_bind_cb = ns_bind_cb;
 101218c:	e0bfee17 	ldw	r2,-72(fp)
 1012190:	e0fffa17 	ldw	r3,-24(fp)
 1012194:	10c01715 	stw	r3,92(r2)
	vdev->priv = rvdev;
 1012198:	e0bff917 	ldw	r2,-28(fp)
 101219c:	e0fff817 	ldw	r3,-32(fp)
 10121a0:	10c00815 	stw	r3,32(r2)
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
 10121a4:	e0ffee17 	ldw	r3,-72(fp)
 10121a8:	00804074 	movhi	r2,257
 10121ac:	10869904 	addi	r2,r2,6756
 10121b0:	18801815 	stw	r2,96(r3)
	role = rpmsg_virtio_get_role(rvdev);
 10121b4:	e13ff817 	ldw	r4,-32(fp)
 10121b8:	101143c0 	call	101143c <rpmsg_virtio_get_role>
 10121bc:	e0bfef15 	stw	r2,-68(fp)

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 10121c0:	e0bfef17 	ldw	r2,-68(fp)
 10121c4:	10800058 	cmpnei	r2,r2,1
 10121c8:	1000021e 	bne	r2,zero,10121d4 <rpmsg_init_vdev+0xac>
		/* wait synchro with the master */
		rpmsg_virtio_wait_remote_ready(rvdev);
 10121cc:	e13ff817 	ldw	r4,-32(fp)
 10121d0:	101197c0 	call	101197c <rpmsg_virtio_wait_remote_ready>
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	vdev->features = rpmsg_virtio_get_features(rvdev);
 10121d4:	e13ff817 	ldw	r4,-32(fp)
 10121d8:	101150c0 	call	101150c <rpmsg_virtio_get_features>
 10121dc:	1025883a 	mov	r18,r2
 10121e0:	0027883a 	mov	r19,zero
 10121e4:	e0bff917 	ldw	r2,-28(fp)
 10121e8:	14800315 	stw	r18,12(r2)
 10121ec:	14c00415 	stw	r19,16(r2)
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
 10121f0:	e13ff917 	ldw	r4,-28(fp)
 10121f4:	20800317 	ldw	r2,12(r4)
 10121f8:	20c00417 	ldw	r3,16(r4)
 10121fc:	1400004c 	andi	r16,r2,1
 1012200:	1822703a 	and	r17,r3,zero
 1012204:	8444b03a 	or	r2,r16,r17
 1012208:	1004c03a 	cmpne	r2,r2,zero
 101220c:	1007883a 	mov	r3,r2
 1012210:	e0bfee17 	ldw	r2,-72(fp)
 1012214:	10c01905 	stb	r3,100(r2)

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 1012218:	e0bfef17 	ldw	r2,-68(fp)
 101221c:	1000231e 	bne	r2,zero,10122ac <rpmsg_init_vdev+0x184>
		/*
		 * Since device is RPMSG Remote so we need to manage the
		 * shared buffers. Create shared memory pool to handle buffers.
		 */
		if (!shpool)
 1012220:	e0800217 	ldw	r2,8(fp)
 1012224:	1000021e 	bne	r2,zero,1012230 <rpmsg_init_vdev+0x108>
			return RPMSG_ERR_PARAM;
 1012228:	00be0b44 	movi	r2,-2003
 101222c:	0000ad06 	br	10124e4 <rpmsg_init_vdev+0x3bc>
		if (!shpool->size)
 1012230:	e0800217 	ldw	r2,8(fp)
 1012234:	10800217 	ldw	r2,8(r2)
 1012238:	1000021e 	bne	r2,zero,1012244 <rpmsg_init_vdev+0x11c>
			return RPMSG_ERR_NO_BUFF;
 101223c:	00be0b84 	movi	r2,-2002
 1012240:	0000a806 	br	10124e4 <rpmsg_init_vdev+0x3bc>
		rvdev->shpool = shpool;
 1012244:	e0bff817 	ldw	r2,-32(fp)
 1012248:	e0c00217 	ldw	r3,8(fp)
 101224c:	10c01e15 	stw	r3,120(r2)

		vq_names[0] = "rx_vq";
 1012250:	008040f4 	movhi	r2,259
 1012254:	10a76f04 	addi	r2,r2,-25156
 1012258:	e0bff215 	stw	r2,-56(fp)
		vq_names[1] = "tx_vq";
 101225c:	008040f4 	movhi	r2,259
 1012260:	10a77104 	addi	r2,r2,-25148
 1012264:	e0bff315 	stw	r2,-52(fp)
		callback[0] = rpmsg_virtio_rx_callback;
 1012268:	00804074 	movhi	r2,257
 101226c:	10872904 	addi	r2,r2,7332
 1012270:	e0bff415 	stw	r2,-48(fp)
		callback[1] = rpmsg_virtio_tx_callback;
 1012274:	00804074 	movhi	r2,257
 1012278:	10872004 	addi	r2,r2,7296
 101227c:	e0bff515 	stw	r2,-44(fp)
		rvdev->rvq  = vdev->vrings_info[0].vq;
 1012280:	e0bff917 	ldw	r2,-28(fp)
 1012284:	10800a17 	ldw	r2,40(r2)
 1012288:	10c00017 	ldw	r3,0(r2)
 101228c:	e0bff817 	ldw	r2,-32(fp)
 1012290:	10c01b15 	stw	r3,108(r2)
		rvdev->svq  = vdev->vrings_info[1].vq;
 1012294:	e0bff917 	ldw	r2,-28(fp)
 1012298:	10800a17 	ldw	r2,40(r2)
 101229c:	10800604 	addi	r2,r2,24
 10122a0:	10c00017 	ldw	r3,0(r2)
 10122a4:	e0bff817 	ldw	r2,-32(fp)
 10122a8:	10c01c15 	stw	r3,112(r2)
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	(void)shpool;
	if (role == RPMSG_REMOTE) {
 10122ac:	e0bfef17 	ldw	r2,-68(fp)
 10122b0:	10800058 	cmpnei	r2,r2,1
 10122b4:	1000171e 	bne	r2,zero,1012314 <rpmsg_init_vdev+0x1ec>
		vq_names[0] = "tx_vq";
 10122b8:	008040f4 	movhi	r2,259
 10122bc:	10a77104 	addi	r2,r2,-25148
 10122c0:	e0bff215 	stw	r2,-56(fp)
		vq_names[1] = "rx_vq";
 10122c4:	008040f4 	movhi	r2,259
 10122c8:	10a76f04 	addi	r2,r2,-25156
 10122cc:	e0bff315 	stw	r2,-52(fp)
		callback[0] = rpmsg_virtio_tx_callback;
 10122d0:	00804074 	movhi	r2,257
 10122d4:	10872004 	addi	r2,r2,7296
 10122d8:	e0bff415 	stw	r2,-48(fp)
		callback[1] = rpmsg_virtio_rx_callback;
 10122dc:	00804074 	movhi	r2,257
 10122e0:	10872904 	addi	r2,r2,7332
 10122e4:	e0bff515 	stw	r2,-44(fp)
		rvdev->rvq  = vdev->vrings_info[1].vq;
 10122e8:	e0bff917 	ldw	r2,-28(fp)
 10122ec:	10800a17 	ldw	r2,40(r2)
 10122f0:	10800604 	addi	r2,r2,24
 10122f4:	10c00017 	ldw	r3,0(r2)
 10122f8:	e0bff817 	ldw	r2,-32(fp)
 10122fc:	10c01b15 	stw	r3,108(r2)
		rvdev->svq  = vdev->vrings_info[0].vq;
 1012300:	e0bff917 	ldw	r2,-28(fp)
 1012304:	10800a17 	ldw	r2,40(r2)
 1012308:	10c00017 	ldw	r3,0(r2)
 101230c:	e0bff817 	ldw	r2,-32(fp)
 1012310:	10c01c15 	stw	r3,112(r2)
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	rvdev->shbuf_io = shm_io;
 1012314:	e0bff817 	ldw	r2,-32(fp)
 1012318:	e0fffb17 	ldw	r3,-20(fp)
 101231c:	10c01d15 	stw	r3,116(r2)

	/* Create virtqueues for remote device */
	status = rpmsg_virtio_create_virtqueues(rvdev, 0, RPMSG_NUM_VRINGS,
 1012320:	e0fff204 	addi	r3,fp,-56
 1012324:	e0bff404 	addi	r2,fp,-48
 1012328:	d8800015 	stw	r2,0(sp)
 101232c:	180f883a 	mov	r7,r3
 1012330:	01800084 	movi	r6,2
 1012334:	000b883a 	mov	r5,zero
 1012338:	e13ff817 	ldw	r4,-32(fp)
 101233c:	10115540 	call	1011554 <rpmsg_virtio_create_virtqueues>
 1012340:	e0bfeb15 	stw	r2,-84(fp)
						vq_names, callback);
	if (status != RPMSG_SUCCESS)
 1012344:	e0bfeb17 	ldw	r2,-84(fp)
 1012348:	10000226 	beq	r2,zero,1012354 <rpmsg_init_vdev+0x22c>
		return status;
 101234c:	e0bfeb17 	ldw	r2,-84(fp)
 1012350:	00006406 	br	10124e4 <rpmsg_init_vdev+0x3bc>

	/*
	 * Suppress "tx-complete" interrupts
	 * since send method use busy loop when buffer pool exhaust
	 */
	virtqueue_disable_cb(rvdev->svq);
 1012354:	e0bff817 	ldw	r2,-32(fp)
 1012358:	10801c17 	ldw	r2,112(r2)
 101235c:	1009883a 	mov	r4,r2
 1012360:	10134640 	call	1013464 <virtqueue_disable_cb>

	/* TODO: can have a virtio function to set the shared memory I/O */
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
 1012364:	e03fec15 	stw	zero,-80(fp)
 1012368:	00000d06 	br	10123a0 <rpmsg_init_vdev+0x278>
		struct virtqueue *vq;

		vq = vdev->vrings_info[i].vq;
 101236c:	e0bff917 	ldw	r2,-28(fp)
 1012370:	10c00a17 	ldw	r3,40(r2)
 1012374:	e0bfec17 	ldw	r2,-80(fp)
 1012378:	10800624 	muli	r2,r2,24
 101237c:	1885883a 	add	r2,r3,r2
 1012380:	10800017 	ldw	r2,0(r2)
 1012384:	e0bff015 	stw	r2,-64(fp)
		vq->shm_io = shm_io;
 1012388:	e0bff017 	ldw	r2,-64(fp)
 101238c:	e0fffb17 	ldw	r3,-20(fp)
 1012390:	10c00a15 	stw	r3,40(r2)
	 * since send method use busy loop when buffer pool exhaust
	 */
	virtqueue_disable_cb(rvdev->svq);

	/* TODO: can have a virtio function to set the shared memory I/O */
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
 1012394:	e0bfec17 	ldw	r2,-80(fp)
 1012398:	10800044 	addi	r2,r2,1
 101239c:	e0bfec15 	stw	r2,-80(fp)
 10123a0:	e0bfec17 	ldw	r2,-80(fp)
 10123a4:	108000b0 	cmpltui	r2,r2,2
 10123a8:	103ff01e 	bne	r2,zero,101236c <__alt_data_end+0xff01236c>
		vq = vdev->vrings_info[i].vq;
		vq->shm_io = shm_io;
	}

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 10123ac:	e0bfef17 	ldw	r2,-68(fp)
 10123b0:	10002e1e 	bne	r2,zero,101246c <rpmsg_init_vdev+0x344>
		struct virtqueue_buf vqbuf;
		unsigned int idx;
		void *buffer;

		vqbuf.len = RPMSG_BUFFER_SIZE;
 10123b4:	00808004 	movi	r2,512
 10123b8:	e0bff715 	stw	r2,-36(fp)
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
 10123bc:	e03fed15 	stw	zero,-76(fp)
 10123c0:	00002406 	br	1012454 <rpmsg_init_vdev+0x32c>
			/* Initialize TX virtqueue buffers for remote device */
			buffer = rpmsg_virtio_shm_pool_get_buffer(shpool,
 10123c4:	01408004 	movi	r5,512
 10123c8:	e1000217 	ldw	r4,8(fp)
 10123cc:	10115f00 	call	10115f0 <rpmsg_virtio_shm_pool_get_buffer>
 10123d0:	e0bff115 	stw	r2,-60(fp)
							RPMSG_BUFFER_SIZE);

			if (!buffer) {
 10123d4:	e0bff117 	ldw	r2,-60(fp)
 10123d8:	1000021e 	bne	r2,zero,10123e4 <rpmsg_init_vdev+0x2bc>
				return RPMSG_ERR_NO_BUFF;
 10123dc:	00be0b84 	movi	r2,-2002
 10123e0:	00004006 	br	10124e4 <rpmsg_init_vdev+0x3bc>
			}

			vqbuf.buf = buffer;
 10123e4:	e0bff117 	ldw	r2,-60(fp)
 10123e8:	e0bff615 	stw	r2,-40(fp)

			metal_io_block_set(shm_io,
 10123ec:	e17ff117 	ldw	r5,-60(fp)
 10123f0:	e13ffb17 	ldw	r4,-20(fp)
 10123f4:	10111a80 	call	10111a8 <metal_io_virt_to_offset>
 10123f8:	01c08004 	movi	r7,512
 10123fc:	000d883a 	mov	r6,zero
 1012400:	100b883a 	mov	r5,r2
 1012404:	e13ffb17 	ldw	r4,-20(fp)
 1012408:	100854c0 	call	100854c <metal_io_block_set>
					   metal_io_virt_to_offset(shm_io,
								   buffer),
					   0x00, RPMSG_BUFFER_SIZE);
			status =
				virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1,
 101240c:	e0bff817 	ldw	r2,-32(fp)
 1012410:	10c01b17 	ldw	r3,108(r2)

			metal_io_block_set(shm_io,
					   metal_io_virt_to_offset(shm_io,
								   buffer),
					   0x00, RPMSG_BUFFER_SIZE);
			status =
 1012414:	e13ff604 	addi	r4,fp,-40
 1012418:	e0bff117 	ldw	r2,-60(fp)
 101241c:	d8800015 	stw	r2,0(sp)
 1012420:	01c00044 	movi	r7,1
 1012424:	000d883a 	mov	r6,zero
 1012428:	200b883a 	mov	r5,r4
 101242c:	1809883a 	mov	r4,r3
 1012430:	1012f2c0 	call	1012f2c <virtqueue_add_buffer>
 1012434:	e0bfeb15 	stw	r2,-84(fp)
				virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1,
						     buffer);

			if (status != RPMSG_SUCCESS) {
 1012438:	e0bfeb17 	ldw	r2,-84(fp)
 101243c:	10000226 	beq	r2,zero,1012448 <rpmsg_init_vdev+0x320>
				return status;
 1012440:	e0bfeb17 	ldw	r2,-84(fp)
 1012444:	00002706 	br	10124e4 <rpmsg_init_vdev+0x3bc>
		struct virtqueue_buf vqbuf;
		unsigned int idx;
		void *buffer;

		vqbuf.len = RPMSG_BUFFER_SIZE;
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
 1012448:	e0bfed17 	ldw	r2,-76(fp)
 101244c:	10800044 	addi	r2,r2,1
 1012450:	e0bfed15 	stw	r2,-76(fp)
 1012454:	e0bff817 	ldw	r2,-32(fp)
 1012458:	10801b17 	ldw	r2,108(r2)
 101245c:	1080028b 	ldhu	r2,10(r2)
 1012460:	10bfffcc 	andi	r2,r2,65535
 1012464:	e0ffed17 	ldw	r3,-76(fp)
 1012468:	18bfd636 	bltu	r3,r2,10123c4 <__alt_data_end+0xff0123c4>
		}
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

	/* Initialize channels and endpoints list */
	metal_list_init(&rdev->endpoints);
 101246c:	e0bfee17 	ldw	r2,-72(fp)
 1012470:	1009883a 	mov	r4,r2
 1012474:	10111340 	call	1011134 <metal_list_init>

	/*
	 * Create name service announcement endpoint if device supports name
	 * service announcement feature.
	 */
	if (rdev->support_ns) {
 1012478:	e0bfee17 	ldw	r2,-72(fp)
 101247c:	10801903 	ldbu	r2,100(r2)
 1012480:	10803fcc 	andi	r2,r2,255
 1012484:	10001126 	beq	r2,zero,10124cc <rpmsg_init_vdev+0x3a4>
		rpmsg_init_ept(&rdev->ns_ept, "NS",
 1012488:	e0bfee17 	ldw	r2,-72(fp)
 101248c:	10c00204 	addi	r3,r2,8
 1012490:	d8000115 	stw	zero,4(sp)
 1012494:	00804074 	movhi	r2,257
 1012498:	1087b704 	addi	r2,r2,7900
 101249c:	d8800015 	stw	r2,0(sp)
 10124a0:	01c00d44 	movi	r7,53
 10124a4:	01800d44 	movi	r6,53
 10124a8:	014040f4 	movhi	r5,259
 10124ac:	29677304 	addi	r5,r5,-25140
 10124b0:	1809883a 	mov	r4,r3
 10124b4:	10113a80 	call	10113a8 <rpmsg_init_ept>
			       RPMSG_NS_EPT_ADDR, RPMSG_NS_EPT_ADDR,
			       rpmsg_virtio_ns_callback, NULL);
		rpmsg_register_endpoint(rdev, &rdev->ns_ept);
 10124b8:	e0bfee17 	ldw	r2,-72(fp)
 10124bc:	10800204 	addi	r2,r2,8
 10124c0:	100b883a 	mov	r5,r2
 10124c4:	e13fee17 	ldw	r4,-72(fp)
 10124c8:	1010e3c0 	call	1010e3c <rpmsg_register_endpoint>
	}

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER)
 10124cc:	e0bfef17 	ldw	r2,-68(fp)
 10124d0:	1000031e 	bne	r2,zero,10124e0 <rpmsg_init_vdev+0x3b8>
		rpmsg_virtio_set_status(rvdev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
 10124d4:	01400104 	movi	r5,4
 10124d8:	e13ff817 	ldw	r4,-32(fp)
 10124dc:	10114680 	call	1011468 <rpmsg_virtio_set_status>
#endif /*!VIRTIO_SLAVE_ONLY*/

	return status;
 10124e0:	e0bfeb17 	ldw	r2,-84(fp)
}
 10124e4:	e6fffc04 	addi	sp,fp,-16
 10124e8:	dfc00517 	ldw	ra,20(sp)
 10124ec:	df000417 	ldw	fp,16(sp)
 10124f0:	dcc00317 	ldw	r19,12(sp)
 10124f4:	dc800217 	ldw	r18,8(sp)
 10124f8:	dc400117 	ldw	r17,4(sp)
 10124fc:	dc000017 	ldw	r16,0(sp)
 1012500:	dec00604 	addi	sp,sp,24
 1012504:	f800283a 	ret

01012508 <rpmsg_deinit_vdev>:

void rpmsg_deinit_vdev(struct rpmsg_virtio_device *rvdev)
{
 1012508:	defffa04 	addi	sp,sp,-24
 101250c:	dfc00515 	stw	ra,20(sp)
 1012510:	df000415 	stw	fp,16(sp)
 1012514:	df000404 	addi	fp,sp,16
 1012518:	e13fff15 	stw	r4,-4(fp)
	struct metal_list *node;
	struct rpmsg_device *rdev;
	struct rpmsg_endpoint *ept;

	rdev = &rvdev->rdev;
 101251c:	e0bfff17 	ldw	r2,-4(fp)
 1012520:	e0bffc15 	stw	r2,-16(fp)
	while (!metal_list_is_empty(&rdev->endpoints)) {
 1012524:	00000806 	br	1012548 <rpmsg_deinit_vdev+0x40>
		node = rdev->endpoints.next;
 1012528:	e0bffc17 	ldw	r2,-16(fp)
 101252c:	10800017 	ldw	r2,0(r2)
 1012530:	e0bffd15 	stw	r2,-12(fp)
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
 1012534:	e0bffd17 	ldw	r2,-12(fp)
 1012538:	10bff304 	addi	r2,r2,-52
 101253c:	e0bffe15 	stw	r2,-8(fp)
		rpmsg_destroy_ept(ept);
 1012540:	e13ffe17 	ldw	r4,-8(fp)
 1012544:	10110180 	call	1011018 <rpmsg_destroy_ept>
	struct metal_list *node;
	struct rpmsg_device *rdev;
	struct rpmsg_endpoint *ept;

	rdev = &rvdev->rdev;
	while (!metal_list_is_empty(&rdev->endpoints)) {
 1012548:	e0bffc17 	ldw	r2,-16(fp)
 101254c:	1009883a 	mov	r4,r2
 1012550:	10111740 	call	1011174 <metal_list_is_empty>
 1012554:	103ff426 	beq	r2,zero,1012528 <__alt_data_end+0xff012528>
		node = rdev->endpoints.next;
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
		rpmsg_destroy_ept(ept);
	}

	rvdev->rvq = 0;
 1012558:	e0bfff17 	ldw	r2,-4(fp)
 101255c:	10001b15 	stw	zero,108(r2)
	rvdev->svq = 0;
 1012560:	e0bfff17 	ldw	r2,-4(fp)
 1012564:	10001c15 	stw	zero,112(r2)

	metal_mutex_deinit(&rdev->lock);
 1012568:	e0bffc17 	ldw	r2,-16(fp)
 101256c:	10801604 	addi	r2,r2,88
 1012570:	1009883a 	mov	r4,r2
 1012574:	101130c0 	call	101130c <metal_mutex_deinit>
}
 1012578:	0001883a 	nop
 101257c:	e037883a 	mov	sp,fp
 1012580:	dfc00117 	ldw	ra,4(sp)
 1012584:	df000017 	ldw	fp,0(sp)
 1012588:	dec00204 	addi	sp,sp,8
 101258c:	f800283a 	ret

01012590 <vring_size>:
 */
#define vring_used_event(vr)	((vr)->avail->ring[(vr)->num])
#define vring_avail_event(vr)	((vr)->used->ring[(vr)->num].event)

static inline int vring_size(unsigned int num, unsigned long align)
{
 1012590:	defffc04 	addi	sp,sp,-16
 1012594:	df000315 	stw	fp,12(sp)
 1012598:	df000304 	addi	fp,sp,12
 101259c:	e13ffe15 	stw	r4,-8(fp)
 10125a0:	e17fff15 	stw	r5,-4(fp)
	int size;

	size = num * sizeof(struct vring_desc);
 10125a4:	e0bffe17 	ldw	r2,-8(fp)
 10125a8:	1004913a 	slli	r2,r2,4
 10125ac:	e0bffd15 	stw	r2,-12(fp)
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
 10125b0:	e0bffe17 	ldw	r2,-8(fp)
 10125b4:	108000c4 	addi	r2,r2,3
 10125b8:	1085883a 	add	r2,r2,r2
 10125bc:	1007883a 	mov	r3,r2
 10125c0:	e0bffd17 	ldw	r2,-12(fp)
 10125c4:	1885883a 	add	r2,r3,r2
 10125c8:	e0bffd15 	stw	r2,-12(fp)
	    sizeof(uint16_t);
	size = (size + align - 1) & ~(align - 1);
 10125cc:	e0fffd17 	ldw	r3,-12(fp)
 10125d0:	e0bfff17 	ldw	r2,-4(fp)
 10125d4:	1885883a 	add	r2,r3,r2
 10125d8:	10ffffc4 	addi	r3,r2,-1
 10125dc:	e0bfff17 	ldw	r2,-4(fp)
 10125e0:	0085c83a 	sub	r2,zero,r2
 10125e4:	1884703a 	and	r2,r3,r2
 10125e8:	e0bffd15 	stw	r2,-12(fp)
	size += sizeof(struct vring_used) +
	    (num * sizeof(struct vring_used_elem)) + sizeof(uint16_t);
 10125ec:	e0bffe17 	ldw	r2,-8(fp)
 10125f0:	100690fa 	slli	r3,r2,3

	size = num * sizeof(struct vring_desc);
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
	    sizeof(uint16_t);
	size = (size + align - 1) & ~(align - 1);
	size += sizeof(struct vring_used) +
 10125f4:	e0bffd17 	ldw	r2,-12(fp)
 10125f8:	1885883a 	add	r2,r3,r2
 10125fc:	10800184 	addi	r2,r2,6
 1012600:	e0bffd15 	stw	r2,-12(fp)
	    (num * sizeof(struct vring_used_elem)) + sizeof(uint16_t);

	return size;
 1012604:	e0bffd17 	ldw	r2,-12(fp)
}
 1012608:	e037883a 	mov	sp,fp
 101260c:	df000017 	ldw	fp,0(sp)
 1012610:	dec00104 	addi	sp,sp,4
 1012614:	f800283a 	ret

01012618 <metal_io_virt_to_offset>:
 * @param[in]	virt	Virtual address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
 1012618:	defffc04 	addi	sp,sp,-16
 101261c:	df000315 	stw	fp,12(sp)
 1012620:	df000304 	addi	fp,sp,12
 1012624:	e13ffe15 	stw	r4,-8(fp)
 1012628:	e17fff15 	stw	r5,-4(fp)
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 101262c:	e0bfff17 	ldw	r2,-4(fp)
 1012630:	e0fffe17 	ldw	r3,-8(fp)
 1012634:	18c00017 	ldw	r3,0(r3)
 1012638:	10c5c83a 	sub	r2,r2,r3
 101263c:	e0bffd15 	stw	r2,-12(fp)
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1012640:	e0bffe17 	ldw	r2,-8(fp)
 1012644:	10800217 	ldw	r2,8(r2)
 1012648:	e0fffd17 	ldw	r3,-12(fp)
 101264c:	1880022e 	bgeu	r3,r2,1012658 <metal_io_virt_to_offset+0x40>
 1012650:	e0bffd17 	ldw	r2,-12(fp)
 1012654:	00000106 	br	101265c <metal_io_virt_to_offset+0x44>
 1012658:	00bfffc4 	movi	r2,-1
}
 101265c:	e037883a 	mov	sp,fp
 1012660:	df000017 	ldw	fp,0(sp)
 1012664:	dec00104 	addi	sp,sp,4
 1012668:	f800283a 	ret

0101266c <virtio_dev_name>:

	{0, NULL}
};

const char *virtio_dev_name(unsigned short devid)
{
 101266c:	defffd04 	addi	sp,sp,-12
 1012670:	df000215 	stw	fp,8(sp)
 1012674:	df000204 	addi	fp,sp,8
 1012678:	2005883a 	mov	r2,r4
 101267c:	e0bfff0d 	sth	r2,-4(fp)
	const struct virtio_ident *ident;

	for (ident = virtio_ident_table; ident->name != NULL; ident++) {
 1012680:	008040f4 	movhi	r2,259
 1012684:	10a78704 	addi	r2,r2,-25060
 1012688:	e0bffe15 	stw	r2,-8(fp)
 101268c:	00000b06 	br	10126bc <virtio_dev_name+0x50>
		if (ident->devid == devid)
 1012690:	e0bffe17 	ldw	r2,-8(fp)
 1012694:	1080000b 	ldhu	r2,0(r2)
 1012698:	10ffffcc 	andi	r3,r2,65535
 101269c:	e0bfff0b 	ldhu	r2,-4(fp)
 10126a0:	1880031e 	bne	r3,r2,10126b0 <virtio_dev_name+0x44>
			return ident->name;
 10126a4:	e0bffe17 	ldw	r2,-8(fp)
 10126a8:	10800117 	ldw	r2,4(r2)
 10126ac:	00000706 	br	10126cc <virtio_dev_name+0x60>

const char *virtio_dev_name(unsigned short devid)
{
	const struct virtio_ident *ident;

	for (ident = virtio_ident_table; ident->name != NULL; ident++) {
 10126b0:	e0bffe17 	ldw	r2,-8(fp)
 10126b4:	10800204 	addi	r2,r2,8
 10126b8:	e0bffe15 	stw	r2,-8(fp)
 10126bc:	e0bffe17 	ldw	r2,-8(fp)
 10126c0:	10800117 	ldw	r2,4(r2)
 10126c4:	103ff21e 	bne	r2,zero,1012690 <__alt_data_end+0xff012690>
		if (ident->devid == devid)
			return ident->name;
	}

	return NULL;
 10126c8:	0005883a 	mov	r2,zero
}
 10126cc:	e037883a 	mov	sp,fp
 10126d0:	df000017 	ldw	fp,0(sp)
 10126d4:	dec00104 	addi	sp,sp,4
 10126d8:	f800283a 	ret

010126dc <virtio_feature_name>:

static const char *virtio_feature_name(unsigned long val,
				       const struct virtio_feature_desc *desc)
{
 10126dc:	defff904 	addi	sp,sp,-28
 10126e0:	df000615 	stw	fp,24(sp)
 10126e4:	df000604 	addi	fp,sp,24
 10126e8:	e13ffe15 	stw	r4,-8(fp)
 10126ec:	e17fff15 	stw	r5,-4(fp)
	int i, j;
	const struct virtio_feature_desc *descs[2] = { desc,
 10126f0:	e0bfff17 	ldw	r2,-4(fp)
 10126f4:	e0bffc15 	stw	r2,-16(fp)
 10126f8:	008040f4 	movhi	r2,259
 10126fc:	10a7a704 	addi	r2,r2,-24932
 1012700:	e0bffd15 	stw	r2,-12(fp)
		virtio_common_feature_desc
	};

	for (i = 0; i < 2; i++) {
 1012704:	e03ffa15 	stw	zero,-24(fp)
 1012708:	00003706 	br	10127e8 <virtio_feature_name+0x10c>
		if (!descs[i])
 101270c:	e0bffa17 	ldw	r2,-24(fp)
 1012710:	1085883a 	add	r2,r2,r2
 1012714:	1085883a 	add	r2,r2,r2
 1012718:	e0fffa04 	addi	r3,fp,-24
 101271c:	1885883a 	add	r2,r3,r2
 1012720:	10800204 	addi	r2,r2,8
 1012724:	10800017 	ldw	r2,0(r2)
 1012728:	10002b26 	beq	r2,zero,10127d8 <virtio_feature_name+0xfc>
			continue;

		for (j = 0; descs[i][j].vfd_val != 0; j++) {
 101272c:	e03ffb15 	stw	zero,-20(fp)
 1012730:	00001c06 	br	10127a4 <virtio_feature_name+0xc8>
			if (val == descs[i][j].vfd_val)
 1012734:	e0bffa17 	ldw	r2,-24(fp)
 1012738:	1085883a 	add	r2,r2,r2
 101273c:	1085883a 	add	r2,r2,r2
 1012740:	e0fffa04 	addi	r3,fp,-24
 1012744:	1885883a 	add	r2,r3,r2
 1012748:	10800204 	addi	r2,r2,8
 101274c:	10c00017 	ldw	r3,0(r2)
 1012750:	e0bffb17 	ldw	r2,-20(fp)
 1012754:	100490fa 	slli	r2,r2,3
 1012758:	1885883a 	add	r2,r3,r2
 101275c:	10c00017 	ldw	r3,0(r2)
 1012760:	e0bffe17 	ldw	r2,-8(fp)
 1012764:	18800c1e 	bne	r3,r2,1012798 <virtio_feature_name+0xbc>
				return descs[i][j].vfd_str;
 1012768:	e0bffa17 	ldw	r2,-24(fp)
 101276c:	1085883a 	add	r2,r2,r2
 1012770:	1085883a 	add	r2,r2,r2
 1012774:	e0fffa04 	addi	r3,fp,-24
 1012778:	1885883a 	add	r2,r3,r2
 101277c:	10800204 	addi	r2,r2,8
 1012780:	10c00017 	ldw	r3,0(r2)
 1012784:	e0bffb17 	ldw	r2,-20(fp)
 1012788:	100490fa 	slli	r2,r2,3
 101278c:	1885883a 	add	r2,r3,r2
 1012790:	10800117 	ldw	r2,4(r2)
 1012794:	00001806 	br	10127f8 <virtio_feature_name+0x11c>

	for (i = 0; i < 2; i++) {
		if (!descs[i])
			continue;

		for (j = 0; descs[i][j].vfd_val != 0; j++) {
 1012798:	e0bffb17 	ldw	r2,-20(fp)
 101279c:	10800044 	addi	r2,r2,1
 10127a0:	e0bffb15 	stw	r2,-20(fp)
 10127a4:	e0bffa17 	ldw	r2,-24(fp)
 10127a8:	1085883a 	add	r2,r2,r2
 10127ac:	1085883a 	add	r2,r2,r2
 10127b0:	e0fffa04 	addi	r3,fp,-24
 10127b4:	1885883a 	add	r2,r3,r2
 10127b8:	10800204 	addi	r2,r2,8
 10127bc:	10c00017 	ldw	r3,0(r2)
 10127c0:	e0bffb17 	ldw	r2,-20(fp)
 10127c4:	100490fa 	slli	r2,r2,3
 10127c8:	1885883a 	add	r2,r3,r2
 10127cc:	10800017 	ldw	r2,0(r2)
 10127d0:	103fd81e 	bne	r2,zero,1012734 <__alt_data_end+0xff012734>
 10127d4:	00000106 	br	10127dc <virtio_feature_name+0x100>
		virtio_common_feature_desc
	};

	for (i = 0; i < 2; i++) {
		if (!descs[i])
			continue;
 10127d8:	0001883a 	nop
	int i, j;
	const struct virtio_feature_desc *descs[2] = { desc,
		virtio_common_feature_desc
	};

	for (i = 0; i < 2; i++) {
 10127dc:	e0bffa17 	ldw	r2,-24(fp)
 10127e0:	10800044 	addi	r2,r2,1
 10127e4:	e0bffa15 	stw	r2,-24(fp)
 10127e8:	e0bffa17 	ldw	r2,-24(fp)
 10127ec:	10800090 	cmplti	r2,r2,2
 10127f0:	103fc61e 	bne	r2,zero,101270c <__alt_data_end+0xff01270c>
			if (val == descs[i][j].vfd_val)
				return descs[i][j].vfd_str;
		}
	}

	return NULL;
 10127f4:	0005883a 	mov	r2,zero
}
 10127f8:	e037883a 	mov	sp,fp
 10127fc:	df000017 	ldw	fp,0(sp)
 1012800:	dec00104 	addi	sp,sp,4
 1012804:	f800283a 	ret

01012808 <virtio_describe>:

void virtio_describe(struct virtio_device *dev, const char *msg,
		     uint32_t features, struct virtio_feature_desc *desc)
{
 1012808:	defffa04 	addi	sp,sp,-24
 101280c:	dfc00515 	stw	ra,20(sp)
 1012810:	df000415 	stw	fp,16(sp)
 1012814:	df000404 	addi	fp,sp,16
 1012818:	e13ffc15 	stw	r4,-16(fp)
 101281c:	e17ffd15 	stw	r5,-12(fp)
 1012820:	e1bffe15 	stw	r6,-8(fp)
 1012824:	e1ffff15 	stw	r7,-4(fp)
	(void)dev;
	(void)msg;
	(void)features;

	// TODO: Not used currently - keeping it for future use
	virtio_feature_name(0, desc);
 1012828:	e17fff17 	ldw	r5,-4(fp)
 101282c:	0009883a 	mov	r4,zero
 1012830:	10126dc0 	call	10126dc <virtio_feature_name>
}
 1012834:	0001883a 	nop
 1012838:	e037883a 	mov	sp,fp
 101283c:	dfc00117 	ldw	ra,4(sp)
 1012840:	df000017 	ldw	fp,0(sp)
 1012844:	dec00204 	addi	sp,sp,8
 1012848:	f800283a 	ret

0101284c <virtio_create_virtqueues>:

int virtio_create_virtqueues(struct virtio_device *vdev, unsigned int flags,
			     unsigned int nvqs, const char *names[],
			     vq_callback *callbacks[])
{
 101284c:	defff004 	addi	sp,sp,-64
 1012850:	dfc00f15 	stw	ra,60(sp)
 1012854:	df000e15 	stw	fp,56(sp)
 1012858:	df000e04 	addi	fp,sp,56
 101285c:	e13ffc15 	stw	r4,-16(fp)
 1012860:	e17ffd15 	stw	r5,-12(fp)
 1012864:	e1bffe15 	stw	r6,-8(fp)
 1012868:	e1ffff15 	stw	r7,-4(fp)
	struct vring_alloc_info *vring_alloc;
	unsigned int num_vrings, i;
	int ret;
	(void)flags;

	num_vrings = vdev->vrings_num;
 101286c:	e0bffc17 	ldw	r2,-16(fp)
 1012870:	10800917 	ldw	r2,36(r2)
 1012874:	e0bff615 	stw	r2,-40(fp)
	if (nvqs > num_vrings)
 1012878:	e0bffe17 	ldw	r2,-8(fp)
 101287c:	e0fff617 	ldw	r3,-40(fp)
 1012880:	1880022e 	bgeu	r3,r2,101288c <virtio_create_virtqueues+0x40>
		return ERROR_VQUEUE_INVLD_PARAM;
 1012884:	00bd1004 	movi	r2,-3008
 1012888:	00004b06 	br	10129b8 <virtio_create_virtqueues+0x16c>
	/* Initialize virtqueue for each vring */
	for (i = 0; i < nvqs; i++) {
 101288c:	e03ff515 	stw	zero,-44(fp)
 1012890:	00004506 	br	10129a8 <virtio_create_virtqueues+0x15c>
		vring_info = &vdev->vrings_info[i];
 1012894:	e0bffc17 	ldw	r2,-16(fp)
 1012898:	10c00a17 	ldw	r3,40(r2)
 101289c:	e0bff517 	ldw	r2,-44(fp)
 10128a0:	10800624 	muli	r2,r2,24
 10128a4:	1885883a 	add	r2,r3,r2
 10128a8:	e0bff715 	stw	r2,-36(fp)

		vring_alloc = &vring_info->info;
 10128ac:	e0bff717 	ldw	r2,-36(fp)
 10128b0:	10800104 	addi	r2,r2,4
 10128b4:	e0bff815 	stw	r2,-32(fp)
#ifndef VIRTIO_SLAVE_ONLY
		if (vdev->role == VIRTIO_DEV_MASTER) {
 10128b8:	e0bffc17 	ldw	r2,-16(fp)
 10128bc:	10800517 	ldw	r2,20(r2)
 10128c0:	1000161e 	bne	r2,zero,101291c <virtio_create_virtqueues+0xd0>
			size_t offset;
			struct metal_io_region *io = vring_info->io;
 10128c4:	e0bff717 	ldw	r2,-36(fp)
 10128c8:	10800517 	ldw	r2,20(r2)
 10128cc:	e0bff915 	stw	r2,-28(fp)

			offset = metal_io_virt_to_offset(io,
 10128d0:	e0bff817 	ldw	r2,-32(fp)
 10128d4:	10800017 	ldw	r2,0(r2)
 10128d8:	100b883a 	mov	r5,r2
 10128dc:	e13ff917 	ldw	r4,-28(fp)
 10128e0:	10126180 	call	1012618 <metal_io_virt_to_offset>
 10128e4:	e0bffa15 	stw	r2,-24(fp)
							 vring_alloc->vaddr);
			metal_io_block_set(io, offset, 0,
					   vring_size(vring_alloc->num_descs,
 10128e8:	e0bff817 	ldw	r2,-32(fp)
 10128ec:	1080020b 	ldhu	r2,8(r2)
			size_t offset;
			struct metal_io_region *io = vring_info->io;

			offset = metal_io_virt_to_offset(io,
							 vring_alloc->vaddr);
			metal_io_block_set(io, offset, 0,
 10128f0:	10ffffcc 	andi	r3,r2,65535
 10128f4:	e0bff817 	ldw	r2,-32(fp)
 10128f8:	10800117 	ldw	r2,4(r2)
 10128fc:	100b883a 	mov	r5,r2
 1012900:	1809883a 	mov	r4,r3
 1012904:	10125900 	call	1012590 <vring_size>
 1012908:	100f883a 	mov	r7,r2
 101290c:	000d883a 	mov	r6,zero
 1012910:	e17ffa17 	ldw	r5,-24(fp)
 1012914:	e13ff917 	ldw	r4,-28(fp)
 1012918:	100854c0 	call	100854c <metal_io_block_set>
					   vring_size(vring_alloc->num_descs,
						      vring_alloc->align));
		}
#endif
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
 101291c:	e0bff517 	ldw	r2,-44(fp)
 1012920:	117fffcc 	andi	r5,r2,65535
 1012924:	e0bff517 	ldw	r2,-44(fp)
 1012928:	1085883a 	add	r2,r2,r2
 101292c:	1085883a 	add	r2,r2,r2
 1012930:	1007883a 	mov	r3,r2
 1012934:	e0bfff17 	ldw	r2,-4(fp)
 1012938:	10c5883a 	add	r2,r2,r3
 101293c:	11800017 	ldw	r6,0(r2)
				       callbacks[i], vdev->func->notify,
 1012940:	e0bff517 	ldw	r2,-44(fp)
 1012944:	1085883a 	add	r2,r2,r2
 1012948:	1085883a 	add	r2,r2,r2
 101294c:	1007883a 	mov	r3,r2
 1012950:	e0800217 	ldw	r2,8(fp)
 1012954:	10c5883a 	add	r2,r2,r3
			metal_io_block_set(io, offset, 0,
					   vring_size(vring_alloc->num_descs,
						      vring_alloc->align));
		}
#endif
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
 1012958:	10800017 	ldw	r2,0(r2)
				       callbacks[i], vdev->func->notify,
 101295c:	e0fffc17 	ldw	r3,-16(fp)
 1012960:	18c00717 	ldw	r3,28(r3)
			metal_io_block_set(io, offset, 0,
					   vring_size(vring_alloc->num_descs,
						      vring_alloc->align));
		}
#endif
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
 1012964:	18c00817 	ldw	r3,32(r3)
 1012968:	e13ff717 	ldw	r4,-36(fp)
 101296c:	21000017 	ldw	r4,0(r4)
 1012970:	d9000215 	stw	r4,8(sp)
 1012974:	d8c00115 	stw	r3,4(sp)
 1012978:	d8800015 	stw	r2,0(sp)
 101297c:	e1fff817 	ldw	r7,-32(fp)
 1012980:	e13ffc17 	ldw	r4,-16(fp)
 1012984:	1012e680 	call	1012e68 <virtqueue_create>
 1012988:	e0bffb15 	stw	r2,-20(fp)
				       callbacks[i], vdev->func->notify,
				       vring_info->vq);
		if (ret)
 101298c:	e0bffb17 	ldw	r2,-20(fp)
 1012990:	10000226 	beq	r2,zero,101299c <virtio_create_virtqueues+0x150>
			return ret;
 1012994:	e0bffb17 	ldw	r2,-20(fp)
 1012998:	00000706 	br	10129b8 <virtio_create_virtqueues+0x16c>

	num_vrings = vdev->vrings_num;
	if (nvqs > num_vrings)
		return ERROR_VQUEUE_INVLD_PARAM;
	/* Initialize virtqueue for each vring */
	for (i = 0; i < nvqs; i++) {
 101299c:	e0bff517 	ldw	r2,-44(fp)
 10129a0:	10800044 	addi	r2,r2,1
 10129a4:	e0bff515 	stw	r2,-44(fp)
 10129a8:	e0fff517 	ldw	r3,-44(fp)
 10129ac:	e0bffe17 	ldw	r2,-8(fp)
 10129b0:	18bfb836 	bltu	r3,r2,1012894 <__alt_data_end+0xff012894>
				       callbacks[i], vdev->func->notify,
				       vring_info->vq);
		if (ret)
			return ret;
	}
	return 0;
 10129b4:	0005883a 	mov	r2,zero
}
 10129b8:	e037883a 	mov	sp,fp
 10129bc:	dfc00117 	ldw	ra,4(sp)
 10129c0:	df000017 	ldw	fp,0(sp)
 10129c4:	dec00204 	addi	sp,sp,8
 10129c8:	f800283a 	ret

010129cc <vring_init>:

static inline void
vring_init(struct vring *vr, unsigned int num, uint8_t *p, unsigned long align)
{
 10129cc:	defffb04 	addi	sp,sp,-20
 10129d0:	df000415 	stw	fp,16(sp)
 10129d4:	df000404 	addi	fp,sp,16
 10129d8:	e13ffc15 	stw	r4,-16(fp)
 10129dc:	e17ffd15 	stw	r5,-12(fp)
 10129e0:	e1bffe15 	stw	r6,-8(fp)
 10129e4:	e1ffff15 	stw	r7,-4(fp)
	vr->num = num;
 10129e8:	e0bffc17 	ldw	r2,-16(fp)
 10129ec:	e0fffd17 	ldw	r3,-12(fp)
 10129f0:	10c00015 	stw	r3,0(r2)
	vr->desc = (struct vring_desc *)p;
 10129f4:	e0bffc17 	ldw	r2,-16(fp)
 10129f8:	e0fffe17 	ldw	r3,-8(fp)
 10129fc:	10c00115 	stw	r3,4(r2)
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
 1012a00:	e0bffd17 	ldw	r2,-12(fp)
 1012a04:	1004913a 	slli	r2,r2,4
 1012a08:	e0fffe17 	ldw	r3,-8(fp)
 1012a0c:	1887883a 	add	r3,r3,r2
 1012a10:	e0bffc17 	ldw	r2,-16(fp)
 1012a14:	10c00215 	stw	r3,8(r2)
	vr->used = (struct vring_used *)
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
 1012a18:	e0bffc17 	ldw	r2,-16(fp)
 1012a1c:	10c00217 	ldw	r3,8(r2)
 1012a20:	e0bffd17 	ldw	r2,-12(fp)
 1012a24:	10800084 	addi	r2,r2,2
 1012a28:	1085883a 	add	r2,r2,r2
 1012a2c:	1885883a 	add	r2,r3,r2
 1012a30:	1007883a 	mov	r3,r2
 1012a34:	e0bfff17 	ldw	r2,-4(fp)
 1012a38:	1885883a 	add	r2,r3,r2
	      align - 1) & ~(align - 1));
 1012a3c:	10c00044 	addi	r3,r2,1
 1012a40:	e0bfff17 	ldw	r2,-4(fp)
 1012a44:	0085c83a 	sub	r2,zero,r2
 1012a48:	1884703a 	and	r2,r3,r2
vring_init(struct vring *vr, unsigned int num, uint8_t *p, unsigned long align)
{
	vr->num = num;
	vr->desc = (struct vring_desc *)p;
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
	vr->used = (struct vring_used *)
 1012a4c:	1007883a 	mov	r3,r2
 1012a50:	e0bffc17 	ldw	r2,-16(fp)
 1012a54:	10c00315 	stw	r3,12(r2)
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
	      align - 1) & ~(align - 1));
}
 1012a58:	0001883a 	nop
 1012a5c:	e037883a 	mov	sp,fp
 1012a60:	df000017 	ldw	fp,0(sp)
 1012a64:	dec00104 	addi	sp,sp,4
 1012a68:	f800283a 	ret

01012a6c <vring_need_event>:
 * just incremented index from old to new_idx, should we trigger an
 * event?
 */
static inline int
vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
 1012a6c:	defffc04 	addi	sp,sp,-16
 1012a70:	df000315 	stw	fp,12(sp)
 1012a74:	df000304 	addi	fp,sp,12
 1012a78:	2807883a 	mov	r3,r5
 1012a7c:	3005883a 	mov	r2,r6
 1012a80:	e13ffd0d 	sth	r4,-12(fp)
 1012a84:	e0fffe0d 	sth	r3,-8(fp)
 1012a88:	e0bfff0d 	sth	r2,-4(fp)
	return (uint16_t)(new_idx - event_idx - 1) <
 1012a8c:	e0fffe0b 	ldhu	r3,-8(fp)
 1012a90:	e0bffd0b 	ldhu	r2,-12(fp)
 1012a94:	1885c83a 	sub	r2,r3,r2
 1012a98:	10bfffc4 	addi	r2,r2,-1
 1012a9c:	1009883a 	mov	r4,r2
	    (uint16_t)(new_idx - old);
 1012aa0:	e0fffe0b 	ldhu	r3,-8(fp)
 1012aa4:	e0bfff0b 	ldhu	r2,-4(fp)
 1012aa8:	1885c83a 	sub	r2,r3,r2
 * event?
 */
static inline int
vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
	return (uint16_t)(new_idx - event_idx - 1) <
 1012aac:	20ffffcc 	andi	r3,r4,65535
 1012ab0:	10bfffcc 	andi	r2,r2,65535
 1012ab4:	1885803a 	cmpltu	r2,r3,r2
 1012ab8:	10803fcc 	andi	r2,r2,255
	    (uint16_t)(new_idx - old);
}
 1012abc:	e037883a 	mov	sp,fp
 1012ac0:	df000017 	ldw	fp,0(sp)
 1012ac4:	dec00104 	addi	sp,sp,4
 1012ac8:	f800283a 	ret

01012acc <metal_free_memory>:
{
	return (pvPortMalloc(size));
}

static inline void metal_free_memory(void *ptr)
{
 1012acc:	defffd04 	addi	sp,sp,-12
 1012ad0:	dfc00215 	stw	ra,8(sp)
 1012ad4:	df000115 	stw	fp,4(sp)
 1012ad8:	df000104 	addi	fp,sp,4
 1012adc:	e13fff15 	stw	r4,-4(fp)
	vPortFree(ptr);
 1012ae0:	e13fff17 	ldw	r4,-4(fp)
 1012ae4:	10012840 	call	1001284 <vPortFree>
}
 1012ae8:	0001883a 	nop
 1012aec:	e037883a 	mov	sp,fp
 1012af0:	dfc00117 	ldw	ra,4(sp)
 1012af4:	df000017 	ldw	fp,0(sp)
 1012af8:	dec00204 	addi	sp,sp,8
 1012afc:	f800283a 	ret

01012b00 <metal_io_virt>:
 * @param[in]	offset	Offset into shared memory segment.
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
 1012b00:	defffd04 	addi	sp,sp,-12
 1012b04:	df000215 	stw	fp,8(sp)
 1012b08:	df000204 	addi	fp,sp,8
 1012b0c:	e13ffe15 	stw	r4,-8(fp)
 1012b10:	e17fff15 	stw	r5,-4(fp)
	return (io->virt != METAL_BAD_VA && offset < io->size
 1012b14:	e0bffe17 	ldw	r2,-8(fp)
 1012b18:	10800017 	ldw	r2,0(r2)
		? (uint8_t *)io->virt + offset
		: NULL);
 1012b1c:	10bfffe0 	cmpeqi	r2,r2,-1
 1012b20:	1000091e 	bne	r2,zero,1012b48 <metal_io_virt+0x48>
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
	return (io->virt != METAL_BAD_VA && offset < io->size
 1012b24:	e0bffe17 	ldw	r2,-8(fp)
 1012b28:	10800217 	ldw	r2,8(r2)
 1012b2c:	e0ffff17 	ldw	r3,-4(fp)
 1012b30:	1880052e 	bgeu	r3,r2,1012b48 <metal_io_virt+0x48>
		? (uint8_t *)io->virt + offset
 1012b34:	e0bffe17 	ldw	r2,-8(fp)
 1012b38:	10c00017 	ldw	r3,0(r2)
		: NULL);
 1012b3c:	e0bfff17 	ldw	r2,-4(fp)
 1012b40:	1885883a 	add	r2,r3,r2
 1012b44:	00000106 	br	1012b4c <metal_io_virt+0x4c>
 1012b48:	0005883a 	mov	r2,zero
}
 1012b4c:	e037883a 	mov	sp,fp
 1012b50:	df000017 	ldw	fp,0(sp)
 1012b54:	dec00104 	addi	sp,sp,4
 1012b58:	f800283a 	ret

01012b5c <metal_io_virt_to_offset>:
 * @param[in]	virt	Virtual address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
 1012b5c:	defffc04 	addi	sp,sp,-16
 1012b60:	df000315 	stw	fp,12(sp)
 1012b64:	df000304 	addi	fp,sp,12
 1012b68:	e13ffe15 	stw	r4,-8(fp)
 1012b6c:	e17fff15 	stw	r5,-4(fp)
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1012b70:	e0bfff17 	ldw	r2,-4(fp)
 1012b74:	e0fffe17 	ldw	r3,-8(fp)
 1012b78:	18c00017 	ldw	r3,0(r3)
 1012b7c:	10c5c83a 	sub	r2,r2,r3
 1012b80:	e0bffd15 	stw	r2,-12(fp)
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1012b84:	e0bffe17 	ldw	r2,-8(fp)
 1012b88:	10800217 	ldw	r2,8(r2)
 1012b8c:	e0fffd17 	ldw	r3,-12(fp)
 1012b90:	1880022e 	bgeu	r3,r2,1012b9c <metal_io_virt_to_offset+0x40>
 1012b94:	e0bffd17 	ldw	r2,-12(fp)
 1012b98:	00000106 	br	1012ba0 <metal_io_virt_to_offset+0x44>
 1012b9c:	00bfffc4 	movi	r2,-1
}
 1012ba0:	e037883a 	mov	sp,fp
 1012ba4:	df000017 	ldw	fp,0(sp)
 1012ba8:	dec00104 	addi	sp,sp,4
 1012bac:	f800283a 	ret

01012bb0 <metal_io_phys>:
 * @return	METAL_BAD_PHYS if offset is out of range, or physical address
 *		of offset.
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
 1012bb0:	defffb04 	addi	sp,sp,-20
 1012bb4:	dfc00415 	stw	ra,16(sp)
 1012bb8:	df000315 	stw	fp,12(sp)
 1012bbc:	df000304 	addi	fp,sp,12
 1012bc0:	e13ffe15 	stw	r4,-8(fp)
 1012bc4:	e17fff15 	stw	r5,-4(fp)
	if (!io->ops.offset_to_phys) {
 1012bc8:	e0bffe17 	ldw	r2,-8(fp)
 1012bcc:	10800c17 	ldw	r2,48(r2)
 1012bd0:	1000211e 	bne	r2,zero,1012c58 <metal_io_phys+0xa8>
		unsigned long page = (io->page_shift >=
 1012bd4:	e0bffe17 	ldw	r2,-8(fp)
 1012bd8:	10800317 	ldw	r2,12(r2)
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
 1012bdc:	10800828 	cmpgeui	r2,r2,32
 1012be0:	1000051e 	bne	r2,zero,1012bf8 <metal_io_phys+0x48>
 1012be4:	e0bffe17 	ldw	r2,-8(fp)
 1012be8:	10800317 	ldw	r2,12(r2)
 1012bec:	e0ffff17 	ldw	r3,-4(fp)
 1012bf0:	1884d83a 	srl	r2,r3,r2
 1012bf4:	00000106 	br	1012bfc <metal_io_phys+0x4c>
 1012bf8:	0005883a 	mov	r2,zero
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
 1012bfc:	e0bffd15 	stw	r2,-12(fp)
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1012c00:	e0bffe17 	ldw	r2,-8(fp)
 1012c04:	10800117 	ldw	r2,4(r2)
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 1012c08:	10001126 	beq	r2,zero,1012c50 <metal_io_phys+0xa0>
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1012c0c:	e0bffe17 	ldw	r2,-8(fp)
 1012c10:	10800217 	ldw	r2,8(r2)
 1012c14:	e0ffff17 	ldw	r3,-4(fp)
 1012c18:	18800d2e 	bgeu	r3,r2,1012c50 <metal_io_phys+0xa0>
			? io->physmap[page] + (offset & io->page_mask)
 1012c1c:	e0bffe17 	ldw	r2,-8(fp)
 1012c20:	10c00117 	ldw	r3,4(r2)
 1012c24:	e0bffd17 	ldw	r2,-12(fp)
 1012c28:	1085883a 	add	r2,r2,r2
 1012c2c:	1085883a 	add	r2,r2,r2
 1012c30:	1885883a 	add	r2,r3,r2
 1012c34:	10c00017 	ldw	r3,0(r2)
 1012c38:	e0bffe17 	ldw	r2,-8(fp)
 1012c3c:	11000417 	ldw	r4,16(r2)
 1012c40:	e0bfff17 	ldw	r2,-4(fp)
 1012c44:	2084703a 	and	r2,r4,r2
			: METAL_BAD_PHYS);
 1012c48:	1885883a 	add	r2,r3,r2
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1012c4c:	00000706 	br	1012c6c <metal_io_phys+0xbc>
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 1012c50:	00bfffc4 	movi	r2,-1
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1012c54:	00000506 	br	1012c6c <metal_io_phys+0xbc>
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
	}

	return io->ops.offset_to_phys(io, offset);
 1012c58:	e0bffe17 	ldw	r2,-8(fp)
 1012c5c:	10800c17 	ldw	r2,48(r2)
 1012c60:	e17fff17 	ldw	r5,-4(fp)
 1012c64:	e13ffe17 	ldw	r4,-8(fp)
 1012c68:	103ee83a 	callr	r2
}
 1012c6c:	e037883a 	mov	sp,fp
 1012c70:	dfc00117 	ldw	ra,4(sp)
 1012c74:	df000017 	ldw	fp,0(sp)
 1012c78:	dec00204 	addi	sp,sp,8
 1012c7c:	f800283a 	ret

01012c80 <metal_io_phys_to_offset>:
 * @param[in]	phys	Physical address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
 1012c80:	defffb04 	addi	sp,sp,-20
 1012c84:	dfc00415 	stw	ra,16(sp)
 1012c88:	df000315 	stw	fp,12(sp)
 1012c8c:	df000304 	addi	fp,sp,12
 1012c90:	e13ffe15 	stw	r4,-8(fp)
 1012c94:	e17fff15 	stw	r5,-4(fp)
	if (!io->ops.phys_to_offset) {
 1012c98:	e0bffe17 	ldw	r2,-8(fp)
 1012c9c:	10800d17 	ldw	r2,52(r2)
 1012ca0:	1000231e 	bne	r2,zero,1012d30 <metal_io_phys_to_offset+0xb0>
		unsigned long offset =
			(io->page_mask == (metal_phys_addr_t)(-1) ?
 1012ca4:	e0bffe17 	ldw	r2,-8(fp)
 1012ca8:	10800417 	ldw	r2,16(r2)
			phys - io->physmap[0] :  phys & io->page_mask);
 1012cac:	10bfffd8 	cmpnei	r2,r2,-1
 1012cb0:	1000061e 	bne	r2,zero,1012ccc <metal_io_phys_to_offset+0x4c>
 1012cb4:	e0bffe17 	ldw	r2,-8(fp)
 1012cb8:	10800117 	ldw	r2,4(r2)
 1012cbc:	10800017 	ldw	r2,0(r2)
 1012cc0:	e0ffff17 	ldw	r3,-4(fp)
 1012cc4:	1885c83a 	sub	r2,r3,r2
 1012cc8:	00000406 	br	1012cdc <metal_io_phys_to_offset+0x5c>
 1012ccc:	e0bffe17 	ldw	r2,-8(fp)
 1012cd0:	10c00417 	ldw	r3,16(r2)
 1012cd4:	e0bfff17 	ldw	r2,-4(fp)
 1012cd8:	1884703a 	and	r2,r3,r2
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
	if (!io->ops.phys_to_offset) {
		unsigned long offset =
 1012cdc:	e0bffd15 	stw	r2,-12(fp)
			(io->page_mask == (metal_phys_addr_t)(-1) ?
			phys - io->physmap[0] :  phys & io->page_mask);
		do {
			if (metal_io_phys(io, offset) == phys)
 1012ce0:	e17ffd17 	ldw	r5,-12(fp)
 1012ce4:	e13ffe17 	ldw	r4,-8(fp)
 1012ce8:	1012bb00 	call	1012bb0 <metal_io_phys>
 1012cec:	1007883a 	mov	r3,r2
 1012cf0:	e0bfff17 	ldw	r2,-4(fp)
 1012cf4:	1880021e 	bne	r3,r2,1012d00 <metal_io_phys_to_offset+0x80>
				return offset;
 1012cf8:	e0bffd17 	ldw	r2,-12(fp)
 1012cfc:	00001106 	br	1012d44 <metal_io_phys_to_offset+0xc4>
			offset += io->page_mask + 1;
 1012d00:	e0bffe17 	ldw	r2,-8(fp)
 1012d04:	10c00417 	ldw	r3,16(r2)
 1012d08:	e0bffd17 	ldw	r2,-12(fp)
 1012d0c:	1885883a 	add	r2,r3,r2
 1012d10:	10800044 	addi	r2,r2,1
 1012d14:	e0bffd15 	stw	r2,-12(fp)
		} while (offset < io->size);
 1012d18:	e0bffe17 	ldw	r2,-8(fp)
 1012d1c:	10800217 	ldw	r2,8(r2)
 1012d20:	e0fffd17 	ldw	r3,-12(fp)
 1012d24:	18bfee36 	bltu	r3,r2,1012ce0 <__alt_data_end+0xff012ce0>
		return METAL_BAD_OFFSET;
 1012d28:	00bfffc4 	movi	r2,-1
 1012d2c:	00000506 	br	1012d44 <metal_io_phys_to_offset+0xc4>
	}

	return (*io->ops.phys_to_offset)(io, phys);
 1012d30:	e0bffe17 	ldw	r2,-8(fp)
 1012d34:	10800d17 	ldw	r2,52(r2)
 1012d38:	e17fff17 	ldw	r5,-4(fp)
 1012d3c:	e13ffe17 	ldw	r4,-8(fp)
 1012d40:	103ee83a 	callr	r2
}
 1012d44:	e037883a 	mov	sp,fp
 1012d48:	dfc00117 	ldw	ra,4(sp)
 1012d4c:	df000017 	ldw	fp,0(sp)
 1012d50:	dec00204 	addi	sp,sp,8
 1012d54:	f800283a 	ret

01012d58 <metal_io_phys_to_virt>:
 * @param[in]	phys	Physical address within segment.
 * @return	NULL if out of range, or corresponding virtual address.
 */
static inline void *
metal_io_phys_to_virt(struct metal_io_region *io, metal_phys_addr_t phys)
{
 1012d58:	defffc04 	addi	sp,sp,-16
 1012d5c:	dfc00315 	stw	ra,12(sp)
 1012d60:	df000215 	stw	fp,8(sp)
 1012d64:	df000204 	addi	fp,sp,8
 1012d68:	e13ffe15 	stw	r4,-8(fp)
 1012d6c:	e17fff15 	stw	r5,-4(fp)
	return metal_io_virt(io, metal_io_phys_to_offset(io, phys));
 1012d70:	e17fff17 	ldw	r5,-4(fp)
 1012d74:	e13ffe17 	ldw	r4,-8(fp)
 1012d78:	1012c800 	call	1012c80 <metal_io_phys_to_offset>
 1012d7c:	100b883a 	mov	r5,r2
 1012d80:	e13ffe17 	ldw	r4,-8(fp)
 1012d84:	1012b000 	call	1012b00 <metal_io_virt>
}
 1012d88:	e037883a 	mov	sp,fp
 1012d8c:	dfc00117 	ldw	ra,4(sp)
 1012d90:	df000017 	ldw	fp,0(sp)
 1012d94:	dec00204 	addi	sp,sp,8
 1012d98:	f800283a 	ret

01012d9c <metal_io_virt_to_phys>:
 * @return	METAL_BAD_PHYS if out of range, or corresponding
 *		physical address.
 */
static inline metal_phys_addr_t
metal_io_virt_to_phys(struct metal_io_region *io, void *virt)
{
 1012d9c:	defffc04 	addi	sp,sp,-16
 1012da0:	dfc00315 	stw	ra,12(sp)
 1012da4:	df000215 	stw	fp,8(sp)
 1012da8:	df000204 	addi	fp,sp,8
 1012dac:	e13ffe15 	stw	r4,-8(fp)
 1012db0:	e17fff15 	stw	r5,-4(fp)
	return metal_io_phys(io, metal_io_virt_to_offset(io, virt));
 1012db4:	e17fff17 	ldw	r5,-4(fp)
 1012db8:	e13ffe17 	ldw	r4,-8(fp)
 1012dbc:	1012b5c0 	call	1012b5c <metal_io_virt_to_offset>
 1012dc0:	100b883a 	mov	r5,r2
 1012dc4:	e13ffe17 	ldw	r4,-8(fp)
 1012dc8:	1012bb00 	call	1012bb0 <metal_io_phys>
}
 1012dcc:	e037883a 	mov	sp,fp
 1012dd0:	dfc00117 	ldw	ra,4(sp)
 1012dd4:	df000017 	ldw	fp,0(sp)
 1012dd8:	dec00204 	addi	sp,sp,8
 1012ddc:	f800283a 	ret

01012de0 <virtqueue_phys_to_virt>:
static int virtqueue_navail(struct virtqueue *vq);

/* Default implementation of P2V based on libmetal */
static inline void *virtqueue_phys_to_virt(struct virtqueue *vq,
					   metal_phys_addr_t phys)
{
 1012de0:	defffb04 	addi	sp,sp,-20
 1012de4:	dfc00415 	stw	ra,16(sp)
 1012de8:	df000315 	stw	fp,12(sp)
 1012dec:	df000304 	addi	fp,sp,12
 1012df0:	e13ffe15 	stw	r4,-8(fp)
 1012df4:	e17fff15 	stw	r5,-4(fp)
	struct metal_io_region *io = vq->shm_io;
 1012df8:	e0bffe17 	ldw	r2,-8(fp)
 1012dfc:	10800a17 	ldw	r2,40(r2)
 1012e00:	e0bffd15 	stw	r2,-12(fp)

	return metal_io_phys_to_virt(io, phys);
 1012e04:	e17fff17 	ldw	r5,-4(fp)
 1012e08:	e13ffd17 	ldw	r4,-12(fp)
 1012e0c:	1012d580 	call	1012d58 <metal_io_phys_to_virt>
}
 1012e10:	e037883a 	mov	sp,fp
 1012e14:	dfc00117 	ldw	ra,4(sp)
 1012e18:	df000017 	ldw	fp,0(sp)
 1012e1c:	dec00204 	addi	sp,sp,8
 1012e20:	f800283a 	ret

01012e24 <virtqueue_virt_to_phys>:

/* Default implementation of V2P based on libmetal */
static inline metal_phys_addr_t virtqueue_virt_to_phys(struct virtqueue *vq,
						       void *buf)
{
 1012e24:	defffb04 	addi	sp,sp,-20
 1012e28:	dfc00415 	stw	ra,16(sp)
 1012e2c:	df000315 	stw	fp,12(sp)
 1012e30:	df000304 	addi	fp,sp,12
 1012e34:	e13ffe15 	stw	r4,-8(fp)
 1012e38:	e17fff15 	stw	r5,-4(fp)
	struct metal_io_region *io = vq->shm_io;
 1012e3c:	e0bffe17 	ldw	r2,-8(fp)
 1012e40:	10800a17 	ldw	r2,40(r2)
 1012e44:	e0bffd15 	stw	r2,-12(fp)

	return metal_io_virt_to_phys(io, buf);
 1012e48:	e17fff17 	ldw	r5,-4(fp)
 1012e4c:	e13ffd17 	ldw	r4,-12(fp)
 1012e50:	1012d9c0 	call	1012d9c <metal_io_virt_to_phys>
}
 1012e54:	e037883a 	mov	sp,fp
 1012e58:	dfc00117 	ldw	ra,4(sp)
 1012e5c:	df000017 	ldw	fp,0(sp)
 1012e60:	dec00204 	addi	sp,sp,8
 1012e64:	f800283a 	ret

01012e68 <virtqueue_create>:
int virtqueue_create(struct virtio_device *virt_dev, unsigned short id,
		     const char *name, struct vring_alloc_info *ring,
		     void (*callback)(struct virtqueue *vq),
		     void (*notify)(struct virtqueue *vq),
		     struct virtqueue *vq)
{
 1012e68:	defff904 	addi	sp,sp,-28
 1012e6c:	dfc00615 	stw	ra,24(sp)
 1012e70:	df000515 	stw	fp,20(sp)
 1012e74:	df000504 	addi	fp,sp,20
 1012e78:	e13ffc15 	stw	r4,-16(fp)
 1012e7c:	2805883a 	mov	r2,r5
 1012e80:	e1bffe15 	stw	r6,-8(fp)
 1012e84:	e1ffff15 	stw	r7,-4(fp)
 1012e88:	e0bffd0d 	sth	r2,-12(fp)
	int status = VQUEUE_SUCCESS;
 1012e8c:	e03ffb15 	stw	zero,-20(fp)
	VQ_PARAM_CHK(ring->num_descs == 0, status, ERROR_VQUEUE_INVLD_PARAM);
	VQ_PARAM_CHK(ring->num_descs & (ring->num_descs - 1), status,
		     ERROR_VRING_ALIGN);
	VQ_PARAM_CHK(vq == NULL, status, ERROR_NO_MEM);

	if (status == VQUEUE_SUCCESS) {
 1012e90:	e0bffb17 	ldw	r2,-20(fp)
 1012e94:	10001f1e 	bne	r2,zero,1012f14 <virtqueue_create+0xac>
		vq->vq_dev = virt_dev;
 1012e98:	e0800417 	ldw	r2,16(fp)
 1012e9c:	e0fffc17 	ldw	r3,-16(fp)
 1012ea0:	10c00015 	stw	r3,0(r2)
		vq->vq_name = name;
 1012ea4:	e0800417 	ldw	r2,16(fp)
 1012ea8:	e0fffe17 	ldw	r3,-8(fp)
 1012eac:	10c00115 	stw	r3,4(r2)
		vq->vq_queue_index = id;
 1012eb0:	e0800417 	ldw	r2,16(fp)
 1012eb4:	e0fffd0b 	ldhu	r3,-12(fp)
 1012eb8:	10c0020d 	sth	r3,8(r2)
		vq->vq_nentries = ring->num_descs;
 1012ebc:	e0bfff17 	ldw	r2,-4(fp)
 1012ec0:	10c0020b 	ldhu	r3,8(r2)
 1012ec4:	e0800417 	ldw	r2,16(fp)
 1012ec8:	10c0028d 	sth	r3,10(r2)
		vq->vq_free_cnt = vq->vq_nentries;
 1012ecc:	e0800417 	ldw	r2,16(fp)
 1012ed0:	10c0028b 	ldhu	r3,10(r2)
 1012ed4:	e0800417 	ldw	r2,16(fp)
 1012ed8:	10c0090d 	sth	r3,36(r2)
		vq->callback = callback;
 1012edc:	e0800417 	ldw	r2,16(fp)
 1012ee0:	e0c00217 	ldw	r3,8(fp)
 1012ee4:	10c00315 	stw	r3,12(r2)
		vq->notify = notify;
 1012ee8:	e0800417 	ldw	r2,16(fp)
 1012eec:	e0c00317 	ldw	r3,12(fp)
 1012ef0:	10c00415 	stw	r3,16(r2)

		/* Initialize vring control block in virtqueue. */
		vq_ring_init(vq, ring->vaddr, ring->align);
 1012ef4:	e0bfff17 	ldw	r2,-4(fp)
 1012ef8:	10c00017 	ldw	r3,0(r2)
 1012efc:	e0bfff17 	ldw	r2,-4(fp)
 1012f00:	10800117 	ldw	r2,4(r2)
 1012f04:	100d883a 	mov	r6,r2
 1012f08:	180b883a 	mov	r5,r3
 1012f0c:	e1000417 	ldw	r4,16(fp)
 1012f10:	1013a240 	call	1013a24 <vq_ring_init>
	}

	return status;
 1012f14:	e0bffb17 	ldw	r2,-20(fp)
}
 1012f18:	e037883a 	mov	sp,fp
 1012f1c:	dfc00117 	ldw	ra,4(sp)
 1012f20:	df000017 	ldw	fp,0(sp)
 1012f24:	dec00204 	addi	sp,sp,8
 1012f28:	f800283a 	ret

01012f2c <virtqueue_add_buffer>:
 *
 * @return                  - Function status
 */
int virtqueue_add_buffer(struct virtqueue *vq, struct virtqueue_buf *buf_list,
			 int readable, int writable, void *cookie)
{
 1012f2c:	defff404 	addi	sp,sp,-48
 1012f30:	dfc00b15 	stw	ra,44(sp)
 1012f34:	df000a15 	stw	fp,40(sp)
 1012f38:	df000a04 	addi	fp,sp,40
 1012f3c:	e13ffc15 	stw	r4,-16(fp)
 1012f40:	e17ffd15 	stw	r5,-12(fp)
 1012f44:	e1bffe15 	stw	r6,-8(fp)
 1012f48:	e1ffff15 	stw	r7,-4(fp)
	struct vq_desc_extra *dxp = NULL;
 1012f4c:	e03ff815 	stw	zero,-32(fp)
	int status = VQUEUE_SUCCESS;
 1012f50:	e03ff915 	stw	zero,-28(fp)
	uint16_t head_idx;
	uint16_t idx;
	int needed;

	needed = readable + writable;
 1012f54:	e0fffe17 	ldw	r3,-8(fp)
 1012f58:	e0bfff17 	ldw	r2,-4(fp)
 1012f5c:	1885883a 	add	r2,r3,r2
 1012f60:	e0bffa15 	stw	r2,-24(fp)
	VQ_PARAM_CHK(needed < 1, status, ERROR_VQUEUE_INVLD_PARAM);
	VQ_PARAM_CHK(vq->vq_free_cnt == 0, status, ERROR_VRING_FULL);

	VQUEUE_BUSY(vq);

	if (status == VQUEUE_SUCCESS) {
 1012f64:	e0bff917 	ldw	r2,-28(fp)
 1012f68:	10002b1e 	bne	r2,zero,1013018 <virtqueue_add_buffer+0xec>
		VQASSERT(vq, cookie != NULL, "enqueuing with no cookie");

		head_idx = vq->vq_desc_head_idx;
 1012f6c:	e0bffc17 	ldw	r2,-16(fp)
 1012f70:	10800b0b 	ldhu	r2,44(r2)
 1012f74:	e0bffb0d 	sth	r2,-20(fp)
		VQ_RING_ASSERT_VALID_IDX(vq, head_idx);
		dxp = &vq->vq_descx[head_idx];
 1012f78:	e0bffb0b 	ldhu	r2,-20(fp)
 1012f7c:	100490fa 	slli	r2,r2,3
 1012f80:	10800d04 	addi	r2,r2,52
 1012f84:	e0fffc17 	ldw	r3,-16(fp)
 1012f88:	1885883a 	add	r2,r3,r2
 1012f8c:	e0bff815 	stw	r2,-32(fp)

		VQASSERT(vq, dxp->cookie == NULL,
			 "cookie already exists for index");

		dxp->cookie = cookie;
 1012f90:	e0bff817 	ldw	r2,-32(fp)
 1012f94:	e0c00217 	ldw	r3,8(fp)
 1012f98:	10c00015 	stw	r3,0(r2)
		dxp->ndescs = needed;
 1012f9c:	e0bffa17 	ldw	r2,-24(fp)
 1012fa0:	1007883a 	mov	r3,r2
 1012fa4:	e0bff817 	ldw	r2,-32(fp)
 1012fa8:	10c0010d 	sth	r3,4(r2)

		/* Enqueue buffer onto the ring. */
		idx = vq_ring_add_buffer(vq, vq->vq_ring.desc, head_idx,
 1012fac:	e0bffc17 	ldw	r2,-16(fp)
 1012fb0:	10c00617 	ldw	r3,24(r2)
 1012fb4:	e13ffb0b 	ldhu	r4,-20(fp)
 1012fb8:	e0bfff17 	ldw	r2,-4(fp)
 1012fbc:	d8800115 	stw	r2,4(sp)
 1012fc0:	e0bffe17 	ldw	r2,-8(fp)
 1012fc4:	d8800015 	stw	r2,0(sp)
 1012fc8:	e1fffd17 	ldw	r7,-12(fp)
 1012fcc:	200d883a 	mov	r6,r4
 1012fd0:	180b883a 	mov	r5,r3
 1012fd4:	e13ffc17 	ldw	r4,-16(fp)
 1012fd8:	10137c40 	call	10137c4 <vq_ring_add_buffer>
 1012fdc:	e0bffb8d 	sth	r2,-18(fp)
					 buf_list, readable, writable);

		vq->vq_desc_head_idx = idx;
 1012fe0:	e0bffc17 	ldw	r2,-16(fp)
 1012fe4:	e0fffb8b 	ldhu	r3,-18(fp)
 1012fe8:	10c00b0d 	sth	r3,44(r2)
		vq->vq_free_cnt -= needed;
 1012fec:	e0bffc17 	ldw	r2,-16(fp)
 1012ff0:	1080090b 	ldhu	r2,36(r2)
 1012ff4:	e0fffa17 	ldw	r3,-24(fp)
 1012ff8:	10c5c83a 	sub	r2,r2,r3
 1012ffc:	1007883a 	mov	r3,r2
 1013000:	e0bffc17 	ldw	r2,-16(fp)
 1013004:	10c0090d 	sth	r3,36(r2)

		/*
		 * Update vring_avail control block fields so that other
		 * side can get buffer using it.
		 */
		vq_ring_update_avail(vq, head_idx);
 1013008:	e0bffb0b 	ldhu	r2,-20(fp)
 101300c:	100b883a 	mov	r5,r2
 1013010:	e13ffc17 	ldw	r4,-16(fp)
 1013014:	1013b000 	call	1013b00 <vq_ring_update_avail>
	}

	VQUEUE_IDLE(vq);

	return status;
 1013018:	e0bff917 	ldw	r2,-28(fp)
}
 101301c:	e037883a 	mov	sp,fp
 1013020:	dfc00117 	ldw	ra,4(sp)
 1013024:	df000017 	ldw	fp,0(sp)
 1013028:	dec00204 	addi	sp,sp,8
 101302c:	f800283a 	ret

01013030 <virtqueue_get_buffer>:
 * @param idx           - index of the buffer
 *
 * @return              - Pointer to used buffer
 */
void *virtqueue_get_buffer(struct virtqueue *vq, uint32_t *len, uint16_t *idx)
{
 1013030:	defff704 	addi	sp,sp,-36
 1013034:	dfc00815 	stw	ra,32(sp)
 1013038:	df000715 	stw	fp,28(sp)
 101303c:	df000704 	addi	fp,sp,28
 1013040:	e13ffd15 	stw	r4,-12(fp)
 1013044:	e17ffe15 	stw	r5,-8(fp)
 1013048:	e1bfff15 	stw	r6,-4(fp)
	struct vring_used_elem *uep;
	void *cookie;
	uint16_t used_idx, desc_idx;

	if (!vq || vq->vq_used_cons_idx == vq->vq_ring.used->idx)
 101304c:	e0bffd17 	ldw	r2,-12(fp)
 1013050:	10000826 	beq	r2,zero,1013074 <virtqueue_get_buffer+0x44>
 1013054:	e0bffd17 	ldw	r2,-12(fp)
 1013058:	10c00b8b 	ldhu	r3,46(r2)
 101305c:	e0bffd17 	ldw	r2,-12(fp)
 1013060:	10800817 	ldw	r2,32(r2)
 1013064:	1080008b 	ldhu	r2,2(r2)
 1013068:	18ffffcc 	andi	r3,r3,65535
 101306c:	10bfffcc 	andi	r2,r2,65535
 1013070:	1880021e 	bne	r3,r2,101307c <virtqueue_get_buffer+0x4c>
		return NULL;
 1013074:	0005883a 	mov	r2,zero
 1013078:	00003406 	br	101314c <virtqueue_get_buffer+0x11c>

	VQUEUE_BUSY(vq);

	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
 101307c:	e0bffd17 	ldw	r2,-12(fp)
 1013080:	10800b8b 	ldhu	r2,46(r2)
 1013084:	10c00044 	addi	r3,r2,1
 1013088:	1809883a 	mov	r4,r3
 101308c:	e0fffd17 	ldw	r3,-12(fp)
 1013090:	19000b8d 	sth	r4,46(r3)
 1013094:	1007883a 	mov	r3,r2
 1013098:	e0bffd17 	ldw	r2,-12(fp)
 101309c:	1080028b 	ldhu	r2,10(r2)
 10130a0:	10bfffc4 	addi	r2,r2,-1
 10130a4:	1884703a 	and	r2,r3,r2
 10130a8:	e0bff90d 	sth	r2,-28(fp)
	uep = &vq->vq_ring.used->ring[used_idx];
 10130ac:	e0bffd17 	ldw	r2,-12(fp)
 10130b0:	10c00817 	ldw	r3,32(r2)
 10130b4:	e0bff90b 	ldhu	r2,-28(fp)
 10130b8:	100490fa 	slli	r2,r2,3
 10130bc:	10800104 	addi	r2,r2,4
 10130c0:	1885883a 	add	r2,r3,r2
 10130c4:	e0bffa15 	stw	r2,-24(fp)

	atomic_thread_fence(memory_order_seq_cst);
 10130c8:	0001b03a 	sync

	desc_idx = (uint16_t)uep->id;
 10130cc:	e0bffa17 	ldw	r2,-24(fp)
 10130d0:	10800017 	ldw	r2,0(r2)
 10130d4:	e0bffb0d 	sth	r2,-20(fp)
	if (len)
 10130d8:	e0bffe17 	ldw	r2,-8(fp)
 10130dc:	10000426 	beq	r2,zero,10130f0 <virtqueue_get_buffer+0xc0>
		*len = uep->len;
 10130e0:	e0bffa17 	ldw	r2,-24(fp)
 10130e4:	10c00117 	ldw	r3,4(r2)
 10130e8:	e0bffe17 	ldw	r2,-8(fp)
 10130ec:	10c00015 	stw	r3,0(r2)

	vq_ring_free_chain(vq, desc_idx);
 10130f0:	e0bffb0b 	ldhu	r2,-20(fp)
 10130f4:	100b883a 	mov	r5,r2
 10130f8:	e13ffd17 	ldw	r4,-12(fp)
 10130fc:	10139100 	call	1013910 <vq_ring_free_chain>

	cookie = vq->vq_descx[desc_idx].cookie;
 1013100:	e0bffb0b 	ldhu	r2,-20(fp)
 1013104:	e0fffd17 	ldw	r3,-12(fp)
 1013108:	100490fa 	slli	r2,r2,3
 101310c:	1885883a 	add	r2,r3,r2
 1013110:	10800d04 	addi	r2,r2,52
 1013114:	10800017 	ldw	r2,0(r2)
 1013118:	e0bffc15 	stw	r2,-16(fp)
	vq->vq_descx[desc_idx].cookie = NULL;
 101311c:	e0bffb0b 	ldhu	r2,-20(fp)
 1013120:	e0fffd17 	ldw	r3,-12(fp)
 1013124:	100490fa 	slli	r2,r2,3
 1013128:	1885883a 	add	r2,r3,r2
 101312c:	10800d04 	addi	r2,r2,52
 1013130:	10000015 	stw	zero,0(r2)

	if (idx)
 1013134:	e0bfff17 	ldw	r2,-4(fp)
 1013138:	10000326 	beq	r2,zero,1013148 <virtqueue_get_buffer+0x118>
		*idx = used_idx;
 101313c:	e0bfff17 	ldw	r2,-4(fp)
 1013140:	e0fff90b 	ldhu	r3,-28(fp)
 1013144:	10c0000d 	sth	r3,0(r2)
	VQUEUE_IDLE(vq);

	return cookie;
 1013148:	e0bffc17 	ldw	r2,-16(fp)
}
 101314c:	e037883a 	mov	sp,fp
 1013150:	dfc00117 	ldw	ra,4(sp)
 1013154:	df000017 	ldw	fp,0(sp)
 1013158:	dec00204 	addi	sp,sp,8
 101315c:	f800283a 	ret

01013160 <virtqueue_get_buffer_length>:

uint32_t virtqueue_get_buffer_length(struct virtqueue *vq, uint16_t idx)
{
 1013160:	defffd04 	addi	sp,sp,-12
 1013164:	df000215 	stw	fp,8(sp)
 1013168:	df000204 	addi	fp,sp,8
 101316c:	e13ffe15 	stw	r4,-8(fp)
 1013170:	2805883a 	mov	r2,r5
 1013174:	e0bfff0d 	sth	r2,-4(fp)
	return vq->vq_ring.desc[idx].len;
 1013178:	e0bffe17 	ldw	r2,-8(fp)
 101317c:	10c00617 	ldw	r3,24(r2)
 1013180:	e0bfff0b 	ldhu	r2,-4(fp)
 1013184:	1004913a 	slli	r2,r2,4
 1013188:	1885883a 	add	r2,r3,r2
 101318c:	10800217 	ldw	r2,8(r2)
}
 1013190:	e037883a 	mov	sp,fp
 1013194:	df000017 	ldw	fp,0(sp)
 1013198:	dec00104 	addi	sp,sp,4
 101319c:	f800283a 	ret

010131a0 <virtqueue_free>:
 *
 * @param vq        - Pointer to VirtIO queue control block
 *
 */
void virtqueue_free(struct virtqueue *vq)
{
 10131a0:	defffd04 	addi	sp,sp,-12
 10131a4:	dfc00215 	stw	ra,8(sp)
 10131a8:	df000115 	stw	fp,4(sp)
 10131ac:	df000104 	addi	fp,sp,4
 10131b0:	e13fff15 	stw	r4,-4(fp)
	if (vq) {
 10131b4:	e0bfff17 	ldw	r2,-4(fp)
 10131b8:	10001c26 	beq	r2,zero,101322c <virtqueue_free+0x8c>
		if (vq->vq_free_cnt != vq->vq_nentries) {
 10131bc:	e0bfff17 	ldw	r2,-4(fp)
 10131c0:	10c0090b 	ldhu	r3,36(r2)
 10131c4:	e0bfff17 	ldw	r2,-4(fp)
 10131c8:	1080028b 	ldhu	r2,10(r2)
 10131cc:	18ffffcc 	andi	r3,r3,65535
 10131d0:	10bfffcc 	andi	r2,r2,65535
 10131d4:	18801326 	beq	r3,r2,1013224 <virtqueue_free+0x84>
			metal_log(METAL_LOG_WARNING,
 10131d8:	008060f4 	movhi	r2,387
 10131dc:	10baf104 	addi	r2,r2,-5180
 10131e0:	10800017 	ldw	r2,0(r2)
 10131e4:	10800130 	cmpltui	r2,r2,4
 10131e8:	10000e1e 	bne	r2,zero,1013224 <virtqueue_free+0x84>
 10131ec:	008060f4 	movhi	r2,387
 10131f0:	10baf104 	addi	r2,r2,-5180
 10131f4:	10800117 	ldw	r2,4(r2)
 10131f8:	10000a26 	beq	r2,zero,1013224 <virtqueue_free+0x84>
 10131fc:	008060f4 	movhi	r2,387
 1013200:	10baf104 	addi	r2,r2,-5180
 1013204:	10800117 	ldw	r2,4(r2)
 1013208:	e0ffff17 	ldw	r3,-4(fp)
 101320c:	18c00117 	ldw	r3,4(r3)
 1013210:	180d883a 	mov	r6,r3
 1013214:	014040f4 	movhi	r5,259
 1013218:	2967b104 	addi	r5,r5,-24892
 101321c:	01000104 	movi	r4,4
 1013220:	103ee83a 	callr	r2
				  "%s: freeing non-empty virtqueue\r\n",
				  vq->vq_name);
		}

		metal_free_memory(vq);
 1013224:	e13fff17 	ldw	r4,-4(fp)
 1013228:	1012acc0 	call	1012acc <metal_free_memory>
	}
}
 101322c:	0001883a 	nop
 1013230:	e037883a 	mov	sp,fp
 1013234:	dfc00117 	ldw	ra,4(sp)
 1013238:	df000017 	ldw	fp,0(sp)
 101323c:	dec00204 	addi	sp,sp,8
 1013240:	f800283a 	ret

01013244 <virtqueue_get_available_buffer>:
 *
 * @return                          - Pointer to available buffer
 */
void *virtqueue_get_available_buffer(struct virtqueue *vq, uint16_t *avail_idx,
				     uint32_t *len)
{
 1013244:	defff904 	addi	sp,sp,-28
 1013248:	dfc00615 	stw	ra,24(sp)
 101324c:	df000515 	stw	fp,20(sp)
 1013250:	df000504 	addi	fp,sp,20
 1013254:	e13ffd15 	stw	r4,-12(fp)
 1013258:	e17ffe15 	stw	r5,-8(fp)
 101325c:	e1bfff15 	stw	r6,-4(fp)
	uint16_t head_idx = 0;
 1013260:	e03ffb0d 	sth	zero,-20(fp)
	void *buffer;

	atomic_thread_fence(memory_order_seq_cst);
 1013264:	0001b03a 	sync
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 1013268:	e0bffd17 	ldw	r2,-12(fp)
 101326c:	10c00c0b 	ldhu	r3,48(r2)
 1013270:	e0bffd17 	ldw	r2,-12(fp)
 1013274:	10800717 	ldw	r2,28(r2)
 1013278:	1080008b 	ldhu	r2,2(r2)
 101327c:	18ffffcc 	andi	r3,r3,65535
 1013280:	10bfffcc 	andi	r2,r2,65535
 1013284:	1880021e 	bne	r3,r2,1013290 <virtqueue_get_available_buffer+0x4c>
		return NULL;
 1013288:	0005883a 	mov	r2,zero
 101328c:	00002d06 	br	1013344 <virtqueue_get_available_buffer+0x100>
	}

	VQUEUE_BUSY(vq);

	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
 1013290:	e0bffd17 	ldw	r2,-12(fp)
 1013294:	10800c0b 	ldhu	r2,48(r2)
 1013298:	10c00044 	addi	r3,r2,1
 101329c:	1809883a 	mov	r4,r3
 10132a0:	e0fffd17 	ldw	r3,-12(fp)
 10132a4:	19000c0d 	sth	r4,48(r3)
 10132a8:	1007883a 	mov	r3,r2
 10132ac:	e0bffd17 	ldw	r2,-12(fp)
 10132b0:	1080028b 	ldhu	r2,10(r2)
 10132b4:	10bfffc4 	addi	r2,r2,-1
 10132b8:	1884703a 	and	r2,r3,r2
 10132bc:	e0bffb0d 	sth	r2,-20(fp)
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
 10132c0:	e0bffd17 	ldw	r2,-12(fp)
 10132c4:	10c00717 	ldw	r3,28(r2)
 10132c8:	e0bffb0b 	ldhu	r2,-20(fp)
 10132cc:	10800084 	addi	r2,r2,2
 10132d0:	1085883a 	add	r2,r2,r2
 10132d4:	1885883a 	add	r2,r3,r2
 10132d8:	10c0000b 	ldhu	r3,0(r2)
 10132dc:	e0bffe17 	ldw	r2,-8(fp)
 10132e0:	10c0000d 	sth	r3,0(r2)

	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 10132e4:	e0bffd17 	ldw	r2,-12(fp)
 10132e8:	10c00617 	ldw	r3,24(r2)
 10132ec:	e0bffe17 	ldw	r2,-8(fp)
 10132f0:	1080000b 	ldhu	r2,0(r2)
 10132f4:	10bfffcc 	andi	r2,r2,65535
 10132f8:	1004913a 	slli	r2,r2,4
 10132fc:	1889883a 	add	r4,r3,r2
 1013300:	20800017 	ldw	r2,0(r4)
 1013304:	20c00117 	ldw	r3,4(r4)
 1013308:	100b883a 	mov	r5,r2
 101330c:	e13ffd17 	ldw	r4,-12(fp)
 1013310:	1012de00 	call	1012de0 <virtqueue_phys_to_virt>
 1013314:	e0bffc15 	stw	r2,-16(fp)
	*len = vq->vq_ring.desc[*avail_idx].len;
 1013318:	e0bffd17 	ldw	r2,-12(fp)
 101331c:	10c00617 	ldw	r3,24(r2)
 1013320:	e0bffe17 	ldw	r2,-8(fp)
 1013324:	1080000b 	ldhu	r2,0(r2)
 1013328:	10bfffcc 	andi	r2,r2,65535
 101332c:	1004913a 	slli	r2,r2,4
 1013330:	1885883a 	add	r2,r3,r2
 1013334:	10c00217 	ldw	r3,8(r2)
 1013338:	e0bfff17 	ldw	r2,-4(fp)
 101333c:	10c00015 	stw	r3,0(r2)

	VQUEUE_IDLE(vq);

	return buffer;
 1013340:	e0bffc17 	ldw	r2,-16(fp)
}
 1013344:	e037883a 	mov	sp,fp
 1013348:	dfc00117 	ldw	ra,4(sp)
 101334c:	df000017 	ldw	fp,0(sp)
 1013350:	dec00204 	addi	sp,sp,8
 1013354:	f800283a 	ret

01013358 <virtqueue_add_consumed_buffer>:
 *
 * @return                       - Function status
 */
int virtqueue_add_consumed_buffer(struct virtqueue *vq, uint16_t head_idx,
				  uint32_t len)
{
 1013358:	defffa04 	addi	sp,sp,-24
 101335c:	df000515 	stw	fp,20(sp)
 1013360:	df000504 	addi	fp,sp,20
 1013364:	e13ffd15 	stw	r4,-12(fp)
 1013368:	2805883a 	mov	r2,r5
 101336c:	e1bfff15 	stw	r6,-4(fp)
 1013370:	e0bffe0d 	sth	r2,-8(fp)
	struct vring_used_elem *used_desc = NULL;
 1013374:	e03ffb15 	stw	zero,-20(fp)
	uint16_t used_idx;

	if (head_idx > vq->vq_nentries) {
 1013378:	e0bffd17 	ldw	r2,-12(fp)
 101337c:	1080028b 	ldhu	r2,10(r2)
 1013380:	10ffffcc 	andi	r3,r2,65535
 1013384:	e0bffe0b 	ldhu	r2,-8(fp)
 1013388:	1880022e 	bgeu	r3,r2,1013394 <virtqueue_add_consumed_buffer+0x3c>
		return ERROR_VRING_NO_BUFF;
 101338c:	00bd1044 	movi	r2,-3007
 1013390:	00002306 	br	1013420 <virtqueue_add_consumed_buffer+0xc8>
	}

	VQUEUE_BUSY(vq);

	used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
 1013394:	e0bffd17 	ldw	r2,-12(fp)
 1013398:	10800817 	ldw	r2,32(r2)
 101339c:	1080008b 	ldhu	r2,2(r2)
 10133a0:	1007883a 	mov	r3,r2
 10133a4:	e0bffd17 	ldw	r2,-12(fp)
 10133a8:	1080028b 	ldhu	r2,10(r2)
 10133ac:	10bfffc4 	addi	r2,r2,-1
 10133b0:	1884703a 	and	r2,r3,r2
 10133b4:	e0bffc0d 	sth	r2,-16(fp)
	used_desc = &vq->vq_ring.used->ring[used_idx];
 10133b8:	e0bffd17 	ldw	r2,-12(fp)
 10133bc:	10c00817 	ldw	r3,32(r2)
 10133c0:	e0bffc0b 	ldhu	r2,-16(fp)
 10133c4:	100490fa 	slli	r2,r2,3
 10133c8:	10800104 	addi	r2,r2,4
 10133cc:	1885883a 	add	r2,r3,r2
 10133d0:	e0bffb15 	stw	r2,-20(fp)
	used_desc->id = head_idx;
 10133d4:	e0fffe0b 	ldhu	r3,-8(fp)
 10133d8:	e0bffb17 	ldw	r2,-20(fp)
 10133dc:	10c00015 	stw	r3,0(r2)
	used_desc->len = len;
 10133e0:	e0bffb17 	ldw	r2,-20(fp)
 10133e4:	e0ffff17 	ldw	r3,-4(fp)
 10133e8:	10c00115 	stw	r3,4(r2)

	atomic_thread_fence(memory_order_seq_cst);
 10133ec:	0001b03a 	sync

	vq->vq_ring.used->idx++;
 10133f0:	e0bffd17 	ldw	r2,-12(fp)
 10133f4:	10800817 	ldw	r2,32(r2)
 10133f8:	10c0008b 	ldhu	r3,2(r2)
 10133fc:	18c00044 	addi	r3,r3,1
 1013400:	10c0008d 	sth	r3,2(r2)

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
 1013404:	e0bffd17 	ldw	r2,-12(fp)
 1013408:	1080098b 	ldhu	r2,38(r2)
 101340c:	10800044 	addi	r2,r2,1
 1013410:	1007883a 	mov	r3,r2
 1013414:	e0bffd17 	ldw	r2,-12(fp)
 1013418:	10c0098d 	sth	r3,38(r2)

	VQUEUE_IDLE(vq);

	return VQUEUE_SUCCESS;
 101341c:	0005883a 	mov	r2,zero
}
 1013420:	e037883a 	mov	sp,fp
 1013424:	df000017 	ldw	fp,0(sp)
 1013428:	dec00104 	addi	sp,sp,4
 101342c:	f800283a 	ret

01013430 <virtqueue_enable_cb>:
 * @param vq            - Pointer to VirtIO queue control block
 *
 * @return              - Function status
 */
int virtqueue_enable_cb(struct virtqueue *vq)
{
 1013430:	defffd04 	addi	sp,sp,-12
 1013434:	dfc00215 	stw	ra,8(sp)
 1013438:	df000115 	stw	fp,4(sp)
 101343c:	df000104 	addi	fp,sp,4
 1013440:	e13fff15 	stw	r4,-4(fp)
	return vq_ring_enable_interrupt(vq, 0);
 1013444:	000b883a 	mov	r5,zero
 1013448:	e13fff17 	ldw	r4,-4(fp)
 101344c:	1013ba00 	call	1013ba0 <vq_ring_enable_interrupt>
}
 1013450:	e037883a 	mov	sp,fp
 1013454:	dfc00117 	ldw	ra,4(sp)
 1013458:	df000017 	ldw	fp,0(sp)
 101345c:	dec00204 	addi	sp,sp,8
 1013460:	f800283a 	ret

01013464 <virtqueue_disable_cb>:
 *
 * @param vq           - Pointer to VirtIO queue control block
 *
 */
void virtqueue_disable_cb(struct virtqueue *vq)
{
 1013464:	defffe04 	addi	sp,sp,-8
 1013468:	df000115 	stw	fp,4(sp)
 101346c:	df000104 	addi	fp,sp,4
 1013470:	e13fff15 	stw	r4,-4(fp)
	VQUEUE_BUSY(vq);

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 1013474:	e0bfff17 	ldw	r2,-4(fp)
 1013478:	11000017 	ldw	r4,0(r2)
 101347c:	20800317 	ldw	r2,12(r4)
 1013480:	20c00417 	ldw	r3,16(r4)
 1013484:	1148002c 	andhi	r5,r2,8192
 1013488:	180c703a 	and	r6,r3,zero
 101348c:	2805883a 	mov	r2,r5
 1013490:	1184b03a 	or	r2,r2,r6
 1013494:	10002626 	beq	r2,zero,1013530 <virtqueue_disable_cb+0xcc>
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 1013498:	e0bfff17 	ldw	r2,-4(fp)
 101349c:	10800017 	ldw	r2,0(r2)
 10134a0:	10800517 	ldw	r2,20(r2)
 10134a4:	10000e1e 	bne	r2,zero,10134e0 <virtqueue_disable_cb+0x7c>
			vring_used_event(&vq->vq_ring) =
 10134a8:	e0bfff17 	ldw	r2,-4(fp)
 10134ac:	10c00717 	ldw	r3,28(r2)
 10134b0:	e0bfff17 	ldw	r2,-4(fp)
 10134b4:	10800517 	ldw	r2,20(r2)
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
 10134b8:	e13fff17 	ldw	r4,-4(fp)
 10134bc:	21400b8b 	ldhu	r5,46(r4)
 10134c0:	e13fff17 	ldw	r4,-4(fp)
 10134c4:	2100028b 	ldhu	r4,10(r4)
	VQUEUE_BUSY(vq);

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
			vring_used_event(&vq->vq_ring) =
 10134c8:	2909c83a 	sub	r4,r5,r4
 10134cc:	213fffc4 	addi	r4,r4,-1
 10134d0:	10800084 	addi	r2,r2,2
 10134d4:	1085883a 	add	r2,r2,r2
 10134d8:	1885883a 	add	r2,r3,r2
 10134dc:	1100000d 	sth	r4,0(r2)
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
		}
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
 10134e0:	e0bfff17 	ldw	r2,-4(fp)
 10134e4:	10800017 	ldw	r2,0(r2)
 10134e8:	10800517 	ldw	r2,20(r2)
 10134ec:	10800058 	cmpnei	r2,r2,1
 10134f0:	1000261e 	bne	r2,zero,101358c <virtqueue_disable_cb+0x128>
			vring_avail_event(&vq->vq_ring) =
 10134f4:	e0bfff17 	ldw	r2,-4(fp)
 10134f8:	10c00817 	ldw	r3,32(r2)
 10134fc:	e0bfff17 	ldw	r2,-4(fp)
 1013500:	10800517 	ldw	r2,20(r2)
			    vq->vq_available_idx - vq->vq_nentries - 1;
 1013504:	e13fff17 	ldw	r4,-4(fp)
 1013508:	21400c0b 	ldhu	r5,48(r4)
 101350c:	e13fff17 	ldw	r4,-4(fp)
 1013510:	2100028b 	ldhu	r4,10(r4)
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
		}
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
			vring_avail_event(&vq->vq_ring) =
 1013514:	2909c83a 	sub	r4,r5,r4
 1013518:	213fffc4 	addi	r4,r4,-1
 101351c:	100490fa 	slli	r2,r2,3
 1013520:	1885883a 	add	r2,r3,r2
 1013524:	10800104 	addi	r2,r2,4
 1013528:	1100000d 	sth	r4,0(r2)
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
#endif /*VIRTIO_MASTER_ONLY*/
	}

	VQUEUE_IDLE(vq);
}
 101352c:	00001706 	br	101358c <virtqueue_disable_cb+0x128>
			    vq->vq_available_idx - vq->vq_nentries - 1;
		}
#endif /*VIRTIO_MASTER_ONLY*/
	} else {
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
 1013530:	e0bfff17 	ldw	r2,-4(fp)
 1013534:	10800017 	ldw	r2,0(r2)
 1013538:	10800517 	ldw	r2,20(r2)
 101353c:	1000071e 	bne	r2,zero,101355c <virtqueue_disable_cb+0xf8>
			vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
 1013540:	e0bfff17 	ldw	r2,-4(fp)
 1013544:	10800717 	ldw	r2,28(r2)
 1013548:	e0ffff17 	ldw	r3,-4(fp)
 101354c:	18c00717 	ldw	r3,28(r3)
 1013550:	18c0000b 	ldhu	r3,0(r3)
 1013554:	18c00054 	ori	r3,r3,1
 1013558:	10c0000d 	sth	r3,0(r2)
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
 101355c:	e0bfff17 	ldw	r2,-4(fp)
 1013560:	10800017 	ldw	r2,0(r2)
 1013564:	10800517 	ldw	r2,20(r2)
 1013568:	10800058 	cmpnei	r2,r2,1
 101356c:	1000071e 	bne	r2,zero,101358c <virtqueue_disable_cb+0x128>
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
 1013570:	e0bfff17 	ldw	r2,-4(fp)
 1013574:	10800817 	ldw	r2,32(r2)
 1013578:	e0ffff17 	ldw	r3,-4(fp)
 101357c:	18c00817 	ldw	r3,32(r3)
 1013580:	18c0000b 	ldhu	r3,0(r3)
 1013584:	18c00054 	ori	r3,r3,1
 1013588:	10c0000d 	sth	r3,0(r2)
#endif /*VIRTIO_MASTER_ONLY*/
	}

	VQUEUE_IDLE(vq);
}
 101358c:	0001883a 	nop
 1013590:	e037883a 	mov	sp,fp
 1013594:	df000017 	ldw	fp,0(sp)
 1013598:	dec00104 	addi	sp,sp,4
 101359c:	f800283a 	ret

010135a0 <virtqueue_kick>:
 * virtqueue_kick - Notifies other side that there is buffer available for it.
 *
 * @param vq      - Pointer to VirtIO queue control block
 */
void virtqueue_kick(struct virtqueue *vq)
{
 10135a0:	defffd04 	addi	sp,sp,-12
 10135a4:	dfc00215 	stw	ra,8(sp)
 10135a8:	df000115 	stw	fp,4(sp)
 10135ac:	df000104 	addi	fp,sp,4
 10135b0:	e13fff15 	stw	r4,-4(fp)
	VQUEUE_BUSY(vq);

	/* Ensure updated avail->idx is visible to host. */
	atomic_thread_fence(memory_order_seq_cst);
 10135b4:	0001b03a 	sync

	if (vq_ring_must_notify(vq))
 10135b8:	e13fff17 	ldw	r4,-4(fp)
 10135bc:	1013d900 	call	1013d90 <vq_ring_must_notify>
 10135c0:	10000226 	beq	r2,zero,10135cc <virtqueue_kick+0x2c>
		vq_ring_notify(vq);
 10135c4:	e13fff17 	ldw	r4,-4(fp)
 10135c8:	1013f480 	call	1013f48 <vq_ring_notify>

	vq->vq_queued_cnt = 0;
 10135cc:	e0bfff17 	ldw	r2,-4(fp)
 10135d0:	1000098d 	sth	zero,38(r2)

	VQUEUE_IDLE(vq);
}
 10135d4:	0001883a 	nop
 10135d8:	e037883a 	mov	sp,fp
 10135dc:	dfc00117 	ldw	ra,4(sp)
 10135e0:	df000017 	ldw	fp,0(sp)
 10135e4:	dec00204 	addi	sp,sp,8
 10135e8:	f800283a 	ret

010135ec <virtqueue_dump>:
 * virtqueue_dump Dumps important virtqueue fields , use for debugging purposes
 *
 * @param vq - Pointer to VirtIO queue control block
 */
void virtqueue_dump(struct virtqueue *vq)
{
 10135ec:	defff504 	addi	sp,sp,-44
 10135f0:	dfc00a15 	stw	ra,40(sp)
 10135f4:	df000915 	stw	fp,36(sp)
 10135f8:	df000904 	addi	fp,sp,36
 10135fc:	e13fff15 	stw	r4,-4(fp)
	if (!vq)
 1013600:	e0bfff17 	ldw	r2,-4(fp)
 1013604:	10003c26 	beq	r2,zero,10136f8 <virtqueue_dump+0x10c>
		return;

	metal_log(METAL_LOG_DEBUG,
 1013608:	008060f4 	movhi	r2,387
 101360c:	10baf104 	addi	r2,r2,-5180
 1013610:	10800017 	ldw	r2,0(r2)
 1013614:	108001f0 	cmpltui	r2,r2,7
 1013618:	1000381e 	bne	r2,zero,10136fc <virtqueue_dump+0x110>
 101361c:	008060f4 	movhi	r2,387
 1013620:	10baf104 	addi	r2,r2,-5180
 1013624:	10800117 	ldw	r2,4(r2)
 1013628:	10003426 	beq	r2,zero,10136fc <virtqueue_dump+0x110>
 101362c:	008060f4 	movhi	r2,387
 1013630:	10baf104 	addi	r2,r2,-5180
 1013634:	10800117 	ldw	r2,4(r2)
 1013638:	e0ffff17 	ldw	r3,-4(fp)
 101363c:	1ac00117 	ldw	r11,4(r3)
 1013640:	e0ffff17 	ldw	r3,-4(fp)
 1013644:	18c0028b 	ldhu	r3,10(r3)
 1013648:	1b3fffcc 	andi	r12,r3,65535
 101364c:	e0ffff17 	ldw	r3,-4(fp)
 1013650:	18c0090b 	ldhu	r3,36(r3)
 1013654:	18ffffcc 	andi	r3,r3,65535
 1013658:	e13fff17 	ldw	r4,-4(fp)
 101365c:	2100098b 	ldhu	r4,38(r4)
 1013660:	213fffcc 	andi	r4,r4,65535
 1013664:	e17fff17 	ldw	r5,-4(fp)
 1013668:	29400b0b 	ldhu	r5,44(r5)
 101366c:	297fffcc 	andi	r5,r5,65535
 1013670:	e1bfff17 	ldw	r6,-4(fp)
 1013674:	31800717 	ldw	r6,28(r6)
 1013678:	3180008b 	ldhu	r6,2(r6)
 101367c:	31bfffcc 	andi	r6,r6,65535
 1013680:	e1ffff17 	ldw	r7,-4(fp)
 1013684:	39c00b8b 	ldhu	r7,46(r7)
 1013688:	39ffffcc 	andi	r7,r7,65535
 101368c:	e23fff17 	ldw	r8,-4(fp)
 1013690:	42000817 	ldw	r8,32(r8)
 1013694:	4200008b 	ldhu	r8,2(r8)
 1013698:	423fffcc 	andi	r8,r8,65535
 101369c:	e27fff17 	ldw	r9,-4(fp)
 10136a0:	4a400717 	ldw	r9,28(r9)
 10136a4:	4a40000b 	ldhu	r9,0(r9)
 10136a8:	4a7fffcc 	andi	r9,r9,65535
 10136ac:	e2bfff17 	ldw	r10,-4(fp)
 10136b0:	52800817 	ldw	r10,32(r10)
 10136b4:	5280000b 	ldhu	r10,0(r10)
 10136b8:	52bfffcc 	andi	r10,r10,65535
 10136bc:	da800715 	stw	r10,28(sp)
 10136c0:	da400615 	stw	r9,24(sp)
 10136c4:	da000515 	stw	r8,20(sp)
 10136c8:	d9c00415 	stw	r7,16(sp)
 10136cc:	d9800315 	stw	r6,12(sp)
 10136d0:	d9400215 	stw	r5,8(sp)
 10136d4:	d9000115 	stw	r4,4(sp)
 10136d8:	d8c00015 	stw	r3,0(sp)
 10136dc:	600f883a 	mov	r7,r12
 10136e0:	580d883a 	mov	r6,r11
 10136e4:	014040f4 	movhi	r5,259
 10136e8:	2967ba04 	addi	r5,r5,-24856
 10136ec:	010001c4 	movi	r4,7
 10136f0:	103ee83a 	callr	r2
 10136f4:	00000106 	br	10136fc <virtqueue_dump+0x110>
 * @param vq - Pointer to VirtIO queue control block
 */
void virtqueue_dump(struct virtqueue *vq)
{
	if (!vq)
		return;
 10136f8:	0001883a 	nop
		  vq->vq_name, vq->vq_nentries, vq->vq_free_cnt,
		  vq->vq_queued_cnt, vq->vq_desc_head_idx,
		  vq->vq_ring.avail->idx, vq->vq_used_cons_idx,
		  vq->vq_ring.used->idx, vq->vq_ring.avail->flags,
		  vq->vq_ring.used->flags);
}
 10136fc:	e037883a 	mov	sp,fp
 1013700:	dfc00117 	ldw	ra,4(sp)
 1013704:	df000017 	ldw	fp,0(sp)
 1013708:	dec00204 	addi	sp,sp,8
 101370c:	f800283a 	ret

01013710 <virtqueue_get_desc_size>:
 * @param vq            - Pointer to VirtIO queue control block
 *
 * @return              - Descriptor length
 */
uint32_t virtqueue_get_desc_size(struct virtqueue *vq)
{
 1013710:	defffc04 	addi	sp,sp,-16
 1013714:	df000315 	stw	fp,12(sp)
 1013718:	df000304 	addi	fp,sp,12
 101371c:	e13fff15 	stw	r4,-4(fp)
	uint16_t head_idx = 0;
 1013720:	e03ffd0d 	sth	zero,-12(fp)
	uint16_t avail_idx = 0;
 1013724:	e03ffd8d 	sth	zero,-10(fp)
	uint32_t len = 0;
 1013728:	e03ffe15 	stw	zero,-8(fp)

	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 101372c:	e0bfff17 	ldw	r2,-4(fp)
 1013730:	10c00c0b 	ldhu	r3,48(r2)
 1013734:	e0bfff17 	ldw	r2,-4(fp)
 1013738:	10800717 	ldw	r2,28(r2)
 101373c:	1080008b 	ldhu	r2,2(r2)
 1013740:	18ffffcc 	andi	r3,r3,65535
 1013744:	10bfffcc 	andi	r2,r2,65535
 1013748:	1880021e 	bne	r3,r2,1013754 <virtqueue_get_desc_size+0x44>
		return 0;
 101374c:	0005883a 	mov	r2,zero
 1013750:	00001806 	br	10137b4 <virtqueue_get_desc_size+0xa4>
	}

	VQUEUE_BUSY(vq);

	head_idx = vq->vq_available_idx & (vq->vq_nentries - 1);
 1013754:	e0bfff17 	ldw	r2,-4(fp)
 1013758:	10800c0b 	ldhu	r2,48(r2)
 101375c:	1007883a 	mov	r3,r2
 1013760:	e0bfff17 	ldw	r2,-4(fp)
 1013764:	1080028b 	ldhu	r2,10(r2)
 1013768:	10bfffc4 	addi	r2,r2,-1
 101376c:	1884703a 	and	r2,r3,r2
 1013770:	e0bffd0d 	sth	r2,-12(fp)
	avail_idx = vq->vq_ring.avail->ring[head_idx];
 1013774:	e0bfff17 	ldw	r2,-4(fp)
 1013778:	10c00717 	ldw	r3,28(r2)
 101377c:	e0bffd0b 	ldhu	r2,-12(fp)
 1013780:	10800084 	addi	r2,r2,2
 1013784:	1085883a 	add	r2,r2,r2
 1013788:	1885883a 	add	r2,r3,r2
 101378c:	1080000b 	ldhu	r2,0(r2)
 1013790:	e0bffd8d 	sth	r2,-10(fp)
	len = vq->vq_ring.desc[avail_idx].len;
 1013794:	e0bfff17 	ldw	r2,-4(fp)
 1013798:	10c00617 	ldw	r3,24(r2)
 101379c:	e0bffd8b 	ldhu	r2,-10(fp)
 10137a0:	1004913a 	slli	r2,r2,4
 10137a4:	1885883a 	add	r2,r3,r2
 10137a8:	10800217 	ldw	r2,8(r2)
 10137ac:	e0bffe15 	stw	r2,-8(fp)

	VQUEUE_IDLE(vq);

	return len;
 10137b0:	e0bffe17 	ldw	r2,-8(fp)
}
 10137b4:	e037883a 	mov	sp,fp
 10137b8:	df000017 	ldw	fp,0(sp)
 10137bc:	dec00104 	addi	sp,sp,4
 10137c0:	f800283a 	ret

010137c4 <vq_ring_add_buffer>:
 */
static uint16_t vq_ring_add_buffer(struct virtqueue *vq,
				   struct vring_desc *desc, uint16_t head_idx,
				   struct virtqueue_buf *buf_list, int readable,
				   int writable)
{
 10137c4:	defff404 	addi	sp,sp,-48
 10137c8:	dfc00b15 	stw	ra,44(sp)
 10137cc:	df000a15 	stw	fp,40(sp)
 10137d0:	dc400915 	stw	r17,36(sp)
 10137d4:	dc000815 	stw	r16,32(sp)
 10137d8:	df000a04 	addi	fp,sp,40
 10137dc:	e13ffa15 	stw	r4,-24(fp)
 10137e0:	e17ffb15 	stw	r5,-20(fp)
 10137e4:	3005883a 	mov	r2,r6
 10137e8:	e1fffd15 	stw	r7,-12(fp)
 10137ec:	e0bffc0d 	sth	r2,-16(fp)
	int i, needed;
	uint16_t idx;

	(void)vq;

	needed = readable + writable;
 10137f0:	e0c00217 	ldw	r3,8(fp)
 10137f4:	e0800317 	ldw	r2,12(fp)
 10137f8:	1885883a 	add	r2,r3,r2
 10137fc:	e0bff815 	stw	r2,-32(fp)

	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1013800:	e03ff615 	stw	zero,-40(fp)
 1013804:	e0bffc0b 	ldhu	r2,-16(fp)
 1013808:	e0bff70d 	sth	r2,-36(fp)
 101380c:	00003506 	br	10138e4 <vq_ring_add_buffer+0x120>
		VQASSERT(vq, idx != VQ_RING_DESC_CHAIN_END,
			 "premature end of free desc chain");

		dp = &desc[idx];
 1013810:	e0bff70b 	ldhu	r2,-36(fp)
 1013814:	1004913a 	slli	r2,r2,4
 1013818:	e0fffb17 	ldw	r3,-20(fp)
 101381c:	1885883a 	add	r2,r3,r2
 1013820:	e0bff915 	stw	r2,-28(fp)
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 1013824:	e0bff617 	ldw	r2,-40(fp)
 1013828:	100490fa 	slli	r2,r2,3
 101382c:	e0fffd17 	ldw	r3,-12(fp)
 1013830:	1885883a 	add	r2,r3,r2
 1013834:	10800017 	ldw	r2,0(r2)
 1013838:	100b883a 	mov	r5,r2
 101383c:	e13ffa17 	ldw	r4,-24(fp)
 1013840:	1012e240 	call	1012e24 <virtqueue_virt_to_phys>
 1013844:	1021883a 	mov	r16,r2
 1013848:	0023883a 	mov	r17,zero
 101384c:	e0bff917 	ldw	r2,-28(fp)
 1013850:	14000015 	stw	r16,0(r2)
 1013854:	14400115 	stw	r17,4(r2)
		dp->len = buf_list[i].len;
 1013858:	e0bff617 	ldw	r2,-40(fp)
 101385c:	100490fa 	slli	r2,r2,3
 1013860:	e0fffd17 	ldw	r3,-12(fp)
 1013864:	1885883a 	add	r2,r3,r2
 1013868:	10800117 	ldw	r2,4(r2)
 101386c:	1007883a 	mov	r3,r2
 1013870:	e0bff917 	ldw	r2,-28(fp)
 1013874:	10c00215 	stw	r3,8(r2)
		dp->flags = 0;
 1013878:	e0bff917 	ldw	r2,-28(fp)
 101387c:	1000030d 	sth	zero,12(r2)

		if (i < needed - 1)
 1013880:	e0bff817 	ldw	r2,-32(fp)
 1013884:	10bfffc4 	addi	r2,r2,-1
 1013888:	e0fff617 	ldw	r3,-40(fp)
 101388c:	1880060e 	bge	r3,r2,10138a8 <vq_ring_add_buffer+0xe4>
			dp->flags |= VRING_DESC_F_NEXT;
 1013890:	e0bff917 	ldw	r2,-28(fp)
 1013894:	1080030b 	ldhu	r2,12(r2)
 1013898:	10800054 	ori	r2,r2,1
 101389c:	1007883a 	mov	r3,r2
 10138a0:	e0bff917 	ldw	r2,-28(fp)
 10138a4:	10c0030d 	sth	r3,12(r2)

		/*
		 * Readable buffers are inserted  into vring before the
		 * writable buffers.
		 */
		if (i >= readable)
 10138a8:	e0fff617 	ldw	r3,-40(fp)
 10138ac:	e0800217 	ldw	r2,8(fp)
 10138b0:	18800616 	blt	r3,r2,10138cc <vq_ring_add_buffer+0x108>
			dp->flags |= VRING_DESC_F_WRITE;
 10138b4:	e0bff917 	ldw	r2,-28(fp)
 10138b8:	1080030b 	ldhu	r2,12(r2)
 10138bc:	10800094 	ori	r2,r2,2
 10138c0:	1007883a 	mov	r3,r2
 10138c4:	e0bff917 	ldw	r2,-28(fp)
 10138c8:	10c0030d 	sth	r3,12(r2)

	(void)vq;

	needed = readable + writable;

	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 10138cc:	e0bff617 	ldw	r2,-40(fp)
 10138d0:	10800044 	addi	r2,r2,1
 10138d4:	e0bff615 	stw	r2,-40(fp)
 10138d8:	e0bff917 	ldw	r2,-28(fp)
 10138dc:	1080038b 	ldhu	r2,14(r2)
 10138e0:	e0bff70d 	sth	r2,-36(fp)
 10138e4:	e0fff617 	ldw	r3,-40(fp)
 10138e8:	e0bff817 	ldw	r2,-32(fp)
 10138ec:	18bfc816 	blt	r3,r2,1013810 <__alt_data_end+0xff013810>
		 */
		if (i >= readable)
			dp->flags |= VRING_DESC_F_WRITE;
	}

	return idx;
 10138f0:	e0bff70b 	ldhu	r2,-36(fp)
}
 10138f4:	e6fffe04 	addi	sp,fp,-8
 10138f8:	dfc00317 	ldw	ra,12(sp)
 10138fc:	df000217 	ldw	fp,8(sp)
 1013900:	dc400117 	ldw	r17,4(sp)
 1013904:	dc000017 	ldw	r16,0(sp)
 1013908:	dec00404 	addi	sp,sp,16
 101390c:	f800283a 	ret

01013910 <vq_ring_free_chain>:
 *
 * vq_ring_free_chain
 *
 */
static void vq_ring_free_chain(struct virtqueue *vq, uint16_t desc_idx)
{
 1013910:	defffb04 	addi	sp,sp,-20
 1013914:	df000415 	stw	fp,16(sp)
 1013918:	df000404 	addi	fp,sp,16
 101391c:	e13ffe15 	stw	r4,-8(fp)
 1013920:	2805883a 	mov	r2,r5
 1013924:	e0bfff0d 	sth	r2,-4(fp)
	struct vring_desc *dp;
	struct vq_desc_extra *dxp;

	VQ_RING_ASSERT_VALID_IDX(vq, desc_idx);
	dp = &vq->vq_ring.desc[desc_idx];
 1013928:	e0bffe17 	ldw	r2,-8(fp)
 101392c:	10c00617 	ldw	r3,24(r2)
 1013930:	e0bfff0b 	ldhu	r2,-4(fp)
 1013934:	1004913a 	slli	r2,r2,4
 1013938:	1885883a 	add	r2,r3,r2
 101393c:	e0bffc15 	stw	r2,-16(fp)
	dxp = &vq->vq_descx[desc_idx];
 1013940:	e0bfff0b 	ldhu	r2,-4(fp)
 1013944:	100490fa 	slli	r2,r2,3
 1013948:	10800d04 	addi	r2,r2,52
 101394c:	e0fffe17 	ldw	r3,-8(fp)
 1013950:	1885883a 	add	r2,r3,r2
 1013954:	e0bffd15 	stw	r2,-12(fp)

	if (vq->vq_free_cnt == 0) {
		VQ_RING_ASSERT_CHAIN_TERM(vq);
	}

	vq->vq_free_cnt += dxp->ndescs;
 1013958:	e0bffe17 	ldw	r2,-8(fp)
 101395c:	10c0090b 	ldhu	r3,36(r2)
 1013960:	e0bffd17 	ldw	r2,-12(fp)
 1013964:	1080010b 	ldhu	r2,4(r2)
 1013968:	1885883a 	add	r2,r3,r2
 101396c:	1007883a 	mov	r3,r2
 1013970:	e0bffe17 	ldw	r2,-8(fp)
 1013974:	10c0090d 	sth	r3,36(r2)
	dxp->ndescs--;
 1013978:	e0bffd17 	ldw	r2,-12(fp)
 101397c:	1080010b 	ldhu	r2,4(r2)
 1013980:	10bfffc4 	addi	r2,r2,-1
 1013984:	1007883a 	mov	r3,r2
 1013988:	e0bffd17 	ldw	r2,-12(fp)
 101398c:	10c0010d 	sth	r3,4(r2)

	if ((dp->flags & VRING_DESC_F_INDIRECT) == 0) {
 1013990:	e0bffc17 	ldw	r2,-16(fp)
 1013994:	1080030b 	ldhu	r2,12(r2)
 1013998:	10bfffcc 	andi	r2,r2,65535
 101399c:	1080010c 	andi	r2,r2,4
 10139a0:	1000141e 	bne	r2,zero,10139f4 <vq_ring_free_chain+0xe4>
		while (dp->flags & VRING_DESC_F_NEXT) {
 10139a4:	00000e06 	br	10139e0 <vq_ring_free_chain+0xd0>
			VQ_RING_ASSERT_VALID_IDX(vq, dp->next);
			dp = &vq->vq_ring.desc[dp->next];
 10139a8:	e0bffe17 	ldw	r2,-8(fp)
 10139ac:	10c00617 	ldw	r3,24(r2)
 10139b0:	e0bffc17 	ldw	r2,-16(fp)
 10139b4:	1080038b 	ldhu	r2,14(r2)
 10139b8:	10bfffcc 	andi	r2,r2,65535
 10139bc:	1004913a 	slli	r2,r2,4
 10139c0:	1885883a 	add	r2,r3,r2
 10139c4:	e0bffc15 	stw	r2,-16(fp)
			dxp->ndescs--;
 10139c8:	e0bffd17 	ldw	r2,-12(fp)
 10139cc:	1080010b 	ldhu	r2,4(r2)
 10139d0:	10bfffc4 	addi	r2,r2,-1
 10139d4:	1007883a 	mov	r3,r2
 10139d8:	e0bffd17 	ldw	r2,-12(fp)
 10139dc:	10c0010d 	sth	r3,4(r2)

	vq->vq_free_cnt += dxp->ndescs;
	dxp->ndescs--;

	if ((dp->flags & VRING_DESC_F_INDIRECT) == 0) {
		while (dp->flags & VRING_DESC_F_NEXT) {
 10139e0:	e0bffc17 	ldw	r2,-16(fp)
 10139e4:	1080030b 	ldhu	r2,12(r2)
 10139e8:	10bfffcc 	andi	r2,r2,65535
 10139ec:	1080004c 	andi	r2,r2,1
 10139f0:	103fed1e 	bne	r2,zero,10139a8 <__alt_data_end+0xff0139a8>
	/*
	 * We must append the existing free chain, if any, to the end of
	 * newly freed chain. If the virtqueue was completely used, then
	 * head would be VQ_RING_DESC_CHAIN_END (ASSERTed above).
	 */
	dp->next = vq->vq_desc_head_idx;
 10139f4:	e0bffe17 	ldw	r2,-8(fp)
 10139f8:	10c00b0b 	ldhu	r3,44(r2)
 10139fc:	e0bffc17 	ldw	r2,-16(fp)
 1013a00:	10c0038d 	sth	r3,14(r2)
	vq->vq_desc_head_idx = desc_idx;
 1013a04:	e0bffe17 	ldw	r2,-8(fp)
 1013a08:	e0ffff0b 	ldhu	r3,-4(fp)
 1013a0c:	10c00b0d 	sth	r3,44(r2)
}
 1013a10:	0001883a 	nop
 1013a14:	e037883a 	mov	sp,fp
 1013a18:	df000017 	ldw	fp,0(sp)
 1013a1c:	dec00104 	addi	sp,sp,4
 1013a20:	f800283a 	ret

01013a24 <vq_ring_init>:
 *
 * vq_ring_init
 *
 */
static void vq_ring_init(struct virtqueue *vq, void *ring_mem, int alignment)
{
 1013a24:	defff804 	addi	sp,sp,-32
 1013a28:	dfc00715 	stw	ra,28(sp)
 1013a2c:	df000615 	stw	fp,24(sp)
 1013a30:	df000604 	addi	fp,sp,24
 1013a34:	e13ffd15 	stw	r4,-12(fp)
 1013a38:	e17ffe15 	stw	r5,-8(fp)
 1013a3c:	e1bfff15 	stw	r6,-4(fp)
	struct vring *vr;
	int i, size;

	size = vq->vq_nentries;
 1013a40:	e0bffd17 	ldw	r2,-12(fp)
 1013a44:	1080028b 	ldhu	r2,10(r2)
 1013a48:	10bfffcc 	andi	r2,r2,65535
 1013a4c:	e0bffb15 	stw	r2,-20(fp)
	vr = &vq->vq_ring;
 1013a50:	e0bffd17 	ldw	r2,-12(fp)
 1013a54:	10800504 	addi	r2,r2,20
 1013a58:	e0bffc15 	stw	r2,-16(fp)

	vring_init(vr, size, ring_mem, alignment);
 1013a5c:	e0bffb17 	ldw	r2,-20(fp)
 1013a60:	e0ffff17 	ldw	r3,-4(fp)
 1013a64:	180f883a 	mov	r7,r3
 1013a68:	e1bffe17 	ldw	r6,-8(fp)
 1013a6c:	100b883a 	mov	r5,r2
 1013a70:	e13ffc17 	ldw	r4,-16(fp)
 1013a74:	10129cc0 	call	10129cc <vring_init>

#ifndef VIRTIO_SLAVE_ONLY
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 1013a78:	e0bffd17 	ldw	r2,-12(fp)
 1013a7c:	10800017 	ldw	r2,0(r2)
 1013a80:	10800517 	ldw	r2,20(r2)
 1013a84:	1000181e 	bne	r2,zero,1013ae8 <vq_ring_init+0xc4>
		for (i = 0; i < size - 1; i++)
 1013a88:	e03ffa15 	stw	zero,-24(fp)
 1013a8c:	00000b06 	br	1013abc <vq_ring_init+0x98>
			vr->desc[i].next = i + 1;
 1013a90:	e0bffc17 	ldw	r2,-16(fp)
 1013a94:	10c00117 	ldw	r3,4(r2)
 1013a98:	e0bffa17 	ldw	r2,-24(fp)
 1013a9c:	1004913a 	slli	r2,r2,4
 1013aa0:	1885883a 	add	r2,r3,r2
 1013aa4:	e0fffa17 	ldw	r3,-24(fp)
 1013aa8:	18c00044 	addi	r3,r3,1
 1013aac:	10c0038d 	sth	r3,14(r2)

	vring_init(vr, size, ring_mem, alignment);

#ifndef VIRTIO_SLAVE_ONLY
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
		for (i = 0; i < size - 1; i++)
 1013ab0:	e0bffa17 	ldw	r2,-24(fp)
 1013ab4:	10800044 	addi	r2,r2,1
 1013ab8:	e0bffa15 	stw	r2,-24(fp)
 1013abc:	e0bffb17 	ldw	r2,-20(fp)
 1013ac0:	10bfffc4 	addi	r2,r2,-1
 1013ac4:	e0fffa17 	ldw	r3,-24(fp)
 1013ac8:	18bff116 	blt	r3,r2,1013a90 <__alt_data_end+0xff013a90>
			vr->desc[i].next = i + 1;
		vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
 1013acc:	e0bffc17 	ldw	r2,-16(fp)
 1013ad0:	10c00117 	ldw	r3,4(r2)
 1013ad4:	e0bffa17 	ldw	r2,-24(fp)
 1013ad8:	1004913a 	slli	r2,r2,4
 1013adc:	1885883a 	add	r2,r3,r2
 1013ae0:	00e00004 	movi	r3,-32768
 1013ae4:	10c0038d 	sth	r3,14(r2)
	}
#endif /*VIRTIO_SLAVE_ONLY*/
}
 1013ae8:	0001883a 	nop
 1013aec:	e037883a 	mov	sp,fp
 1013af0:	dfc00117 	ldw	ra,4(sp)
 1013af4:	df000017 	ldw	fp,0(sp)
 1013af8:	dec00204 	addi	sp,sp,8
 1013afc:	f800283a 	ret

01013b00 <vq_ring_update_avail>:
 *
 * vq_ring_update_avail
 *
 */
static void vq_ring_update_avail(struct virtqueue *vq, uint16_t desc_idx)
{
 1013b00:	defffc04 	addi	sp,sp,-16
 1013b04:	df000315 	stw	fp,12(sp)
 1013b08:	df000304 	addi	fp,sp,12
 1013b0c:	e13ffe15 	stw	r4,-8(fp)
 1013b10:	2805883a 	mov	r2,r5
 1013b14:	e0bfff0d 	sth	r2,-4(fp)
	 * it usable to the host. The chain is made available now rather than
	 * deferring to virtqueue_notify() in the hopes that if the host is
	 * currently running on another CPU, we can keep it processing the new
	 * descriptor.
	 */
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
 1013b18:	e0bffe17 	ldw	r2,-8(fp)
 1013b1c:	10800717 	ldw	r2,28(r2)
 1013b20:	1080008b 	ldhu	r2,2(r2)
 1013b24:	1007883a 	mov	r3,r2
 1013b28:	e0bffe17 	ldw	r2,-8(fp)
 1013b2c:	1080028b 	ldhu	r2,10(r2)
 1013b30:	10bfffc4 	addi	r2,r2,-1
 1013b34:	1884703a 	and	r2,r3,r2
 1013b38:	e0bffd0d 	sth	r2,-12(fp)
	vq->vq_ring.avail->ring[avail_idx] = desc_idx;
 1013b3c:	e0bffe17 	ldw	r2,-8(fp)
 1013b40:	10c00717 	ldw	r3,28(r2)
 1013b44:	e0bffd0b 	ldhu	r2,-12(fp)
 1013b48:	10800084 	addi	r2,r2,2
 1013b4c:	1085883a 	add	r2,r2,r2
 1013b50:	1885883a 	add	r2,r3,r2
 1013b54:	e0ffff0b 	ldhu	r3,-4(fp)
 1013b58:	10c0000d 	sth	r3,0(r2)

	atomic_thread_fence(memory_order_seq_cst);
 1013b5c:	0001b03a 	sync

	vq->vq_ring.avail->idx++;
 1013b60:	e0bffe17 	ldw	r2,-8(fp)
 1013b64:	10800717 	ldw	r2,28(r2)
 1013b68:	10c0008b 	ldhu	r3,2(r2)
 1013b6c:	18c00044 	addi	r3,r3,1
 1013b70:	10c0008d 	sth	r3,2(r2)

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
 1013b74:	e0bffe17 	ldw	r2,-8(fp)
 1013b78:	1080098b 	ldhu	r2,38(r2)
 1013b7c:	10800044 	addi	r2,r2,1
 1013b80:	1007883a 	mov	r3,r2
 1013b84:	e0bffe17 	ldw	r2,-8(fp)
 1013b88:	10c0098d 	sth	r3,38(r2)
}
 1013b8c:	0001883a 	nop
 1013b90:	e037883a 	mov	sp,fp
 1013b94:	df000017 	ldw	fp,0(sp)
 1013b98:	dec00104 	addi	sp,sp,4
 1013b9c:	f800283a 	ret

01013ba0 <vq_ring_enable_interrupt>:
 *
 * vq_ring_enable_interrupt
 *
 */
static int vq_ring_enable_interrupt(struct virtqueue *vq, uint16_t ndesc)
{
 1013ba0:	defffc04 	addi	sp,sp,-16
 1013ba4:	dfc00315 	stw	ra,12(sp)
 1013ba8:	df000215 	stw	fp,8(sp)
 1013bac:	df000204 	addi	fp,sp,8
 1013bb0:	e13ffe15 	stw	r4,-8(fp)
 1013bb4:	2805883a 	mov	r2,r5
 1013bb8:	e0bfff0d 	sth	r2,-4(fp)
	/*
	 * Enable interrupts, making sure we get the latest index of
	 * what's already been consumed.
	 */
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 1013bbc:	e0bffe17 	ldw	r2,-8(fp)
 1013bc0:	11000017 	ldw	r4,0(r2)
 1013bc4:	20800317 	ldw	r2,12(r4)
 1013bc8:	20c00417 	ldw	r3,16(r4)
 1013bcc:	1188002c 	andhi	r6,r2,8192
 1013bd0:	180e703a 	and	r7,r3,zero
 1013bd4:	3005883a 	mov	r2,r6
 1013bd8:	11c4b03a 	or	r2,r2,r7
 1013bdc:	10002226 	beq	r2,zero,1013c68 <vq_ring_enable_interrupt+0xc8>
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
 1013be0:	e0bffe17 	ldw	r2,-8(fp)
 1013be4:	10800017 	ldw	r2,0(r2)
 1013be8:	10800517 	ldw	r2,20(r2)
 1013bec:	10000c1e 	bne	r2,zero,1013c20 <vq_ring_enable_interrupt+0x80>
			vring_used_event(&vq->vq_ring) = vq->vq_used_cons_idx + ndesc;
 1013bf0:	e0bffe17 	ldw	r2,-8(fp)
 1013bf4:	10c00717 	ldw	r3,28(r2)
 1013bf8:	e0bffe17 	ldw	r2,-8(fp)
 1013bfc:	10800517 	ldw	r2,20(r2)
 1013c00:	e13ffe17 	ldw	r4,-8(fp)
 1013c04:	21400b8b 	ldhu	r5,46(r4)
 1013c08:	e13fff0b 	ldhu	r4,-4(fp)
 1013c0c:	2909883a 	add	r4,r5,r4
 1013c10:	10800084 	addi	r2,r2,2
 1013c14:	1085883a 	add	r2,r2,r2
 1013c18:	1885883a 	add	r2,r3,r2
 1013c1c:	1100000d 	sth	r4,0(r2)
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
 1013c20:	e0bffe17 	ldw	r2,-8(fp)
 1013c24:	10800017 	ldw	r2,0(r2)
 1013c28:	10800517 	ldw	r2,20(r2)
 1013c2c:	10800058 	cmpnei	r2,r2,1
 1013c30:	1000261e 	bne	r2,zero,1013ccc <vq_ring_enable_interrupt+0x12c>
			vring_avail_event(&vq->vq_ring) = vq->vq_available_idx + ndesc;
 1013c34:	e0bffe17 	ldw	r2,-8(fp)
 1013c38:	10c00817 	ldw	r3,32(r2)
 1013c3c:	e0bffe17 	ldw	r2,-8(fp)
 1013c40:	10800517 	ldw	r2,20(r2)
 1013c44:	e13ffe17 	ldw	r4,-8(fp)
 1013c48:	21400c0b 	ldhu	r5,48(r4)
 1013c4c:	e13fff0b 	ldhu	r4,-4(fp)
 1013c50:	2909883a 	add	r4,r5,r4
 1013c54:	100490fa 	slli	r2,r2,3
 1013c58:	1885883a 	add	r2,r3,r2
 1013c5c:	10800104 	addi	r2,r2,4
 1013c60:	1100000d 	sth	r4,0(r2)
 1013c64:	00001906 	br	1013ccc <vq_ring_enable_interrupt+0x12c>
#endif /*VIRTIO_MASTER_ONLY*/
	} else {
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
 1013c68:	e0bffe17 	ldw	r2,-8(fp)
 1013c6c:	10800017 	ldw	r2,0(r2)
 1013c70:	10800517 	ldw	r2,20(r2)
 1013c74:	1000081e 	bne	r2,zero,1013c98 <vq_ring_enable_interrupt+0xf8>
			vq->vq_ring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
 1013c78:	e0bffe17 	ldw	r2,-8(fp)
 1013c7c:	10800717 	ldw	r2,28(r2)
 1013c80:	e0fffe17 	ldw	r3,-8(fp)
 1013c84:	18c00717 	ldw	r3,28(r3)
 1013c88:	1900000b 	ldhu	r4,0(r3)
 1013c8c:	00ffff84 	movi	r3,-2
 1013c90:	20c6703a 	and	r3,r4,r3
 1013c94:	10c0000d 	sth	r3,0(r2)
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
 1013c98:	e0bffe17 	ldw	r2,-8(fp)
 1013c9c:	10800017 	ldw	r2,0(r2)
 1013ca0:	10800517 	ldw	r2,20(r2)
 1013ca4:	10800058 	cmpnei	r2,r2,1
 1013ca8:	1000081e 	bne	r2,zero,1013ccc <vq_ring_enable_interrupt+0x12c>
			vq->vq_ring.used->flags &= ~VRING_USED_F_NO_NOTIFY;
 1013cac:	e0bffe17 	ldw	r2,-8(fp)
 1013cb0:	10800817 	ldw	r2,32(r2)
 1013cb4:	e0fffe17 	ldw	r3,-8(fp)
 1013cb8:	18c00817 	ldw	r3,32(r3)
 1013cbc:	1900000b 	ldhu	r4,0(r3)
 1013cc0:	00ffff84 	movi	r3,-2
 1013cc4:	20c6703a 	and	r3,r4,r3
 1013cc8:	10c0000d 	sth	r3,0(r2)
#endif /*VIRTIO_MASTER_ONLY*/
	}

	atomic_thread_fence(memory_order_seq_cst);
 1013ccc:	0001b03a 	sync
	 * Enough items may have already been consumed to meet our threshold
	 * since we last checked. Let our caller know so it processes the new
	 * entries.
	 */
#ifndef VIRTIO_SLAVE_ONLY
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 1013cd0:	e0bffe17 	ldw	r2,-8(fp)
 1013cd4:	10800017 	ldw	r2,0(r2)
 1013cd8:	10800517 	ldw	r2,20(r2)
 1013cdc:	1000071e 	bne	r2,zero,1013cfc <vq_ring_enable_interrupt+0x15c>
		if (virtqueue_nused(vq) > ndesc) {
 1013ce0:	e13ffe17 	ldw	r4,-8(fp)
 1013ce4:	1013f900 	call	1013f90 <virtqueue_nused>
 1013ce8:	1007883a 	mov	r3,r2
 1013cec:	e0bfff0b 	ldhu	r2,-4(fp)
 1013cf0:	10c0020e 	bge	r2,r3,1013cfc <vq_ring_enable_interrupt+0x15c>
			return 1;
 1013cf4:	00800044 	movi	r2,1
 1013cf8:	00000d06 	br	1013d30 <vq_ring_enable_interrupt+0x190>
		}
	}
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
	if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
 1013cfc:	e0bffe17 	ldw	r2,-8(fp)
 1013d00:	10800017 	ldw	r2,0(r2)
 1013d04:	10800517 	ldw	r2,20(r2)
 1013d08:	10800058 	cmpnei	r2,r2,1
 1013d0c:	1000071e 	bne	r2,zero,1013d2c <vq_ring_enable_interrupt+0x18c>
		if (virtqueue_navail(vq) > ndesc) {
 1013d10:	e13ffe17 	ldw	r4,-8(fp)
 1013d14:	1013fd80 	call	1013fd8 <virtqueue_navail>
 1013d18:	1007883a 	mov	r3,r2
 1013d1c:	e0bfff0b 	ldhu	r2,-4(fp)
 1013d20:	10c0020e 	bge	r2,r3,1013d2c <vq_ring_enable_interrupt+0x18c>
			return 1;
 1013d24:	00800044 	movi	r2,1
 1013d28:	00000106 	br	1013d30 <vq_ring_enable_interrupt+0x190>
		}
	}
#endif /*VIRTIO_MASTER_ONLY*/

	return 0;
 1013d2c:	0005883a 	mov	r2,zero
}
 1013d30:	e037883a 	mov	sp,fp
 1013d34:	dfc00117 	ldw	ra,4(sp)
 1013d38:	df000017 	ldw	fp,0(sp)
 1013d3c:	dec00204 	addi	sp,sp,8
 1013d40:	f800283a 	ret

01013d44 <virtqueue_notification>:
 *
 * virtqueue_interrupt
 *
 */
void virtqueue_notification(struct virtqueue *vq)
{
 1013d44:	defffd04 	addi	sp,sp,-12
 1013d48:	dfc00215 	stw	ra,8(sp)
 1013d4c:	df000115 	stw	fp,4(sp)
 1013d50:	df000104 	addi	fp,sp,4
 1013d54:	e13fff15 	stw	r4,-4(fp)
	atomic_thread_fence(memory_order_seq_cst);
 1013d58:	0001b03a 	sync
	if (vq->callback)
 1013d5c:	e0bfff17 	ldw	r2,-4(fp)
 1013d60:	10800317 	ldw	r2,12(r2)
 1013d64:	10000426 	beq	r2,zero,1013d78 <virtqueue_notification+0x34>
		vq->callback(vq);
 1013d68:	e0bfff17 	ldw	r2,-4(fp)
 1013d6c:	10800317 	ldw	r2,12(r2)
 1013d70:	e13fff17 	ldw	r4,-4(fp)
 1013d74:	103ee83a 	callr	r2
}
 1013d78:	0001883a 	nop
 1013d7c:	e037883a 	mov	sp,fp
 1013d80:	dfc00117 	ldw	ra,4(sp)
 1013d84:	df000017 	ldw	fp,0(sp)
 1013d88:	dec00204 	addi	sp,sp,8
 1013d8c:	f800283a 	ret

01013d90 <vq_ring_must_notify>:
 *
 * vq_ring_must_notify
 *
 */
static int vq_ring_must_notify(struct virtqueue *vq)
{
 1013d90:	defffb04 	addi	sp,sp,-20
 1013d94:	dfc00415 	stw	ra,16(sp)
 1013d98:	df000315 	stw	fp,12(sp)
 1013d9c:	df000304 	addi	fp,sp,12
 1013da0:	e13fff15 	stw	r4,-4(fp)
	uint16_t new_idx, prev_idx, event_idx;

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 1013da4:	e0bfff17 	ldw	r2,-4(fp)
 1013da8:	11000017 	ldw	r4,0(r2)
 1013dac:	20800317 	ldw	r2,12(r4)
 1013db0:	20c00417 	ldw	r3,16(r4)
 1013db4:	1148002c 	andhi	r5,r2,8192
 1013db8:	180c703a 	and	r6,r3,zero
 1013dbc:	2805883a 	mov	r2,r5
 1013dc0:	1184b03a 	or	r2,r2,r6
 1013dc4:	10004126 	beq	r2,zero,1013ecc <vq_ring_must_notify+0x13c>
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 1013dc8:	e0bfff17 	ldw	r2,-4(fp)
 1013dcc:	10800017 	ldw	r2,0(r2)
 1013dd0:	10800517 	ldw	r2,20(r2)
 1013dd4:	10001c1e 	bne	r2,zero,1013e48 <vq_ring_must_notify+0xb8>
			new_idx = vq->vq_ring.avail->idx;
 1013dd8:	e0bfff17 	ldw	r2,-4(fp)
 1013ddc:	10800717 	ldw	r2,28(r2)
 1013de0:	1080008b 	ldhu	r2,2(r2)
 1013de4:	e0bffd0d 	sth	r2,-12(fp)
			prev_idx = new_idx - vq->vq_queued_cnt;
 1013de8:	e0bfff17 	ldw	r2,-4(fp)
 1013dec:	1080098b 	ldhu	r2,38(r2)
 1013df0:	e0fffd0b 	ldhu	r3,-12(fp)
 1013df4:	1885c83a 	sub	r2,r3,r2
 1013df8:	e0bffd8d 	sth	r2,-10(fp)
			event_idx = vring_avail_event(&vq->vq_ring);
 1013dfc:	e0bfff17 	ldw	r2,-4(fp)
 1013e00:	10c00817 	ldw	r3,32(r2)
 1013e04:	e0bfff17 	ldw	r2,-4(fp)
 1013e08:	10800517 	ldw	r2,20(r2)
 1013e0c:	100490fa 	slli	r2,r2,3
 1013e10:	1885883a 	add	r2,r3,r2
 1013e14:	10800104 	addi	r2,r2,4
 1013e18:	1080000b 	ldhu	r2,0(r2)
 1013e1c:	e0bffe0d 	sth	r2,-8(fp)
			return vring_need_event(event_idx, new_idx, prev_idx) != 0;
 1013e20:	e0bffe0b 	ldhu	r2,-8(fp)
 1013e24:	e0fffd0b 	ldhu	r3,-12(fp)
 1013e28:	e13ffd8b 	ldhu	r4,-10(fp)
 1013e2c:	200d883a 	mov	r6,r4
 1013e30:	180b883a 	mov	r5,r3
 1013e34:	1009883a 	mov	r4,r2
 1013e38:	1012a6c0 	call	1012a6c <vring_need_event>
 1013e3c:	1004c03a 	cmpne	r2,r2,zero
 1013e40:	10803fcc 	andi	r2,r2,255
 1013e44:	00003b06 	br	1013f34 <vq_ring_must_notify+0x1a4>
		}
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
 1013e48:	e0bfff17 	ldw	r2,-4(fp)
 1013e4c:	10800017 	ldw	r2,0(r2)
 1013e50:	10800517 	ldw	r2,20(r2)
 1013e54:	10800058 	cmpnei	r2,r2,1
 1013e58:	1000351e 	bne	r2,zero,1013f30 <vq_ring_must_notify+0x1a0>
			new_idx = vq->vq_ring.used->idx;
 1013e5c:	e0bfff17 	ldw	r2,-4(fp)
 1013e60:	10800817 	ldw	r2,32(r2)
 1013e64:	1080008b 	ldhu	r2,2(r2)
 1013e68:	e0bffd0d 	sth	r2,-12(fp)
			prev_idx = new_idx - vq->vq_queued_cnt;
 1013e6c:	e0bfff17 	ldw	r2,-4(fp)
 1013e70:	1080098b 	ldhu	r2,38(r2)
 1013e74:	e0fffd0b 	ldhu	r3,-12(fp)
 1013e78:	1885c83a 	sub	r2,r3,r2
 1013e7c:	e0bffd8d 	sth	r2,-10(fp)
			event_idx = vring_used_event(&vq->vq_ring);
 1013e80:	e0bfff17 	ldw	r2,-4(fp)
 1013e84:	10c00717 	ldw	r3,28(r2)
 1013e88:	e0bfff17 	ldw	r2,-4(fp)
 1013e8c:	10800517 	ldw	r2,20(r2)
 1013e90:	10800084 	addi	r2,r2,2
 1013e94:	1085883a 	add	r2,r2,r2
 1013e98:	1885883a 	add	r2,r3,r2
 1013e9c:	1080000b 	ldhu	r2,0(r2)
 1013ea0:	e0bffe0d 	sth	r2,-8(fp)
			return vring_need_event(event_idx, new_idx, prev_idx) != 0;
 1013ea4:	e0bffe0b 	ldhu	r2,-8(fp)
 1013ea8:	e0fffd0b 	ldhu	r3,-12(fp)
 1013eac:	e13ffd8b 	ldhu	r4,-10(fp)
 1013eb0:	200d883a 	mov	r6,r4
 1013eb4:	180b883a 	mov	r5,r3
 1013eb8:	1009883a 	mov	r4,r2
 1013ebc:	1012a6c0 	call	1012a6c <vring_need_event>
 1013ec0:	1004c03a 	cmpne	r2,r2,zero
 1013ec4:	10803fcc 	andi	r2,r2,255
 1013ec8:	00001a06 	br	1013f34 <vq_ring_must_notify+0x1a4>
		}
#endif /*VIRTIO_MASTER_ONLY*/
	} else {
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
 1013ecc:	e0bfff17 	ldw	r2,-4(fp)
 1013ed0:	10800017 	ldw	r2,0(r2)
 1013ed4:	10800517 	ldw	r2,20(r2)
 1013ed8:	1000081e 	bne	r2,zero,1013efc <vq_ring_must_notify+0x16c>
			return (vq->vq_ring.used->flags & VRING_USED_F_NO_NOTIFY) == 0;
 1013edc:	e0bfff17 	ldw	r2,-4(fp)
 1013ee0:	10800817 	ldw	r2,32(r2)
 1013ee4:	1080000b 	ldhu	r2,0(r2)
 1013ee8:	10bfffcc 	andi	r2,r2,65535
 1013eec:	1080004c 	andi	r2,r2,1
 1013ef0:	1005003a 	cmpeq	r2,r2,zero
 1013ef4:	10803fcc 	andi	r2,r2,255
 1013ef8:	00000e06 	br	1013f34 <vq_ring_must_notify+0x1a4>
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
 1013efc:	e0bfff17 	ldw	r2,-4(fp)
 1013f00:	10800017 	ldw	r2,0(r2)
 1013f04:	10800517 	ldw	r2,20(r2)
 1013f08:	10800058 	cmpnei	r2,r2,1
 1013f0c:	1000081e 	bne	r2,zero,1013f30 <vq_ring_must_notify+0x1a0>
			return (vq->vq_ring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT) == 0;
 1013f10:	e0bfff17 	ldw	r2,-4(fp)
 1013f14:	10800717 	ldw	r2,28(r2)
 1013f18:	1080000b 	ldhu	r2,0(r2)
 1013f1c:	10bfffcc 	andi	r2,r2,65535
 1013f20:	1080004c 	andi	r2,r2,1
 1013f24:	1005003a 	cmpeq	r2,r2,zero
 1013f28:	10803fcc 	andi	r2,r2,255
 1013f2c:	00000106 	br	1013f34 <vq_ring_must_notify+0x1a4>
#endif /*VIRTIO_MASTER_ONLY*/
	}

	return 0;
 1013f30:	0005883a 	mov	r2,zero
}
 1013f34:	e037883a 	mov	sp,fp
 1013f38:	dfc00117 	ldw	ra,4(sp)
 1013f3c:	df000017 	ldw	fp,0(sp)
 1013f40:	dec00204 	addi	sp,sp,8
 1013f44:	f800283a 	ret

01013f48 <vq_ring_notify>:
 *
 * vq_ring_notify
 *
 */
static void vq_ring_notify(struct virtqueue *vq)
{
 1013f48:	defffd04 	addi	sp,sp,-12
 1013f4c:	dfc00215 	stw	ra,8(sp)
 1013f50:	df000115 	stw	fp,4(sp)
 1013f54:	df000104 	addi	fp,sp,4
 1013f58:	e13fff15 	stw	r4,-4(fp)
	if (vq->notify)
 1013f5c:	e0bfff17 	ldw	r2,-4(fp)
 1013f60:	10800417 	ldw	r2,16(r2)
 1013f64:	10000426 	beq	r2,zero,1013f78 <vq_ring_notify+0x30>
		vq->notify(vq);
 1013f68:	e0bfff17 	ldw	r2,-4(fp)
 1013f6c:	10800417 	ldw	r2,16(r2)
 1013f70:	e13fff17 	ldw	r4,-4(fp)
 1013f74:	103ee83a 	callr	r2
}
 1013f78:	0001883a 	nop
 1013f7c:	e037883a 	mov	sp,fp
 1013f80:	dfc00117 	ldw	ra,4(sp)
 1013f84:	df000017 	ldw	fp,0(sp)
 1013f88:	dec00204 	addi	sp,sp,8
 1013f8c:	f800283a 	ret

01013f90 <virtqueue_nused>:
 * virtqueue_nused
 *
 */
#ifndef VIRTIO_SLAVE_ONLY
static int virtqueue_nused(struct virtqueue *vq)
{
 1013f90:	defffd04 	addi	sp,sp,-12
 1013f94:	df000215 	stw	fp,8(sp)
 1013f98:	df000204 	addi	fp,sp,8
 1013f9c:	e13fff15 	stw	r4,-4(fp)
	uint16_t used_idx, nused;

	used_idx = vq->vq_ring.used->idx;
 1013fa0:	e0bfff17 	ldw	r2,-4(fp)
 1013fa4:	10800817 	ldw	r2,32(r2)
 1013fa8:	1080008b 	ldhu	r2,2(r2)
 1013fac:	e0bffe0d 	sth	r2,-8(fp)

	nused = (uint16_t)(used_idx - vq->vq_used_cons_idx);
 1013fb0:	e0bfff17 	ldw	r2,-4(fp)
 1013fb4:	10800b8b 	ldhu	r2,46(r2)
 1013fb8:	e0fffe0b 	ldhu	r3,-8(fp)
 1013fbc:	1885c83a 	sub	r2,r3,r2
 1013fc0:	e0bffe8d 	sth	r2,-6(fp)
	VQASSERT(vq, nused <= vq->vq_nentries, "used more than available");

	return nused;
 1013fc4:	e0bffe8b 	ldhu	r2,-6(fp)
}
 1013fc8:	e037883a 	mov	sp,fp
 1013fcc:	df000017 	ldw	fp,0(sp)
 1013fd0:	dec00104 	addi	sp,sp,4
 1013fd4:	f800283a 	ret

01013fd8 <virtqueue_navail>:
 * virtqueue_navail
 *
 */
#ifndef VIRTIO_MASTER_ONLY
static int virtqueue_navail(struct virtqueue *vq)
{
 1013fd8:	defffd04 	addi	sp,sp,-12
 1013fdc:	df000215 	stw	fp,8(sp)
 1013fe0:	df000204 	addi	fp,sp,8
 1013fe4:	e13fff15 	stw	r4,-4(fp)
	uint16_t avail_idx, navail;

	avail_idx = vq->vq_ring.avail->idx;
 1013fe8:	e0bfff17 	ldw	r2,-4(fp)
 1013fec:	10800717 	ldw	r2,28(r2)
 1013ff0:	1080008b 	ldhu	r2,2(r2)
 1013ff4:	e0bffe0d 	sth	r2,-8(fp)

	navail = (uint16_t)(avail_idx - vq->vq_available_idx);
 1013ff8:	e0bfff17 	ldw	r2,-4(fp)
 1013ffc:	10800c0b 	ldhu	r2,48(r2)
 1014000:	e0fffe0b 	ldhu	r3,-8(fp)
 1014004:	1885c83a 	sub	r2,r3,r2
 1014008:	e0bffe8d 	sth	r2,-6(fp)
	VQASSERT(vq, navail <= vq->vq_nentries, "avail more than available");

	return navail;
 101400c:	e0bffe8b 	ldhu	r2,-6(fp)
}
 1014010:	e037883a 	mov	sp,fp
 1014014:	df000017 	ldw	fp,0(sp)
 1014018:	dec00104 	addi	sp,sp,4
 101401c:	f800283a 	ret

01014020 <metal_io_virt>:
 * @param[in]	offset	Offset into shared memory segment.
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
 1014020:	defffd04 	addi	sp,sp,-12
 1014024:	df000215 	stw	fp,8(sp)
 1014028:	df000204 	addi	fp,sp,8
 101402c:	e13ffe15 	stw	r4,-8(fp)
 1014030:	e17fff15 	stw	r5,-4(fp)
	return (io->virt != METAL_BAD_VA && offset < io->size
 1014034:	e0bffe17 	ldw	r2,-8(fp)
 1014038:	10800017 	ldw	r2,0(r2)
		? (uint8_t *)io->virt + offset
		: NULL);
 101403c:	10bfffe0 	cmpeqi	r2,r2,-1
 1014040:	1000091e 	bne	r2,zero,1014068 <metal_io_virt+0x48>
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
	return (io->virt != METAL_BAD_VA && offset < io->size
 1014044:	e0bffe17 	ldw	r2,-8(fp)
 1014048:	10800217 	ldw	r2,8(r2)
 101404c:	e0ffff17 	ldw	r3,-4(fp)
 1014050:	1880052e 	bgeu	r3,r2,1014068 <metal_io_virt+0x48>
		? (uint8_t *)io->virt + offset
 1014054:	e0bffe17 	ldw	r2,-8(fp)
 1014058:	10c00017 	ldw	r3,0(r2)
		: NULL);
 101405c:	e0bfff17 	ldw	r2,-4(fp)
 1014060:	1885883a 	add	r2,r3,r2
 1014064:	00000106 	br	101406c <metal_io_virt+0x4c>
 1014068:	0005883a 	mov	r2,zero
}
 101406c:	e037883a 	mov	sp,fp
 1014070:	df000017 	ldw	fp,0(sp)
 1014074:	dec00104 	addi	sp,sp,4
 1014078:	f800283a 	ret

0101407c <metal_io_phys>:
 * @return	METAL_BAD_PHYS if offset is out of range, or physical address
 *		of offset.
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
 101407c:	defffb04 	addi	sp,sp,-20
 1014080:	dfc00415 	stw	ra,16(sp)
 1014084:	df000315 	stw	fp,12(sp)
 1014088:	df000304 	addi	fp,sp,12
 101408c:	e13ffe15 	stw	r4,-8(fp)
 1014090:	e17fff15 	stw	r5,-4(fp)
	if (!io->ops.offset_to_phys) {
 1014094:	e0bffe17 	ldw	r2,-8(fp)
 1014098:	10800c17 	ldw	r2,48(r2)
 101409c:	1000211e 	bne	r2,zero,1014124 <metal_io_phys+0xa8>
		unsigned long page = (io->page_shift >=
 10140a0:	e0bffe17 	ldw	r2,-8(fp)
 10140a4:	10800317 	ldw	r2,12(r2)
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
 10140a8:	10800828 	cmpgeui	r2,r2,32
 10140ac:	1000051e 	bne	r2,zero,10140c4 <metal_io_phys+0x48>
 10140b0:	e0bffe17 	ldw	r2,-8(fp)
 10140b4:	10800317 	ldw	r2,12(r2)
 10140b8:	e0ffff17 	ldw	r3,-4(fp)
 10140bc:	1884d83a 	srl	r2,r3,r2
 10140c0:	00000106 	br	10140c8 <metal_io_phys+0x4c>
 10140c4:	0005883a 	mov	r2,zero
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
 10140c8:	e0bffd15 	stw	r2,-12(fp)
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 10140cc:	e0bffe17 	ldw	r2,-8(fp)
 10140d0:	10800117 	ldw	r2,4(r2)
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 10140d4:	10001126 	beq	r2,zero,101411c <metal_io_phys+0xa0>
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 10140d8:	e0bffe17 	ldw	r2,-8(fp)
 10140dc:	10800217 	ldw	r2,8(r2)
 10140e0:	e0ffff17 	ldw	r3,-4(fp)
 10140e4:	18800d2e 	bgeu	r3,r2,101411c <metal_io_phys+0xa0>
			? io->physmap[page] + (offset & io->page_mask)
 10140e8:	e0bffe17 	ldw	r2,-8(fp)
 10140ec:	10c00117 	ldw	r3,4(r2)
 10140f0:	e0bffd17 	ldw	r2,-12(fp)
 10140f4:	1085883a 	add	r2,r2,r2
 10140f8:	1085883a 	add	r2,r2,r2
 10140fc:	1885883a 	add	r2,r3,r2
 1014100:	10c00017 	ldw	r3,0(r2)
 1014104:	e0bffe17 	ldw	r2,-8(fp)
 1014108:	11000417 	ldw	r4,16(r2)
 101410c:	e0bfff17 	ldw	r2,-4(fp)
 1014110:	2084703a 	and	r2,r4,r2
			: METAL_BAD_PHYS);
 1014114:	1885883a 	add	r2,r3,r2
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1014118:	00000706 	br	1014138 <metal_io_phys+0xbc>
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 101411c:	00bfffc4 	movi	r2,-1
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1014120:	00000506 	br	1014138 <metal_io_phys+0xbc>
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
	}

	return io->ops.offset_to_phys(io, offset);
 1014124:	e0bffe17 	ldw	r2,-8(fp)
 1014128:	10800c17 	ldw	r2,48(r2)
 101412c:	e17fff17 	ldw	r5,-4(fp)
 1014130:	e13ffe17 	ldw	r4,-8(fp)
 1014134:	103ee83a 	callr	r2
}
 1014138:	e037883a 	mov	sp,fp
 101413c:	dfc00117 	ldw	ra,4(sp)
 1014140:	df000017 	ldw	fp,0(sp)
 1014144:	dec00204 	addi	sp,sp,8
 1014148:	f800283a 	ret

0101414c <metal_io_phys_to_offset>:
 * @param[in]	phys	Physical address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
 101414c:	defffb04 	addi	sp,sp,-20
 1014150:	dfc00415 	stw	ra,16(sp)
 1014154:	df000315 	stw	fp,12(sp)
 1014158:	df000304 	addi	fp,sp,12
 101415c:	e13ffe15 	stw	r4,-8(fp)
 1014160:	e17fff15 	stw	r5,-4(fp)
	if (!io->ops.phys_to_offset) {
 1014164:	e0bffe17 	ldw	r2,-8(fp)
 1014168:	10800d17 	ldw	r2,52(r2)
 101416c:	1000231e 	bne	r2,zero,10141fc <metal_io_phys_to_offset+0xb0>
		unsigned long offset =
			(io->page_mask == (metal_phys_addr_t)(-1) ?
 1014170:	e0bffe17 	ldw	r2,-8(fp)
 1014174:	10800417 	ldw	r2,16(r2)
			phys - io->physmap[0] :  phys & io->page_mask);
 1014178:	10bfffd8 	cmpnei	r2,r2,-1
 101417c:	1000061e 	bne	r2,zero,1014198 <metal_io_phys_to_offset+0x4c>
 1014180:	e0bffe17 	ldw	r2,-8(fp)
 1014184:	10800117 	ldw	r2,4(r2)
 1014188:	10800017 	ldw	r2,0(r2)
 101418c:	e0ffff17 	ldw	r3,-4(fp)
 1014190:	1885c83a 	sub	r2,r3,r2
 1014194:	00000406 	br	10141a8 <metal_io_phys_to_offset+0x5c>
 1014198:	e0bffe17 	ldw	r2,-8(fp)
 101419c:	10c00417 	ldw	r3,16(r2)
 10141a0:	e0bfff17 	ldw	r2,-4(fp)
 10141a4:	1884703a 	and	r2,r3,r2
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
	if (!io->ops.phys_to_offset) {
		unsigned long offset =
 10141a8:	e0bffd15 	stw	r2,-12(fp)
			(io->page_mask == (metal_phys_addr_t)(-1) ?
			phys - io->physmap[0] :  phys & io->page_mask);
		do {
			if (metal_io_phys(io, offset) == phys)
 10141ac:	e17ffd17 	ldw	r5,-12(fp)
 10141b0:	e13ffe17 	ldw	r4,-8(fp)
 10141b4:	101407c0 	call	101407c <metal_io_phys>
 10141b8:	1007883a 	mov	r3,r2
 10141bc:	e0bfff17 	ldw	r2,-4(fp)
 10141c0:	1880021e 	bne	r3,r2,10141cc <metal_io_phys_to_offset+0x80>
				return offset;
 10141c4:	e0bffd17 	ldw	r2,-12(fp)
 10141c8:	00001106 	br	1014210 <metal_io_phys_to_offset+0xc4>
			offset += io->page_mask + 1;
 10141cc:	e0bffe17 	ldw	r2,-8(fp)
 10141d0:	10c00417 	ldw	r3,16(r2)
 10141d4:	e0bffd17 	ldw	r2,-12(fp)
 10141d8:	1885883a 	add	r2,r3,r2
 10141dc:	10800044 	addi	r2,r2,1
 10141e0:	e0bffd15 	stw	r2,-12(fp)
		} while (offset < io->size);
 10141e4:	e0bffe17 	ldw	r2,-8(fp)
 10141e8:	10800217 	ldw	r2,8(r2)
 10141ec:	e0fffd17 	ldw	r3,-12(fp)
 10141f0:	18bfee36 	bltu	r3,r2,10141ac <__alt_data_end+0xff0141ac>
		return METAL_BAD_OFFSET;
 10141f4:	00bfffc4 	movi	r2,-1
 10141f8:	00000506 	br	1014210 <metal_io_phys_to_offset+0xc4>
	}

	return (*io->ops.phys_to_offset)(io, phys);
 10141fc:	e0bffe17 	ldw	r2,-8(fp)
 1014200:	10800d17 	ldw	r2,52(r2)
 1014204:	e17fff17 	ldw	r5,-4(fp)
 1014208:	e13ffe17 	ldw	r4,-8(fp)
 101420c:	103ee83a 	callr	r2
}
 1014210:	e037883a 	mov	sp,fp
 1014214:	dfc00117 	ldw	ra,4(sp)
 1014218:	df000017 	ldw	fp,0(sp)
 101421c:	dec00204 	addi	sp,sp,8
 1014220:	f800283a 	ret

01014224 <metal_io_phys_to_virt>:
 * @param[in]	phys	Physical address within segment.
 * @return	NULL if out of range, or corresponding virtual address.
 */
static inline void *
metal_io_phys_to_virt(struct metal_io_region *io, metal_phys_addr_t phys)
{
 1014224:	defffc04 	addi	sp,sp,-16
 1014228:	dfc00315 	stw	ra,12(sp)
 101422c:	df000215 	stw	fp,8(sp)
 1014230:	df000204 	addi	fp,sp,8
 1014234:	e13ffe15 	stw	r4,-8(fp)
 1014238:	e17fff15 	stw	r5,-4(fp)
	return metal_io_virt(io, metal_io_phys_to_offset(io, phys));
 101423c:	e17fff17 	ldw	r5,-4(fp)
 1014240:	e13ffe17 	ldw	r4,-8(fp)
 1014244:	101414c0 	call	101414c <metal_io_phys_to_offset>
 1014248:	100b883a 	mov	r5,r2
 101424c:	e13ffe17 	ldw	r4,-8(fp)
 1014250:	10140200 	call	1014020 <metal_io_virt>
}
 1014254:	e037883a 	mov	sp,fp
 1014258:	dfc00117 	ldw	ra,4(sp)
 101425c:	df000017 	ldw	fp,0(sp)
 1014260:	dec00204 	addi	sp,sp,8
 1014264:	f800283a 	ret

01014268 <metal_allocate_memory>:
#ifdef __cplusplus
extern "C" {
#endif

static inline void *metal_allocate_memory(unsigned int size)
{
 1014268:	defffd04 	addi	sp,sp,-12
 101426c:	dfc00215 	stw	ra,8(sp)
 1014270:	df000115 	stw	fp,4(sp)
 1014274:	df000104 	addi	fp,sp,4
 1014278:	e13fff15 	stw	r4,-4(fp)
	return (pvPortMalloc(size));
 101427c:	e13fff17 	ldw	r4,-4(fp)
 1014280:	10010b00 	call	10010b0 <pvPortMalloc>
}
 1014284:	e037883a 	mov	sp,fp
 1014288:	dfc00117 	ldw	ra,4(sp)
 101428c:	df000017 	ldw	fp,0(sp)
 1014290:	dec00204 	addi	sp,sp,8
 1014294:	f800283a 	ret

01014298 <metal_free_memory>:

static inline void metal_free_memory(void *ptr)
{
 1014298:	defffd04 	addi	sp,sp,-12
 101429c:	dfc00215 	stw	ra,8(sp)
 10142a0:	df000115 	stw	fp,4(sp)
 10142a4:	df000104 	addi	fp,sp,4
 10142a8:	e13fff15 	stw	r4,-4(fp)
	vPortFree(ptr);
 10142ac:	e13fff17 	ldw	r4,-4(fp)
 10142b0:	10012840 	call	1001284 <vPortFree>
}
 10142b4:	0001883a 	nop
 10142b8:	e037883a 	mov	sp,fp
 10142bc:	dfc00117 	ldw	ra,4(sp)
 10142c0:	df000017 	ldw	fp,0(sp)
 10142c4:	dec00204 	addi	sp,sp,8
 10142c8:	f800283a 	ret

010142cc <rpmsg_virtio_get_rpmsg_device>:
 * @param rvdev - pointer to RPMsg virtio device
 * @return - RPMsg device pointed by RPMsg virtio device
 */
static inline struct rpmsg_device *
rpmsg_virtio_get_rpmsg_device(struct rpmsg_virtio_device *rvdev)
{
 10142cc:	defffe04 	addi	sp,sp,-8
 10142d0:	df000115 	stw	fp,4(sp)
 10142d4:	df000104 	addi	fp,sp,4
 10142d8:	e13fff15 	stw	r4,-4(fp)
	return &rvdev->rdev;
 10142dc:	e0bfff17 	ldw	r2,-4(fp)
}
 10142e0:	e037883a 	mov	sp,fp
 10142e4:	df000017 	ldw	fp,0(sp)
 10142e8:	dec00104 	addi	sp,sp,4
 10142ec:	f800283a 	ret

010142f0 <platform_create_proc>:
/* RPMsg virtio shared buffer pool */
static struct rpmsg_virtio_shm_pool shpool;

static struct remoteproc *
platform_create_proc(int proc_index, int rsc_index)
{
 10142f0:	defff604 	addi	sp,sp,-40
 10142f4:	dfc00915 	stw	ra,36(sp)
 10142f8:	df000815 	stw	fp,32(sp)
 10142fc:	df000804 	addi	fp,sp,32
 1014300:	e13ffe15 	stw	r4,-8(fp)
 1014304:	e17fff15 	stw	r5,-4(fp)
	int rsc_size;
	int ret;
	metal_phys_addr_t pa;

	(void) proc_index;
	rsc_table = get_resource_table(rsc_index, &rsc_size);
 1014308:	e0bffc04 	addi	r2,fp,-16
 101430c:	100b883a 	mov	r5,r2
 1014310:	e13fff17 	ldw	r4,-4(fp)
 1014314:	1014a2c0 	call	1014a2c <get_resource_table>
 1014318:	e0bffa15 	stw	r2,-24(fp)

	/* Register IPI device */
	(void)metal_register_generic_device(&ipi_device);
 101431c:	010040f4 	movhi	r4,259
 1014320:	212b7f04 	addi	r4,r4,-20996
 1014324:	10068880 	call	1006888 <metal_register_generic_device>

	/* Initialize remoteproc instance */
	if (!remoteproc_init(&rproc_inst, &zynqmp_r5_a53_proc_ops, &rproc_priv))
 1014328:	018040f4 	movhi	r6,259
 101432c:	31ab9404 	addi	r6,r6,-20912
 1014330:	014040f4 	movhi	r5,259
 1014334:	296b9a04 	addi	r5,r5,-20888
 1014338:	010060f4 	movhi	r4,387
 101433c:	213ac604 	addi	r4,r4,-5352
 1014340:	100c8600 	call	100c860 <remoteproc_init>
 1014344:	1000021e 	bne	r2,zero,1014350 <platform_create_proc+0x60>
		return NULL;
 1014348:	0005883a 	mov	r2,zero
 101434c:	00003206 	br	1014418 <platform_create_proc+0x128>
	 * Mmap shared memories
	 * Or shall we constraint that they will be set as carved out
	 * in the resource table?
	 */
	/* mmap resource table */
	pa = (metal_phys_addr_t)rsc_table;
 1014350:	e0bffa17 	ldw	r2,-24(fp)
 1014354:	e0bffd15 	stw	r2,-12(fp)
	(void *)remoteproc_mmap(&rproc_inst, &pa,
 1014358:	e0bffc17 	ldw	r2,-16(fp)
 101435c:	1009883a 	mov	r4,r2
 1014360:	e0fffd04 	addi	r3,fp,-12
 1014364:	008060f4 	movhi	r2,387
 1014368:	10bac904 	addi	r2,r2,-5340
 101436c:	d8800115 	stw	r2,4(sp)
 1014370:	0080c204 	movi	r2,776
 1014374:	d8800015 	stw	r2,0(sp)
 1014378:	200f883a 	mov	r7,r4
 101437c:	000d883a 	mov	r6,zero
 1014380:	180b883a 	mov	r5,r3
 1014384:	010060f4 	movhi	r4,387
 1014388:	213ac604 	addi	r4,r4,-5352
 101438c:	100ce140 	call	100ce14 <remoteproc_mmap>
				NULL, rsc_size,
				NORM_NSHARED_NCACHE|PRIV_RW_USER_RW,
				&rproc_inst.rsc_io);

	/* mmap shared memory */
	pa = SHARED_MEM_PA;
 1014390:	00807034 	movhi	r2,448
 1014394:	e0bffd15 	stw	r2,-12(fp)
	(void *)remoteproc_mmap(&rproc_inst, &pa,
 1014398:	e0fffd04 	addi	r3,fp,-12
 101439c:	d8000115 	stw	zero,4(sp)
 10143a0:	0080c204 	movi	r2,776
 10143a4:	d8800015 	stw	r2,0(sp)
 10143a8:	01c01034 	movhi	r7,64
 10143ac:	000d883a 	mov	r6,zero
 10143b0:	180b883a 	mov	r5,r3
 10143b4:	010060f4 	movhi	r4,387
 10143b8:	213ac604 	addi	r4,r4,-5352
 10143bc:	100ce140 	call	100ce14 <remoteproc_mmap>
				NULL, SHARED_MEM_SIZE,
				NORM_NSHARED_NCACHE|PRIV_RW_USER_RW,
				NULL);

	/* parse resource table to remoteproc */
	ret = remoteproc_set_rsc_table(&rproc_inst, rsc_table, rsc_size);
 10143c0:	e0bffc17 	ldw	r2,-16(fp)
 10143c4:	100d883a 	mov	r6,r2
 10143c8:	e17ffa17 	ldw	r5,-24(fp)
 10143cc:	010060f4 	movhi	r4,387
 10143d0:	213ac604 	addi	r4,r4,-5352
 10143d4:	100c7cc0 	call	100c7cc <remoteproc_set_rsc_table>
 10143d8:	e0bffb15 	stw	r2,-20(fp)
	if (ret) {
 10143dc:	e0bffb17 	ldw	r2,-20(fp)
 10143e0:	10000826 	beq	r2,zero,1014404 <platform_create_proc+0x114>
		printf("Failed to intialize remoteproc\r\n");
 10143e4:	010040f4 	movhi	r4,259
 10143e8:	2127e104 	addi	r4,r4,-24700
 10143ec:	1015c900 	call	1015c90 <puts>
		remoteproc_remove(&rproc_inst);
 10143f0:	010060f4 	movhi	r4,387
 10143f4:	213ac604 	addi	r4,r4,-5352
 10143f8:	100c8fc0 	call	100c8fc <remoteproc_remove>
		return NULL;
 10143fc:	0005883a 	mov	r2,zero
 1014400:	00000506 	br	1014418 <platform_create_proc+0x128>
	}

	printf("Initialize remoteproc successfully.\r\n");
 1014404:	010040f4 	movhi	r4,259
 1014408:	2127e904 	addi	r4,r4,-24668
 101440c:	1015c900 	call	1015c90 <puts>

	return &rproc_inst;
 1014410:	008060f4 	movhi	r2,387
 1014414:	10bac604 	addi	r2,r2,-5352
}
 1014418:	e037883a 	mov	sp,fp
 101441c:	dfc00117 	ldw	ra,4(sp)
 1014420:	df000017 	ldw	fp,0(sp)
 1014424:	dec00204 	addi	sp,sp,8
 1014428:	f800283a 	ret

0101442c <platform_init>:

int platform_init(void **platform)
{
 101442c:	defffc04 	addi	sp,sp,-16
 1014430:	dfc00315 	stw	ra,12(sp)
 1014434:	df000215 	stw	fp,8(sp)
 1014438:	df000204 	addi	fp,sp,8
 101443c:	e13fff15 	stw	r4,-4(fp)
	struct remoteproc *rproc;

	if (!platform) {
 1014440:	e0bfff17 	ldw	r2,-4(fp)
 1014444:	1000051e 	bne	r2,zero,101445c <platform_init+0x30>
		printf("Failed to initialize platform,"
 1014448:	010040f4 	movhi	r4,259
 101444c:	2127f304 	addi	r4,r4,-24628
 1014450:	1015c900 	call	1015c90 <puts>
			   "NULL pointer to store platform data.\r\n");
		return -EINVAL;
 1014454:	00bffa84 	movi	r2,-22
 1014458:	00001006 	br	101449c <platform_init+0x70>
	}
	/* Initialize HW system components */
	init_system();
 101445c:	1005f000 	call	1005f00 <init_system>

	rproc = platform_create_proc(PROC_ID, RSC_ID);
 1014460:	01400044 	movi	r5,1
 1014464:	01000044 	movi	r4,1
 1014468:	10142f00 	call	10142f0 <platform_create_proc>
 101446c:	e0bffe15 	stw	r2,-8(fp)
	if (!rproc) {
 1014470:	e0bffe17 	ldw	r2,-8(fp)
 1014474:	1000051e 	bne	r2,zero,101448c <platform_init+0x60>
		printf("Failed to create remoteproc device.\r\n");
 1014478:	010040f4 	movhi	r4,259
 101447c:	21280404 	addi	r4,r4,-24560
 1014480:	1015c900 	call	1015c90 <puts>
		return -EINVAL;
 1014484:	00bffa84 	movi	r2,-22
 1014488:	00000406 	br	101449c <platform_init+0x70>
	}

	*platform = rproc;
 101448c:	e0bfff17 	ldw	r2,-4(fp)
 1014490:	e0fffe17 	ldw	r3,-8(fp)
 1014494:	10c00015 	stw	r3,0(r2)
	return 0;
 1014498:	0005883a 	mov	r2,zero
}
 101449c:	e037883a 	mov	sp,fp
 10144a0:	dfc00117 	ldw	ra,4(sp)
 10144a4:	df000017 	ldw	fp,0(sp)
 10144a8:	dec00204 	addi	sp,sp,8
 10144ac:	f800283a 	ret

010144b0 <platform_create_rpmsg_vdev>:
struct  rpmsg_device *
platform_create_rpmsg_vdev(void *platform, unsigned int vdev_index,
			   unsigned int role,
			   void (*rst_cb)(struct virtio_device *vdev),
			   rpmsg_ns_bind_cb ns_bind_cb)
{
 10144b0:	defff304 	addi	sp,sp,-52
 10144b4:	dfc00c15 	stw	ra,48(sp)
 10144b8:	df000b15 	stw	fp,44(sp)
 10144bc:	df000b04 	addi	fp,sp,44
 10144c0:	e13ffc15 	stw	r4,-16(fp)
 10144c4:	e17ffd15 	stw	r5,-12(fp)
 10144c8:	e1bffe15 	stw	r6,-8(fp)
 10144cc:	e1ffff15 	stw	r7,-4(fp)
	struct remoteproc *rproc = platform;
 10144d0:	e0bffc17 	ldw	r2,-16(fp)
 10144d4:	e0bff615 	stw	r2,-40(fp)
	struct virtio_device *vdev;
	void *shbuf;
	struct metal_io_region *shbuf_io;
	int ret;

	rpmsg_vdev = metal_allocate_memory(sizeof(*rpmsg_vdev));
 10144d8:	01001f04 	movi	r4,124
 10144dc:	10142680 	call	1014268 <metal_allocate_memory>
 10144e0:	e0bff715 	stw	r2,-36(fp)
	if (!rpmsg_vdev)
 10144e4:	e0bff717 	ldw	r2,-36(fp)
 10144e8:	1000021e 	bne	r2,zero,10144f4 <platform_create_rpmsg_vdev+0x44>
		return NULL;
 10144ec:	0005883a 	mov	r2,zero
 10144f0:	00004506 	br	1014608 <platform_create_rpmsg_vdev+0x158>

	shbuf_io = remoteproc_get_io_with_pa(rproc, SHARED_MEM_PA);
 10144f4:	01407034 	movhi	r5,448
 10144f8:	e13ff617 	ldw	r4,-40(fp)
 10144fc:	100ccb00 	call	100ccb0 <remoteproc_get_io_with_pa>
 1014500:	e0bff815 	stw	r2,-32(fp)
	if (!shbuf_io)
 1014504:	e0bff817 	ldw	r2,-32(fp)
 1014508:	1000021e 	bne	r2,zero,1014514 <platform_create_rpmsg_vdev+0x64>
		return NULL;
 101450c:	0005883a 	mov	r2,zero
 1014510:	00003d06 	br	1014608 <platform_create_rpmsg_vdev+0x158>

	shbuf = metal_io_phys_to_virt(shbuf_io,
 1014514:	01407074 	movhi	r5,449
 1014518:	29600004 	addi	r5,r5,-32768
 101451c:	e13ff817 	ldw	r4,-32(fp)
 1014520:	10142240 	call	1014224 <metal_io_phys_to_virt>
 1014524:	e0bff915 	stw	r2,-28(fp)
				      SHARED_MEM_PA + SHARED_BUF_OFFSET);

	printf("creating remoteproc virtio\r\n");
 1014528:	010040f4 	movhi	r4,259
 101452c:	21280e04 	addi	r4,r4,-24520
 1014530:	1015c900 	call	1015c90 <puts>
	/* TODO: can we have a wrapper for the following two functions? */
	vdev = remoteproc_create_virtio(rproc, vdev_index, role, rst_cb);
 1014534:	e0bffd17 	ldw	r2,-12(fp)
 1014538:	e1ffff17 	ldw	r7,-4(fp)
 101453c:	e1bffe17 	ldw	r6,-8(fp)
 1014540:	100b883a 	mov	r5,r2
 1014544:	e13ff617 	ldw	r4,-40(fp)
 1014548:	100e8980 	call	100e898 <remoteproc_create_virtio>
 101454c:	e0bffa15 	stw	r2,-24(fp)
	if (!vdev) {
 1014550:	e0bffa17 	ldw	r2,-24(fp)
 1014554:	1000041e 	bne	r2,zero,1014568 <platform_create_rpmsg_vdev+0xb8>
		printf("failed remoteproc_create_virtio\r\n");
 1014558:	010040f4 	movhi	r4,259
 101455c:	21281504 	addi	r4,r4,-24492
 1014560:	1015c900 	call	1015c90 <puts>
		goto err1;
 1014564:	00002506 	br	10145fc <platform_create_rpmsg_vdev+0x14c>
	}

	printf("initializing rpmsg shared buffer pool\r\n");
 1014568:	010040f4 	movhi	r4,259
 101456c:	21281e04 	addi	r4,r4,-24456
 1014570:	1015c900 	call	1015c90 <puts>
	/* Only RPMsg virtio master needs to initialize the shared buffers pool */
	rpmsg_virtio_init_shm_pool(&shpool, shbuf,
 1014574:	01801034 	movhi	r6,64
 1014578:	31a00004 	addi	r6,r6,-32768
 101457c:	e17ff917 	ldw	r5,-28(fp)
 1014580:	010060f4 	movhi	r4,387
 1014584:	213ad404 	addi	r4,r4,-5296
 1014588:	101166c0 	call	101166c <rpmsg_virtio_init_shm_pool>
				   (SHARED_MEM_SIZE - SHARED_BUF_OFFSET));

	printf("initializing rpmsg vdev\r\n");
 101458c:	010040f4 	movhi	r4,259
 1014590:	21282804 	addi	r4,r4,-24416
 1014594:	1015c900 	call	1015c90 <puts>
	/* RPMsg virtio slave can set shared buffers pool argument to NULL */
	ret =  rpmsg_init_vdev(rpmsg_vdev, vdev, ns_bind_cb,
 1014598:	008060f4 	movhi	r2,387
 101459c:	10bad404 	addi	r2,r2,-5296
 10145a0:	d8800015 	stw	r2,0(sp)
 10145a4:	e1fff817 	ldw	r7,-32(fp)
 10145a8:	e1800217 	ldw	r6,8(fp)
 10145ac:	e17ffa17 	ldw	r5,-24(fp)
 10145b0:	e13ff717 	ldw	r4,-36(fp)
 10145b4:	10121280 	call	1012128 <rpmsg_init_vdev>
 10145b8:	e0bffb15 	stw	r2,-20(fp)
			       shbuf_io,
			       &shpool);
	if (ret) {
 10145bc:	e0bffb17 	ldw	r2,-20(fp)
 10145c0:	10000826 	beq	r2,zero,10145e4 <platform_create_rpmsg_vdev+0x134>
		printf("failed rpmsg_init_vdev\r\n");
 10145c4:	010040f4 	movhi	r4,259
 10145c8:	21282f04 	addi	r4,r4,-24388
 10145cc:	1015c900 	call	1015c90 <puts>
		goto err2;
 10145d0:	0001883a 	nop
	}
	printf("initializing rpmsg vdev\r\n");
	return rpmsg_virtio_get_rpmsg_device(rpmsg_vdev);
err2:
	remoteproc_remove_virtio(rproc, vdev);
 10145d4:	e17ffa17 	ldw	r5,-24(fp)
 10145d8:	e13ff617 	ldw	r4,-40(fp)
 10145dc:	100ec280 	call	100ec28 <remoteproc_remove_virtio>
 10145e0:	00000606 	br	10145fc <platform_create_rpmsg_vdev+0x14c>
			       &shpool);
	if (ret) {
		printf("failed rpmsg_init_vdev\r\n");
		goto err2;
	}
	printf("initializing rpmsg vdev\r\n");
 10145e4:	010040f4 	movhi	r4,259
 10145e8:	21282804 	addi	r4,r4,-24416
 10145ec:	1015c900 	call	1015c90 <puts>
	return rpmsg_virtio_get_rpmsg_device(rpmsg_vdev);
 10145f0:	e13ff717 	ldw	r4,-36(fp)
 10145f4:	10142cc0 	call	10142cc <rpmsg_virtio_get_rpmsg_device>
 10145f8:	00000306 	br	1014608 <platform_create_rpmsg_vdev+0x158>
err2:
	remoteproc_remove_virtio(rproc, vdev);
err1:
	metal_free_memory(rpmsg_vdev);
 10145fc:	e13ff717 	ldw	r4,-36(fp)
 1014600:	10142980 	call	1014298 <metal_free_memory>
	return NULL;
 1014604:	0005883a 	mov	r2,zero
}
 1014608:	e037883a 	mov	sp,fp
 101460c:	dfc00117 	ldw	ra,4(sp)
 1014610:	df000017 	ldw	fp,0(sp)
 1014614:	dec00204 	addi	sp,sp,8
 1014618:	f800283a 	ret

0101461c <platform_poll>:

int platform_poll(void *priv)
{
 101461c:	defff604 	addi	sp,sp,-40
 1014620:	dfc00915 	stw	ra,36(sp)
 1014624:	df000815 	stw	fp,32(sp)
 1014628:	df000804 	addi	fp,sp,32
 101462c:	e13fff15 	stw	r4,-4(fp)
	struct remoteproc *rproc = priv;
 1014630:	e0bfff17 	ldw	r2,-4(fp)
 1014634:	e0bff815 	stw	r2,-32(fp)
	struct remoteproc_priv *prproc;
	unsigned int flags;

	prproc = rproc->priv;
 1014638:	e0bff817 	ldw	r2,-32(fp)
 101463c:	10800d17 	ldw	r2,52(r2)
 1014640:	e0bff915 	stw	r2,-28(fp)

	while(1) {
		flags = metal_irq_save_disable();
 1014644:	10071bc0 	call	10071bc <metal_irq_save_disable>
 1014648:	e0bffa15 	stw	r2,-24(fp)

		atomic_int val;

		atomic_mutex_acquire();
 101464c:	1005e680 	call	1005e68 <atomic_mutex_acquire>
		val = atomic_flag_test_and_set(&prproc->ipi_nokick);
 1014650:	e0bff917 	ldw	r2,-28(fp)
 1014654:	10800504 	addi	r2,r2,20
 1014658:	e0bffb15 	stw	r2,-20(fp)
 101465c:	e0bffb17 	ldw	r2,-20(fp)
 1014660:	10800017 	ldw	r2,0(r2)
 1014664:	e0bffc15 	stw	r2,-16(fp)
 1014668:	00800044 	movi	r2,1
 101466c:	e0bffd15 	stw	r2,-12(fp)
 1014670:	e0bff917 	ldw	r2,-28(fp)
 1014674:	e0fffd17 	ldw	r3,-12(fp)
 1014678:	10c00515 	stw	r3,20(r2)
 101467c:	e0bffc17 	ldw	r2,-16(fp)
 1014680:	e0bffe15 	stw	r2,-8(fp)
		atomic_mutex_release();
 1014684:	1005e9c0 	call	1005e9c <atomic_mutex_release>

		if (!val) {
 1014688:	e0bffe17 	ldw	r2,-8(fp)
 101468c:	1000061e 	bne	r2,zero,10146a8 <platform_poll+0x8c>
			metal_irq_restore_enable(flags);
 1014690:	e13ffa17 	ldw	r4,-24(fp)
 1014694:	10071e40 	call	10071e4 <metal_irq_restore_enable>
			remoteproc_get_notification(rproc, RSC_NOTIFY_ID_ANY);
 1014698:	017fffc4 	movi	r5,-1
 101469c:	e13ff817 	ldw	r4,-32(fp)
 10146a0:	100ecac0 	call	100ecac <remoteproc_get_notification>
			break;
 10146a4:	00000406 	br	10146b8 <platform_poll+0x9c>
		}

		_rproc_wait();
 10146a8:	0001883a 	nop
		metal_irq_restore_enable(flags);
 10146ac:	e13ffa17 	ldw	r4,-24(fp)
 10146b0:	10071e40 	call	10071e4 <metal_irq_restore_enable>
	}
 10146b4:	003fe306 	br	1014644 <__alt_data_end+0xff014644>
	return 0;
 10146b8:	0005883a 	mov	r2,zero
}
 10146bc:	e037883a 	mov	sp,fp
 10146c0:	dfc00117 	ldw	ra,4(sp)
 10146c4:	df000017 	ldw	fp,0(sp)
 10146c8:	dec00204 	addi	sp,sp,8
 10146cc:	f800283a 	ret

010146d0 <platform_release_rpmsg_vdev>:

void platform_release_rpmsg_vdev(struct rpmsg_device *rpdev)
{
 10146d0:	defffe04 	addi	sp,sp,-8
 10146d4:	df000115 	stw	fp,4(sp)
 10146d8:	df000104 	addi	fp,sp,4
 10146dc:	e13fff15 	stw	r4,-4(fp)
	(void)rpdev;
}
 10146e0:	0001883a 	nop
 10146e4:	e037883a 	mov	sp,fp
 10146e8:	df000017 	ldw	fp,0(sp)
 10146ec:	dec00104 	addi	sp,sp,4
 10146f0:	f800283a 	ret

010146f4 <platform_cleanup>:

void platform_cleanup(void *platform)
{
 10146f4:	defffc04 	addi	sp,sp,-16
 10146f8:	dfc00315 	stw	ra,12(sp)
 10146fc:	df000215 	stw	fp,8(sp)
 1014700:	df000204 	addi	fp,sp,8
 1014704:	e13fff15 	stw	r4,-4(fp)
	struct remoteproc *rproc = platform;
 1014708:	e0bfff17 	ldw	r2,-4(fp)
 101470c:	e0bffe15 	stw	r2,-8(fp)

	if (rproc)
 1014710:	e0bffe17 	ldw	r2,-8(fp)
 1014714:	10000226 	beq	r2,zero,1014720 <platform_cleanup+0x2c>
		remoteproc_remove(rproc);
 1014718:	e13ffe17 	ldw	r4,-8(fp)
 101471c:	100c8fc0 	call	100c8fc <remoteproc_remove>
	cleanup_system();
 1014720:	1005f6c0 	call	1005f6c <cleanup_system>
}
 1014724:	0001883a 	nop
 1014728:	e037883a 	mov	sp,fp
 101472c:	dfc00117 	ldw	ra,4(sp)
 1014730:	df000017 	ldw	fp,0(sp)
 1014734:	dec00204 	addi	sp,sp,8
 1014738:	f800283a 	ret

0101473c <rpmsg_send>:
 *
 * Returns number of bytes it has sent or negative error value on failure.
 */
static inline int rpmsg_send(struct rpmsg_endpoint *ept, const void *data,
			     int len)
{
 101473c:	defff904 	addi	sp,sp,-28
 1014740:	dfc00615 	stw	ra,24(sp)
 1014744:	df000515 	stw	fp,20(sp)
 1014748:	df000504 	addi	fp,sp,20
 101474c:	e13ffd15 	stw	r4,-12(fp)
 1014750:	e17ffe15 	stw	r5,-8(fp)
 1014754:	e1bfff15 	stw	r6,-4(fp)
	if (ept->dest_addr == RPMSG_ADDR_ANY)
 1014758:	e0bffd17 	ldw	r2,-12(fp)
 101475c:	10800a17 	ldw	r2,40(r2)
 1014760:	10bfffd8 	cmpnei	r2,r2,-1
 1014764:	1000021e 	bne	r2,zero,1014770 <rpmsg_send+0x34>
		return RPMSG_ERR_ADDR;
 1014768:	00be0a44 	movi	r2,-2007
 101476c:	00000d06 	br	10147a4 <rpmsg_send+0x68>
	return rpmsg_send_offchannel_raw(ept, ept->addr, ept->dest_addr, data,
 1014770:	e0bffd17 	ldw	r2,-12(fp)
 1014774:	10c00917 	ldw	r3,36(r2)
 1014778:	e0bffd17 	ldw	r2,-12(fp)
 101477c:	11000a17 	ldw	r4,40(r2)
 1014780:	00800044 	movi	r2,1
 1014784:	d8800115 	stw	r2,4(sp)
 1014788:	e0bfff17 	ldw	r2,-4(fp)
 101478c:	d8800015 	stw	r2,0(sp)
 1014790:	e1fffe17 	ldw	r7,-8(fp)
 1014794:	200d883a 	mov	r6,r4
 1014798:	180b883a 	mov	r5,r3
 101479c:	e13ffd17 	ldw	r4,-12(fp)
 10147a0:	1010b280 	call	1010b28 <rpmsg_send_offchannel_raw>
					 len, true);
}
 10147a4:	e037883a 	mov	sp,fp
 10147a8:	dfc00117 	ldw	ra,4(sp)
 10147ac:	df000017 	ldw	fp,0(sp)
 10147b0:	dec00204 	addi	sp,sp,8
 10147b4:	f800283a 	ret

010147b8 <rpmsg_endpoint_cb>:
/*-----------------------------------------------------------------------------*
 *  RPMSG endpoint callbacks
 *-----------------------------------------------------------------------------*/
static int rpmsg_endpoint_cb(struct rpmsg_endpoint *ept, void *data, size_t len,
			     uint32_t src, void *priv)
{
 10147b8:	defffa04 	addi	sp,sp,-24
 10147bc:	dfc00515 	stw	ra,20(sp)
 10147c0:	df000415 	stw	fp,16(sp)
 10147c4:	df000404 	addi	fp,sp,16
 10147c8:	e13ffc15 	stw	r4,-16(fp)
 10147cc:	e17ffd15 	stw	r5,-12(fp)
 10147d0:	e1bffe15 	stw	r6,-8(fp)
 10147d4:	e1ffff15 	stw	r7,-4(fp)
	(void)priv;
	(void)src;

	/* On reception of a shutdown we signal the application to terminate */
	if ((*(unsigned int *)data) == SHUTDOWN_MSG) {
 10147d8:	e0bffd17 	ldw	r2,-12(fp)
 10147dc:	10c00017 	ldw	r3,0(r2)
 10147e0:	00bbd5f4 	movhi	r2,61271
 10147e4:	10a95684 	addi	r2,r2,-23206
 10147e8:	1880071e 	bne	r3,r2,1014808 <rpmsg_endpoint_cb+0x50>
		LPRINTF("shutdown message is received.\r\n");
 10147ec:	010040f4 	movhi	r4,259
 10147f0:	21283504 	addi	r4,r4,-24364
 10147f4:	1015c900 	call	1015c90 <puts>
		shutdown_req = 1;
 10147f8:	00800044 	movi	r2,1
 10147fc:	d0a75415 	stw	r2,-25264(gp)
		return RPMSG_SUCCESS;
 1014800:	0005883a 	mov	r2,zero
 1014804:	00000a06 	br	1014830 <rpmsg_endpoint_cb+0x78>
	}

	/* Send data back to master */
	if (rpmsg_send(ept, data, len) < 0) {
 1014808:	e0bffe17 	ldw	r2,-8(fp)
 101480c:	100d883a 	mov	r6,r2
 1014810:	e17ffd17 	ldw	r5,-12(fp)
 1014814:	e13ffc17 	ldw	r4,-16(fp)
 1014818:	101473c0 	call	101473c <rpmsg_send>
 101481c:	1000030e 	bge	r2,zero,101482c <rpmsg_endpoint_cb+0x74>
		LPERROR("rpmsg_send failed\r\n");
 1014820:	010040f4 	movhi	r4,259
 1014824:	21283d04 	addi	r4,r4,-24332
 1014828:	1015c900 	call	1015c90 <puts>
	}
	return RPMSG_SUCCESS;
 101482c:	0005883a 	mov	r2,zero
}
 1014830:	e037883a 	mov	sp,fp
 1014834:	dfc00117 	ldw	ra,4(sp)
 1014838:	df000017 	ldw	fp,0(sp)
 101483c:	dec00204 	addi	sp,sp,8
 1014840:	f800283a 	ret

01014844 <rpmsg_service_unbind>:

static void rpmsg_service_unbind(struct rpmsg_endpoint *ept)
{
 1014844:	defffd04 	addi	sp,sp,-12
 1014848:	dfc00215 	stw	ra,8(sp)
 101484c:	df000115 	stw	fp,4(sp)
 1014850:	df000104 	addi	fp,sp,4
 1014854:	e13fff15 	stw	r4,-4(fp)
	(void)ept;
	LPRINTF("unexpected Remote endpoint destroy\r\n");
 1014858:	010040f4 	movhi	r4,259
 101485c:	21284404 	addi	r4,r4,-24304
 1014860:	1015c900 	call	1015c90 <puts>
	shutdown_req = 1;
 1014864:	00800044 	movi	r2,1
 1014868:	d0a75415 	stw	r2,-25264(gp)
}
 101486c:	0001883a 	nop
 1014870:	e037883a 	mov	sp,fp
 1014874:	dfc00117 	ldw	ra,4(sp)
 1014878:	df000017 	ldw	fp,0(sp)
 101487c:	dec00204 	addi	sp,sp,8
 1014880:	f800283a 	ret

01014884 <app>:

/*-----------------------------------------------------------------------------*
 *  Application
 *-----------------------------------------------------------------------------*/
int app(struct rpmsg_device *rdev, void *priv)
{
 1014884:	defff804 	addi	sp,sp,-32
 1014888:	dfc00715 	stw	ra,28(sp)
 101488c:	df000615 	stw	fp,24(sp)
 1014890:	df000604 	addi	fp,sp,24
 1014894:	e13ffe15 	stw	r4,-8(fp)
 1014898:	e17fff15 	stw	r5,-4(fp)
	int ret;

	/* Initialize RPMSG framework */
	LPRINTF("Try to create rpmsg endpoint.\r\n");
 101489c:	010040f4 	movhi	r4,259
 10148a0:	21284d04 	addi	r4,r4,-24268
 10148a4:	1015c900 	call	1015c90 <puts>

	ret = rpmsg_create_ept(&lept, rdev, RPMSG_SERVICE_NAME,
 10148a8:	00804074 	movhi	r2,257
 10148ac:	10921104 	addi	r2,r2,18500
 10148b0:	d8800215 	stw	r2,8(sp)
 10148b4:	00804074 	movhi	r2,257
 10148b8:	1091ee04 	addi	r2,r2,18360
 10148bc:	d8800115 	stw	r2,4(sp)
 10148c0:	00bfffc4 	movi	r2,-1
 10148c4:	d8800015 	stw	r2,0(sp)
 10148c8:	000f883a 	mov	r7,zero
 10148cc:	018040f4 	movhi	r6,259
 10148d0:	31a85504 	addi	r6,r6,-24236
 10148d4:	e17ffe17 	ldw	r5,-8(fp)
 10148d8:	010060f4 	movhi	r4,387
 10148dc:	213ad704 	addi	r4,r4,-5284
 10148e0:	1010e900 	call	1010e90 <rpmsg_create_ept>
 10148e4:	e0bffd15 	stw	r2,-12(fp)
			       0, RPMSG_ADDR_ANY, rpmsg_endpoint_cb,
			       rpmsg_service_unbind);
	if (ret) {
 10148e8:	e0bffd17 	ldw	r2,-12(fp)
 10148ec:	10000526 	beq	r2,zero,1014904 <app+0x80>
		LPERROR("Failed to create endpoint.\r\n");
 10148f0:	010040f4 	movhi	r4,259
 10148f4:	21285c04 	addi	r4,r4,-24208
 10148f8:	1015c900 	call	1015c90 <puts>
		return -1;
 10148fc:	00bfffc4 	movi	r2,-1
 1014900:	00000d06 	br	1014938 <app+0xb4>
	}

	LPRINTF("Successfully created rpmsg endpoint.\r\n");
 1014904:	010040f4 	movhi	r4,259
 1014908:	21286504 	addi	r4,r4,-24172
 101490c:	1015c900 	call	1015c90 <puts>

	while(1) {
		platform_poll(priv);
 1014910:	e13fff17 	ldw	r4,-4(fp)
 1014914:	101461c0 	call	101461c <platform_poll>

		/* we got a shutdown request, exit */
		if (shutdown_req) {
 1014918:	d0a75417 	ldw	r2,-25264(gp)
 101491c:	1000011e 	bne	r2,zero,1014924 <app+0xa0>
			break;
		}
	}
 1014920:	003ffb06 	br	1014910 <__alt_data_end+0xff014910>
	while(1) {
		platform_poll(priv);

		/* we got a shutdown request, exit */
		if (shutdown_req) {
			break;
 1014924:	0001883a 	nop
		}
	}
	rpmsg_destroy_ept(&lept);
 1014928:	010060f4 	movhi	r4,387
 101492c:	213ad704 	addi	r4,r4,-5284
 1014930:	10110180 	call	1011018 <rpmsg_destroy_ept>

	return 0;
 1014934:	0005883a 	mov	r2,zero
}
 1014938:	e037883a 	mov	sp,fp
 101493c:	dfc00117 	ldw	ra,4(sp)
 1014940:	df000017 	ldw	fp,0(sp)
 1014944:	dec00204 	addi	sp,sp,8
 1014948:	f800283a 	ret

0101494c <main>:

/*-----------------------------------------------------------------------------*
 *  Application entry point
 *-----------------------------------------------------------------------------*/
int main()
{
 101494c:	defffa04 	addi	sp,sp,-24
 1014950:	dfc00515 	stw	ra,20(sp)
 1014954:	df000415 	stw	fp,16(sp)
 1014958:	df000404 	addi	fp,sp,16
	atomic_mutex_init();
 101495c:	1005e000 	call	1005e00 <atomic_mutex_init>

	void *platform;
	struct rpmsg_device *rpdev;
	int ret;

	LPRINTF("Starting application...\r\n");
 1014960:	010040f4 	movhi	r4,259
 1014964:	21286f04 	addi	r4,r4,-24132
 1014968:	1015c900 	call	1015c90 <puts>

	/* Initialize platform */
	ret = platform_init(&platform);
 101496c:	e0bfff04 	addi	r2,fp,-4
 1014970:	1009883a 	mov	r4,r2
 1014974:	101442c0 	call	101442c <platform_init>
 1014978:	e0bffd15 	stw	r2,-12(fp)
	if (ret) {
 101497c:	e0bffd17 	ldw	r2,-12(fp)
 1014980:	10000626 	beq	r2,zero,101499c <main+0x50>
		LPERROR("Failed to initialize platform.\r\n");
 1014984:	010040f4 	movhi	r4,259
 1014988:	21287604 	addi	r4,r4,-24104
 101498c:	1015c900 	call	1015c90 <puts>
		ret = -1;
 1014990:	00bfffc4 	movi	r2,-1
 1014994:	e0bffd15 	stw	r2,-12(fp)
 1014998:	00001706 	br	10149f8 <main+0xac>
	} else {
		rpdev = platform_create_rpmsg_vdev(platform, 0,
 101499c:	e0bfff17 	ldw	r2,-4(fp)
 10149a0:	d8000015 	stw	zero,0(sp)
 10149a4:	000f883a 	mov	r7,zero
 10149a8:	01800044 	movi	r6,1
 10149ac:	000b883a 	mov	r5,zero
 10149b0:	1009883a 	mov	r4,r2
 10149b4:	10144b00 	call	10144b0 <platform_create_rpmsg_vdev>
 10149b8:	e0bffe15 	stw	r2,-8(fp)
						   VIRTIO_DEV_SLAVE,
						   NULL, NULL);
		if (!rpdev) {
 10149bc:	e0bffe17 	ldw	r2,-8(fp)
 10149c0:	1000061e 	bne	r2,zero,10149dc <main+0x90>
			LPERROR("Failed to create rpmsg virtio device.\r\n");
 10149c4:	010040f4 	movhi	r4,259
 10149c8:	21288004 	addi	r4,r4,-24064
 10149cc:	1015c900 	call	1015c90 <puts>
			ret = -1;
 10149d0:	00bfffc4 	movi	r2,-1
 10149d4:	e0bffd15 	stw	r2,-12(fp)
 10149d8:	00000706 	br	10149f8 <main+0xac>
		} else {
			app(rpdev, platform);
 10149dc:	e0bfff17 	ldw	r2,-4(fp)
 10149e0:	100b883a 	mov	r5,r2
 10149e4:	e13ffe17 	ldw	r4,-8(fp)
 10149e8:	10148840 	call	1014884 <app>
			platform_release_rpmsg_vdev(rpdev);
 10149ec:	e13ffe17 	ldw	r4,-8(fp)
 10149f0:	10146d00 	call	10146d0 <platform_release_rpmsg_vdev>
			ret = 0;
 10149f4:	e03ffd15 	stw	zero,-12(fp)
		}
	}

	LPRINTF("Stopping application...\r\n");
 10149f8:	010040f4 	movhi	r4,259
 10149fc:	21288c04 	addi	r4,r4,-24016
 1014a00:	1015c900 	call	1015c90 <puts>
	platform_cleanup(platform);
 1014a04:	e0bfff17 	ldw	r2,-4(fp)
 1014a08:	1009883a 	mov	r4,r2
 1014a0c:	10146f40 	call	10146f4 <platform_cleanup>

	atomic_mutex_deinit();
 1014a10:	1005e340 	call	1005e34 <atomic_mutex_deinit>

	return ret;
 1014a14:	e0bffd17 	ldw	r2,-12(fp)
}
 1014a18:	e037883a 	mov	sp,fp
 1014a1c:	dfc00117 	ldw	ra,4(sp)
 1014a20:	df000017 	ldw	fp,0(sp)
 1014a24:	dec00204 	addi	sp,sp,8
 1014a28:	f800283a 	ret

01014a2c <get_resource_table>:
	{RING_TX, VRING_ALIGN, VRING_SIZE, 1, 0},
	{RING_RX, VRING_ALIGN, VRING_SIZE, 2, 0},
};

void *get_resource_table (int rsc_id, int *len)
{
 1014a2c:	defffd04 	addi	sp,sp,-12
 1014a30:	df000215 	stw	fp,8(sp)
 1014a34:	df000204 	addi	fp,sp,8
 1014a38:	e13ffe15 	stw	r4,-8(fp)
 1014a3c:	e17fff15 	stw	r5,-4(fp)
	(void) rsc_id;
	*len = sizeof(resources);
 1014a40:	e0bfff17 	ldw	r2,-4(fp)
 1014a44:	00c04004 	movi	r3,256
 1014a48:	10c00015 	stw	r3,0(r2)
	return &resources;
 1014a4c:	00806034 	movhi	r2,384
 1014a50:	10800004 	addi	r2,r2,0
}
 1014a54:	e037883a 	mov	sp,fp
 1014a58:	df000017 	ldw	fp,0(sp)
 1014a5c:	dec00104 	addi	sp,sp,4
 1014a60:	f800283a 	ret

01014a64 <metal_list_add_before>:
	list->next = list->prev = list;
}

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
 1014a64:	defffd04 	addi	sp,sp,-12
 1014a68:	df000215 	stw	fp,8(sp)
 1014a6c:	df000204 	addi	fp,sp,8
 1014a70:	e13ffe15 	stw	r4,-8(fp)
 1014a74:	e17fff15 	stw	r5,-4(fp)
	new_node->prev = node->prev;
 1014a78:	e0bffe17 	ldw	r2,-8(fp)
 1014a7c:	10c00117 	ldw	r3,4(r2)
 1014a80:	e0bfff17 	ldw	r2,-4(fp)
 1014a84:	10c00115 	stw	r3,4(r2)
	new_node->next = node;
 1014a88:	e0bfff17 	ldw	r2,-4(fp)
 1014a8c:	e0fffe17 	ldw	r3,-8(fp)
 1014a90:	10c00015 	stw	r3,0(r2)
	new_node->next->prev = new_node;
 1014a94:	e0bfff17 	ldw	r2,-4(fp)
 1014a98:	10800017 	ldw	r2,0(r2)
 1014a9c:	e0ffff17 	ldw	r3,-4(fp)
 1014aa0:	10c00115 	stw	r3,4(r2)
	new_node->prev->next = new_node;
 1014aa4:	e0bfff17 	ldw	r2,-4(fp)
 1014aa8:	10800117 	ldw	r2,4(r2)
 1014aac:	e0ffff17 	ldw	r3,-4(fp)
 1014ab0:	10c00015 	stw	r3,0(r2)
}
 1014ab4:	0001883a 	nop
 1014ab8:	e037883a 	mov	sp,fp
 1014abc:	df000017 	ldw	fp,0(sp)
 1014ac0:	dec00104 	addi	sp,sp,4
 1014ac4:	f800283a 	ret

01014ac8 <metal_list_add_tail>:
	metal_list_add_after(list, node);
}

static inline void metal_list_add_tail(struct metal_list *list,
				       struct metal_list *node)
{
 1014ac8:	defffc04 	addi	sp,sp,-16
 1014acc:	dfc00315 	stw	ra,12(sp)
 1014ad0:	df000215 	stw	fp,8(sp)
 1014ad4:	df000204 	addi	fp,sp,8
 1014ad8:	e13ffe15 	stw	r4,-8(fp)
 1014adc:	e17fff15 	stw	r5,-4(fp)
	metal_list_add_before(list, node);
 1014ae0:	e17fff17 	ldw	r5,-4(fp)
 1014ae4:	e13ffe17 	ldw	r4,-8(fp)
 1014ae8:	1014a640 	call	1014a64 <metal_list_add_before>
}
 1014aec:	0001883a 	nop
 1014af0:	e037883a 	mov	sp,fp
 1014af4:	dfc00117 	ldw	ra,4(sp)
 1014af8:	df000017 	ldw	fp,0(sp)
 1014afc:	dec00204 	addi	sp,sp,8
 1014b00:	f800283a 	ret

01014b04 <metal_irq_unregister>:
 *
 * @param[in]  irq         interrupt id
 */
static inline
void metal_irq_unregister(int irq)
{
 1014b04:	defffd04 	addi	sp,sp,-12
 1014b08:	dfc00215 	stw	ra,8(sp)
 1014b0c:	df000115 	stw	fp,4(sp)
 1014b10:	df000104 	addi	fp,sp,4
 1014b14:	e13fff15 	stw	r4,-4(fp)
	metal_irq_register(irq, 0, NULL);
 1014b18:	000d883a 	mov	r6,zero
 1014b1c:	000b883a 	mov	r5,zero
 1014b20:	e13fff17 	ldw	r4,-4(fp)
 1014b24:	1008a640 	call	1008a64 <metal_irq_register>
}
 1014b28:	0001883a 	nop
 1014b2c:	e037883a 	mov	sp,fp
 1014b30:	dfc00117 	ldw	ra,4(sp)
 1014b34:	df000017 	ldw	fp,0(sp)
 1014b38:	dec00204 	addi	sp,sp,8
 1014b3c:	f800283a 	ret

01014b40 <metal_io_virt>:
 * @param[in]	offset	Offset into shared memory segment.
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
 1014b40:	defffd04 	addi	sp,sp,-12
 1014b44:	df000215 	stw	fp,8(sp)
 1014b48:	df000204 	addi	fp,sp,8
 1014b4c:	e13ffe15 	stw	r4,-8(fp)
 1014b50:	e17fff15 	stw	r5,-4(fp)
	return (io->virt != METAL_BAD_VA && offset < io->size
 1014b54:	e0bffe17 	ldw	r2,-8(fp)
 1014b58:	10800017 	ldw	r2,0(r2)
		? (uint8_t *)io->virt + offset
		: NULL);
 1014b5c:	10bfffe0 	cmpeqi	r2,r2,-1
 1014b60:	1000091e 	bne	r2,zero,1014b88 <metal_io_virt+0x48>
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
	return (io->virt != METAL_BAD_VA && offset < io->size
 1014b64:	e0bffe17 	ldw	r2,-8(fp)
 1014b68:	10800217 	ldw	r2,8(r2)
 1014b6c:	e0ffff17 	ldw	r3,-4(fp)
 1014b70:	1880052e 	bgeu	r3,r2,1014b88 <metal_io_virt+0x48>
		? (uint8_t *)io->virt + offset
 1014b74:	e0bffe17 	ldw	r2,-8(fp)
 1014b78:	10c00017 	ldw	r3,0(r2)
		: NULL);
 1014b7c:	e0bfff17 	ldw	r2,-4(fp)
 1014b80:	1885883a 	add	r2,r3,r2
 1014b84:	00000106 	br	1014b8c <metal_io_virt+0x4c>
 1014b88:	0005883a 	mov	r2,zero
}
 1014b8c:	e037883a 	mov	sp,fp
 1014b90:	df000017 	ldw	fp,0(sp)
 1014b94:	dec00104 	addi	sp,sp,4
 1014b98:	f800283a 	ret

01014b9c <metal_io_phys>:
 * @return	METAL_BAD_PHYS if offset is out of range, or physical address
 *		of offset.
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
 1014b9c:	defffb04 	addi	sp,sp,-20
 1014ba0:	dfc00415 	stw	ra,16(sp)
 1014ba4:	df000315 	stw	fp,12(sp)
 1014ba8:	df000304 	addi	fp,sp,12
 1014bac:	e13ffe15 	stw	r4,-8(fp)
 1014bb0:	e17fff15 	stw	r5,-4(fp)
	if (!io->ops.offset_to_phys) {
 1014bb4:	e0bffe17 	ldw	r2,-8(fp)
 1014bb8:	10800c17 	ldw	r2,48(r2)
 1014bbc:	1000211e 	bne	r2,zero,1014c44 <metal_io_phys+0xa8>
		unsigned long page = (io->page_shift >=
 1014bc0:	e0bffe17 	ldw	r2,-8(fp)
 1014bc4:	10800317 	ldw	r2,12(r2)
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
 1014bc8:	10800828 	cmpgeui	r2,r2,32
 1014bcc:	1000051e 	bne	r2,zero,1014be4 <metal_io_phys+0x48>
 1014bd0:	e0bffe17 	ldw	r2,-8(fp)
 1014bd4:	10800317 	ldw	r2,12(r2)
 1014bd8:	e0ffff17 	ldw	r3,-4(fp)
 1014bdc:	1884d83a 	srl	r2,r3,r2
 1014be0:	00000106 	br	1014be8 <metal_io_phys+0x4c>
 1014be4:	0005883a 	mov	r2,zero
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
 1014be8:	e0bffd15 	stw	r2,-12(fp)
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1014bec:	e0bffe17 	ldw	r2,-8(fp)
 1014bf0:	10800117 	ldw	r2,4(r2)
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 1014bf4:	10001126 	beq	r2,zero,1014c3c <metal_io_phys+0xa0>
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1014bf8:	e0bffe17 	ldw	r2,-8(fp)
 1014bfc:	10800217 	ldw	r2,8(r2)
 1014c00:	e0ffff17 	ldw	r3,-4(fp)
 1014c04:	18800d2e 	bgeu	r3,r2,1014c3c <metal_io_phys+0xa0>
			? io->physmap[page] + (offset & io->page_mask)
 1014c08:	e0bffe17 	ldw	r2,-8(fp)
 1014c0c:	10c00117 	ldw	r3,4(r2)
 1014c10:	e0bffd17 	ldw	r2,-12(fp)
 1014c14:	1085883a 	add	r2,r2,r2
 1014c18:	1085883a 	add	r2,r2,r2
 1014c1c:	1885883a 	add	r2,r3,r2
 1014c20:	10c00017 	ldw	r3,0(r2)
 1014c24:	e0bffe17 	ldw	r2,-8(fp)
 1014c28:	11000417 	ldw	r4,16(r2)
 1014c2c:	e0bfff17 	ldw	r2,-4(fp)
 1014c30:	2084703a 	and	r2,r4,r2
			: METAL_BAD_PHYS);
 1014c34:	1885883a 	add	r2,r3,r2
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1014c38:	00000706 	br	1014c58 <metal_io_phys+0xbc>
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 1014c3c:	00bfffc4 	movi	r2,-1
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap != NULL && offset < io->size
 1014c40:	00000506 	br	1014c58 <metal_io_phys+0xbc>
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
	}

	return io->ops.offset_to_phys(io, offset);
 1014c44:	e0bffe17 	ldw	r2,-8(fp)
 1014c48:	10800c17 	ldw	r2,48(r2)
 1014c4c:	e17fff17 	ldw	r5,-4(fp)
 1014c50:	e13ffe17 	ldw	r4,-8(fp)
 1014c54:	103ee83a 	callr	r2
}
 1014c58:	e037883a 	mov	sp,fp
 1014c5c:	dfc00117 	ldw	ra,4(sp)
 1014c60:	df000017 	ldw	fp,0(sp)
 1014c64:	dec00204 	addi	sp,sp,8
 1014c68:	f800283a 	ret

01014c6c <metal_io_phys_to_offset>:
 * @param[in]	phys	Physical address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
 1014c6c:	defffb04 	addi	sp,sp,-20
 1014c70:	dfc00415 	stw	ra,16(sp)
 1014c74:	df000315 	stw	fp,12(sp)
 1014c78:	df000304 	addi	fp,sp,12
 1014c7c:	e13ffe15 	stw	r4,-8(fp)
 1014c80:	e17fff15 	stw	r5,-4(fp)
	if (!io->ops.phys_to_offset) {
 1014c84:	e0bffe17 	ldw	r2,-8(fp)
 1014c88:	10800d17 	ldw	r2,52(r2)
 1014c8c:	1000231e 	bne	r2,zero,1014d1c <metal_io_phys_to_offset+0xb0>
		unsigned long offset =
			(io->page_mask == (metal_phys_addr_t)(-1) ?
 1014c90:	e0bffe17 	ldw	r2,-8(fp)
 1014c94:	10800417 	ldw	r2,16(r2)
			phys - io->physmap[0] :  phys & io->page_mask);
 1014c98:	10bfffd8 	cmpnei	r2,r2,-1
 1014c9c:	1000061e 	bne	r2,zero,1014cb8 <metal_io_phys_to_offset+0x4c>
 1014ca0:	e0bffe17 	ldw	r2,-8(fp)
 1014ca4:	10800117 	ldw	r2,4(r2)
 1014ca8:	10800017 	ldw	r2,0(r2)
 1014cac:	e0ffff17 	ldw	r3,-4(fp)
 1014cb0:	1885c83a 	sub	r2,r3,r2
 1014cb4:	00000406 	br	1014cc8 <metal_io_phys_to_offset+0x5c>
 1014cb8:	e0bffe17 	ldw	r2,-8(fp)
 1014cbc:	10c00417 	ldw	r3,16(r2)
 1014cc0:	e0bfff17 	ldw	r2,-4(fp)
 1014cc4:	1884703a 	and	r2,r3,r2
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
	if (!io->ops.phys_to_offset) {
		unsigned long offset =
 1014cc8:	e0bffd15 	stw	r2,-12(fp)
			(io->page_mask == (metal_phys_addr_t)(-1) ?
			phys - io->physmap[0] :  phys & io->page_mask);
		do {
			if (metal_io_phys(io, offset) == phys)
 1014ccc:	e17ffd17 	ldw	r5,-12(fp)
 1014cd0:	e13ffe17 	ldw	r4,-8(fp)
 1014cd4:	1014b9c0 	call	1014b9c <metal_io_phys>
 1014cd8:	1007883a 	mov	r3,r2
 1014cdc:	e0bfff17 	ldw	r2,-4(fp)
 1014ce0:	1880021e 	bne	r3,r2,1014cec <metal_io_phys_to_offset+0x80>
				return offset;
 1014ce4:	e0bffd17 	ldw	r2,-12(fp)
 1014ce8:	00001106 	br	1014d30 <metal_io_phys_to_offset+0xc4>
			offset += io->page_mask + 1;
 1014cec:	e0bffe17 	ldw	r2,-8(fp)
 1014cf0:	10c00417 	ldw	r3,16(r2)
 1014cf4:	e0bffd17 	ldw	r2,-12(fp)
 1014cf8:	1885883a 	add	r2,r3,r2
 1014cfc:	10800044 	addi	r2,r2,1
 1014d00:	e0bffd15 	stw	r2,-12(fp)
		} while (offset < io->size);
 1014d04:	e0bffe17 	ldw	r2,-8(fp)
 1014d08:	10800217 	ldw	r2,8(r2)
 1014d0c:	e0fffd17 	ldw	r3,-12(fp)
 1014d10:	18bfee36 	bltu	r3,r2,1014ccc <__alt_data_end+0xff014ccc>
		return METAL_BAD_OFFSET;
 1014d14:	00bfffc4 	movi	r2,-1
 1014d18:	00000506 	br	1014d30 <metal_io_phys_to_offset+0xc4>
	}

	return (*io->ops.phys_to_offset)(io, phys);
 1014d1c:	e0bffe17 	ldw	r2,-8(fp)
 1014d20:	10800d17 	ldw	r2,52(r2)
 1014d24:	e17fff17 	ldw	r5,-4(fp)
 1014d28:	e13ffe17 	ldw	r4,-8(fp)
 1014d2c:	103ee83a 	callr	r2
}
 1014d30:	e037883a 	mov	sp,fp
 1014d34:	dfc00117 	ldw	ra,4(sp)
 1014d38:	df000017 	ldw	fp,0(sp)
 1014d3c:	dec00204 	addi	sp,sp,8
 1014d40:	f800283a 	ret

01014d44 <metal_io_phys_to_virt>:
 * @param[in]	phys	Physical address within segment.
 * @return	NULL if out of range, or corresponding virtual address.
 */
static inline void *
metal_io_phys_to_virt(struct metal_io_region *io, metal_phys_addr_t phys)
{
 1014d44:	defffc04 	addi	sp,sp,-16
 1014d48:	dfc00315 	stw	ra,12(sp)
 1014d4c:	df000215 	stw	fp,8(sp)
 1014d50:	df000204 	addi	fp,sp,8
 1014d54:	e13ffe15 	stw	r4,-8(fp)
 1014d58:	e17fff15 	stw	r5,-4(fp)
	return metal_io_virt(io, metal_io_phys_to_offset(io, phys));
 1014d5c:	e17fff17 	ldw	r5,-4(fp)
 1014d60:	e13ffe17 	ldw	r4,-8(fp)
 1014d64:	1014c6c0 	call	1014c6c <metal_io_phys_to_offset>
 1014d68:	100b883a 	mov	r5,r2
 1014d6c:	e13ffe17 	ldw	r4,-8(fp)
 1014d70:	1014b400 	call	1014b40 <metal_io_virt>
}
 1014d74:	e037883a 	mov	sp,fp
 1014d78:	dfc00117 	ldw	ra,4(sp)
 1014d7c:	df000017 	ldw	fp,0(sp)
 1014d80:	dec00204 	addi	sp,sp,8
 1014d84:	f800283a 	ret

01014d88 <metal_io_read>:
 * @return	Value.
 */
static inline uint64_t
metal_io_read(struct metal_io_region *io, unsigned long offset,
	      memory_order order, int width)
{
 1014d88:	defff704 	addi	sp,sp,-36
 1014d8c:	dfc00815 	stw	ra,32(sp)
 1014d90:	df000715 	stw	fp,28(sp)
 1014d94:	dc400615 	stw	r17,24(sp)
 1014d98:	dc000515 	stw	r16,20(sp)
 1014d9c:	df000704 	addi	fp,sp,28
 1014da0:	e13ffa15 	stw	r4,-24(fp)
 1014da4:	e17ffb15 	stw	r5,-20(fp)
 1014da8:	e1bffc15 	stw	r6,-16(fp)
 1014dac:	e1fffd15 	stw	r7,-12(fp)
	void *ptr = metal_io_virt(io, offset);
 1014db0:	e17ffb17 	ldw	r5,-20(fp)
 1014db4:	e13ffa17 	ldw	r4,-24(fp)
 1014db8:	1014b400 	call	1014b40 <metal_io_virt>
 1014dbc:	e0bff915 	stw	r2,-28(fp)

	if (io->ops.read)
 1014dc0:	e0bffa17 	ldw	r2,-24(fp)
 1014dc4:	10800617 	ldw	r2,24(r2)
 1014dc8:	10000a26 	beq	r2,zero,1014df4 <metal_io_read+0x6c>
		return (*io->ops.read)(io, offset, order, width);
 1014dcc:	e0bffa17 	ldw	r2,-24(fp)
 1014dd0:	10800617 	ldw	r2,24(r2)
 1014dd4:	e1fffd17 	ldw	r7,-12(fp)
 1014dd8:	e1bffc17 	ldw	r6,-16(fp)
 1014ddc:	e17ffb17 	ldw	r5,-20(fp)
 1014de0:	e13ffa17 	ldw	r4,-24(fp)
 1014de4:	103ee83a 	callr	r2
 1014de8:	1021883a 	mov	r16,r2
 1014dec:	1823883a 	mov	r17,r3
 1014df0:	00004006 	br	1014ef4 <metal_io_read+0x16c>
	else if (ptr && sizeof(atomic_uchar) == width)
 1014df4:	e0bff917 	ldw	r2,-28(fp)
 1014df8:	10000a26 	beq	r2,zero,1014e24 <metal_io_read+0x9c>
 1014dfc:	e0bffd17 	ldw	r2,-12(fp)
 1014e00:	10800058 	cmpnei	r2,r2,1
 1014e04:	1000071e 	bne	r2,zero,1014e24 <metal_io_read+0x9c>
		return atomic_load_explicit((atomic_uchar *)ptr, order);
 1014e08:	0001b03a 	sync
 1014e0c:	e0bff917 	ldw	r2,-28(fp)
 1014e10:	10800003 	ldbu	r2,0(r2)
 1014e14:	10803fcc 	andi	r2,r2,255
 1014e18:	1021883a 	mov	r16,r2
 1014e1c:	0023883a 	mov	r17,zero
 1014e20:	00003406 	br	1014ef4 <metal_io_read+0x16c>
	else if (ptr && sizeof(atomic_ushort) == width)
 1014e24:	e0bff917 	ldw	r2,-28(fp)
 1014e28:	10000a26 	beq	r2,zero,1014e54 <metal_io_read+0xcc>
 1014e2c:	e0bffd17 	ldw	r2,-12(fp)
 1014e30:	10800098 	cmpnei	r2,r2,2
 1014e34:	1000071e 	bne	r2,zero,1014e54 <metal_io_read+0xcc>
		return atomic_load_explicit((atomic_ushort *)ptr, order);
 1014e38:	0001b03a 	sync
 1014e3c:	e0bff917 	ldw	r2,-28(fp)
 1014e40:	1080000b 	ldhu	r2,0(r2)
 1014e44:	10bfffcc 	andi	r2,r2,65535
 1014e48:	1021883a 	mov	r16,r2
 1014e4c:	0023883a 	mov	r17,zero
 1014e50:	00002806 	br	1014ef4 <metal_io_read+0x16c>
	else if (ptr && sizeof(atomic_uint) == width)
 1014e54:	e0bff917 	ldw	r2,-28(fp)
 1014e58:	10000926 	beq	r2,zero,1014e80 <metal_io_read+0xf8>
 1014e5c:	e0bffd17 	ldw	r2,-12(fp)
 1014e60:	10800118 	cmpnei	r2,r2,4
 1014e64:	1000061e 	bne	r2,zero,1014e80 <metal_io_read+0xf8>
		return atomic_load_explicit((atomic_uint *)ptr, order);
 1014e68:	0001b03a 	sync
 1014e6c:	e0bff917 	ldw	r2,-28(fp)
 1014e70:	10800017 	ldw	r2,0(r2)
 1014e74:	1021883a 	mov	r16,r2
 1014e78:	0023883a 	mov	r17,zero
 1014e7c:	00001d06 	br	1014ef4 <metal_io_read+0x16c>
	else if (ptr && sizeof(atomic_ulong) == width)
 1014e80:	e0bff917 	ldw	r2,-28(fp)
 1014e84:	10000926 	beq	r2,zero,1014eac <metal_io_read+0x124>
 1014e88:	e0bffd17 	ldw	r2,-12(fp)
 1014e8c:	10800118 	cmpnei	r2,r2,4
 1014e90:	1000061e 	bne	r2,zero,1014eac <metal_io_read+0x124>
		return atomic_load_explicit((atomic_ulong *)ptr, order);
 1014e94:	0001b03a 	sync
 1014e98:	e0bff917 	ldw	r2,-28(fp)
 1014e9c:	10800017 	ldw	r2,0(r2)
 1014ea0:	1021883a 	mov	r16,r2
 1014ea4:	0023883a 	mov	r17,zero
 1014ea8:	00001206 	br	1014ef4 <metal_io_read+0x16c>
#ifndef NO_ATOMIC_64_SUPPORT
	else if (ptr && sizeof(atomic_ullong) == width)
 1014eac:	e0bff917 	ldw	r2,-28(fp)
 1014eb0:	10000826 	beq	r2,zero,1014ed4 <metal_io_read+0x14c>
 1014eb4:	e0bffd17 	ldw	r2,-12(fp)
 1014eb8:	10800218 	cmpnei	r2,r2,8
 1014ebc:	1000051e 	bne	r2,zero,1014ed4 <metal_io_read+0x14c>
		return atomic_load_explicit((atomic_ullong *)ptr, order);
 1014ec0:	0001b03a 	sync
 1014ec4:	e0bff917 	ldw	r2,-28(fp)
 1014ec8:	14000017 	ldw	r16,0(r2)
 1014ecc:	14400117 	ldw	r17,4(r2)
 1014ed0:	00000806 	br	1014ef4 <metal_io_read+0x16c>
#endif
	metal_assert(0);
 1014ed4:	01c040f4 	movhi	r7,259
 1014ed8:	39e89304 	addi	r7,r7,-23988
 1014edc:	018040f4 	movhi	r6,259
 1014ee0:	31a8a204 	addi	r6,r6,-23928
 1014ee4:	01403f84 	movi	r5,254
 1014ee8:	010040f4 	movhi	r4,259
 1014eec:	21289404 	addi	r4,r4,-23984
 1014ef0:	10157a00 	call	10157a0 <__assert_func>
 1014ef4:	8007883a 	mov	r3,r16
 1014ef8:	8809883a 	mov	r4,r17
	return 0; /* quiet compiler */
}
 1014efc:	1805883a 	mov	r2,r3
 1014f00:	2007883a 	mov	r3,r4
 1014f04:	e6fffe04 	addi	sp,fp,-8
 1014f08:	dfc00317 	ldw	ra,12(sp)
 1014f0c:	df000217 	ldw	fp,8(sp)
 1014f10:	dc400117 	ldw	r17,4(sp)
 1014f14:	dc000017 	ldw	r16,0(sp)
 1014f18:	dec00404 	addi	sp,sp,16
 1014f1c:	f800283a 	ret

01014f20 <metal_io_write>:
 *			to inline cleanly.
 */
static inline void
metal_io_write(struct metal_io_region *io, unsigned long offset,
	       uint64_t value, memory_order order, int width)
{
 1014f20:	defff704 	addi	sp,sp,-36
 1014f24:	dfc00815 	stw	ra,32(sp)
 1014f28:	df000715 	stw	fp,28(sp)
 1014f2c:	df000704 	addi	fp,sp,28
 1014f30:	e13ffc15 	stw	r4,-16(fp)
 1014f34:	e17ffd15 	stw	r5,-12(fp)
 1014f38:	e1bffe15 	stw	r6,-8(fp)
 1014f3c:	e1ffff15 	stw	r7,-4(fp)
	void *ptr = metal_io_virt(io, offset);
 1014f40:	e17ffd17 	ldw	r5,-12(fp)
 1014f44:	e13ffc17 	ldw	r4,-16(fp)
 1014f48:	1014b400 	call	1014b40 <metal_io_virt>
 1014f4c:	e0bffb15 	stw	r2,-20(fp)
	if (io->ops.write)
 1014f50:	e0bffc17 	ldw	r2,-16(fp)
 1014f54:	10800717 	ldw	r2,28(r2)
 1014f58:	10000c26 	beq	r2,zero,1014f8c <metal_io_write+0x6c>
		(*io->ops.write)(io, offset, value, order, width);
 1014f5c:	e0bffc17 	ldw	r2,-16(fp)
 1014f60:	10800717 	ldw	r2,28(r2)
 1014f64:	e0c00317 	ldw	r3,12(fp)
 1014f68:	d8c00115 	stw	r3,4(sp)
 1014f6c:	e0c00217 	ldw	r3,8(fp)
 1014f70:	d8c00015 	stw	r3,0(sp)
 1014f74:	e1bffe17 	ldw	r6,-8(fp)
 1014f78:	e1ffff17 	ldw	r7,-4(fp)
 1014f7c:	e17ffd17 	ldw	r5,-12(fp)
 1014f80:	e13ffc17 	ldw	r4,-16(fp)
 1014f84:	103ee83a 	callr	r2
	else if (ptr && sizeof(atomic_ullong) == width)
		atomic_store_explicit((atomic_ullong *)ptr, value, order);
#endif
	else
		metal_assert (0);
}
 1014f88:	00003e06 	br	1015084 <metal_io_write+0x164>
	       uint64_t value, memory_order order, int width)
{
	void *ptr = metal_io_virt(io, offset);
	if (io->ops.write)
		(*io->ops.write)(io, offset, value, order, width);
	else if (ptr && sizeof(atomic_uchar) == width)
 1014f8c:	e0bffb17 	ldw	r2,-20(fp)
 1014f90:	10000926 	beq	r2,zero,1014fb8 <metal_io_write+0x98>
 1014f94:	e0800317 	ldw	r2,12(fp)
 1014f98:	10800058 	cmpnei	r2,r2,1
 1014f9c:	1000061e 	bne	r2,zero,1014fb8 <metal_io_write+0x98>
		atomic_store_explicit((atomic_uchar *)ptr, value, order);
 1014fa0:	e0bffe17 	ldw	r2,-8(fp)
 1014fa4:	1007883a 	mov	r3,r2
 1014fa8:	e0bffb17 	ldw	r2,-20(fp)
 1014fac:	10c00005 	stb	r3,0(r2)
 1014fb0:	0001b03a 	sync
 1014fb4:	00003306 	br	1015084 <metal_io_write+0x164>
	else if (ptr && sizeof(atomic_ushort) == width)
 1014fb8:	e0bffb17 	ldw	r2,-20(fp)
 1014fbc:	10000926 	beq	r2,zero,1014fe4 <metal_io_write+0xc4>
 1014fc0:	e0800317 	ldw	r2,12(fp)
 1014fc4:	10800098 	cmpnei	r2,r2,2
 1014fc8:	1000061e 	bne	r2,zero,1014fe4 <metal_io_write+0xc4>
		atomic_store_explicit((atomic_ushort *)ptr, value, order);
 1014fcc:	e0bffe17 	ldw	r2,-8(fp)
 1014fd0:	1007883a 	mov	r3,r2
 1014fd4:	e0bffb17 	ldw	r2,-20(fp)
 1014fd8:	10c0000d 	sth	r3,0(r2)
 1014fdc:	0001b03a 	sync
 1014fe0:	00002806 	br	1015084 <metal_io_write+0x164>
	else if (ptr && sizeof(atomic_uint) == width)
 1014fe4:	e0bffb17 	ldw	r2,-20(fp)
 1014fe8:	10000826 	beq	r2,zero,101500c <metal_io_write+0xec>
 1014fec:	e0800317 	ldw	r2,12(fp)
 1014ff0:	10800118 	cmpnei	r2,r2,4
 1014ff4:	1000051e 	bne	r2,zero,101500c <metal_io_write+0xec>
		atomic_store_explicit((atomic_uint *)ptr, value, order);
 1014ff8:	e0fffe17 	ldw	r3,-8(fp)
 1014ffc:	e0bffb17 	ldw	r2,-20(fp)
 1015000:	10c00015 	stw	r3,0(r2)
 1015004:	0001b03a 	sync
 1015008:	00001e06 	br	1015084 <metal_io_write+0x164>
	else if (ptr && sizeof(atomic_ulong) == width)
 101500c:	e0bffb17 	ldw	r2,-20(fp)
 1015010:	10000826 	beq	r2,zero,1015034 <metal_io_write+0x114>
 1015014:	e0800317 	ldw	r2,12(fp)
 1015018:	10800118 	cmpnei	r2,r2,4
 101501c:	1000051e 	bne	r2,zero,1015034 <metal_io_write+0x114>
		atomic_store_explicit((atomic_ulong *)ptr, value, order);
 1015020:	e0fffe17 	ldw	r3,-8(fp)
 1015024:	e0bffb17 	ldw	r2,-20(fp)
 1015028:	10c00015 	stw	r3,0(r2)
 101502c:	0001b03a 	sync
 1015030:	00001406 	br	1015084 <metal_io_write+0x164>
#ifndef NO_ATOMIC_64_SUPPORT
	else if (ptr && sizeof(atomic_ullong) == width)
 1015034:	e0bffb17 	ldw	r2,-20(fp)
 1015038:	10000a26 	beq	r2,zero,1015064 <metal_io_write+0x144>
 101503c:	e0800317 	ldw	r2,12(fp)
 1015040:	10800218 	cmpnei	r2,r2,8
 1015044:	1000071e 	bne	r2,zero,1015064 <metal_io_write+0x144>
		atomic_store_explicit((atomic_ullong *)ptr, value, order);
 1015048:	e0bffb17 	ldw	r2,-20(fp)
 101504c:	e0fffe17 	ldw	r3,-8(fp)
 1015050:	10c00015 	stw	r3,0(r2)
 1015054:	e0ffff17 	ldw	r3,-4(fp)
 1015058:	10c00115 	stw	r3,4(r2)
 101505c:	0001b03a 	sync
 1015060:	00000806 	br	1015084 <metal_io_write+0x164>
#endif
	else
		metal_assert (0);
 1015064:	01c040f4 	movhi	r7,259
 1015068:	39e89304 	addi	r7,r7,-23988
 101506c:	018040f4 	movhi	r6,259
 1015070:	31a8a604 	addi	r6,r6,-23912
 1015074:	01404804 	movi	r5,288
 1015078:	010040f4 	movhi	r4,259
 101507c:	21289404 	addi	r4,r4,-23984
 1015080:	10157a00 	call	10157a0 <__assert_func>
}
 1015084:	0001883a 	nop
 1015088:	e037883a 	mov	sp,fp
 101508c:	dfc00117 	ldw	ra,4(sp)
 1015090:	df000017 	ldw	fp,0(sp)
 1015094:	dec00204 	addi	sp,sp,8
 1015098:	f800283a 	ret

0101509c <metal_device_io_region>:
 * @param[in]	index		Region index.
 * @return I/O accessor handle, or NULL on failure.
 */
static inline struct metal_io_region *
metal_device_io_region(struct metal_device *device, unsigned index)
{
 101509c:	defffd04 	addi	sp,sp,-12
 10150a0:	df000215 	stw	fp,8(sp)
 10150a4:	df000204 	addi	fp,sp,8
 10150a8:	e13ffe15 	stw	r4,-8(fp)
 10150ac:	e17fff15 	stw	r5,-4(fp)
	return (index < device->num_regions
 10150b0:	e0bffe17 	ldw	r2,-8(fp)
 10150b4:	10800217 	ldw	r2,8(r2)
		? &device->regions[index]
		: NULL);
 10150b8:	e0ffff17 	ldw	r3,-4(fp)
 10150bc:	1880062e 	bgeu	r3,r2,10150d8 <metal_device_io_region+0x3c>
 10150c0:	e0bfff17 	ldw	r2,-4(fp)
 10150c4:	10800e24 	muli	r2,r2,56
 10150c8:	10800304 	addi	r2,r2,12
 10150cc:	e0fffe17 	ldw	r3,-8(fp)
 10150d0:	1885883a 	add	r2,r3,r2
 * @return I/O accessor handle, or NULL on failure.
 */
static inline struct metal_io_region *
metal_device_io_region(struct metal_device *device, unsigned index)
{
	return (index < device->num_regions
 10150d4:	00000106 	br	10150dc <metal_device_io_region+0x40>
		? &device->regions[index]
		: NULL);
 10150d8:	0005883a 	mov	r2,zero
}
 10150dc:	e037883a 	mov	sp,fp
 10150e0:	df000017 	ldw	fp,0(sp)
 10150e4:	dec00104 	addi	sp,sp,4
 10150e8:	f800283a 	ret

010150ec <metal_allocate_memory>:
#ifdef __cplusplus
extern "C" {
#endif

static inline void *metal_allocate_memory(unsigned int size)
{
 10150ec:	defffd04 	addi	sp,sp,-12
 10150f0:	dfc00215 	stw	ra,8(sp)
 10150f4:	df000115 	stw	fp,4(sp)
 10150f8:	df000104 	addi	fp,sp,4
 10150fc:	e13fff15 	stw	r4,-4(fp)
	return (pvPortMalloc(size));
 1015100:	e13fff17 	ldw	r4,-4(fp)
 1015104:	10010b00 	call	10010b0 <pvPortMalloc>
}
 1015108:	e037883a 	mov	sp,fp
 101510c:	dfc00117 	ldw	ra,4(sp)
 1015110:	df000017 	ldw	fp,0(sp)
 1015114:	dec00204 	addi	sp,sp,8
 1015118:	f800283a 	ret

0101511c <metal_free_memory>:

static inline void metal_free_memory(void *ptr)
{
 101511c:	defffd04 	addi	sp,sp,-12
 1015120:	dfc00215 	stw	ra,8(sp)
 1015124:	df000115 	stw	fp,4(sp)
 1015128:	df000104 	addi	fp,sp,4
 101512c:	e13fff15 	stw	r4,-4(fp)
	vPortFree(ptr);
 1015130:	e13fff17 	ldw	r4,-4(fp)
 1015134:	10012840 	call	1001284 <vPortFree>
}
 1015138:	0001883a 	nop
 101513c:	e037883a 	mov	sp,fp
 1015140:	dfc00117 	ldw	ra,4(sp)
 1015144:	df000017 	ldw	fp,0(sp)
 1015148:	dec00204 	addi	sp,sp,8
 101514c:	f800283a 	ret

01015150 <remoteproc_init_mem>:
 */
static inline void
remoteproc_init_mem(struct remoteproc_mem *mem, const char *name,
		    metal_phys_addr_t pa, metal_phys_addr_t da,
		    size_t size, struct metal_io_region *io)
{
 1015150:	defffa04 	addi	sp,sp,-24
 1015154:	dfc00515 	stw	ra,20(sp)
 1015158:	df000415 	stw	fp,16(sp)
 101515c:	df000404 	addi	fp,sp,16
 1015160:	e13ffc15 	stw	r4,-16(fp)
 1015164:	e17ffd15 	stw	r5,-12(fp)
 1015168:	e1bffe15 	stw	r6,-8(fp)
 101516c:	e1ffff15 	stw	r7,-4(fp)
	if (!mem)
 1015170:	e0bffc17 	ldw	r2,-16(fp)
 1015174:	10001826 	beq	r2,zero,10151d8 <remoteproc_init_mem+0x88>
		return;
	if (name)
 1015178:	e0bffd17 	ldw	r2,-12(fp)
 101517c:	10000726 	beq	r2,zero,101519c <remoteproc_init_mem+0x4c>
		strncpy(mem->name, name, sizeof(mem->name));
 1015180:	e0bffc17 	ldw	r2,-16(fp)
 1015184:	10800304 	addi	r2,r2,12
 1015188:	01800804 	movi	r6,32
 101518c:	e17ffd17 	ldw	r5,-12(fp)
 1015190:	1009883a 	mov	r4,r2
 1015194:	101671c0 	call	101671c <strncpy>
 1015198:	00000206 	br	10151a4 <remoteproc_init_mem+0x54>
	else
		mem->name[0] = 0;
 101519c:	e0bffc17 	ldw	r2,-16(fp)
 10151a0:	10000305 	stb	zero,12(r2)
	mem->pa = pa;
 10151a4:	e0bffc17 	ldw	r2,-16(fp)
 10151a8:	e0fffe17 	ldw	r3,-8(fp)
 10151ac:	10c00115 	stw	r3,4(r2)
	mem->da = da;
 10151b0:	e0bffc17 	ldw	r2,-16(fp)
 10151b4:	e0ffff17 	ldw	r3,-4(fp)
 10151b8:	10c00015 	stw	r3,0(r2)
	mem->io = io;
 10151bc:	e0bffc17 	ldw	r2,-16(fp)
 10151c0:	e0c00317 	ldw	r3,12(fp)
 10151c4:	10c00b15 	stw	r3,44(r2)
	mem->size = size;
 10151c8:	e0bffc17 	ldw	r2,-16(fp)
 10151cc:	e0c00217 	ldw	r3,8(fp)
 10151d0:	10c00215 	stw	r3,8(r2)
 10151d4:	00000106 	br	10151dc <remoteproc_init_mem+0x8c>
remoteproc_init_mem(struct remoteproc_mem *mem, const char *name,
		    metal_phys_addr_t pa, metal_phys_addr_t da,
		    size_t size, struct metal_io_region *io)
{
	if (!mem)
		return;
 10151d8:	0001883a 	nop
		mem->name[0] = 0;
	mem->pa = pa;
	mem->da = da;
	mem->io = io;
	mem->size = size;
}
 10151dc:	e037883a 	mov	sp,fp
 10151e0:	dfc00117 	ldw	ra,4(sp)
 10151e4:	df000017 	ldw	fp,0(sp)
 10151e8:	dec00204 	addi	sp,sp,8
 10151ec:	f800283a 	ret

010151f0 <remoteproc_add_mem>:
 * @rproc - pointer to remoteproc
 * @mem - pointer to remoteproc memory
 */
static inline void
remoteproc_add_mem(struct remoteproc *rproc, struct remoteproc_mem *mem)
{
 10151f0:	defffc04 	addi	sp,sp,-16
 10151f4:	dfc00315 	stw	ra,12(sp)
 10151f8:	df000215 	stw	fp,8(sp)
 10151fc:	df000204 	addi	fp,sp,8
 1015200:	e13ffe15 	stw	r4,-8(fp)
 1015204:	e17fff15 	stw	r5,-4(fp)
	if (!rproc || !mem)
 1015208:	e0bffe17 	ldw	r2,-8(fp)
 101520c:	10000a26 	beq	r2,zero,1015238 <remoteproc_add_mem+0x48>
 1015210:	e0bfff17 	ldw	r2,-4(fp)
 1015214:	10000826 	beq	r2,zero,1015238 <remoteproc_add_mem+0x48>
		return;
	metal_list_add_tail(&rproc->mems, &mem->node);
 1015218:	e0bffe17 	ldw	r2,-8(fp)
 101521c:	10c00404 	addi	r3,r2,16
 1015220:	e0bfff17 	ldw	r2,-4(fp)
 1015224:	10800c04 	addi	r2,r2,48
 1015228:	100b883a 	mov	r5,r2
 101522c:	1809883a 	mov	r4,r3
 1015230:	1014ac80 	call	1014ac8 <metal_list_add_tail>
 1015234:	00000106 	br	101523c <remoteproc_add_mem+0x4c>
 */
static inline void
remoteproc_add_mem(struct remoteproc *rproc, struct remoteproc_mem *mem)
{
	if (!rproc || !mem)
		return;
 1015238:	0001883a 	nop
	metal_list_add_tail(&rproc->mems, &mem->node);
}
 101523c:	e037883a 	mov	sp,fp
 1015240:	dfc00117 	ldw	ra,4(sp)
 1015244:	df000017 	ldw	fp,0(sp)
 1015248:	dec00204 	addi	sp,sp,8
 101524c:	f800283a 	ret

01015250 <zynqmp_r5_a53_proc_irq_handler>:
#define IPI_IMR_OFFSET           0x00000014    /* IPI interrupt mask register offset */
#define IPI_IER_OFFSET           0x00000018    /* IPI interrupt enable register offset */
#define IPI_IDR_OFFSET           0x0000001C    /* IPI interrupt disable register offset */

static int zynqmp_r5_a53_proc_irq_handler(int vect_id, void *data)
{
 1015250:	defff504 	addi	sp,sp,-44
 1015254:	dfc00a15 	stw	ra,40(sp)
 1015258:	df000915 	stw	fp,36(sp)
 101525c:	dc400815 	stw	r17,32(sp)
 1015260:	dc000715 	stw	r16,28(sp)
 1015264:	df000904 	addi	fp,sp,36
 1015268:	e13ffc15 	stw	r4,-16(fp)
 101526c:	e17ffd15 	stw	r5,-12(fp)
	struct remoteproc *rproc = data;
 1015270:	e0bffd17 	ldw	r2,-12(fp)
 1015274:	e0bff915 	stw	r2,-28(fp)
	struct remoteproc_priv *prproc;
	unsigned int ipi_intr_status;

	(void)vect_id;
	if (!rproc)
 1015278:	e0bff917 	ldw	r2,-28(fp)
 101527c:	1000021e 	bne	r2,zero,1015288 <zynqmp_r5_a53_proc_irq_handler+0x38>
		return METAL_IRQ_NOT_HANDLED;
 1015280:	0005883a 	mov	r2,zero
 1015284:	00002806 	br	1015328 <zynqmp_r5_a53_proc_irq_handler+0xd8>
	prproc = rproc->priv;
 1015288:	e0bff917 	ldw	r2,-28(fp)
 101528c:	10800d17 	ldw	r2,52(r2)
 1015290:	e0bffa15 	stw	r2,-24(fp)
	ipi_intr_status = (unsigned int)metal_io_read32(prproc->ipi_io,
 1015294:	e0bffa17 	ldw	r2,-24(fp)
 1015298:	10800317 	ldw	r2,12(r2)
 101529c:	01c00104 	movi	r7,4
 10152a0:	01800144 	movi	r6,5
 10152a4:	01400404 	movi	r5,16
 10152a8:	1009883a 	mov	r4,r2
 10152ac:	1014d880 	call	1014d88 <metal_io_read>
 10152b0:	1009883a 	mov	r4,r2
 10152b4:	180b883a 	mov	r5,r3
 10152b8:	e13ffb15 	stw	r4,-20(fp)
							IPI_ISR_OFFSET);
	if (ipi_intr_status & prproc->ipi_chn_mask) {
 10152bc:	e0bffa17 	ldw	r2,-24(fp)
 10152c0:	10c00417 	ldw	r3,16(r2)
 10152c4:	e0bffb17 	ldw	r2,-20(fp)
 10152c8:	1884703a 	and	r2,r3,r2
 10152cc:	10001526 	beq	r2,zero,1015324 <zynqmp_r5_a53_proc_irq_handler+0xd4>
		atomic_flag_clear(&prproc->ipi_nokick);
 10152d0:	e0bffa17 	ldw	r2,-24(fp)
 10152d4:	10800504 	addi	r2,r2,20
 10152d8:	0001b03a 	sync
 10152dc:	10000015 	stw	zero,0(r2)
		metal_io_write32(prproc->ipi_io, IPI_ISR_OFFSET,
 10152e0:	e0bffa17 	ldw	r2,-24(fp)
 10152e4:	10c00317 	ldw	r3,12(r2)
 10152e8:	e0bffa17 	ldw	r2,-24(fp)
 10152ec:	10800417 	ldw	r2,16(r2)
 10152f0:	1021883a 	mov	r16,r2
 10152f4:	0023883a 	mov	r17,zero
 10152f8:	00800104 	movi	r2,4
 10152fc:	d8800115 	stw	r2,4(sp)
 1015300:	00800144 	movi	r2,5
 1015304:	d8800015 	stw	r2,0(sp)
 1015308:	800d883a 	mov	r6,r16
 101530c:	880f883a 	mov	r7,r17
 1015310:	01400404 	movi	r5,16
 1015314:	1809883a 	mov	r4,r3
 1015318:	1014f200 	call	1014f20 <metal_io_write>
				 prproc->ipi_chn_mask);
		return METAL_IRQ_HANDLED;
 101531c:	00800044 	movi	r2,1
 1015320:	00000106 	br	1015328 <zynqmp_r5_a53_proc_irq_handler+0xd8>
	}
	return METAL_IRQ_NOT_HANDLED;
 1015324:	0005883a 	mov	r2,zero
}
 1015328:	e6fffe04 	addi	sp,fp,-8
 101532c:	dfc00317 	ldw	ra,12(sp)
 1015330:	df000217 	ldw	fp,8(sp)
 1015334:	dc400117 	ldw	r17,4(sp)
 1015338:	dc000017 	ldw	r16,0(sp)
 101533c:	dec00404 	addi	sp,sp,16
 1015340:	f800283a 	ret

01015344 <zynqmp_r5_a53_proc_init>:

static struct remoteproc *
zynqmp_r5_a53_proc_init(struct remoteproc *rproc,
            struct remoteproc_ops *ops, void *arg)
{
 1015344:	defff304 	addi	sp,sp,-52
 1015348:	dfc00c15 	stw	ra,48(sp)
 101534c:	df000b15 	stw	fp,44(sp)
 1015350:	dc400a15 	stw	r17,40(sp)
 1015354:	dc000915 	stw	r16,36(sp)
 1015358:	df000b04 	addi	fp,sp,44
 101535c:	e13ffb15 	stw	r4,-20(fp)
 1015360:	e17ffc15 	stw	r5,-16(fp)
 1015364:	e1bffd15 	stw	r6,-12(fp)
	struct remoteproc_priv *prproc = arg;
 1015368:	e0bffd17 	ldw	r2,-12(fp)
 101536c:	e0bff715 	stw	r2,-36(fp)
	struct metal_device *ipi_dev;
	unsigned int irq_vect;
	int ret;

	if (!rproc || !prproc || !ops)
 1015370:	e0bffb17 	ldw	r2,-20(fp)
 1015374:	10000426 	beq	r2,zero,1015388 <zynqmp_r5_a53_proc_init+0x44>
 1015378:	e0bff717 	ldw	r2,-36(fp)
 101537c:	10000226 	beq	r2,zero,1015388 <zynqmp_r5_a53_proc_init+0x44>
 1015380:	e0bffc17 	ldw	r2,-16(fp)
 1015384:	1000021e 	bne	r2,zero,1015390 <zynqmp_r5_a53_proc_init+0x4c>
		return NULL;
 1015388:	0005883a 	mov	r2,zero
 101538c:	00004a06 	br	10154b8 <zynqmp_r5_a53_proc_init+0x174>
	ret = metal_device_open(prproc->ipi_bus_name, prproc->ipi_name,
 1015390:	e0bff717 	ldw	r2,-36(fp)
 1015394:	10c00117 	ldw	r3,4(r2)
 1015398:	e0bff717 	ldw	r2,-36(fp)
 101539c:	10800017 	ldw	r2,0(r2)
 10153a0:	e13ffa04 	addi	r4,fp,-24
 10153a4:	200d883a 	mov	r6,r4
 10153a8:	100b883a 	mov	r5,r2
 10153ac:	1809883a 	mov	r4,r3
 10153b0:	100670c0 	call	100670c <metal_device_open>
 10153b4:	e0bff815 	stw	r2,-32(fp)
				&ipi_dev);
	if (ret) {
 10153b8:	e0bff817 	ldw	r2,-32(fp)
 10153bc:	10000626 	beq	r2,zero,10153d8 <zynqmp_r5_a53_proc_init+0x94>
		printf("failed to open ipi device: %d.\r\n", ret);
 10153c0:	e17ff817 	ldw	r5,-32(fp)
 10153c4:	010040f4 	movhi	r4,259
 10153c8:	21289904 	addi	r4,r4,-23964
 10153cc:	1015b940 	call	1015b94 <printf>
		return NULL;
 10153d0:	0005883a 	mov	r2,zero
 10153d4:	00003806 	br	10154b8 <zynqmp_r5_a53_proc_init+0x174>
	}
	rproc->priv = prproc;
 10153d8:	e0bffb17 	ldw	r2,-20(fp)
 10153dc:	e0fff717 	ldw	r3,-36(fp)
 10153e0:	10c00d15 	stw	r3,52(r2)
	prproc->ipi_dev = ipi_dev;
 10153e4:	e0fffa17 	ldw	r3,-24(fp)
 10153e8:	e0bff717 	ldw	r2,-36(fp)
 10153ec:	10c00215 	stw	r3,8(r2)
	prproc->ipi_io = metal_device_io_region(ipi_dev, 0);
 10153f0:	e0bffa17 	ldw	r2,-24(fp)
 10153f4:	000b883a 	mov	r5,zero
 10153f8:	1009883a 	mov	r4,r2
 10153fc:	101509c0 	call	101509c <metal_device_io_region>
 1015400:	1007883a 	mov	r3,r2
 1015404:	e0bff717 	ldw	r2,-36(fp)
 1015408:	10c00315 	stw	r3,12(r2)
	if (!prproc->ipi_io)
 101540c:	e0bff717 	ldw	r2,-36(fp)
 1015410:	10800317 	ldw	r2,12(r2)
 1015414:	10002326 	beq	r2,zero,10154a4 <zynqmp_r5_a53_proc_init+0x160>
		goto err1;
	atomic_store(&prproc->ipi_nokick, 1);
 1015418:	e0bff717 	ldw	r2,-36(fp)
 101541c:	00c00044 	movi	r3,1
 1015420:	10c00515 	stw	r3,20(r2)
 1015424:	0001b03a 	sync
	rproc->ops = ops;
 1015428:	e0bffb17 	ldw	r2,-20(fp)
 101542c:	e0fffc17 	ldw	r3,-16(fp)
 1015430:	10c00915 	stw	r3,36(r2)

	/* Register interrupt handler and enable interrupt */
	irq_vect = (uintptr_t)ipi_dev->irq_info;
 1015434:	e0bffa17 	ldw	r2,-24(fp)
 1015438:	10801417 	ldw	r2,80(r2)
 101543c:	e0bff915 	stw	r2,-28(fp)
	metal_irq_register(irq_vect, zynqmp_r5_a53_proc_irq_handler, rproc);
 1015440:	e0bff917 	ldw	r2,-28(fp)
 1015444:	e1bffb17 	ldw	r6,-20(fp)
 1015448:	01404074 	movhi	r5,257
 101544c:	29549404 	addi	r5,r5,21072
 1015450:	1009883a 	mov	r4,r2
 1015454:	1008a640 	call	1008a64 <metal_irq_register>
	metal_irq_enable(irq_vect);
 1015458:	e13ff917 	ldw	r4,-28(fp)
 101545c:	1008b300 	call	1008b30 <metal_irq_enable>
	metal_io_write32(prproc->ipi_io, IPI_IER_OFFSET,
 1015460:	e0bff717 	ldw	r2,-36(fp)
 1015464:	10c00317 	ldw	r3,12(r2)
 1015468:	e0bff717 	ldw	r2,-36(fp)
 101546c:	10800417 	ldw	r2,16(r2)
 1015470:	1021883a 	mov	r16,r2
 1015474:	0023883a 	mov	r17,zero
 1015478:	00800104 	movi	r2,4
 101547c:	d8800115 	stw	r2,4(sp)
 1015480:	00800144 	movi	r2,5
 1015484:	d8800015 	stw	r2,0(sp)
 1015488:	800d883a 	mov	r6,r16
 101548c:	880f883a 	mov	r7,r17
 1015490:	01400604 	movi	r5,24
 1015494:	1809883a 	mov	r4,r3
 1015498:	1014f200 	call	1014f20 <metal_io_write>
			 prproc->ipi_chn_mask);
	return rproc;
 101549c:	e0bffb17 	ldw	r2,-20(fp)
 10154a0:	00000506 	br	10154b8 <zynqmp_r5_a53_proc_init+0x174>
	}
	rproc->priv = prproc;
	prproc->ipi_dev = ipi_dev;
	prproc->ipi_io = metal_device_io_region(ipi_dev, 0);
	if (!prproc->ipi_io)
		goto err1;
 10154a4:	0001883a 	nop
	metal_irq_enable(irq_vect);
	metal_io_write32(prproc->ipi_io, IPI_IER_OFFSET,
			 prproc->ipi_chn_mask);
	return rproc;
err1:
	metal_device_close(ipi_dev);
 10154a8:	e0bffa17 	ldw	r2,-24(fp)
 10154ac:	1009883a 	mov	r4,r2
 10154b0:	10067f80 	call	10067f8 <metal_device_close>
	return NULL;
 10154b4:	0005883a 	mov	r2,zero
}
 10154b8:	e6fffe04 	addi	sp,fp,-8
 10154bc:	dfc00317 	ldw	ra,12(sp)
 10154c0:	df000217 	ldw	fp,8(sp)
 10154c4:	dc400117 	ldw	r17,4(sp)
 10154c8:	dc000017 	ldw	r16,0(sp)
 10154cc:	dec00404 	addi	sp,sp,16
 10154d0:	f800283a 	ret

010154d4 <zynqmp_r5_a53_proc_remove>:

static void zynqmp_r5_a53_proc_remove(struct remoteproc *rproc)
{
 10154d4:	defff904 	addi	sp,sp,-28
 10154d8:	dfc00615 	stw	ra,24(sp)
 10154dc:	df000515 	stw	fp,20(sp)
 10154e0:	df000504 	addi	fp,sp,20
 10154e4:	e13fff15 	stw	r4,-4(fp)
	struct remoteproc_priv *prproc;
	struct metal_device *dev;

	if (!rproc)
 10154e8:	e13fff17 	ldw	r4,-4(fp)
 10154ec:	20002226 	beq	r4,zero,1015578 <zynqmp_r5_a53_proc_remove+0xa4>
		return;
	prproc = rproc->priv;
 10154f0:	e13fff17 	ldw	r4,-4(fp)
 10154f4:	21000d17 	ldw	r4,52(r4)
 10154f8:	e13ffd15 	stw	r4,-12(fp)
	metal_io_write32(prproc->ipi_io, IPI_IDR_OFFSET, prproc->ipi_chn_mask);
 10154fc:	e13ffd17 	ldw	r4,-12(fp)
 1015500:	22000317 	ldw	r8,12(r4)
 1015504:	e13ffd17 	ldw	r4,-12(fp)
 1015508:	21000417 	ldw	r4,16(r4)
 101550c:	2005883a 	mov	r2,r4
 1015510:	0007883a 	mov	r3,zero
 1015514:	01000104 	movi	r4,4
 1015518:	d9000115 	stw	r4,4(sp)
 101551c:	01000144 	movi	r4,5
 1015520:	d9000015 	stw	r4,0(sp)
 1015524:	100d883a 	mov	r6,r2
 1015528:	180f883a 	mov	r7,r3
 101552c:	01400704 	movi	r5,28
 1015530:	4009883a 	mov	r4,r8
 1015534:	1014f200 	call	1014f20 <metal_io_write>
	dev = prproc->ipi_dev;
 1015538:	e0bffd17 	ldw	r2,-12(fp)
 101553c:	10800217 	ldw	r2,8(r2)
 1015540:	e0bffe15 	stw	r2,-8(fp)
	if (dev) {
 1015544:	e0bffe17 	ldw	r2,-8(fp)
 1015548:	10000c26 	beq	r2,zero,101557c <zynqmp_r5_a53_proc_remove+0xa8>
		metal_irq_disable((uintptr_t)dev->irq_info);
 101554c:	e0bffe17 	ldw	r2,-8(fp)
 1015550:	10801417 	ldw	r2,80(r2)
 1015554:	1009883a 	mov	r4,r2
 1015558:	1008b6c0 	call	1008b6c <metal_irq_disable>
		metal_irq_unregister((uintptr_t)dev->irq_info);
 101555c:	e0bffe17 	ldw	r2,-8(fp)
 1015560:	10801417 	ldw	r2,80(r2)
 1015564:	1009883a 	mov	r4,r2
 1015568:	1014b040 	call	1014b04 <metal_irq_unregister>
		metal_device_close(dev);
 101556c:	e13ffe17 	ldw	r4,-8(fp)
 1015570:	10067f80 	call	10067f8 <metal_device_close>
 1015574:	00000106 	br	101557c <zynqmp_r5_a53_proc_remove+0xa8>
{
	struct remoteproc_priv *prproc;
	struct metal_device *dev;

	if (!rproc)
		return;
 1015578:	0001883a 	nop
	if (dev) {
		metal_irq_disable((uintptr_t)dev->irq_info);
		metal_irq_unregister((uintptr_t)dev->irq_info);
		metal_device_close(dev);
	}
}
 101557c:	e037883a 	mov	sp,fp
 1015580:	dfc00117 	ldw	ra,4(sp)
 1015584:	df000017 	ldw	fp,0(sp)
 1015588:	dec00204 	addi	sp,sp,8
 101558c:	f800283a 	ret

01015590 <zynqmp_r5_a53_proc_mmap>:

static void *
zynqmp_r5_a53_proc_mmap(struct remoteproc *rproc, metal_phys_addr_t *pa,
			metal_phys_addr_t *da, size_t size,
			unsigned int attribute, struct metal_io_region **io)
{
 1015590:	defff304 	addi	sp,sp,-52
 1015594:	dfc00c15 	stw	ra,48(sp)
 1015598:	df000b15 	stw	fp,44(sp)
 101559c:	df000b04 	addi	fp,sp,44
 10155a0:	e13ffc15 	stw	r4,-16(fp)
 10155a4:	e17ffd15 	stw	r5,-12(fp)
 10155a8:	e1bffe15 	stw	r6,-8(fp)
 10155ac:	e1ffff15 	stw	r7,-4(fp)
	struct remoteproc_mem *mem;
	metal_phys_addr_t lpa, lda;
	struct metal_io_region *tmpio;

	lpa = *pa;
 10155b0:	e0bffd17 	ldw	r2,-12(fp)
 10155b4:	10800017 	ldw	r2,0(r2)
 10155b8:	e0bff815 	stw	r2,-32(fp)
	lda = *da;
 10155bc:	e0bffe17 	ldw	r2,-8(fp)
 10155c0:	10800017 	ldw	r2,0(r2)
 10155c4:	e0bff915 	stw	r2,-28(fp)

	if (lpa == METAL_BAD_PHYS && lda == METAL_BAD_PHYS)
 10155c8:	e0bff817 	ldw	r2,-32(fp)
 10155cc:	10bfffd8 	cmpnei	r2,r2,-1
 10155d0:	1000051e 	bne	r2,zero,10155e8 <zynqmp_r5_a53_proc_mmap+0x58>
 10155d4:	e0bff917 	ldw	r2,-28(fp)
 10155d8:	10bfffd8 	cmpnei	r2,r2,-1
 10155dc:	1000021e 	bne	r2,zero,10155e8 <zynqmp_r5_a53_proc_mmap+0x58>
		return NULL;
 10155e0:	0005883a 	mov	r2,zero
 10155e4:	00004706 	br	1015704 <zynqmp_r5_a53_proc_mmap+0x174>
	if (lpa == METAL_BAD_PHYS)
 10155e8:	e0bff817 	ldw	r2,-32(fp)
 10155ec:	10bfffd8 	cmpnei	r2,r2,-1
 10155f0:	1000021e 	bne	r2,zero,10155fc <zynqmp_r5_a53_proc_mmap+0x6c>
		lpa = lda;
 10155f4:	e0bff917 	ldw	r2,-28(fp)
 10155f8:	e0bff815 	stw	r2,-32(fp)
	if (lda == METAL_BAD_PHYS)
 10155fc:	e0bff917 	ldw	r2,-28(fp)
 1015600:	10bfffd8 	cmpnei	r2,r2,-1
 1015604:	1000021e 	bne	r2,zero,1015610 <zynqmp_r5_a53_proc_mmap+0x80>
		lda = lpa;
 1015608:	e0bff817 	ldw	r2,-32(fp)
 101560c:	e0bff915 	stw	r2,-28(fp)

	if (!attribute)
 1015610:	e0800217 	ldw	r2,8(fp)
 1015614:	1000021e 	bne	r2,zero,1015620 <zynqmp_r5_a53_proc_mmap+0x90>
		attribute = NORM_SHARED_NCACHE | PRIV_RW_USER_RW;
 1015618:	0080c304 	movi	r2,780
 101561c:	e0800215 	stw	r2,8(fp)

	mem = metal_allocate_memory(sizeof(*mem));
 1015620:	01000e04 	movi	r4,56
 1015624:	10150ec0 	call	10150ec <metal_allocate_memory>
 1015628:	e0bffa15 	stw	r2,-24(fp)
	if (!mem)
 101562c:	e0bffa17 	ldw	r2,-24(fp)
 1015630:	1000021e 	bne	r2,zero,101563c <zynqmp_r5_a53_proc_mmap+0xac>
		return NULL;
 1015634:	0005883a 	mov	r2,zero
 1015638:	00003206 	br	1015704 <zynqmp_r5_a53_proc_mmap+0x174>

	tmpio = metal_allocate_memory(sizeof(*tmpio));
 101563c:	01000e04 	movi	r4,56
 1015640:	10150ec0 	call	10150ec <metal_allocate_memory>
 1015644:	e0bffb15 	stw	r2,-20(fp)
	if (!tmpio) {
 1015648:	e0bffb17 	ldw	r2,-20(fp)
 101564c:	1000041e 	bne	r2,zero,1015660 <zynqmp_r5_a53_proc_mmap+0xd0>
		metal_free_memory(mem);
 1015650:	e13ffa17 	ldw	r4,-24(fp)
 1015654:	101511c0 	call	101511c <metal_free_memory>
		return NULL;
 1015658:	0005883a 	mov	r2,zero
 101565c:	00002906 	br	1015704 <zynqmp_r5_a53_proc_mmap+0x174>
	}

	remoteproc_init_mem(mem, NULL, lpa, lda, size, tmpio);
 1015660:	e0bffb17 	ldw	r2,-20(fp)
 1015664:	d8800115 	stw	r2,4(sp)
 1015668:	e0bfff17 	ldw	r2,-4(fp)
 101566c:	d8800015 	stw	r2,0(sp)
 1015670:	e1fff917 	ldw	r7,-28(fp)
 1015674:	e1bff817 	ldw	r6,-32(fp)
 1015678:	000b883a 	mov	r5,zero
 101567c:	e13ffa17 	ldw	r4,-24(fp)
 1015680:	10151500 	call	1015150 <remoteproc_init_mem>

	/* va is the same as pa in this platform */
	metal_io_init(tmpio, (void *)lpa, &mem->pa, size,
 1015684:	e0fff817 	ldw	r3,-32(fp)
 1015688:	e0bffa17 	ldw	r2,-24(fp)
 101568c:	11000104 	addi	r4,r2,4
 1015690:	d8000215 	stw	zero,8(sp)
 1015694:	e0800217 	ldw	r2,8(fp)
 1015698:	d8800115 	stw	r2,4(sp)
 101569c:	00800804 	movi	r2,32
 10156a0:	d8800015 	stw	r2,0(sp)
 10156a4:	e1ffff17 	ldw	r7,-4(fp)
 10156a8:	200d883a 	mov	r6,r4
 10156ac:	180b883a 	mov	r5,r3
 10156b0:	e13ffb17 	ldw	r4,-20(fp)
 10156b4:	10080800 	call	1008080 <metal_io_init>
			  sizeof(metal_phys_addr_t)<<3, attribute, NULL);

	remoteproc_add_mem(rproc, mem);
 10156b8:	e17ffa17 	ldw	r5,-24(fp)
 10156bc:	e13ffc17 	ldw	r4,-16(fp)
 10156c0:	10151f00 	call	10151f0 <remoteproc_add_mem>

	*pa = lpa;
 10156c4:	e0bffd17 	ldw	r2,-12(fp)
 10156c8:	e0fff817 	ldw	r3,-32(fp)
 10156cc:	10c00015 	stw	r3,0(r2)
	*da = lda;
 10156d0:	e0bffe17 	ldw	r2,-8(fp)
 10156d4:	e0fff917 	ldw	r3,-28(fp)
 10156d8:	10c00015 	stw	r3,0(r2)
	if (io)
 10156dc:	e0800317 	ldw	r2,12(fp)
 10156e0:	10000326 	beq	r2,zero,10156f0 <zynqmp_r5_a53_proc_mmap+0x160>
		*io = tmpio;
 10156e4:	e0800317 	ldw	r2,12(fp)
 10156e8:	e0fffb17 	ldw	r3,-20(fp)
 10156ec:	10c00015 	stw	r3,0(r2)
	return metal_io_phys_to_virt(tmpio, mem->pa);
 10156f0:	e0bffa17 	ldw	r2,-24(fp)
 10156f4:	10800117 	ldw	r2,4(r2)
 10156f8:	100b883a 	mov	r5,r2
 10156fc:	e13ffb17 	ldw	r4,-20(fp)
 1015700:	1014d440 	call	1014d44 <metal_io_phys_to_virt>
}
 1015704:	e037883a 	mov	sp,fp
 1015708:	dfc00117 	ldw	ra,4(sp)
 101570c:	df000017 	ldw	fp,0(sp)
 1015710:	dec00204 	addi	sp,sp,8
 1015714:	f800283a 	ret

01015718 <zynqmp_r5_a53_proc_notify>:

static int zynqmp_r5_a53_proc_notify(struct remoteproc *rproc, uint32_t id)
{
 1015718:	defff904 	addi	sp,sp,-28
 101571c:	dfc00615 	stw	ra,24(sp)
 1015720:	df000515 	stw	fp,20(sp)
 1015724:	df000504 	addi	fp,sp,20
 1015728:	e13ffe15 	stw	r4,-8(fp)
 101572c:	e17fff15 	stw	r5,-4(fp)
	struct remoteproc_priv *prproc;

	(void)id;
	if (!rproc)
 1015730:	e13ffe17 	ldw	r4,-8(fp)
 1015734:	2000021e 	bne	r4,zero,1015740 <zynqmp_r5_a53_proc_notify+0x28>
		return -1;
 1015738:	00bfffc4 	movi	r2,-1
 101573c:	00001306 	br	101578c <zynqmp_r5_a53_proc_notify+0x74>
	prproc = rproc->priv;
 1015740:	e13ffe17 	ldw	r4,-8(fp)
 1015744:	21000d17 	ldw	r4,52(r4)
 1015748:	e13ffd15 	stw	r4,-12(fp)

	/* TODO: use IPI driver instead and pass ID */
	metal_io_write32(prproc->ipi_io, IPI_TRIG_OFFSET,
 101574c:	e13ffd17 	ldw	r4,-12(fp)
 1015750:	22000317 	ldw	r8,12(r4)
 1015754:	e13ffd17 	ldw	r4,-12(fp)
 1015758:	21000417 	ldw	r4,16(r4)
 101575c:	2005883a 	mov	r2,r4
 1015760:	0007883a 	mov	r3,zero
 1015764:	01000104 	movi	r4,4
 1015768:	d9000115 	stw	r4,4(sp)
 101576c:	01000144 	movi	r4,5
 1015770:	d9000015 	stw	r4,0(sp)
 1015774:	100d883a 	mov	r6,r2
 1015778:	180f883a 	mov	r7,r3
 101577c:	000b883a 	mov	r5,zero
 1015780:	4009883a 	mov	r4,r8
 1015784:	1014f200 	call	1014f20 <metal_io_write>
			  prproc->ipi_chn_mask);
	return 0;
 1015788:	0005883a 	mov	r2,zero
}
 101578c:	e037883a 	mov	sp,fp
 1015790:	dfc00117 	ldw	ra,4(sp)
 1015794:	df000017 	ldw	fp,0(sp)
 1015798:	dec00204 	addi	sp,sp,8
 101579c:	f800283a 	ret

010157a0 <__assert_func>:
 10157a0:	008040f4 	movhi	r2,259
 10157a4:	10b25d04 	addi	r2,r2,-13964
 10157a8:	10800017 	ldw	r2,0(r2)
 10157ac:	defffc04 	addi	sp,sp,-16
 10157b0:	dfc00315 	stw	ra,12(sp)
 10157b4:	2015883a 	mov	r10,r4
 10157b8:	2811883a 	mov	r8,r5
 10157bc:	3813883a 	mov	r9,r7
 10157c0:	11000317 	ldw	r4,12(r2)
 10157c4:	30000c26 	beq	r6,zero,10157f8 <__assert_func+0x58>
 10157c8:	00c040f4 	movhi	r3,259
 10157cc:	18e8aa04 	addi	r3,r3,-23896
 10157d0:	3005883a 	mov	r2,r6
 10157d4:	014040f4 	movhi	r5,259
 10157d8:	2968ae04 	addi	r5,r5,-23880
 10157dc:	500f883a 	mov	r7,r10
 10157e0:	480d883a 	mov	r6,r9
 10157e4:	d8c00115 	stw	r3,4(sp)
 10157e8:	da000015 	stw	r8,0(sp)
 10157ec:	d8800215 	stw	r2,8(sp)
 10157f0:	101583c0 	call	101583c <fiprintf>
 10157f4:	101ae240 	call	101ae24 <abort>
 10157f8:	00c040f4 	movhi	r3,259
 10157fc:	18e8ad04 	addi	r3,r3,-23884
 1015800:	1805883a 	mov	r2,r3
 1015804:	003ff306 	br	10157d4 <__alt_data_end+0xff0157d4>

01015808 <__assert>:
 1015808:	deffff04 	addi	sp,sp,-4
 101580c:	300f883a 	mov	r7,r6
 1015810:	000d883a 	mov	r6,zero
 1015814:	dfc00015 	stw	ra,0(sp)
 1015818:	10157a00 	call	10157a0 <__assert_func>

0101581c <_fiprintf_r>:
 101581c:	defffe04 	addi	sp,sp,-8
 1015820:	dfc00015 	stw	ra,0(sp)
 1015824:	d9c00115 	stw	r7,4(sp)
 1015828:	d9c00104 	addi	r7,sp,4
 101582c:	10189e80 	call	10189e8 <_vfiprintf_r>
 1015830:	dfc00017 	ldw	ra,0(sp)
 1015834:	dec00204 	addi	sp,sp,8
 1015838:	f800283a 	ret

0101583c <fiprintf>:
 101583c:	defffd04 	addi	sp,sp,-12
 1015840:	2005883a 	mov	r2,r4
 1015844:	dfc00015 	stw	ra,0(sp)
 1015848:	d9800115 	stw	r6,4(sp)
 101584c:	d9c00215 	stw	r7,8(sp)
 1015850:	00c040f4 	movhi	r3,259
 1015854:	18f25d04 	addi	r3,r3,-13964
 1015858:	19000017 	ldw	r4,0(r3)
 101585c:	280d883a 	mov	r6,r5
 1015860:	d9c00104 	addi	r7,sp,4
 1015864:	100b883a 	mov	r5,r2
 1015868:	10189e80 	call	10189e8 <_vfiprintf_r>
 101586c:	dfc00017 	ldw	ra,0(sp)
 1015870:	dec00304 	addi	sp,sp,12
 1015874:	f800283a 	ret

01015878 <memcmp>:
 1015878:	01c000c4 	movi	r7,3
 101587c:	3980192e 	bgeu	r7,r6,10158e4 <memcmp+0x6c>
 1015880:	2144b03a 	or	r2,r4,r5
 1015884:	11c4703a 	and	r2,r2,r7
 1015888:	10000f26 	beq	r2,zero,10158c8 <memcmp+0x50>
 101588c:	20800003 	ldbu	r2,0(r4)
 1015890:	28c00003 	ldbu	r3,0(r5)
 1015894:	10c0151e 	bne	r2,r3,10158ec <memcmp+0x74>
 1015898:	31bfff84 	addi	r6,r6,-2
 101589c:	01ffffc4 	movi	r7,-1
 10158a0:	00000406 	br	10158b4 <memcmp+0x3c>
 10158a4:	20800003 	ldbu	r2,0(r4)
 10158a8:	28c00003 	ldbu	r3,0(r5)
 10158ac:	31bfffc4 	addi	r6,r6,-1
 10158b0:	10c00e1e 	bne	r2,r3,10158ec <memcmp+0x74>
 10158b4:	21000044 	addi	r4,r4,1
 10158b8:	29400044 	addi	r5,r5,1
 10158bc:	31fff91e 	bne	r6,r7,10158a4 <__alt_data_end+0xff0158a4>
 10158c0:	0005883a 	mov	r2,zero
 10158c4:	f800283a 	ret
 10158c8:	20c00017 	ldw	r3,0(r4)
 10158cc:	28800017 	ldw	r2,0(r5)
 10158d0:	18bfee1e 	bne	r3,r2,101588c <__alt_data_end+0xff01588c>
 10158d4:	31bfff04 	addi	r6,r6,-4
 10158d8:	21000104 	addi	r4,r4,4
 10158dc:	29400104 	addi	r5,r5,4
 10158e0:	39bff936 	bltu	r7,r6,10158c8 <__alt_data_end+0xff0158c8>
 10158e4:	303fe91e 	bne	r6,zero,101588c <__alt_data_end+0xff01588c>
 10158e8:	003ff506 	br	10158c0 <__alt_data_end+0xff0158c0>
 10158ec:	10c5c83a 	sub	r2,r2,r3
 10158f0:	f800283a 	ret

010158f4 <memcpy>:
 10158f4:	defffd04 	addi	sp,sp,-12
 10158f8:	dfc00215 	stw	ra,8(sp)
 10158fc:	dc400115 	stw	r17,4(sp)
 1015900:	dc000015 	stw	r16,0(sp)
 1015904:	00c003c4 	movi	r3,15
 1015908:	2005883a 	mov	r2,r4
 101590c:	1980452e 	bgeu	r3,r6,1015a24 <memcpy+0x130>
 1015910:	2906b03a 	or	r3,r5,r4
 1015914:	18c000cc 	andi	r3,r3,3
 1015918:	1800441e 	bne	r3,zero,1015a2c <memcpy+0x138>
 101591c:	347ffc04 	addi	r17,r6,-16
 1015920:	8822d13a 	srli	r17,r17,4
 1015924:	28c00104 	addi	r3,r5,4
 1015928:	23400104 	addi	r13,r4,4
 101592c:	8820913a 	slli	r16,r17,4
 1015930:	2b000204 	addi	r12,r5,8
 1015934:	22c00204 	addi	r11,r4,8
 1015938:	84000504 	addi	r16,r16,20
 101593c:	2a800304 	addi	r10,r5,12
 1015940:	22400304 	addi	r9,r4,12
 1015944:	2c21883a 	add	r16,r5,r16
 1015948:	2811883a 	mov	r8,r5
 101594c:	200f883a 	mov	r7,r4
 1015950:	41000017 	ldw	r4,0(r8)
 1015954:	1fc00017 	ldw	ra,0(r3)
 1015958:	63c00017 	ldw	r15,0(r12)
 101595c:	39000015 	stw	r4,0(r7)
 1015960:	53800017 	ldw	r14,0(r10)
 1015964:	6fc00015 	stw	ra,0(r13)
 1015968:	5bc00015 	stw	r15,0(r11)
 101596c:	4b800015 	stw	r14,0(r9)
 1015970:	18c00404 	addi	r3,r3,16
 1015974:	39c00404 	addi	r7,r7,16
 1015978:	42000404 	addi	r8,r8,16
 101597c:	6b400404 	addi	r13,r13,16
 1015980:	63000404 	addi	r12,r12,16
 1015984:	5ac00404 	addi	r11,r11,16
 1015988:	52800404 	addi	r10,r10,16
 101598c:	4a400404 	addi	r9,r9,16
 1015990:	1c3fef1e 	bne	r3,r16,1015950 <__alt_data_end+0xff015950>
 1015994:	89c00044 	addi	r7,r17,1
 1015998:	380e913a 	slli	r7,r7,4
 101599c:	310003cc 	andi	r4,r6,15
 10159a0:	02c000c4 	movi	r11,3
 10159a4:	11c7883a 	add	r3,r2,r7
 10159a8:	29cb883a 	add	r5,r5,r7
 10159ac:	5900212e 	bgeu	r11,r4,1015a34 <memcpy+0x140>
 10159b0:	1813883a 	mov	r9,r3
 10159b4:	2811883a 	mov	r8,r5
 10159b8:	200f883a 	mov	r7,r4
 10159bc:	42800017 	ldw	r10,0(r8)
 10159c0:	4a400104 	addi	r9,r9,4
 10159c4:	39ffff04 	addi	r7,r7,-4
 10159c8:	4abfff15 	stw	r10,-4(r9)
 10159cc:	42000104 	addi	r8,r8,4
 10159d0:	59fffa36 	bltu	r11,r7,10159bc <__alt_data_end+0xff0159bc>
 10159d4:	213fff04 	addi	r4,r4,-4
 10159d8:	2008d0ba 	srli	r4,r4,2
 10159dc:	318000cc 	andi	r6,r6,3
 10159e0:	21000044 	addi	r4,r4,1
 10159e4:	2109883a 	add	r4,r4,r4
 10159e8:	2109883a 	add	r4,r4,r4
 10159ec:	1907883a 	add	r3,r3,r4
 10159f0:	290b883a 	add	r5,r5,r4
 10159f4:	30000626 	beq	r6,zero,1015a10 <memcpy+0x11c>
 10159f8:	198d883a 	add	r6,r3,r6
 10159fc:	29c00003 	ldbu	r7,0(r5)
 1015a00:	18c00044 	addi	r3,r3,1
 1015a04:	29400044 	addi	r5,r5,1
 1015a08:	19ffffc5 	stb	r7,-1(r3)
 1015a0c:	19bffb1e 	bne	r3,r6,10159fc <__alt_data_end+0xff0159fc>
 1015a10:	dfc00217 	ldw	ra,8(sp)
 1015a14:	dc400117 	ldw	r17,4(sp)
 1015a18:	dc000017 	ldw	r16,0(sp)
 1015a1c:	dec00304 	addi	sp,sp,12
 1015a20:	f800283a 	ret
 1015a24:	2007883a 	mov	r3,r4
 1015a28:	003ff206 	br	10159f4 <__alt_data_end+0xff0159f4>
 1015a2c:	2007883a 	mov	r3,r4
 1015a30:	003ff106 	br	10159f8 <__alt_data_end+0xff0159f8>
 1015a34:	200d883a 	mov	r6,r4
 1015a38:	003fee06 	br	10159f4 <__alt_data_end+0xff0159f4>

01015a3c <memset>:
 1015a3c:	20c000cc 	andi	r3,r4,3
 1015a40:	2005883a 	mov	r2,r4
 1015a44:	18004426 	beq	r3,zero,1015b58 <memset+0x11c>
 1015a48:	31ffffc4 	addi	r7,r6,-1
 1015a4c:	30004026 	beq	r6,zero,1015b50 <memset+0x114>
 1015a50:	2813883a 	mov	r9,r5
 1015a54:	200d883a 	mov	r6,r4
 1015a58:	2007883a 	mov	r3,r4
 1015a5c:	00000406 	br	1015a70 <memset+0x34>
 1015a60:	3a3fffc4 	addi	r8,r7,-1
 1015a64:	31800044 	addi	r6,r6,1
 1015a68:	38003926 	beq	r7,zero,1015b50 <memset+0x114>
 1015a6c:	400f883a 	mov	r7,r8
 1015a70:	18c00044 	addi	r3,r3,1
 1015a74:	32400005 	stb	r9,0(r6)
 1015a78:	1a0000cc 	andi	r8,r3,3
 1015a7c:	403ff81e 	bne	r8,zero,1015a60 <__alt_data_end+0xff015a60>
 1015a80:	010000c4 	movi	r4,3
 1015a84:	21c02d2e 	bgeu	r4,r7,1015b3c <memset+0x100>
 1015a88:	29003fcc 	andi	r4,r5,255
 1015a8c:	200c923a 	slli	r6,r4,8
 1015a90:	3108b03a 	or	r4,r6,r4
 1015a94:	200c943a 	slli	r6,r4,16
 1015a98:	218cb03a 	or	r6,r4,r6
 1015a9c:	010003c4 	movi	r4,15
 1015aa0:	21c0182e 	bgeu	r4,r7,1015b04 <memset+0xc8>
 1015aa4:	3b3ffc04 	addi	r12,r7,-16
 1015aa8:	6018d13a 	srli	r12,r12,4
 1015aac:	1a000104 	addi	r8,r3,4
 1015ab0:	1ac00204 	addi	r11,r3,8
 1015ab4:	6008913a 	slli	r4,r12,4
 1015ab8:	1a800304 	addi	r10,r3,12
 1015abc:	1813883a 	mov	r9,r3
 1015ac0:	21000504 	addi	r4,r4,20
 1015ac4:	1909883a 	add	r4,r3,r4
 1015ac8:	49800015 	stw	r6,0(r9)
 1015acc:	41800015 	stw	r6,0(r8)
 1015ad0:	59800015 	stw	r6,0(r11)
 1015ad4:	51800015 	stw	r6,0(r10)
 1015ad8:	42000404 	addi	r8,r8,16
 1015adc:	4a400404 	addi	r9,r9,16
 1015ae0:	5ac00404 	addi	r11,r11,16
 1015ae4:	52800404 	addi	r10,r10,16
 1015ae8:	413ff71e 	bne	r8,r4,1015ac8 <__alt_data_end+0xff015ac8>
 1015aec:	63000044 	addi	r12,r12,1
 1015af0:	6018913a 	slli	r12,r12,4
 1015af4:	39c003cc 	andi	r7,r7,15
 1015af8:	010000c4 	movi	r4,3
 1015afc:	1b07883a 	add	r3,r3,r12
 1015b00:	21c00e2e 	bgeu	r4,r7,1015b3c <memset+0x100>
 1015b04:	1813883a 	mov	r9,r3
 1015b08:	3811883a 	mov	r8,r7
 1015b0c:	010000c4 	movi	r4,3
 1015b10:	49800015 	stw	r6,0(r9)
 1015b14:	423fff04 	addi	r8,r8,-4
 1015b18:	4a400104 	addi	r9,r9,4
 1015b1c:	223ffc36 	bltu	r4,r8,1015b10 <__alt_data_end+0xff015b10>
 1015b20:	393fff04 	addi	r4,r7,-4
 1015b24:	2008d0ba 	srli	r4,r4,2
 1015b28:	39c000cc 	andi	r7,r7,3
 1015b2c:	21000044 	addi	r4,r4,1
 1015b30:	2109883a 	add	r4,r4,r4
 1015b34:	2109883a 	add	r4,r4,r4
 1015b38:	1907883a 	add	r3,r3,r4
 1015b3c:	38000526 	beq	r7,zero,1015b54 <memset+0x118>
 1015b40:	19cf883a 	add	r7,r3,r7
 1015b44:	19400005 	stb	r5,0(r3)
 1015b48:	18c00044 	addi	r3,r3,1
 1015b4c:	38fffd1e 	bne	r7,r3,1015b44 <__alt_data_end+0xff015b44>
 1015b50:	f800283a 	ret
 1015b54:	f800283a 	ret
 1015b58:	2007883a 	mov	r3,r4
 1015b5c:	300f883a 	mov	r7,r6
 1015b60:	003fc706 	br	1015a80 <__alt_data_end+0xff015a80>

01015b64 <_printf_r>:
 1015b64:	defffd04 	addi	sp,sp,-12
 1015b68:	2805883a 	mov	r2,r5
 1015b6c:	dfc00015 	stw	ra,0(sp)
 1015b70:	d9800115 	stw	r6,4(sp)
 1015b74:	d9c00215 	stw	r7,8(sp)
 1015b78:	21400217 	ldw	r5,8(r4)
 1015b7c:	d9c00104 	addi	r7,sp,4
 1015b80:	100d883a 	mov	r6,r2
 1015b84:	1018a000 	call	1018a00 <___vfprintf_internal_r>
 1015b88:	dfc00017 	ldw	ra,0(sp)
 1015b8c:	dec00304 	addi	sp,sp,12
 1015b90:	f800283a 	ret

01015b94 <printf>:
 1015b94:	defffc04 	addi	sp,sp,-16
 1015b98:	dfc00015 	stw	ra,0(sp)
 1015b9c:	d9400115 	stw	r5,4(sp)
 1015ba0:	d9800215 	stw	r6,8(sp)
 1015ba4:	d9c00315 	stw	r7,12(sp)
 1015ba8:	008040f4 	movhi	r2,259
 1015bac:	10b25d04 	addi	r2,r2,-13964
 1015bb0:	10800017 	ldw	r2,0(r2)
 1015bb4:	200b883a 	mov	r5,r4
 1015bb8:	d9800104 	addi	r6,sp,4
 1015bbc:	11000217 	ldw	r4,8(r2)
 1015bc0:	101abf80 	call	101abf8 <__vfprintf_internal>
 1015bc4:	dfc00017 	ldw	ra,0(sp)
 1015bc8:	dec00404 	addi	sp,sp,16
 1015bcc:	f800283a 	ret

01015bd0 <_puts_r>:
 1015bd0:	defff604 	addi	sp,sp,-40
 1015bd4:	dc000715 	stw	r16,28(sp)
 1015bd8:	2021883a 	mov	r16,r4
 1015bdc:	2809883a 	mov	r4,r5
 1015be0:	dc400815 	stw	r17,32(sp)
 1015be4:	dfc00915 	stw	ra,36(sp)
 1015be8:	2823883a 	mov	r17,r5
 1015bec:	10165b40 	call	10165b4 <strlen>
 1015bf0:	10c00044 	addi	r3,r2,1
 1015bf4:	d8800115 	stw	r2,4(sp)
 1015bf8:	008040f4 	movhi	r2,259
 1015bfc:	10a8bb04 	addi	r2,r2,-23828
 1015c00:	d8800215 	stw	r2,8(sp)
 1015c04:	00800044 	movi	r2,1
 1015c08:	d8800315 	stw	r2,12(sp)
 1015c0c:	00800084 	movi	r2,2
 1015c10:	dc400015 	stw	r17,0(sp)
 1015c14:	d8c00615 	stw	r3,24(sp)
 1015c18:	dec00415 	stw	sp,16(sp)
 1015c1c:	d8800515 	stw	r2,20(sp)
 1015c20:	80000226 	beq	r16,zero,1015c2c <_puts_r+0x5c>
 1015c24:	80800e17 	ldw	r2,56(r16)
 1015c28:	10001426 	beq	r2,zero,1015c7c <_puts_r+0xac>
 1015c2c:	81400217 	ldw	r5,8(r16)
 1015c30:	2880030b 	ldhu	r2,12(r5)
 1015c34:	10c8000c 	andi	r3,r2,8192
 1015c38:	1800061e 	bne	r3,zero,1015c54 <_puts_r+0x84>
 1015c3c:	29001917 	ldw	r4,100(r5)
 1015c40:	00f7ffc4 	movi	r3,-8193
 1015c44:	10880014 	ori	r2,r2,8192
 1015c48:	20c6703a 	and	r3,r4,r3
 1015c4c:	2880030d 	sth	r2,12(r5)
 1015c50:	28c01915 	stw	r3,100(r5)
 1015c54:	d9800404 	addi	r6,sp,16
 1015c58:	8009883a 	mov	r4,r16
 1015c5c:	101d1400 	call	101d140 <__sfvwrite_r>
 1015c60:	1000091e 	bne	r2,zero,1015c88 <_puts_r+0xb8>
 1015c64:	00800284 	movi	r2,10
 1015c68:	dfc00917 	ldw	ra,36(sp)
 1015c6c:	dc400817 	ldw	r17,32(sp)
 1015c70:	dc000717 	ldw	r16,28(sp)
 1015c74:	dec00a04 	addi	sp,sp,40
 1015c78:	f800283a 	ret
 1015c7c:	8009883a 	mov	r4,r16
 1015c80:	101ccbc0 	call	101ccbc <__sinit>
 1015c84:	003fe906 	br	1015c2c <__alt_data_end+0xff015c2c>
 1015c88:	00bfffc4 	movi	r2,-1
 1015c8c:	003ff606 	br	1015c68 <__alt_data_end+0xff015c68>

01015c90 <puts>:
 1015c90:	008040f4 	movhi	r2,259
 1015c94:	10b25d04 	addi	r2,r2,-13964
 1015c98:	200b883a 	mov	r5,r4
 1015c9c:	11000017 	ldw	r4,0(r2)
 1015ca0:	1015bd01 	jmpi	1015bd0 <_puts_r>

01015ca4 <_snprintf_r>:
 1015ca4:	30003116 	blt	r6,zero,1015d6c <_snprintf_r+0xc8>
 1015ca8:	deffe404 	addi	sp,sp,-112
 1015cac:	00c08204 	movi	r3,520
 1015cb0:	dc001a15 	stw	r16,104(sp)
 1015cb4:	3005883a 	mov	r2,r6
 1015cb8:	dfc01b15 	stw	ra,108(sp)
 1015cbc:	d8c0030d 	sth	r3,12(sp)
 1015cc0:	d9400015 	stw	r5,0(sp)
 1015cc4:	d9400415 	stw	r5,16(sp)
 1015cc8:	380d883a 	mov	r6,r7
 1015ccc:	2021883a 	mov	r16,r4
 1015cd0:	10001026 	beq	r2,zero,1015d14 <_snprintf_r+0x70>
 1015cd4:	10bfffc4 	addi	r2,r2,-1
 1015cd8:	d8800215 	stw	r2,8(sp)
 1015cdc:	d8800515 	stw	r2,20(sp)
 1015ce0:	d9c01c04 	addi	r7,sp,112
 1015ce4:	00bfffc4 	movi	r2,-1
 1015ce8:	d80b883a 	mov	r5,sp
 1015cec:	d880038d 	sth	r2,14(sp)
 1015cf0:	10168080 	call	1016808 <___svfprintf_internal_r>
 1015cf4:	00ffffc4 	movi	r3,-1
 1015cf8:	10c01316 	blt	r2,r3,1015d48 <_snprintf_r+0xa4>
 1015cfc:	d8c00017 	ldw	r3,0(sp)
 1015d00:	18000005 	stb	zero,0(r3)
 1015d04:	dfc01b17 	ldw	ra,108(sp)
 1015d08:	dc001a17 	ldw	r16,104(sp)
 1015d0c:	dec01c04 	addi	sp,sp,112
 1015d10:	f800283a 	ret
 1015d14:	00bfffc4 	movi	r2,-1
 1015d18:	d9c01c04 	addi	r7,sp,112
 1015d1c:	d80b883a 	mov	r5,sp
 1015d20:	d8000215 	stw	zero,8(sp)
 1015d24:	d8000515 	stw	zero,20(sp)
 1015d28:	d880038d 	sth	r2,14(sp)
 1015d2c:	10168080 	call	1016808 <___svfprintf_internal_r>
 1015d30:	00ffffc4 	movi	r3,-1
 1015d34:	10c00716 	blt	r2,r3,1015d54 <_snprintf_r+0xb0>
 1015d38:	dfc01b17 	ldw	ra,108(sp)
 1015d3c:	dc001a17 	ldw	r16,104(sp)
 1015d40:	dec01c04 	addi	sp,sp,112
 1015d44:	f800283a 	ret
 1015d48:	00c022c4 	movi	r3,139
 1015d4c:	80c00015 	stw	r3,0(r16)
 1015d50:	003fea06 	br	1015cfc <__alt_data_end+0xff015cfc>
 1015d54:	00c022c4 	movi	r3,139
 1015d58:	80c00015 	stw	r3,0(r16)
 1015d5c:	dfc01b17 	ldw	ra,108(sp)
 1015d60:	dc001a17 	ldw	r16,104(sp)
 1015d64:	dec01c04 	addi	sp,sp,112
 1015d68:	f800283a 	ret
 1015d6c:	008022c4 	movi	r2,139
 1015d70:	20800015 	stw	r2,0(r4)
 1015d74:	00bfffc4 	movi	r2,-1
 1015d78:	f800283a 	ret

01015d7c <snprintf>:
 1015d7c:	deffe304 	addi	sp,sp,-116
 1015d80:	dfc01b15 	stw	ra,108(sp)
 1015d84:	dc001a15 	stw	r16,104(sp)
 1015d88:	d9c01c15 	stw	r7,112(sp)
 1015d8c:	008040f4 	movhi	r2,259
 1015d90:	10b25d04 	addi	r2,r2,-13964
 1015d94:	14000017 	ldw	r16,0(r2)
 1015d98:	28002d16 	blt	r5,zero,1015e50 <snprintf+0xd4>
 1015d9c:	00808204 	movi	r2,520
 1015da0:	d880030d 	sth	r2,12(sp)
 1015da4:	d9000015 	stw	r4,0(sp)
 1015da8:	d9000415 	stw	r4,16(sp)
 1015dac:	28001126 	beq	r5,zero,1015df4 <snprintf+0x78>
 1015db0:	28bfffc4 	addi	r2,r5,-1
 1015db4:	d8800215 	stw	r2,8(sp)
 1015db8:	d8800515 	stw	r2,20(sp)
 1015dbc:	d9c01c04 	addi	r7,sp,112
 1015dc0:	00bfffc4 	movi	r2,-1
 1015dc4:	d80b883a 	mov	r5,sp
 1015dc8:	8009883a 	mov	r4,r16
 1015dcc:	d880038d 	sth	r2,14(sp)
 1015dd0:	10168080 	call	1016808 <___svfprintf_internal_r>
 1015dd4:	00ffffc4 	movi	r3,-1
 1015dd8:	10c01416 	blt	r2,r3,1015e2c <snprintf+0xb0>
 1015ddc:	d8c00017 	ldw	r3,0(sp)
 1015de0:	18000005 	stb	zero,0(r3)
 1015de4:	dfc01b17 	ldw	ra,108(sp)
 1015de8:	dc001a17 	ldw	r16,104(sp)
 1015dec:	dec01d04 	addi	sp,sp,116
 1015df0:	f800283a 	ret
 1015df4:	00bfffc4 	movi	r2,-1
 1015df8:	d9c01c04 	addi	r7,sp,112
 1015dfc:	d80b883a 	mov	r5,sp
 1015e00:	8009883a 	mov	r4,r16
 1015e04:	d8000215 	stw	zero,8(sp)
 1015e08:	d8000515 	stw	zero,20(sp)
 1015e0c:	d880038d 	sth	r2,14(sp)
 1015e10:	10168080 	call	1016808 <___svfprintf_internal_r>
 1015e14:	00ffffc4 	movi	r3,-1
 1015e18:	10c00716 	blt	r2,r3,1015e38 <snprintf+0xbc>
 1015e1c:	dfc01b17 	ldw	ra,108(sp)
 1015e20:	dc001a17 	ldw	r16,104(sp)
 1015e24:	dec01d04 	addi	sp,sp,116
 1015e28:	f800283a 	ret
 1015e2c:	00c022c4 	movi	r3,139
 1015e30:	80c00015 	stw	r3,0(r16)
 1015e34:	003fe906 	br	1015ddc <__alt_data_end+0xff015ddc>
 1015e38:	00c022c4 	movi	r3,139
 1015e3c:	80c00015 	stw	r3,0(r16)
 1015e40:	dfc01b17 	ldw	ra,108(sp)
 1015e44:	dc001a17 	ldw	r16,104(sp)
 1015e48:	dec01d04 	addi	sp,sp,116
 1015e4c:	f800283a 	ret
 1015e50:	008022c4 	movi	r2,139
 1015e54:	80800015 	stw	r2,0(r16)
 1015e58:	00bfffc4 	movi	r2,-1
 1015e5c:	003fef06 	br	1015e1c <__alt_data_end+0xff015e1c>

01015e60 <strcmp>:
 1015e60:	2144b03a 	or	r2,r4,r5
 1015e64:	108000cc 	andi	r2,r2,3
 1015e68:	1000171e 	bne	r2,zero,1015ec8 <strcmp+0x68>
 1015e6c:	20800017 	ldw	r2,0(r4)
 1015e70:	28c00017 	ldw	r3,0(r5)
 1015e74:	10c0141e 	bne	r2,r3,1015ec8 <strcmp+0x68>
 1015e78:	027fbff4 	movhi	r9,65279
 1015e7c:	4a7fbfc4 	addi	r9,r9,-257
 1015e80:	0086303a 	nor	r3,zero,r2
 1015e84:	02202074 	movhi	r8,32897
 1015e88:	1245883a 	add	r2,r2,r9
 1015e8c:	42202004 	addi	r8,r8,-32640
 1015e90:	10c4703a 	and	r2,r2,r3
 1015e94:	1204703a 	and	r2,r2,r8
 1015e98:	10000226 	beq	r2,zero,1015ea4 <strcmp+0x44>
 1015e9c:	00002306 	br	1015f2c <strcmp+0xcc>
 1015ea0:	1000221e 	bne	r2,zero,1015f2c <strcmp+0xcc>
 1015ea4:	21000104 	addi	r4,r4,4
 1015ea8:	20c00017 	ldw	r3,0(r4)
 1015eac:	29400104 	addi	r5,r5,4
 1015eb0:	29800017 	ldw	r6,0(r5)
 1015eb4:	1a4f883a 	add	r7,r3,r9
 1015eb8:	00c4303a 	nor	r2,zero,r3
 1015ebc:	3884703a 	and	r2,r7,r2
 1015ec0:	1204703a 	and	r2,r2,r8
 1015ec4:	19bff626 	beq	r3,r6,1015ea0 <__alt_data_end+0xff015ea0>
 1015ec8:	20800003 	ldbu	r2,0(r4)
 1015ecc:	10c03fcc 	andi	r3,r2,255
 1015ed0:	18c0201c 	xori	r3,r3,128
 1015ed4:	18ffe004 	addi	r3,r3,-128
 1015ed8:	18000c26 	beq	r3,zero,1015f0c <strcmp+0xac>
 1015edc:	29800007 	ldb	r6,0(r5)
 1015ee0:	19800326 	beq	r3,r6,1015ef0 <strcmp+0x90>
 1015ee4:	00001306 	br	1015f34 <strcmp+0xd4>
 1015ee8:	29800007 	ldb	r6,0(r5)
 1015eec:	11800b1e 	bne	r2,r6,1015f1c <strcmp+0xbc>
 1015ef0:	21000044 	addi	r4,r4,1
 1015ef4:	20c00003 	ldbu	r3,0(r4)
 1015ef8:	29400044 	addi	r5,r5,1
 1015efc:	18803fcc 	andi	r2,r3,255
 1015f00:	1080201c 	xori	r2,r2,128
 1015f04:	10bfe004 	addi	r2,r2,-128
 1015f08:	103ff71e 	bne	r2,zero,1015ee8 <__alt_data_end+0xff015ee8>
 1015f0c:	0007883a 	mov	r3,zero
 1015f10:	28800003 	ldbu	r2,0(r5)
 1015f14:	1885c83a 	sub	r2,r3,r2
 1015f18:	f800283a 	ret
 1015f1c:	28800003 	ldbu	r2,0(r5)
 1015f20:	18c03fcc 	andi	r3,r3,255
 1015f24:	1885c83a 	sub	r2,r3,r2
 1015f28:	f800283a 	ret
 1015f2c:	0005883a 	mov	r2,zero
 1015f30:	f800283a 	ret
 1015f34:	10c03fcc 	andi	r3,r2,255
 1015f38:	003ff506 	br	1015f10 <__alt_data_end+0xff015f10>

01015f3c <_strerror_r>:
 1015f3c:	deffff04 	addi	sp,sp,-4
 1015f40:	2807883a 	mov	r3,r5
 1015f44:	dfc00015 	stw	ra,0(sp)
 1015f48:	00802384 	movi	r2,142
 1015f4c:	300b883a 	mov	r5,r6
 1015f50:	10c18736 	bltu	r2,r3,1016570 <_strerror_r+0x634>
 1015f54:	181090ba 	slli	r8,r3,2
 1015f58:	00804074 	movhi	r2,257
 1015f5c:	1097db04 	addi	r2,r2,24428
 1015f60:	4085883a 	add	r2,r8,r2
 1015f64:	10800017 	ldw	r2,0(r2)
 1015f68:	1000683a 	jmp	r2
 1015f6c:	010161a8 	cmpgeui	r4,zero,1414
 1015f70:	01016564 	muli	r4,zero,1429
 1015f74:	01016558 	cmpnei	r4,zero,1429
 1015f78:	0101654c 	andi	r4,zero,1429
 1015f7c:	01016540 	call	101654 <__reset-0xefe9ac>
 1015f80:	01016534 	movhi	r4,1428
 1015f84:	01016528 	cmpgeui	r4,zero,1428
 1015f88:	0101651c 	xori	r4,zero,1428
 1015f8c:	01016510 	cmplti	r4,zero,1428
 1015f90:	01016504 	movi	r4,1428
 1015f94:	010164f8 	rdprs	r4,zero,1427
 1015f98:	010164ec 	andhi	r4,zero,1427
 1015f9c:	010164e0 	cmpeqi	r4,zero,1427
 1015fa0:	010164d4 	movui	r4,1427
 1015fa4:	010164c8 	cmpgei	r4,zero,1427
 1015fa8:	01016570 	cmpltui	r4,zero,1429
 1015fac:	010164bc 	xorhi	r4,zero,1426
 1015fb0:	010164b0 	cmpltui	r4,zero,1426
 1015fb4:	010164a4 	muli	r4,zero,1426
 1015fb8:	01016498 	cmpnei	r4,zero,1426
 1015fbc:	0101648c 	andi	r4,zero,1426
 1015fc0:	01016480 	call	101648 <__reset-0xefe9b8>
 1015fc4:	01016474 	movhi	r4,1425
 1015fc8:	01016468 	cmpgeui	r4,zero,1425
 1015fcc:	0101645c 	xori	r4,zero,1425
 1015fd0:	01016450 	cmplti	r4,zero,1425
 1015fd4:	01016444 	movi	r4,1425
 1015fd8:	01016438 	rdprs	r4,zero,1424
 1015fdc:	0101642c 	andhi	r4,zero,1424
 1015fe0:	01016420 	cmpeqi	r4,zero,1424
 1015fe4:	01016414 	movui	r4,1424
 1015fe8:	01016408 	cmpgei	r4,zero,1424
 1015fec:	010163fc 	xorhi	r4,zero,1423
 1015ff0:	010163f0 	cmpltui	r4,zero,1423
 1015ff4:	010163e4 	muli	r4,zero,1423
 1015ff8:	010163d8 	cmpnei	r4,zero,1423
 1015ffc:	010163cc 	andi	r4,zero,1423
 1016000:	01016570 	cmpltui	r4,zero,1429
 1016004:	01016570 	cmpltui	r4,zero,1429
 1016008:	01016570 	cmpltui	r4,zero,1429
 101600c:	01016570 	cmpltui	r4,zero,1429
 1016010:	01016570 	cmpltui	r4,zero,1429
 1016014:	01016570 	cmpltui	r4,zero,1429
 1016018:	01016570 	cmpltui	r4,zero,1429
 101601c:	01016570 	cmpltui	r4,zero,1429
 1016020:	010163c0 	call	10163c <__reset-0xefe9c4>
 1016024:	010163b4 	movhi	r4,1422
 1016028:	01016570 	cmpltui	r4,zero,1429
 101602c:	01016570 	cmpltui	r4,zero,1429
 1016030:	01016570 	cmpltui	r4,zero,1429
 1016034:	01016570 	cmpltui	r4,zero,1429
 1016038:	01016570 	cmpltui	r4,zero,1429
 101603c:	01016570 	cmpltui	r4,zero,1429
 1016040:	01016570 	cmpltui	r4,zero,1429
 1016044:	01016570 	cmpltui	r4,zero,1429
 1016048:	01016570 	cmpltui	r4,zero,1429
 101604c:	01016570 	cmpltui	r4,zero,1429
 1016050:	01016570 	cmpltui	r4,zero,1429
 1016054:	01016570 	cmpltui	r4,zero,1429
 1016058:	01016570 	cmpltui	r4,zero,1429
 101605c:	010163a8 	cmpgeui	r4,zero,1422
 1016060:	0101639c 	xori	r4,zero,1422
 1016064:	01016390 	cmplti	r4,zero,1422
 1016068:	01016384 	movi	r4,1422
 101606c:	01016570 	cmpltui	r4,zero,1429
 1016070:	01016570 	cmpltui	r4,zero,1429
 1016074:	01016570 	cmpltui	r4,zero,1429
 1016078:	01016378 	rdprs	r4,zero,1421
 101607c:	01016570 	cmpltui	r4,zero,1429
 1016080:	01016570 	cmpltui	r4,zero,1429
 1016084:	01016570 	cmpltui	r4,zero,1429
 1016088:	0101636c 	andhi	r4,zero,1421
 101608c:	01016570 	cmpltui	r4,zero,1429
 1016090:	01016570 	cmpltui	r4,zero,1429
 1016094:	01016360 	cmpeqi	r4,zero,1421
 1016098:	01016570 	cmpltui	r4,zero,1429
 101609c:	01016570 	cmpltui	r4,zero,1429
 10160a0:	01016354 	movui	r4,1421
 10160a4:	01016570 	cmpltui	r4,zero,1429
 10160a8:	01016570 	cmpltui	r4,zero,1429
 10160ac:	01016570 	cmpltui	r4,zero,1429
 10160b0:	01016570 	cmpltui	r4,zero,1429
 10160b4:	01016570 	cmpltui	r4,zero,1429
 10160b8:	01016570 	cmpltui	r4,zero,1429
 10160bc:	01016570 	cmpltui	r4,zero,1429
 10160c0:	01016570 	cmpltui	r4,zero,1429
 10160c4:	01016570 	cmpltui	r4,zero,1429
 10160c8:	01016570 	cmpltui	r4,zero,1429
 10160cc:	01016348 	cmpgei	r4,zero,1421
 10160d0:	01016570 	cmpltui	r4,zero,1429
 10160d4:	0101633c 	xorhi	r4,zero,1420
 10160d8:	01016330 	cmpltui	r4,zero,1420
 10160dc:	01016324 	muli	r4,zero,1420
 10160e0:	01016570 	cmpltui	r4,zero,1429
 10160e4:	01016570 	cmpltui	r4,zero,1429
 10160e8:	01016318 	cmpnei	r4,zero,1420
 10160ec:	01016570 	cmpltui	r4,zero,1429
 10160f0:	01016570 	cmpltui	r4,zero,1429
 10160f4:	01016570 	cmpltui	r4,zero,1429
 10160f8:	01016570 	cmpltui	r4,zero,1429
 10160fc:	01016570 	cmpltui	r4,zero,1429
 1016100:	01016570 	cmpltui	r4,zero,1429
 1016104:	01016570 	cmpltui	r4,zero,1429
 1016108:	01016570 	cmpltui	r4,zero,1429
 101610c:	0101630c 	andi	r4,zero,1420
 1016110:	01016300 	call	101630 <__reset-0xefe9d0>
 1016114:	010162f4 	movhi	r4,1419
 1016118:	010162e8 	cmpgeui	r4,zero,1419
 101611c:	010162dc 	xori	r4,zero,1419
 1016120:	010162d0 	cmplti	r4,zero,1419
 1016124:	01016570 	cmpltui	r4,zero,1429
 1016128:	010162c4 	movi	r4,1419
 101612c:	010162b8 	rdprs	r4,zero,1418
 1016130:	010162ac 	andhi	r4,zero,1418
 1016134:	010162a0 	cmpeqi	r4,zero,1418
 1016138:	01016294 	movui	r4,1418
 101613c:	01016288 	cmpgei	r4,zero,1418
 1016140:	0101627c 	xorhi	r4,zero,1417
 1016144:	01016270 	cmpltui	r4,zero,1417
 1016148:	01016264 	muli	r4,zero,1417
 101614c:	01016258 	cmpnei	r4,zero,1417
 1016150:	0101624c 	andi	r4,zero,1417
 1016154:	01016240 	call	101624 <__reset-0xefe9dc>
 1016158:	01016234 	movhi	r4,1416
 101615c:	01016570 	cmpltui	r4,zero,1429
 1016160:	01016228 	cmpgeui	r4,zero,1416
 1016164:	0101621c 	xori	r4,zero,1416
 1016168:	01016210 	cmplti	r4,zero,1416
 101616c:	01016204 	movi	r4,1416
 1016170:	01016570 	cmpltui	r4,zero,1429
 1016174:	01016570 	cmpltui	r4,zero,1429
 1016178:	01016570 	cmpltui	r4,zero,1429
 101617c:	01016570 	cmpltui	r4,zero,1429
 1016180:	01016570 	cmpltui	r4,zero,1429
 1016184:	010161f8 	rdprs	r4,zero,1415
 1016188:	01016570 	cmpltui	r4,zero,1429
 101618c:	01016570 	cmpltui	r4,zero,1429
 1016190:	01016570 	cmpltui	r4,zero,1429
 1016194:	010161ec 	andhi	r4,zero,1415
 1016198:	010161e0 	cmpeqi	r4,zero,1415
 101619c:	010161d4 	movui	r4,1415
 10161a0:	010161c8 	cmpgei	r4,zero,1415
 10161a4:	010161bc 	xorhi	r4,zero,1414
 10161a8:	008040f4 	movhi	r2,259
 10161ac:	10a8bc04 	addi	r2,r2,-23824
 10161b0:	dfc00017 	ldw	ra,0(sp)
 10161b4:	dec00104 	addi	sp,sp,4
 10161b8:	f800283a 	ret
 10161bc:	008040f4 	movhi	r2,259
 10161c0:	10aa5904 	addi	r2,r2,-22172
 10161c4:	003ffa06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10161c8:	008040f4 	movhi	r2,259
 10161cc:	10aa5304 	addi	r2,r2,-22196
 10161d0:	003ff706 	br	10161b0 <__alt_data_end+0xff0161b0>
 10161d4:	008040f4 	movhi	r2,259
 10161d8:	10aa4e04 	addi	r2,r2,-22216
 10161dc:	003ff406 	br	10161b0 <__alt_data_end+0xff0161b0>
 10161e0:	008040f4 	movhi	r2,259
 10161e4:	10aa6704 	addi	r2,r2,-22116
 10161e8:	003ff106 	br	10161b0 <__alt_data_end+0xff0161b0>
 10161ec:	008040f4 	movhi	r2,259
 10161f0:	10a9a504 	addi	r2,r2,-22892
 10161f4:	003fee06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10161f8:	008040f4 	movhi	r2,259
 10161fc:	10a97304 	addi	r2,r2,-23092
 1016200:	003feb06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016204:	008040f4 	movhi	r2,259
 1016208:	10aa4104 	addi	r2,r2,-22268
 101620c:	003fe806 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016210:	008040f4 	movhi	r2,259
 1016214:	10aa4704 	addi	r2,r2,-22244
 1016218:	003fe506 	br	10161b0 <__alt_data_end+0xff0161b0>
 101621c:	008040f4 	movhi	r2,259
 1016220:	10a94204 	addi	r2,r2,-23288
 1016224:	003fe206 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016228:	008040f4 	movhi	r2,259
 101622c:	10aa3204 	addi	r2,r2,-22328
 1016230:	003fdf06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016234:	008040f4 	movhi	r2,259
 1016238:	10a9cf04 	addi	r2,r2,-22724
 101623c:	003fdc06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016240:	008040f4 	movhi	r2,259
 1016244:	10aa7104 	addi	r2,r2,-22076
 1016248:	003fd906 	br	10161b0 <__alt_data_end+0xff0161b0>
 101624c:	008040f4 	movhi	r2,259
 1016250:	10a8f404 	addi	r2,r2,-23600
 1016254:	003fd606 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016258:	008040f4 	movhi	r2,259
 101625c:	10a8e604 	addi	r2,r2,-23656
 1016260:	003fd306 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016264:	008040f4 	movhi	r2,259
 1016268:	10a92804 	addi	r2,r2,-23392
 101626c:	003fd006 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016270:	008040f4 	movhi	r2,259
 1016274:	10a96804 	addi	r2,r2,-23136
 1016278:	003fcd06 	br	10161b0 <__alt_data_end+0xff0161b0>
 101627c:	008040f4 	movhi	r2,259
 1016280:	10a92404 	addi	r2,r2,-23408
 1016284:	003fca06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016288:	008040f4 	movhi	r2,259
 101628c:	10aa7604 	addi	r2,r2,-22056
 1016290:	003fc706 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016294:	008040f4 	movhi	r2,259
 1016298:	10a93904 	addi	r2,r2,-23324
 101629c:	003fc406 	br	10161b0 <__alt_data_end+0xff0161b0>
 10162a0:	008040f4 	movhi	r2,259
 10162a4:	10a9ae04 	addi	r2,r2,-22856
 10162a8:	003fc106 	br	10161b0 <__alt_data_end+0xff0161b0>
 10162ac:	008040f4 	movhi	r2,259
 10162b0:	10aa3804 	addi	r2,r2,-22304
 10162b4:	003fbe06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10162b8:	008040f4 	movhi	r2,259
 10162bc:	10aa2c04 	addi	r2,r2,-22352
 10162c0:	003fbb06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10162c4:	008040f4 	movhi	r2,259
 10162c8:	10aa2004 	addi	r2,r2,-22400
 10162cc:	003fb806 	br	10161b0 <__alt_data_end+0xff0161b0>
 10162d0:	008040f4 	movhi	r2,259
 10162d4:	10aa1a04 	addi	r2,r2,-22424
 10162d8:	003fb506 	br	10161b0 <__alt_data_end+0xff0161b0>
 10162dc:	008040f4 	movhi	r2,259
 10162e0:	10aa1204 	addi	r2,r2,-22456
 10162e4:	003fb206 	br	10161b0 <__alt_data_end+0xff0161b0>
 10162e8:	008040f4 	movhi	r2,259
 10162ec:	10aa0a04 	addi	r2,r2,-22488
 10162f0:	003faf06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10162f4:	008040f4 	movhi	r2,259
 10162f8:	10a9fe04 	addi	r2,r2,-22536
 10162fc:	003fac06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016300:	008040f4 	movhi	r2,259
 1016304:	10a9f504 	addi	r2,r2,-22572
 1016308:	003fa906 	br	10161b0 <__alt_data_end+0xff0161b0>
 101630c:	008040f4 	movhi	r2,259
 1016310:	10aa2504 	addi	r2,r2,-22380
 1016314:	003fa606 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016318:	008040f4 	movhi	r2,259
 101631c:	10aa5e04 	addi	r2,r2,-22152
 1016320:	003fa306 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016324:	008040f4 	movhi	r2,259
 1016328:	10a9ef04 	addi	r2,r2,-22596
 101632c:	003fa006 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016330:	008040f4 	movhi	r2,259
 1016334:	10a9e804 	addi	r2,r2,-22624
 1016338:	003f9d06 	br	10161b0 <__alt_data_end+0xff0161b0>
 101633c:	008040f4 	movhi	r2,259
 1016340:	10a9e304 	addi	r2,r2,-22644
 1016344:	003f9a06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016348:	008040f4 	movhi	r2,259
 101634c:	10a9dc04 	addi	r2,r2,-22672
 1016350:	003f9706 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016354:	008040f4 	movhi	r2,259
 1016358:	10a9d904 	addi	r2,r2,-22684
 101635c:	003f9406 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016360:	008040f4 	movhi	r2,259
 1016364:	10a9d404 	addi	r2,r2,-22704
 1016368:	003f9106 	br	10161b0 <__alt_data_end+0xff0161b0>
 101636c:	008040f4 	movhi	r2,259
 1016370:	10a9cb04 	addi	r2,r2,-22740
 1016374:	003f8e06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016378:	008040f4 	movhi	r2,259
 101637c:	10a9c504 	addi	r2,r2,-22764
 1016380:	003f8b06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016384:	008040f4 	movhi	r2,259
 1016388:	10a9c004 	addi	r2,r2,-22784
 101638c:	003f8806 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016390:	008040f4 	movhi	r2,259
 1016394:	10a9ba04 	addi	r2,r2,-22808
 1016398:	003f8506 	br	10161b0 <__alt_data_end+0xff0161b0>
 101639c:	008040f4 	movhi	r2,259
 10163a0:	10a9fc04 	addi	r2,r2,-22544
 10163a4:	003f8206 	br	10161b0 <__alt_data_end+0xff0161b0>
 10163a8:	008040f4 	movhi	r2,259
 10163ac:	10a9b604 	addi	r2,r2,-22824
 10163b0:	003f7f06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10163b4:	008040f4 	movhi	r2,259
 10163b8:	10a9b404 	addi	r2,r2,-22832
 10163bc:	003f7c06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10163c0:	008040f4 	movhi	r2,259
 10163c4:	10a9ab04 	addi	r2,r2,-22868
 10163c8:	003f7906 	br	10161b0 <__alt_data_end+0xff0161b0>
 10163cc:	008040f4 	movhi	r2,259
 10163d0:	10a9a004 	addi	r2,r2,-22912
 10163d4:	003f7606 	br	10161b0 <__alt_data_end+0xff0161b0>
 10163d8:	008040f4 	movhi	r2,259
 10163dc:	10a99904 	addi	r2,r2,-22940
 10163e0:	003f7306 	br	10161b0 <__alt_data_end+0xff0161b0>
 10163e4:	008040f4 	movhi	r2,259
 10163e8:	10a99404 	addi	r2,r2,-22960
 10163ec:	003f7006 	br	10161b0 <__alt_data_end+0xff0161b0>
 10163f0:	008040f4 	movhi	r2,259
 10163f4:	10a98804 	addi	r2,r2,-23008
 10163f8:	003f6d06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10163fc:	008040f4 	movhi	r2,259
 1016400:	10a98504 	addi	r2,r2,-23020
 1016404:	003f6a06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016408:	008040f4 	movhi	r2,259
 101640c:	10a98104 	addi	r2,r2,-23036
 1016410:	003f6706 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016414:	008040f4 	movhi	r2,259
 1016418:	10a97b04 	addi	r2,r2,-23060
 101641c:	003f6406 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016420:	008040f4 	movhi	r2,259
 1016424:	10a97704 	addi	r2,r2,-23076
 1016428:	003f6106 	br	10161b0 <__alt_data_end+0xff0161b0>
 101642c:	008040f4 	movhi	r2,259
 1016430:	10a96d04 	addi	r2,r2,-23116
 1016434:	003f5e06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016438:	008040f4 	movhi	r2,259
 101643c:	10a96404 	addi	r2,r2,-23152
 1016440:	003f5b06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016444:	008040f4 	movhi	r2,259
 1016448:	10a96004 	addi	r2,r2,-23168
 101644c:	003f5806 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016450:	008040f4 	movhi	r2,259
 1016454:	10a95a04 	addi	r2,r2,-23192
 1016458:	003f5506 	br	10161b0 <__alt_data_end+0xff0161b0>
 101645c:	008040f4 	movhi	r2,259
 1016460:	10a95204 	addi	r2,r2,-23224
 1016464:	003f5206 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016468:	008040f4 	movhi	r2,259
 101646c:	10a94a04 	addi	r2,r2,-23256
 1016470:	003f4f06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016474:	008040f4 	movhi	r2,259
 1016478:	10a93404 	addi	r2,r2,-23344
 101647c:	003f4c06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016480:	008040f4 	movhi	r2,259
 1016484:	10a93004 	addi	r2,r2,-23360
 1016488:	003f4906 	br	10161b0 <__alt_data_end+0xff0161b0>
 101648c:	008040f4 	movhi	r2,259
 1016490:	10a92004 	addi	r2,r2,-23424
 1016494:	003f4606 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016498:	008040f4 	movhi	r2,259
 101649c:	10a91c04 	addi	r2,r2,-23440
 10164a0:	003f4306 	br	10161b0 <__alt_data_end+0xff0161b0>
 10164a4:	008040f4 	movhi	r2,259
 10164a8:	10a91704 	addi	r2,r2,-23460
 10164ac:	003f4006 	br	10161b0 <__alt_data_end+0xff0161b0>
 10164b0:	008040f4 	movhi	r2,259
 10164b4:	10a91404 	addi	r2,r2,-23472
 10164b8:	003f3d06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10164bc:	008040f4 	movhi	r2,259
 10164c0:	10a90e04 	addi	r2,r2,-23496
 10164c4:	003f3a06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10164c8:	008040f4 	movhi	r2,259
 10164cc:	10a90b04 	addi	r2,r2,-23508
 10164d0:	003f3706 	br	10161b0 <__alt_data_end+0xff0161b0>
 10164d4:	008040f4 	movhi	r2,259
 10164d8:	10a90604 	addi	r2,r2,-23528
 10164dc:	003f3406 	br	10161b0 <__alt_data_end+0xff0161b0>
 10164e0:	008040f4 	movhi	r2,259
 10164e4:	10a90104 	addi	r2,r2,-23548
 10164e8:	003f3106 	br	10161b0 <__alt_data_end+0xff0161b0>
 10164ec:	008040f4 	movhi	r2,259
 10164f0:	10a8fc04 	addi	r2,r2,-23568
 10164f4:	003f2e06 	br	10161b0 <__alt_data_end+0xff0161b0>
 10164f8:	008040f4 	movhi	r2,259
 10164fc:	10a8f104 	addi	r2,r2,-23612
 1016500:	003f2b06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016504:	008040f4 	movhi	r2,259
 1016508:	10a8ed04 	addi	r2,r2,-23628
 101650c:	003f2806 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016510:	008040f4 	movhi	r2,259
 1016514:	10a8e104 	addi	r2,r2,-23676
 1016518:	003f2506 	br	10161b0 <__alt_data_end+0xff0161b0>
 101651c:	008040f4 	movhi	r2,259
 1016520:	10a8dc04 	addi	r2,r2,-23696
 1016524:	003f2206 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016528:	008040f4 	movhi	r2,259
 101652c:	10a8d504 	addi	r2,r2,-23724
 1016530:	003f1f06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016534:	008040f4 	movhi	r2,259
 1016538:	10a8d204 	addi	r2,r2,-23736
 101653c:	003f1c06 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016540:	008040f4 	movhi	r2,259
 1016544:	10a8cc04 	addi	r2,r2,-23760
 1016548:	003f1906 	br	10161b0 <__alt_data_end+0xff0161b0>
 101654c:	008040f4 	movhi	r2,259
 1016550:	10a8c804 	addi	r2,r2,-23776
 1016554:	003f1606 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016558:	008040f4 	movhi	r2,259
 101655c:	10a8c104 	addi	r2,r2,-23804
 1016560:	003f1306 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016564:	008040f4 	movhi	r2,259
 1016568:	10a8be04 	addi	r2,r2,-23816
 101656c:	003f1006 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016570:	38000726 	beq	r7,zero,1016590 <_strerror_r+0x654>
 1016574:	380d883a 	mov	r6,r7
 1016578:	1809883a 	mov	r4,r3
 101657c:	10189e00 	call	10189e0 <_user_strerror>
 1016580:	103f0b1e 	bne	r2,zero,10161b0 <__alt_data_end+0xff0161b0>
 1016584:	008040f4 	movhi	r2,259
 1016588:	10a8ad04 	addi	r2,r2,-23884
 101658c:	003f0806 	br	10161b0 <__alt_data_end+0xff0161b0>
 1016590:	200f883a 	mov	r7,r4
 1016594:	003ff706 	br	1016574 <__alt_data_end+0xff016574>

01016598 <strerror>:
 1016598:	008040f4 	movhi	r2,259
 101659c:	10b25d04 	addi	r2,r2,-13964
 10165a0:	200b883a 	mov	r5,r4
 10165a4:	11000017 	ldw	r4,0(r2)
 10165a8:	000f883a 	mov	r7,zero
 10165ac:	000d883a 	mov	r6,zero
 10165b0:	1015f3c1 	jmpi	1015f3c <_strerror_r>

010165b4 <strlen>:
 10165b4:	208000cc 	andi	r2,r4,3
 10165b8:	10002026 	beq	r2,zero,101663c <strlen+0x88>
 10165bc:	20800007 	ldb	r2,0(r4)
 10165c0:	10002026 	beq	r2,zero,1016644 <strlen+0x90>
 10165c4:	2005883a 	mov	r2,r4
 10165c8:	00000206 	br	10165d4 <strlen+0x20>
 10165cc:	10c00007 	ldb	r3,0(r2)
 10165d0:	18001826 	beq	r3,zero,1016634 <strlen+0x80>
 10165d4:	10800044 	addi	r2,r2,1
 10165d8:	10c000cc 	andi	r3,r2,3
 10165dc:	183ffb1e 	bne	r3,zero,10165cc <__alt_data_end+0xff0165cc>
 10165e0:	10c00017 	ldw	r3,0(r2)
 10165e4:	01ffbff4 	movhi	r7,65279
 10165e8:	39ffbfc4 	addi	r7,r7,-257
 10165ec:	00ca303a 	nor	r5,zero,r3
 10165f0:	01a02074 	movhi	r6,32897
 10165f4:	19c7883a 	add	r3,r3,r7
 10165f8:	31a02004 	addi	r6,r6,-32640
 10165fc:	1946703a 	and	r3,r3,r5
 1016600:	1986703a 	and	r3,r3,r6
 1016604:	1800091e 	bne	r3,zero,101662c <strlen+0x78>
 1016608:	10800104 	addi	r2,r2,4
 101660c:	10c00017 	ldw	r3,0(r2)
 1016610:	19cb883a 	add	r5,r3,r7
 1016614:	00c6303a 	nor	r3,zero,r3
 1016618:	28c6703a 	and	r3,r5,r3
 101661c:	1986703a 	and	r3,r3,r6
 1016620:	183ff926 	beq	r3,zero,1016608 <__alt_data_end+0xff016608>
 1016624:	00000106 	br	101662c <strlen+0x78>
 1016628:	10800044 	addi	r2,r2,1
 101662c:	10c00007 	ldb	r3,0(r2)
 1016630:	183ffd1e 	bne	r3,zero,1016628 <__alt_data_end+0xff016628>
 1016634:	1105c83a 	sub	r2,r2,r4
 1016638:	f800283a 	ret
 101663c:	2005883a 	mov	r2,r4
 1016640:	003fe706 	br	10165e0 <__alt_data_end+0xff0165e0>
 1016644:	0005883a 	mov	r2,zero
 1016648:	f800283a 	ret

0101664c <strncmp>:
 101664c:	30003126 	beq	r6,zero,1016714 <strncmp+0xc8>
 1016650:	2144b03a 	or	r2,r4,r5
 1016654:	108000cc 	andi	r2,r2,3
 1016658:	10001e1e 	bne	r2,zero,10166d4 <strncmp+0x88>
 101665c:	024000c4 	movi	r9,3
 1016660:	49801c2e 	bgeu	r9,r6,10166d4 <strncmp+0x88>
 1016664:	20800017 	ldw	r2,0(r4)
 1016668:	28c00017 	ldw	r3,0(r5)
 101666c:	10c0191e 	bne	r2,r3,10166d4 <strncmp+0x88>
 1016670:	31bfff04 	addi	r6,r6,-4
 1016674:	30002726 	beq	r6,zero,1016714 <strncmp+0xc8>
 1016678:	02ffbff4 	movhi	r11,65279
 101667c:	5affbfc4 	addi	r11,r11,-257
 1016680:	0086303a 	nor	r3,zero,r2
 1016684:	02a02074 	movhi	r10,32897
 1016688:	12c5883a 	add	r2,r2,r11
 101668c:	52a02004 	addi	r10,r10,-32640
 1016690:	10c4703a 	and	r2,r2,r3
 1016694:	1284703a 	and	r2,r2,r10
 1016698:	10000b26 	beq	r2,zero,10166c8 <strncmp+0x7c>
 101669c:	00001d06 	br	1016714 <strncmp+0xc8>
 10166a0:	20c00017 	ldw	r3,0(r4)
 10166a4:	29c00017 	ldw	r7,0(r5)
 10166a8:	1ad1883a 	add	r8,r3,r11
 10166ac:	00c4303a 	nor	r2,zero,r3
 10166b0:	4084703a 	and	r2,r8,r2
 10166b4:	1284703a 	and	r2,r2,r10
 10166b8:	19c0061e 	bne	r3,r7,10166d4 <strncmp+0x88>
 10166bc:	31bfff04 	addi	r6,r6,-4
 10166c0:	30001426 	beq	r6,zero,1016714 <strncmp+0xc8>
 10166c4:	1000131e 	bne	r2,zero,1016714 <strncmp+0xc8>
 10166c8:	21000104 	addi	r4,r4,4
 10166cc:	29400104 	addi	r5,r5,4
 10166d0:	49bff336 	bltu	r9,r6,10166a0 <__alt_data_end+0xff0166a0>
 10166d4:	28800007 	ldb	r2,0(r5)
 10166d8:	20c00007 	ldb	r3,0(r4)
 10166dc:	31bfffc4 	addi	r6,r6,-1
 10166e0:	10c0081e 	bne	r2,r3,1016704 <strncmp+0xb8>
 10166e4:	30000b26 	beq	r6,zero,1016714 <strncmp+0xc8>
 10166e8:	10000a26 	beq	r2,zero,1016714 <strncmp+0xc8>
 10166ec:	21000044 	addi	r4,r4,1
 10166f0:	29400044 	addi	r5,r5,1
 10166f4:	20800007 	ldb	r2,0(r4)
 10166f8:	28c00007 	ldb	r3,0(r5)
 10166fc:	31bfffc4 	addi	r6,r6,-1
 1016700:	10fff826 	beq	r2,r3,10166e4 <__alt_data_end+0xff0166e4>
 1016704:	20800003 	ldbu	r2,0(r4)
 1016708:	28c00003 	ldbu	r3,0(r5)
 101670c:	10c5c83a 	sub	r2,r2,r3
 1016710:	f800283a 	ret
 1016714:	0005883a 	mov	r2,zero
 1016718:	f800283a 	ret

0101671c <strncpy>:
 101671c:	2906b03a 	or	r3,r5,r4
 1016720:	18c000cc 	andi	r3,r3,3
 1016724:	2005883a 	mov	r2,r4
 1016728:	18002c1e 	bne	r3,zero,10167dc <strncpy+0xc0>
 101672c:	010000c4 	movi	r4,3
 1016730:	21802a2e 	bgeu	r4,r6,10167dc <strncpy+0xc0>
 1016734:	033fbff4 	movhi	r12,65279
 1016738:	02e02074 	movhi	r11,32897
 101673c:	633fbfc4 	addi	r12,r12,-257
 1016740:	5ae02004 	addi	r11,r11,-32640
 1016744:	100f883a 	mov	r7,r2
 1016748:	2a000017 	ldw	r8,0(r5)
 101674c:	3815883a 	mov	r10,r7
 1016750:	4313883a 	add	r9,r8,r12
 1016754:	0206303a 	nor	r3,zero,r8
 1016758:	48c6703a 	and	r3,r9,r3
 101675c:	1ac6703a 	and	r3,r3,r11
 1016760:	1800261e 	bne	r3,zero,10167fc <strncpy+0xe0>
 1016764:	39c00104 	addi	r7,r7,4
 1016768:	52000015 	stw	r8,0(r10)
 101676c:	31bfff04 	addi	r6,r6,-4
 1016770:	3811883a 	mov	r8,r7
 1016774:	29400104 	addi	r5,r5,4
 1016778:	21bff336 	bltu	r4,r6,1016748 <__alt_data_end+0xff016748>
 101677c:	30001e26 	beq	r6,zero,10167f8 <strncpy+0xdc>
 1016780:	29c00003 	ldbu	r7,0(r5)
 1016784:	31bfffc4 	addi	r6,r6,-1
 1016788:	40c00044 	addi	r3,r8,1
 101678c:	41c00005 	stb	r7,0(r8)
 1016790:	39c03fcc 	andi	r7,r7,255
 1016794:	39c0201c 	xori	r7,r7,128
 1016798:	39ffe004 	addi	r7,r7,-128
 101679c:	29400044 	addi	r5,r5,1
 10167a0:	38001026 	beq	r7,zero,10167e4 <strncpy+0xc8>
 10167a4:	1811883a 	mov	r8,r3
 10167a8:	00000906 	br	10167d0 <strncpy+0xb4>
 10167ac:	29c00003 	ldbu	r7,0(r5)
 10167b0:	31bfffc4 	addi	r6,r6,-1
 10167b4:	29400044 	addi	r5,r5,1
 10167b8:	41c00005 	stb	r7,0(r8)
 10167bc:	39c03fcc 	andi	r7,r7,255
 10167c0:	39c0201c 	xori	r7,r7,128
 10167c4:	39ffe004 	addi	r7,r7,-128
 10167c8:	1811883a 	mov	r8,r3
 10167cc:	38000526 	beq	r7,zero,10167e4 <strncpy+0xc8>
 10167d0:	18c00044 	addi	r3,r3,1
 10167d4:	303ff51e 	bne	r6,zero,10167ac <__alt_data_end+0xff0167ac>
 10167d8:	f800283a 	ret
 10167dc:	1011883a 	mov	r8,r2
 10167e0:	003fe606 	br	101677c <__alt_data_end+0xff01677c>
 10167e4:	30000726 	beq	r6,zero,1016804 <strncpy+0xe8>
 10167e8:	198d883a 	add	r6,r3,r6
 10167ec:	18000005 	stb	zero,0(r3)
 10167f0:	18c00044 	addi	r3,r3,1
 10167f4:	19bffd1e 	bne	r3,r6,10167ec <__alt_data_end+0xff0167ec>
 10167f8:	f800283a 	ret
 10167fc:	3811883a 	mov	r8,r7
 1016800:	003fdf06 	br	1016780 <__alt_data_end+0xff016780>
 1016804:	f800283a 	ret

01016808 <___svfprintf_internal_r>:
 1016808:	deffb704 	addi	sp,sp,-292
 101680c:	dfc04815 	stw	ra,288(sp)
 1016810:	ddc04615 	stw	r23,280(sp)
 1016814:	d9402c15 	stw	r5,176(sp)
 1016818:	d9003915 	stw	r4,228(sp)
 101681c:	302f883a 	mov	r23,r6
 1016820:	d9c02d15 	stw	r7,180(sp)
 1016824:	df004715 	stw	fp,284(sp)
 1016828:	dd804515 	stw	r22,276(sp)
 101682c:	dd404415 	stw	r21,272(sp)
 1016830:	dd004315 	stw	r20,268(sp)
 1016834:	dcc04215 	stw	r19,264(sp)
 1016838:	dc804115 	stw	r18,260(sp)
 101683c:	dc404015 	stw	r17,256(sp)
 1016840:	dc003f15 	stw	r16,252(sp)
 1016844:	101d8300 	call	101d830 <_localeconv_r>
 1016848:	10800017 	ldw	r2,0(r2)
 101684c:	1009883a 	mov	r4,r2
 1016850:	d8803415 	stw	r2,208(sp)
 1016854:	10165b40 	call	10165b4 <strlen>
 1016858:	d8c02c17 	ldw	r3,176(sp)
 101685c:	d8803815 	stw	r2,224(sp)
 1016860:	1880030b 	ldhu	r2,12(r3)
 1016864:	1080200c 	andi	r2,r2,128
 1016868:	10000226 	beq	r2,zero,1016874 <___svfprintf_internal_r+0x6c>
 101686c:	18800417 	ldw	r2,16(r3)
 1016870:	10067f26 	beq	r2,zero,1018270 <___svfprintf_internal_r+0x1a68>
 1016874:	dcc03917 	ldw	r19,228(sp)
 1016878:	d8c00404 	addi	r3,sp,16
 101687c:	054040f4 	movhi	r21,259
 1016880:	d9001e04 	addi	r4,sp,120
 1016884:	ad6a8c84 	addi	r21,r21,-21966
 1016888:	d8c01e15 	stw	r3,120(sp)
 101688c:	d8002015 	stw	zero,128(sp)
 1016890:	d8001f15 	stw	zero,124(sp)
 1016894:	d8003315 	stw	zero,204(sp)
 1016898:	d8003615 	stw	zero,216(sp)
 101689c:	d8003715 	stw	zero,220(sp)
 10168a0:	1811883a 	mov	r8,r3
 10168a4:	d8003a15 	stw	zero,232(sp)
 10168a8:	d8003b15 	stw	zero,236(sp)
 10168ac:	d8002f15 	stw	zero,188(sp)
 10168b0:	d9002815 	stw	r4,160(sp)
 10168b4:	b8800007 	ldb	r2,0(r23)
 10168b8:	10026726 	beq	r2,zero,1017258 <___svfprintf_internal_r+0xa50>
 10168bc:	00c00944 	movi	r3,37
 10168c0:	b821883a 	mov	r16,r23
 10168c4:	10c0021e 	bne	r2,r3,10168d0 <___svfprintf_internal_r+0xc8>
 10168c8:	00001406 	br	101691c <___svfprintf_internal_r+0x114>
 10168cc:	10c00326 	beq	r2,r3,10168dc <___svfprintf_internal_r+0xd4>
 10168d0:	84000044 	addi	r16,r16,1
 10168d4:	80800007 	ldb	r2,0(r16)
 10168d8:	103ffc1e 	bne	r2,zero,10168cc <__alt_data_end+0xff0168cc>
 10168dc:	85e3c83a 	sub	r17,r16,r23
 10168e0:	88000e26 	beq	r17,zero,101691c <___svfprintf_internal_r+0x114>
 10168e4:	d8c02017 	ldw	r3,128(sp)
 10168e8:	d8801f17 	ldw	r2,124(sp)
 10168ec:	45c00015 	stw	r23,0(r8)
 10168f0:	1c47883a 	add	r3,r3,r17
 10168f4:	10800044 	addi	r2,r2,1
 10168f8:	d8c02015 	stw	r3,128(sp)
 10168fc:	44400115 	stw	r17,4(r8)
 1016900:	d8801f15 	stw	r2,124(sp)
 1016904:	00c001c4 	movi	r3,7
 1016908:	18809716 	blt	r3,r2,1016b68 <___svfprintf_internal_r+0x360>
 101690c:	42000204 	addi	r8,r8,8
 1016910:	d9402f17 	ldw	r5,188(sp)
 1016914:	2c4b883a 	add	r5,r5,r17
 1016918:	d9402f15 	stw	r5,188(sp)
 101691c:	80800007 	ldb	r2,0(r16)
 1016920:	10009826 	beq	r2,zero,1016b84 <___svfprintf_internal_r+0x37c>
 1016924:	84400047 	ldb	r17,1(r16)
 1016928:	00bfffc4 	movi	r2,-1
 101692c:	85c00044 	addi	r23,r16,1
 1016930:	d8002785 	stb	zero,158(sp)
 1016934:	0007883a 	mov	r3,zero
 1016938:	000f883a 	mov	r7,zero
 101693c:	d8802915 	stw	r2,164(sp)
 1016940:	d8003115 	stw	zero,196(sp)
 1016944:	0025883a 	mov	r18,zero
 1016948:	01401604 	movi	r5,88
 101694c:	01800244 	movi	r6,9
 1016950:	02800a84 	movi	r10,42
 1016954:	02401b04 	movi	r9,108
 1016958:	bdc00044 	addi	r23,r23,1
 101695c:	88bff804 	addi	r2,r17,-32
 1016960:	2882f036 	bltu	r5,r2,1017524 <___svfprintf_internal_r+0xd1c>
 1016964:	100490ba 	slli	r2,r2,2
 1016968:	01004074 	movhi	r4,257
 101696c:	211a5f04 	addi	r4,r4,27004
 1016970:	1105883a 	add	r2,r2,r4
 1016974:	10800017 	ldw	r2,0(r2)
 1016978:	1000683a 	jmp	r2
 101697c:	0101748c 	andi	r4,zero,1490
 1016980:	01017524 	muli	r4,zero,1492
 1016984:	01017524 	muli	r4,zero,1492
 1016988:	01017480 	call	101748 <__reset-0xefe8b8>
 101698c:	01017524 	muli	r4,zero,1492
 1016990:	01017524 	muli	r4,zero,1492
 1016994:	01017524 	muli	r4,zero,1492
 1016998:	01017524 	muli	r4,zero,1492
 101699c:	01017524 	muli	r4,zero,1492
 10169a0:	01017524 	muli	r4,zero,1492
 10169a4:	01016be0 	cmpeqi	r4,zero,1455
 10169a8:	010173bc 	xorhi	r4,zero,1486
 10169ac:	01017524 	muli	r4,zero,1492
 10169b0:	01016af0 	cmpltui	r4,zero,1451
 10169b4:	01016c08 	cmpgei	r4,zero,1456
 10169b8:	01017524 	muli	r4,zero,1492
 10169bc:	01016c7c 	xorhi	r4,zero,1457
 10169c0:	01016c48 	cmpgei	r4,zero,1457
 10169c4:	01016c48 	cmpgei	r4,zero,1457
 10169c8:	01016c48 	cmpgei	r4,zero,1457
 10169cc:	01016c48 	cmpgei	r4,zero,1457
 10169d0:	01016c48 	cmpgei	r4,zero,1457
 10169d4:	01016c48 	cmpgei	r4,zero,1457
 10169d8:	01016c48 	cmpgei	r4,zero,1457
 10169dc:	01016c48 	cmpgei	r4,zero,1457
 10169e0:	01016c48 	cmpgei	r4,zero,1457
 10169e4:	01017524 	muli	r4,zero,1492
 10169e8:	01017524 	muli	r4,zero,1492
 10169ec:	01017524 	muli	r4,zero,1492
 10169f0:	01017524 	muli	r4,zero,1492
 10169f4:	01017524 	muli	r4,zero,1492
 10169f8:	01017524 	muli	r4,zero,1492
 10169fc:	01017524 	muli	r4,zero,1492
 1016a00:	01017524 	muli	r4,zero,1492
 1016a04:	01017524 	muli	r4,zero,1492
 1016a08:	01017524 	muli	r4,zero,1492
 1016a0c:	01016d34 	movhi	r4,1460
 1016a10:	01016c88 	cmpgei	r4,zero,1458
 1016a14:	01017524 	muli	r4,zero,1492
 1016a18:	01016c88 	cmpgei	r4,zero,1458
 1016a1c:	01017524 	muli	r4,zero,1492
 1016a20:	01017524 	muli	r4,zero,1492
 1016a24:	01017524 	muli	r4,zero,1492
 1016a28:	01017524 	muli	r4,zero,1492
 1016a2c:	01016d28 	cmpgeui	r4,zero,1460
 1016a30:	01017524 	muli	r4,zero,1492
 1016a34:	01017524 	muli	r4,zero,1492
 1016a38:	01016df0 	cmpltui	r4,zero,1463
 1016a3c:	01017524 	muli	r4,zero,1492
 1016a40:	01017524 	muli	r4,zero,1492
 1016a44:	01017524 	muli	r4,zero,1492
 1016a48:	01017524 	muli	r4,zero,1492
 1016a4c:	01017524 	muli	r4,zero,1492
 1016a50:	01017260 	cmpeqi	r4,zero,1481
 1016a54:	01017524 	muli	r4,zero,1492
 1016a58:	01017524 	muli	r4,zero,1492
 1016a5c:	010172c0 	call	10172c <__reset-0xefe8d4>
 1016a60:	01017524 	muli	r4,zero,1492
 1016a64:	01017524 	muli	r4,zero,1492
 1016a68:	01017524 	muli	r4,zero,1492
 1016a6c:	01017524 	muli	r4,zero,1492
 1016a70:	01017524 	muli	r4,zero,1492
 1016a74:	01017524 	muli	r4,zero,1492
 1016a78:	01017524 	muli	r4,zero,1492
 1016a7c:	01017524 	muli	r4,zero,1492
 1016a80:	01017524 	muli	r4,zero,1492
 1016a84:	01017524 	muli	r4,zero,1492
 1016a88:	01017370 	cmpltui	r4,zero,1485
 1016a8c:	010174ac 	andhi	r4,zero,1490
 1016a90:	01016c88 	cmpgei	r4,zero,1458
 1016a94:	01016c88 	cmpgei	r4,zero,1458
 1016a98:	01016c88 	cmpgei	r4,zero,1458
 1016a9c:	01017500 	call	101750 <__reset-0xefe8b0>
 1016aa0:	010174ac 	andhi	r4,zero,1490
 1016aa4:	01017524 	muli	r4,zero,1492
 1016aa8:	01017524 	muli	r4,zero,1492
 1016aac:	010174bc 	xorhi	r4,zero,1490
 1016ab0:	01017524 	muli	r4,zero,1492
 1016ab4:	010174cc 	andi	r4,zero,1491
 1016ab8:	010173ac 	andhi	r4,zero,1486
 1016abc:	01016afc 	xorhi	r4,zero,1451
 1016ac0:	010173cc 	andi	r4,zero,1487
 1016ac4:	01017524 	muli	r4,zero,1492
 1016ac8:	010173d8 	cmpnei	r4,zero,1487
 1016acc:	01017524 	muli	r4,zero,1492
 1016ad0:	01017434 	movhi	r4,1488
 1016ad4:	01017524 	muli	r4,zero,1492
 1016ad8:	01017524 	muli	r4,zero,1492
 1016adc:	01017444 	movi	r4,1489
 1016ae0:	d9003117 	ldw	r4,196(sp)
 1016ae4:	d8802d15 	stw	r2,180(sp)
 1016ae8:	0109c83a 	sub	r4,zero,r4
 1016aec:	d9003115 	stw	r4,196(sp)
 1016af0:	94800114 	ori	r18,r18,4
 1016af4:	bc400007 	ldb	r17,0(r23)
 1016af8:	003f9706 	br	1016958 <__alt_data_end+0xff016958>
 1016afc:	00800c04 	movi	r2,48
 1016b00:	d9002d17 	ldw	r4,180(sp)
 1016b04:	d9402917 	ldw	r5,164(sp)
 1016b08:	d8802705 	stb	r2,156(sp)
 1016b0c:	00801e04 	movi	r2,120
 1016b10:	d8802745 	stb	r2,157(sp)
 1016b14:	d8002785 	stb	zero,158(sp)
 1016b18:	20c00104 	addi	r3,r4,4
 1016b1c:	25000017 	ldw	r20,0(r4)
 1016b20:	002d883a 	mov	r22,zero
 1016b24:	90800094 	ori	r2,r18,2
 1016b28:	28028616 	blt	r5,zero,1017544 <___svfprintf_internal_r+0xd3c>
 1016b2c:	00bfdfc4 	movi	r2,-129
 1016b30:	90a4703a 	and	r18,r18,r2
 1016b34:	d8c02d15 	stw	r3,180(sp)
 1016b38:	94800094 	ori	r18,r18,2
 1016b3c:	a002731e 	bne	r20,zero,101750c <___svfprintf_internal_r+0xd04>
 1016b40:	008040f4 	movhi	r2,259
 1016b44:	10aa8504 	addi	r2,r2,-21996
 1016b48:	d8803a15 	stw	r2,232(sp)
 1016b4c:	04401e04 	movi	r17,120
 1016b50:	d8c02917 	ldw	r3,164(sp)
 1016b54:	0039883a 	mov	fp,zero
 1016b58:	1801d526 	beq	r3,zero,10172b0 <___svfprintf_internal_r+0xaa8>
 1016b5c:	0029883a 	mov	r20,zero
 1016b60:	002d883a 	mov	r22,zero
 1016b64:	0001f106 	br	101732c <___svfprintf_internal_r+0xb24>
 1016b68:	d9402c17 	ldw	r5,176(sp)
 1016b6c:	d9801e04 	addi	r6,sp,120
 1016b70:	9809883a 	mov	r4,r19
 1016b74:	101fed00 	call	101fed0 <__ssprint_r>
 1016b78:	1000081e 	bne	r2,zero,1016b9c <___svfprintf_internal_r+0x394>
 1016b7c:	da000404 	addi	r8,sp,16
 1016b80:	003f6306 	br	1016910 <__alt_data_end+0xff016910>
 1016b84:	d8802017 	ldw	r2,128(sp)
 1016b88:	10000426 	beq	r2,zero,1016b9c <___svfprintf_internal_r+0x394>
 1016b8c:	d9402c17 	ldw	r5,176(sp)
 1016b90:	d9003917 	ldw	r4,228(sp)
 1016b94:	d9801e04 	addi	r6,sp,120
 1016b98:	101fed00 	call	101fed0 <__ssprint_r>
 1016b9c:	d8802c17 	ldw	r2,176(sp)
 1016ba0:	10c0030b 	ldhu	r3,12(r2)
 1016ba4:	d8802f17 	ldw	r2,188(sp)
 1016ba8:	18c0100c 	andi	r3,r3,64
 1016bac:	1805f51e 	bne	r3,zero,1018384 <___svfprintf_internal_r+0x1b7c>
 1016bb0:	dfc04817 	ldw	ra,288(sp)
 1016bb4:	df004717 	ldw	fp,284(sp)
 1016bb8:	ddc04617 	ldw	r23,280(sp)
 1016bbc:	dd804517 	ldw	r22,276(sp)
 1016bc0:	dd404417 	ldw	r21,272(sp)
 1016bc4:	dd004317 	ldw	r20,268(sp)
 1016bc8:	dcc04217 	ldw	r19,264(sp)
 1016bcc:	dc804117 	ldw	r18,260(sp)
 1016bd0:	dc404017 	ldw	r17,256(sp)
 1016bd4:	dc003f17 	ldw	r16,252(sp)
 1016bd8:	dec04904 	addi	sp,sp,292
 1016bdc:	f800283a 	ret
 1016be0:	d8802d17 	ldw	r2,180(sp)
 1016be4:	d9002d17 	ldw	r4,180(sp)
 1016be8:	10800017 	ldw	r2,0(r2)
 1016bec:	d8803115 	stw	r2,196(sp)
 1016bf0:	20800104 	addi	r2,r4,4
 1016bf4:	d9003117 	ldw	r4,196(sp)
 1016bf8:	203fb916 	blt	r4,zero,1016ae0 <__alt_data_end+0xff016ae0>
 1016bfc:	d8802d15 	stw	r2,180(sp)
 1016c00:	bc400007 	ldb	r17,0(r23)
 1016c04:	003f5406 	br	1016958 <__alt_data_end+0xff016958>
 1016c08:	bc400007 	ldb	r17,0(r23)
 1016c0c:	bac00044 	addi	r11,r23,1
 1016c10:	8a873926 	beq	r17,r10,10188f8 <___svfprintf_internal_r+0x20f0>
 1016c14:	88bff404 	addi	r2,r17,-48
 1016c18:	0009883a 	mov	r4,zero
 1016c1c:	30868836 	bltu	r6,r2,1018640 <___svfprintf_internal_r+0x1e38>
 1016c20:	5c400007 	ldb	r17,0(r11)
 1016c24:	210002a4 	muli	r4,r4,10
 1016c28:	5dc00044 	addi	r23,r11,1
 1016c2c:	b817883a 	mov	r11,r23
 1016c30:	2089883a 	add	r4,r4,r2
 1016c34:	88bff404 	addi	r2,r17,-48
 1016c38:	30bff92e 	bgeu	r6,r2,1016c20 <__alt_data_end+0xff016c20>
 1016c3c:	2005d716 	blt	r4,zero,101839c <___svfprintf_internal_r+0x1b94>
 1016c40:	d9002915 	stw	r4,164(sp)
 1016c44:	003f4506 	br	101695c <__alt_data_end+0xff01695c>
 1016c48:	b809883a 	mov	r4,r23
 1016c4c:	d8003115 	stw	zero,196(sp)
 1016c50:	88bff404 	addi	r2,r17,-48
 1016c54:	0017883a 	mov	r11,zero
 1016c58:	24400007 	ldb	r17,0(r4)
 1016c5c:	5ac002a4 	muli	r11,r11,10
 1016c60:	bdc00044 	addi	r23,r23,1
 1016c64:	b809883a 	mov	r4,r23
 1016c68:	12d7883a 	add	r11,r2,r11
 1016c6c:	88bff404 	addi	r2,r17,-48
 1016c70:	30bff92e 	bgeu	r6,r2,1016c58 <__alt_data_end+0xff016c58>
 1016c74:	dac03115 	stw	r11,196(sp)
 1016c78:	003f3806 	br	101695c <__alt_data_end+0xff01695c>
 1016c7c:	94802014 	ori	r18,r18,128
 1016c80:	bc400007 	ldb	r17,0(r23)
 1016c84:	003f3406 	br	1016958 <__alt_data_end+0xff016958>
 1016c88:	18c03fcc 	andi	r3,r3,255
 1016c8c:	1807471e 	bne	r3,zero,10189ac <___svfprintf_internal_r+0x21a4>
 1016c90:	9080020c 	andi	r2,r18,8
 1016c94:	10047d26 	beq	r2,zero,1017e8c <___svfprintf_internal_r+0x1684>
 1016c98:	d8c02d17 	ldw	r3,180(sp)
 1016c9c:	d9002d17 	ldw	r4,180(sp)
 1016ca0:	d9402d17 	ldw	r5,180(sp)
 1016ca4:	18c00017 	ldw	r3,0(r3)
 1016ca8:	21000117 	ldw	r4,4(r4)
 1016cac:	29400204 	addi	r5,r5,8
 1016cb0:	d8c03615 	stw	r3,216(sp)
 1016cb4:	d9003715 	stw	r4,220(sp)
 1016cb8:	d9402d15 	stw	r5,180(sp)
 1016cbc:	d9003617 	ldw	r4,216(sp)
 1016cc0:	d9403717 	ldw	r5,220(sp)
 1016cc4:	da003e15 	stw	r8,248(sp)
 1016cc8:	04000044 	movi	r16,1
 1016ccc:	101f9c80 	call	101f9c8 <__fpclassifyd>
 1016cd0:	da003e17 	ldw	r8,248(sp)
 1016cd4:	14044b1e 	bne	r2,r16,1017e04 <___svfprintf_internal_r+0x15fc>
 1016cd8:	d9003617 	ldw	r4,216(sp)
 1016cdc:	d9403717 	ldw	r5,220(sp)
 1016ce0:	000d883a 	mov	r6,zero
 1016ce4:	000f883a 	mov	r7,zero
 1016ce8:	10251b40 	call	10251b4 <__ledf2>
 1016cec:	da003e17 	ldw	r8,248(sp)
 1016cf0:	1005f316 	blt	r2,zero,10184c0 <___svfprintf_internal_r+0x1cb8>
 1016cf4:	df002783 	ldbu	fp,158(sp)
 1016cf8:	008011c4 	movi	r2,71
 1016cfc:	1445590e 	bge	r2,r17,1018264 <___svfprintf_internal_r+0x1a5c>
 1016d00:	040040f4 	movhi	r16,259
 1016d04:	842a7d04 	addi	r16,r16,-22028
 1016d08:	00c000c4 	movi	r3,3
 1016d0c:	00bfdfc4 	movi	r2,-129
 1016d10:	d8c02a15 	stw	r3,168(sp)
 1016d14:	90a4703a 	and	r18,r18,r2
 1016d18:	d8c02e15 	stw	r3,184(sp)
 1016d1c:	d8002915 	stw	zero,164(sp)
 1016d20:	d8003215 	stw	zero,200(sp)
 1016d24:	00006606 	br	1016ec0 <___svfprintf_internal_r+0x6b8>
 1016d28:	94800214 	ori	r18,r18,8
 1016d2c:	bc400007 	ldb	r17,0(r23)
 1016d30:	003f0906 	br	1016958 <__alt_data_end+0xff016958>
 1016d34:	18c03fcc 	andi	r3,r3,255
 1016d38:	1807181e 	bne	r3,zero,101899c <___svfprintf_internal_r+0x2194>
 1016d3c:	94800414 	ori	r18,r18,16
 1016d40:	9080080c 	andi	r2,r18,32
 1016d44:	10039626 	beq	r2,zero,1017ba0 <___svfprintf_internal_r+0x1398>
 1016d48:	d9402d17 	ldw	r5,180(sp)
 1016d4c:	28800117 	ldw	r2,4(r5)
 1016d50:	2d000017 	ldw	r20,0(r5)
 1016d54:	29400204 	addi	r5,r5,8
 1016d58:	d9402d15 	stw	r5,180(sp)
 1016d5c:	102d883a 	mov	r22,r2
 1016d60:	10039816 	blt	r2,zero,1017bc4 <___svfprintf_internal_r+0x13bc>
 1016d64:	d9402917 	ldw	r5,164(sp)
 1016d68:	df002783 	ldbu	fp,158(sp)
 1016d6c:	2803ab16 	blt	r5,zero,1017c1c <___svfprintf_internal_r+0x1414>
 1016d70:	00ffdfc4 	movi	r3,-129
 1016d74:	a584b03a 	or	r2,r20,r22
 1016d78:	90e4703a 	and	r18,r18,r3
 1016d7c:	10014a26 	beq	r2,zero,10172a8 <___svfprintf_internal_r+0xaa0>
 1016d80:	b0034b26 	beq	r22,zero,1017ab0 <___svfprintf_internal_r+0x12a8>
 1016d84:	dc402a15 	stw	r17,168(sp)
 1016d88:	dc001e04 	addi	r16,sp,120
 1016d8c:	b023883a 	mov	r17,r22
 1016d90:	402d883a 	mov	r22,r8
 1016d94:	a009883a 	mov	r4,r20
 1016d98:	880b883a 	mov	r5,r17
 1016d9c:	01800284 	movi	r6,10
 1016da0:	000f883a 	mov	r7,zero
 1016da4:	10237d00 	call	10237d0 <__umoddi3>
 1016da8:	10800c04 	addi	r2,r2,48
 1016dac:	843fffc4 	addi	r16,r16,-1
 1016db0:	a009883a 	mov	r4,r20
 1016db4:	880b883a 	mov	r5,r17
 1016db8:	80800005 	stb	r2,0(r16)
 1016dbc:	01800284 	movi	r6,10
 1016dc0:	000f883a 	mov	r7,zero
 1016dc4:	10232580 	call	1023258 <__udivdi3>
 1016dc8:	1029883a 	mov	r20,r2
 1016dcc:	10c4b03a 	or	r2,r2,r3
 1016dd0:	1823883a 	mov	r17,r3
 1016dd4:	103fef1e 	bne	r2,zero,1016d94 <__alt_data_end+0xff016d94>
 1016dd8:	d8c02817 	ldw	r3,160(sp)
 1016ddc:	dc402a17 	ldw	r17,168(sp)
 1016de0:	b011883a 	mov	r8,r22
 1016de4:	1c07c83a 	sub	r3,r3,r16
 1016de8:	d8c02e15 	stw	r3,184(sp)
 1016dec:	00002e06 	br	1016ea8 <___svfprintf_internal_r+0x6a0>
 1016df0:	18c03fcc 	andi	r3,r3,255
 1016df4:	1806e71e 	bne	r3,zero,1018994 <___svfprintf_internal_r+0x218c>
 1016df8:	94800414 	ori	r18,r18,16
 1016dfc:	9080080c 	andi	r2,r18,32
 1016e00:	1002d426 	beq	r2,zero,1017954 <___svfprintf_internal_r+0x114c>
 1016e04:	d9402d17 	ldw	r5,180(sp)
 1016e08:	d8c02917 	ldw	r3,164(sp)
 1016e0c:	d8002785 	stb	zero,158(sp)
 1016e10:	28800204 	addi	r2,r5,8
 1016e14:	2d000017 	ldw	r20,0(r5)
 1016e18:	2d800117 	ldw	r22,4(r5)
 1016e1c:	18041516 	blt	r3,zero,1017e74 <___svfprintf_internal_r+0x166c>
 1016e20:	013fdfc4 	movi	r4,-129
 1016e24:	a586b03a 	or	r3,r20,r22
 1016e28:	d8802d15 	stw	r2,180(sp)
 1016e2c:	9124703a 	and	r18,r18,r4
 1016e30:	1802d51e 	bne	r3,zero,1017988 <___svfprintf_internal_r+0x1180>
 1016e34:	d9402917 	ldw	r5,164(sp)
 1016e38:	0039883a 	mov	fp,zero
 1016e3c:	2806be26 	beq	r5,zero,1018938 <___svfprintf_internal_r+0x2130>
 1016e40:	0029883a 	mov	r20,zero
 1016e44:	002d883a 	mov	r22,zero
 1016e48:	dc001e04 	addi	r16,sp,120
 1016e4c:	a006d0fa 	srli	r3,r20,3
 1016e50:	b008977a 	slli	r4,r22,29
 1016e54:	b02cd0fa 	srli	r22,r22,3
 1016e58:	a50001cc 	andi	r20,r20,7
 1016e5c:	a0800c04 	addi	r2,r20,48
 1016e60:	843fffc4 	addi	r16,r16,-1
 1016e64:	20e8b03a 	or	r20,r4,r3
 1016e68:	80800005 	stb	r2,0(r16)
 1016e6c:	a586b03a 	or	r3,r20,r22
 1016e70:	183ff61e 	bne	r3,zero,1016e4c <__alt_data_end+0xff016e4c>
 1016e74:	90c0004c 	andi	r3,r18,1
 1016e78:	18013926 	beq	r3,zero,1017360 <___svfprintf_internal_r+0xb58>
 1016e7c:	10803fcc 	andi	r2,r2,255
 1016e80:	1080201c 	xori	r2,r2,128
 1016e84:	10bfe004 	addi	r2,r2,-128
 1016e88:	00c00c04 	movi	r3,48
 1016e8c:	10c13426 	beq	r2,r3,1017360 <___svfprintf_internal_r+0xb58>
 1016e90:	80ffffc5 	stb	r3,-1(r16)
 1016e94:	d8c02817 	ldw	r3,160(sp)
 1016e98:	80bfffc4 	addi	r2,r16,-1
 1016e9c:	1021883a 	mov	r16,r2
 1016ea0:	1887c83a 	sub	r3,r3,r2
 1016ea4:	d8c02e15 	stw	r3,184(sp)
 1016ea8:	d8802e17 	ldw	r2,184(sp)
 1016eac:	d9002917 	ldw	r4,164(sp)
 1016eb0:	1100010e 	bge	r2,r4,1016eb8 <___svfprintf_internal_r+0x6b0>
 1016eb4:	2005883a 	mov	r2,r4
 1016eb8:	d8802a15 	stw	r2,168(sp)
 1016ebc:	d8003215 	stw	zero,200(sp)
 1016ec0:	e7003fcc 	andi	fp,fp,255
 1016ec4:	e700201c 	xori	fp,fp,128
 1016ec8:	e73fe004 	addi	fp,fp,-128
 1016ecc:	e0000326 	beq	fp,zero,1016edc <___svfprintf_internal_r+0x6d4>
 1016ed0:	d8c02a17 	ldw	r3,168(sp)
 1016ed4:	18c00044 	addi	r3,r3,1
 1016ed8:	d8c02a15 	stw	r3,168(sp)
 1016edc:	90c0008c 	andi	r3,r18,2
 1016ee0:	d8c02b15 	stw	r3,172(sp)
 1016ee4:	18000326 	beq	r3,zero,1016ef4 <___svfprintf_internal_r+0x6ec>
 1016ee8:	d8c02a17 	ldw	r3,168(sp)
 1016eec:	18c00084 	addi	r3,r3,2
 1016ef0:	d8c02a15 	stw	r3,168(sp)
 1016ef4:	90c0210c 	andi	r3,r18,132
 1016ef8:	d8c03015 	stw	r3,192(sp)
 1016efc:	1801a11e 	bne	r3,zero,1017584 <___svfprintf_internal_r+0xd7c>
 1016f00:	d9003117 	ldw	r4,196(sp)
 1016f04:	d8c02a17 	ldw	r3,168(sp)
 1016f08:	20e9c83a 	sub	r20,r4,r3
 1016f0c:	05019d0e 	bge	zero,r20,1017584 <___svfprintf_internal_r+0xd7c>
 1016f10:	02400404 	movi	r9,16
 1016f14:	d8c02017 	ldw	r3,128(sp)
 1016f18:	d8801f17 	ldw	r2,124(sp)
 1016f1c:	4d051b0e 	bge	r9,r20,101838c <___svfprintf_internal_r+0x1b84>
 1016f20:	014040f4 	movhi	r5,259
 1016f24:	296a9084 	addi	r5,r5,-21950
 1016f28:	dc403c15 	stw	r17,240(sp)
 1016f2c:	d9403515 	stw	r5,212(sp)
 1016f30:	a023883a 	mov	r17,r20
 1016f34:	482d883a 	mov	r22,r9
 1016f38:	9029883a 	mov	r20,r18
 1016f3c:	070001c4 	movi	fp,7
 1016f40:	8025883a 	mov	r18,r16
 1016f44:	dc002c17 	ldw	r16,176(sp)
 1016f48:	00000306 	br	1016f58 <___svfprintf_internal_r+0x750>
 1016f4c:	8c7ffc04 	addi	r17,r17,-16
 1016f50:	42000204 	addi	r8,r8,8
 1016f54:	b440130e 	bge	r22,r17,1016fa4 <___svfprintf_internal_r+0x79c>
 1016f58:	010040f4 	movhi	r4,259
 1016f5c:	18c00404 	addi	r3,r3,16
 1016f60:	10800044 	addi	r2,r2,1
 1016f64:	212a9084 	addi	r4,r4,-21950
 1016f68:	41000015 	stw	r4,0(r8)
 1016f6c:	45800115 	stw	r22,4(r8)
 1016f70:	d8c02015 	stw	r3,128(sp)
 1016f74:	d8801f15 	stw	r2,124(sp)
 1016f78:	e0bff40e 	bge	fp,r2,1016f4c <__alt_data_end+0xff016f4c>
 1016f7c:	d9801e04 	addi	r6,sp,120
 1016f80:	800b883a 	mov	r5,r16
 1016f84:	9809883a 	mov	r4,r19
 1016f88:	101fed00 	call	101fed0 <__ssprint_r>
 1016f8c:	103f031e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1016f90:	8c7ffc04 	addi	r17,r17,-16
 1016f94:	d8c02017 	ldw	r3,128(sp)
 1016f98:	d8801f17 	ldw	r2,124(sp)
 1016f9c:	da000404 	addi	r8,sp,16
 1016fa0:	b47fed16 	blt	r22,r17,1016f58 <__alt_data_end+0xff016f58>
 1016fa4:	9021883a 	mov	r16,r18
 1016fa8:	a025883a 	mov	r18,r20
 1016fac:	8829883a 	mov	r20,r17
 1016fb0:	dc403c17 	ldw	r17,240(sp)
 1016fb4:	d9403517 	ldw	r5,212(sp)
 1016fb8:	a0c7883a 	add	r3,r20,r3
 1016fbc:	10800044 	addi	r2,r2,1
 1016fc0:	41400015 	stw	r5,0(r8)
 1016fc4:	45000115 	stw	r20,4(r8)
 1016fc8:	d8c02015 	stw	r3,128(sp)
 1016fcc:	d8801f15 	stw	r2,124(sp)
 1016fd0:	010001c4 	movi	r4,7
 1016fd4:	20829f16 	blt	r4,r2,1017a54 <___svfprintf_internal_r+0x124c>
 1016fd8:	df002787 	ldb	fp,158(sp)
 1016fdc:	42000204 	addi	r8,r8,8
 1016fe0:	e0000c26 	beq	fp,zero,1017014 <___svfprintf_internal_r+0x80c>
 1016fe4:	d8801f17 	ldw	r2,124(sp)
 1016fe8:	d9002784 	addi	r4,sp,158
 1016fec:	18c00044 	addi	r3,r3,1
 1016ff0:	10800044 	addi	r2,r2,1
 1016ff4:	41000015 	stw	r4,0(r8)
 1016ff8:	01000044 	movi	r4,1
 1016ffc:	41000115 	stw	r4,4(r8)
 1017000:	d8c02015 	stw	r3,128(sp)
 1017004:	d8801f15 	stw	r2,124(sp)
 1017008:	010001c4 	movi	r4,7
 101700c:	20823816 	blt	r4,r2,10178f0 <___svfprintf_internal_r+0x10e8>
 1017010:	42000204 	addi	r8,r8,8
 1017014:	d8802b17 	ldw	r2,172(sp)
 1017018:	10000c26 	beq	r2,zero,101704c <___svfprintf_internal_r+0x844>
 101701c:	d8801f17 	ldw	r2,124(sp)
 1017020:	d9002704 	addi	r4,sp,156
 1017024:	18c00084 	addi	r3,r3,2
 1017028:	10800044 	addi	r2,r2,1
 101702c:	41000015 	stw	r4,0(r8)
 1017030:	01000084 	movi	r4,2
 1017034:	41000115 	stw	r4,4(r8)
 1017038:	d8c02015 	stw	r3,128(sp)
 101703c:	d8801f15 	stw	r2,124(sp)
 1017040:	010001c4 	movi	r4,7
 1017044:	20823216 	blt	r4,r2,1017910 <___svfprintf_internal_r+0x1108>
 1017048:	42000204 	addi	r8,r8,8
 101704c:	d9003017 	ldw	r4,192(sp)
 1017050:	00802004 	movi	r2,128
 1017054:	20819726 	beq	r4,r2,10176b4 <___svfprintf_internal_r+0xeac>
 1017058:	d9402917 	ldw	r5,164(sp)
 101705c:	d8802e17 	ldw	r2,184(sp)
 1017060:	28adc83a 	sub	r22,r5,r2
 1017064:	05802f0e 	bge	zero,r22,1017124 <___svfprintf_internal_r+0x91c>
 1017068:	07000404 	movi	fp,16
 101706c:	d8801f17 	ldw	r2,124(sp)
 1017070:	e583c00e 	bge	fp,r22,1017f74 <___svfprintf_internal_r+0x176c>
 1017074:	014040f4 	movhi	r5,259
 1017078:	296a8c84 	addi	r5,r5,-21966
 101707c:	dc402915 	stw	r17,164(sp)
 1017080:	d9402b15 	stw	r5,172(sp)
 1017084:	b023883a 	mov	r17,r22
 1017088:	050001c4 	movi	r20,7
 101708c:	902d883a 	mov	r22,r18
 1017090:	8025883a 	mov	r18,r16
 1017094:	dc002c17 	ldw	r16,176(sp)
 1017098:	00000306 	br	10170a8 <___svfprintf_internal_r+0x8a0>
 101709c:	8c7ffc04 	addi	r17,r17,-16
 10170a0:	42000204 	addi	r8,r8,8
 10170a4:	e440110e 	bge	fp,r17,10170ec <___svfprintf_internal_r+0x8e4>
 10170a8:	18c00404 	addi	r3,r3,16
 10170ac:	10800044 	addi	r2,r2,1
 10170b0:	45400015 	stw	r21,0(r8)
 10170b4:	47000115 	stw	fp,4(r8)
 10170b8:	d8c02015 	stw	r3,128(sp)
 10170bc:	d8801f15 	stw	r2,124(sp)
 10170c0:	a0bff60e 	bge	r20,r2,101709c <__alt_data_end+0xff01709c>
 10170c4:	d9801e04 	addi	r6,sp,120
 10170c8:	800b883a 	mov	r5,r16
 10170cc:	9809883a 	mov	r4,r19
 10170d0:	101fed00 	call	101fed0 <__ssprint_r>
 10170d4:	103eb11e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 10170d8:	8c7ffc04 	addi	r17,r17,-16
 10170dc:	d8c02017 	ldw	r3,128(sp)
 10170e0:	d8801f17 	ldw	r2,124(sp)
 10170e4:	da000404 	addi	r8,sp,16
 10170e8:	e47fef16 	blt	fp,r17,10170a8 <__alt_data_end+0xff0170a8>
 10170ec:	9021883a 	mov	r16,r18
 10170f0:	b025883a 	mov	r18,r22
 10170f4:	882d883a 	mov	r22,r17
 10170f8:	dc402917 	ldw	r17,164(sp)
 10170fc:	d9002b17 	ldw	r4,172(sp)
 1017100:	1d87883a 	add	r3,r3,r22
 1017104:	10800044 	addi	r2,r2,1
 1017108:	41000015 	stw	r4,0(r8)
 101710c:	45800115 	stw	r22,4(r8)
 1017110:	d8c02015 	stw	r3,128(sp)
 1017114:	d8801f15 	stw	r2,124(sp)
 1017118:	010001c4 	movi	r4,7
 101711c:	2081ec16 	blt	r4,r2,10178d0 <___svfprintf_internal_r+0x10c8>
 1017120:	42000204 	addi	r8,r8,8
 1017124:	9080400c 	andi	r2,r18,256
 1017128:	1001181e 	bne	r2,zero,101758c <___svfprintf_internal_r+0xd84>
 101712c:	d9402e17 	ldw	r5,184(sp)
 1017130:	d8801f17 	ldw	r2,124(sp)
 1017134:	44000015 	stw	r16,0(r8)
 1017138:	1947883a 	add	r3,r3,r5
 101713c:	10800044 	addi	r2,r2,1
 1017140:	41400115 	stw	r5,4(r8)
 1017144:	d8c02015 	stw	r3,128(sp)
 1017148:	d8801f15 	stw	r2,124(sp)
 101714c:	010001c4 	movi	r4,7
 1017150:	2081d116 	blt	r4,r2,1017898 <___svfprintf_internal_r+0x1090>
 1017154:	42000204 	addi	r8,r8,8
 1017158:	9480010c 	andi	r18,r18,4
 101715c:	90003226 	beq	r18,zero,1017228 <___svfprintf_internal_r+0xa20>
 1017160:	d9403117 	ldw	r5,196(sp)
 1017164:	d8802a17 	ldw	r2,168(sp)
 1017168:	28a1c83a 	sub	r16,r5,r2
 101716c:	04002e0e 	bge	zero,r16,1017228 <___svfprintf_internal_r+0xa20>
 1017170:	04400404 	movi	r17,16
 1017174:	d8801f17 	ldw	r2,124(sp)
 1017178:	8c04b90e 	bge	r17,r16,1018460 <___svfprintf_internal_r+0x1c58>
 101717c:	014040f4 	movhi	r5,259
 1017180:	296a9084 	addi	r5,r5,-21950
 1017184:	d9403515 	stw	r5,212(sp)
 1017188:	048001c4 	movi	r18,7
 101718c:	dd002c17 	ldw	r20,176(sp)
 1017190:	00000306 	br	10171a0 <___svfprintf_internal_r+0x998>
 1017194:	843ffc04 	addi	r16,r16,-16
 1017198:	42000204 	addi	r8,r8,8
 101719c:	8c00130e 	bge	r17,r16,10171ec <___svfprintf_internal_r+0x9e4>
 10171a0:	010040f4 	movhi	r4,259
 10171a4:	18c00404 	addi	r3,r3,16
 10171a8:	10800044 	addi	r2,r2,1
 10171ac:	212a9084 	addi	r4,r4,-21950
 10171b0:	41000015 	stw	r4,0(r8)
 10171b4:	44400115 	stw	r17,4(r8)
 10171b8:	d8c02015 	stw	r3,128(sp)
 10171bc:	d8801f15 	stw	r2,124(sp)
 10171c0:	90bff40e 	bge	r18,r2,1017194 <__alt_data_end+0xff017194>
 10171c4:	d9801e04 	addi	r6,sp,120
 10171c8:	a00b883a 	mov	r5,r20
 10171cc:	9809883a 	mov	r4,r19
 10171d0:	101fed00 	call	101fed0 <__ssprint_r>
 10171d4:	103e711e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 10171d8:	843ffc04 	addi	r16,r16,-16
 10171dc:	d8c02017 	ldw	r3,128(sp)
 10171e0:	d8801f17 	ldw	r2,124(sp)
 10171e4:	da000404 	addi	r8,sp,16
 10171e8:	8c3fed16 	blt	r17,r16,10171a0 <__alt_data_end+0xff0171a0>
 10171ec:	d9403517 	ldw	r5,212(sp)
 10171f0:	1c07883a 	add	r3,r3,r16
 10171f4:	10800044 	addi	r2,r2,1
 10171f8:	41400015 	stw	r5,0(r8)
 10171fc:	44000115 	stw	r16,4(r8)
 1017200:	d8c02015 	stw	r3,128(sp)
 1017204:	d8801f15 	stw	r2,124(sp)
 1017208:	010001c4 	movi	r4,7
 101720c:	2080060e 	bge	r4,r2,1017228 <___svfprintf_internal_r+0xa20>
 1017210:	d9402c17 	ldw	r5,176(sp)
 1017214:	d9801e04 	addi	r6,sp,120
 1017218:	9809883a 	mov	r4,r19
 101721c:	101fed00 	call	101fed0 <__ssprint_r>
 1017220:	103e5e1e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017224:	d8c02017 	ldw	r3,128(sp)
 1017228:	d8803117 	ldw	r2,196(sp)
 101722c:	d9002a17 	ldw	r4,168(sp)
 1017230:	1100010e 	bge	r2,r4,1017238 <___svfprintf_internal_r+0xa30>
 1017234:	2005883a 	mov	r2,r4
 1017238:	d9402f17 	ldw	r5,188(sp)
 101723c:	288b883a 	add	r5,r5,r2
 1017240:	d9402f15 	stw	r5,188(sp)
 1017244:	18019c1e 	bne	r3,zero,10178b8 <___svfprintf_internal_r+0x10b0>
 1017248:	b8800007 	ldb	r2,0(r23)
 101724c:	d8001f15 	stw	zero,124(sp)
 1017250:	da000404 	addi	r8,sp,16
 1017254:	103d991e 	bne	r2,zero,10168bc <__alt_data_end+0xff0168bc>
 1017258:	b821883a 	mov	r16,r23
 101725c:	003daf06 	br	101691c <__alt_data_end+0xff01691c>
 1017260:	18c03fcc 	andi	r3,r3,255
 1017264:	1805c71e 	bne	r3,zero,1018984 <___svfprintf_internal_r+0x217c>
 1017268:	94800414 	ori	r18,r18,16
 101726c:	9080080c 	andi	r2,r18,32
 1017270:	10020126 	beq	r2,zero,1017a78 <___svfprintf_internal_r+0x1270>
 1017274:	d8802d17 	ldw	r2,180(sp)
 1017278:	d9002917 	ldw	r4,164(sp)
 101727c:	d8002785 	stb	zero,158(sp)
 1017280:	10c00204 	addi	r3,r2,8
 1017284:	15000017 	ldw	r20,0(r2)
 1017288:	15800117 	ldw	r22,4(r2)
 101728c:	20038e16 	blt	r4,zero,10180c8 <___svfprintf_internal_r+0x18c0>
 1017290:	013fdfc4 	movi	r4,-129
 1017294:	a584b03a 	or	r2,r20,r22
 1017298:	d8c02d15 	stw	r3,180(sp)
 101729c:	9124703a 	and	r18,r18,r4
 10172a0:	0039883a 	mov	fp,zero
 10172a4:	103eb61e 	bne	r2,zero,1016d80 <__alt_data_end+0xff016d80>
 10172a8:	d8802917 	ldw	r2,164(sp)
 10172ac:	1002c81e 	bne	r2,zero,1017dd0 <___svfprintf_internal_r+0x15c8>
 10172b0:	d8002915 	stw	zero,164(sp)
 10172b4:	d8002e15 	stw	zero,184(sp)
 10172b8:	dc001e04 	addi	r16,sp,120
 10172bc:	003efa06 	br	1016ea8 <__alt_data_end+0xff016ea8>
 10172c0:	18c03fcc 	andi	r3,r3,255
 10172c4:	1805ad1e 	bne	r3,zero,101897c <___svfprintf_internal_r+0x2174>
 10172c8:	014040f4 	movhi	r5,259
 10172cc:	296a8004 	addi	r5,r5,-22016
 10172d0:	d9403a15 	stw	r5,232(sp)
 10172d4:	9080080c 	andi	r2,r18,32
 10172d8:	10006126 	beq	r2,zero,1017460 <___svfprintf_internal_r+0xc58>
 10172dc:	d8802d17 	ldw	r2,180(sp)
 10172e0:	15000017 	ldw	r20,0(r2)
 10172e4:	15800117 	ldw	r22,4(r2)
 10172e8:	10800204 	addi	r2,r2,8
 10172ec:	d8802d15 	stw	r2,180(sp)
 10172f0:	9080004c 	andi	r2,r18,1
 10172f4:	10018e26 	beq	r2,zero,1017930 <___svfprintf_internal_r+0x1128>
 10172f8:	a584b03a 	or	r2,r20,r22
 10172fc:	10030926 	beq	r2,zero,1017f24 <___svfprintf_internal_r+0x171c>
 1017300:	d8c02917 	ldw	r3,164(sp)
 1017304:	00800c04 	movi	r2,48
 1017308:	d8802705 	stb	r2,156(sp)
 101730c:	dc402745 	stb	r17,157(sp)
 1017310:	d8002785 	stb	zero,158(sp)
 1017314:	90800094 	ori	r2,r18,2
 1017318:	18048716 	blt	r3,zero,1018538 <___svfprintf_internal_r+0x1d30>
 101731c:	00bfdfc4 	movi	r2,-129
 1017320:	90a4703a 	and	r18,r18,r2
 1017324:	94800094 	ori	r18,r18,2
 1017328:	0039883a 	mov	fp,zero
 101732c:	d9003a17 	ldw	r4,232(sp)
 1017330:	dc001e04 	addi	r16,sp,120
 1017334:	a08003cc 	andi	r2,r20,15
 1017338:	b006973a 	slli	r3,r22,28
 101733c:	2085883a 	add	r2,r4,r2
 1017340:	a028d13a 	srli	r20,r20,4
 1017344:	10800003 	ldbu	r2,0(r2)
 1017348:	b02cd13a 	srli	r22,r22,4
 101734c:	843fffc4 	addi	r16,r16,-1
 1017350:	1d28b03a 	or	r20,r3,r20
 1017354:	80800005 	stb	r2,0(r16)
 1017358:	a584b03a 	or	r2,r20,r22
 101735c:	103ff51e 	bne	r2,zero,1017334 <__alt_data_end+0xff017334>
 1017360:	d8c02817 	ldw	r3,160(sp)
 1017364:	1c07c83a 	sub	r3,r3,r16
 1017368:	d8c02e15 	stw	r3,184(sp)
 101736c:	003ece06 	br	1016ea8 <__alt_data_end+0xff016ea8>
 1017370:	d8c02d17 	ldw	r3,180(sp)
 1017374:	d9002d17 	ldw	r4,180(sp)
 1017378:	d8002785 	stb	zero,158(sp)
 101737c:	18800017 	ldw	r2,0(r3)
 1017380:	21000104 	addi	r4,r4,4
 1017384:	00c00044 	movi	r3,1
 1017388:	d8c02a15 	stw	r3,168(sp)
 101738c:	d8801405 	stb	r2,80(sp)
 1017390:	d9002d15 	stw	r4,180(sp)
 1017394:	d8c02e15 	stw	r3,184(sp)
 1017398:	d8002915 	stw	zero,164(sp)
 101739c:	d8003215 	stw	zero,200(sp)
 10173a0:	dc001404 	addi	r16,sp,80
 10173a4:	0039883a 	mov	fp,zero
 10173a8:	003ecc06 	br	1016edc <__alt_data_end+0xff016edc>
 10173ac:	18c03fcc 	andi	r3,r3,255
 10173b0:	183e9226 	beq	r3,zero,1016dfc <__alt_data_end+0xff016dfc>
 10173b4:	d9c02785 	stb	r7,158(sp)
 10173b8:	003e9006 	br	1016dfc <__alt_data_end+0xff016dfc>
 10173bc:	00c00044 	movi	r3,1
 10173c0:	01c00ac4 	movi	r7,43
 10173c4:	bc400007 	ldb	r17,0(r23)
 10173c8:	003d6306 	br	1016958 <__alt_data_end+0xff016958>
 10173cc:	94800814 	ori	r18,r18,32
 10173d0:	bc400007 	ldb	r17,0(r23)
 10173d4:	003d6006 	br	1016958 <__alt_data_end+0xff016958>
 10173d8:	d8c02d17 	ldw	r3,180(sp)
 10173dc:	d8002785 	stb	zero,158(sp)
 10173e0:	1c000017 	ldw	r16,0(r3)
 10173e4:	1d000104 	addi	r20,r3,4
 10173e8:	80040f26 	beq	r16,zero,1018428 <___svfprintf_internal_r+0x1c20>
 10173ec:	d9002917 	ldw	r4,164(sp)
 10173f0:	2003dc16 	blt	r4,zero,1018364 <___svfprintf_internal_r+0x1b5c>
 10173f4:	200d883a 	mov	r6,r4
 10173f8:	000b883a 	mov	r5,zero
 10173fc:	8009883a 	mov	r4,r16
 1017400:	da003e15 	stw	r8,248(sp)
 1017404:	101e2280 	call	101e228 <memchr>
 1017408:	da003e17 	ldw	r8,248(sp)
 101740c:	10045826 	beq	r2,zero,1018570 <___svfprintf_internal_r+0x1d68>
 1017410:	1405c83a 	sub	r2,r2,r16
 1017414:	d8802e15 	stw	r2,184(sp)
 1017418:	1003d816 	blt	r2,zero,101837c <___svfprintf_internal_r+0x1b74>
 101741c:	df002783 	ldbu	fp,158(sp)
 1017420:	d8802a15 	stw	r2,168(sp)
 1017424:	dd002d15 	stw	r20,180(sp)
 1017428:	d8002915 	stw	zero,164(sp)
 101742c:	d8003215 	stw	zero,200(sp)
 1017430:	003ea306 	br	1016ec0 <__alt_data_end+0xff016ec0>
 1017434:	18c03fcc 	andi	r3,r3,255
 1017438:	183f8c26 	beq	r3,zero,101726c <__alt_data_end+0xff01726c>
 101743c:	d9c02785 	stb	r7,158(sp)
 1017440:	003f8a06 	br	101726c <__alt_data_end+0xff01726c>
 1017444:	18c03fcc 	andi	r3,r3,255
 1017448:	1805631e 	bne	r3,zero,10189d8 <___svfprintf_internal_r+0x21d0>
 101744c:	014040f4 	movhi	r5,259
 1017450:	296a8504 	addi	r5,r5,-21996
 1017454:	d9403a15 	stw	r5,232(sp)
 1017458:	9080080c 	andi	r2,r18,32
 101745c:	103f9f1e 	bne	r2,zero,10172dc <__alt_data_end+0xff0172dc>
 1017460:	9080040c 	andi	r2,r18,16
 1017464:	10029c26 	beq	r2,zero,1017ed8 <___svfprintf_internal_r+0x16d0>
 1017468:	d8c02d17 	ldw	r3,180(sp)
 101746c:	002d883a 	mov	r22,zero
 1017470:	1d000017 	ldw	r20,0(r3)
 1017474:	18c00104 	addi	r3,r3,4
 1017478:	d8c02d15 	stw	r3,180(sp)
 101747c:	003f9c06 	br	10172f0 <__alt_data_end+0xff0172f0>
 1017480:	94800054 	ori	r18,r18,1
 1017484:	bc400007 	ldb	r17,0(r23)
 1017488:	003d3306 	br	1016958 <__alt_data_end+0xff016958>
 101748c:	38803fcc 	andi	r2,r7,255
 1017490:	1080201c 	xori	r2,r2,128
 1017494:	10bfe004 	addi	r2,r2,-128
 1017498:	1002971e 	bne	r2,zero,1017ef8 <___svfprintf_internal_r+0x16f0>
 101749c:	00c00044 	movi	r3,1
 10174a0:	01c00804 	movi	r7,32
 10174a4:	bc400007 	ldb	r17,0(r23)
 10174a8:	003d2b06 	br	1016958 <__alt_data_end+0xff016958>
 10174ac:	18c03fcc 	andi	r3,r3,255
 10174b0:	183e2326 	beq	r3,zero,1016d40 <__alt_data_end+0xff016d40>
 10174b4:	d9c02785 	stb	r7,158(sp)
 10174b8:	003e2106 	br	1016d40 <__alt_data_end+0xff016d40>
 10174bc:	bc400007 	ldb	r17,0(r23)
 10174c0:	8a430426 	beq	r17,r9,10180d4 <___svfprintf_internal_r+0x18cc>
 10174c4:	94800414 	ori	r18,r18,16
 10174c8:	003d2306 	br	1016958 <__alt_data_end+0xff016958>
 10174cc:	18c03fcc 	andi	r3,r3,255
 10174d0:	18053f1e 	bne	r3,zero,10189d0 <___svfprintf_internal_r+0x21c8>
 10174d4:	9080080c 	andi	r2,r18,32
 10174d8:	10028926 	beq	r2,zero,1017f00 <___svfprintf_internal_r+0x16f8>
 10174dc:	d9402d17 	ldw	r5,180(sp)
 10174e0:	d9002f17 	ldw	r4,188(sp)
 10174e4:	28800017 	ldw	r2,0(r5)
 10174e8:	2007d7fa 	srai	r3,r4,31
 10174ec:	29400104 	addi	r5,r5,4
 10174f0:	d9402d15 	stw	r5,180(sp)
 10174f4:	11000015 	stw	r4,0(r2)
 10174f8:	10c00115 	stw	r3,4(r2)
 10174fc:	003ced06 	br	10168b4 <__alt_data_end+0xff0168b4>
 1017500:	94801014 	ori	r18,r18,64
 1017504:	bc400007 	ldb	r17,0(r23)
 1017508:	003d1306 	br	1016958 <__alt_data_end+0xff016958>
 101750c:	010040f4 	movhi	r4,259
 1017510:	212a8504 	addi	r4,r4,-21996
 1017514:	0039883a 	mov	fp,zero
 1017518:	d9003a15 	stw	r4,232(sp)
 101751c:	04401e04 	movi	r17,120
 1017520:	003f8206 	br	101732c <__alt_data_end+0xff01732c>
 1017524:	18c03fcc 	andi	r3,r3,255
 1017528:	1805221e 	bne	r3,zero,10189b4 <___svfprintf_internal_r+0x21ac>
 101752c:	883d9526 	beq	r17,zero,1016b84 <__alt_data_end+0xff016b84>
 1017530:	00c00044 	movi	r3,1
 1017534:	d8c02a15 	stw	r3,168(sp)
 1017538:	dc401405 	stb	r17,80(sp)
 101753c:	d8002785 	stb	zero,158(sp)
 1017540:	003f9406 	br	1017394 <__alt_data_end+0xff017394>
 1017544:	010040f4 	movhi	r4,259
 1017548:	212a8504 	addi	r4,r4,-21996
 101754c:	d9003a15 	stw	r4,232(sp)
 1017550:	d8c02d15 	stw	r3,180(sp)
 1017554:	1025883a 	mov	r18,r2
 1017558:	04401e04 	movi	r17,120
 101755c:	a584b03a 	or	r2,r20,r22
 1017560:	1000fa1e 	bne	r2,zero,101794c <___svfprintf_internal_r+0x1144>
 1017564:	0039883a 	mov	fp,zero
 1017568:	00800084 	movi	r2,2
 101756c:	10803fcc 	andi	r2,r2,255
 1017570:	00c00044 	movi	r3,1
 1017574:	10c21626 	beq	r2,r3,1017dd0 <___svfprintf_internal_r+0x15c8>
 1017578:	00c00084 	movi	r3,2
 101757c:	10fe301e 	bne	r2,r3,1016e40 <__alt_data_end+0xff016e40>
 1017580:	003d7606 	br	1016b5c <__alt_data_end+0xff016b5c>
 1017584:	d8c02017 	ldw	r3,128(sp)
 1017588:	003e9506 	br	1016fe0 <__alt_data_end+0xff016fe0>
 101758c:	00801944 	movi	r2,101
 1017590:	14407c0e 	bge	r2,r17,1017784 <___svfprintf_internal_r+0xf7c>
 1017594:	d9003617 	ldw	r4,216(sp)
 1017598:	d9403717 	ldw	r5,220(sp)
 101759c:	000d883a 	mov	r6,zero
 10175a0:	000f883a 	mov	r7,zero
 10175a4:	d8c03d15 	stw	r3,244(sp)
 10175a8:	da003e15 	stw	r8,248(sp)
 10175ac:	10250500 	call	1025050 <__eqdf2>
 10175b0:	d8c03d17 	ldw	r3,244(sp)
 10175b4:	da003e17 	ldw	r8,248(sp)
 10175b8:	1000f51e 	bne	r2,zero,1017990 <___svfprintf_internal_r+0x1188>
 10175bc:	d8801f17 	ldw	r2,124(sp)
 10175c0:	010040f4 	movhi	r4,259
 10175c4:	212a8c04 	addi	r4,r4,-21968
 10175c8:	18c00044 	addi	r3,r3,1
 10175cc:	10800044 	addi	r2,r2,1
 10175d0:	41000015 	stw	r4,0(r8)
 10175d4:	01000044 	movi	r4,1
 10175d8:	41000115 	stw	r4,4(r8)
 10175dc:	d8c02015 	stw	r3,128(sp)
 10175e0:	d8801f15 	stw	r2,124(sp)
 10175e4:	010001c4 	movi	r4,7
 10175e8:	20826616 	blt	r4,r2,1017f84 <___svfprintf_internal_r+0x177c>
 10175ec:	42000204 	addi	r8,r8,8
 10175f0:	d8802617 	ldw	r2,152(sp)
 10175f4:	d9403317 	ldw	r5,204(sp)
 10175f8:	11400216 	blt	r2,r5,1017604 <___svfprintf_internal_r+0xdfc>
 10175fc:	9080004c 	andi	r2,r18,1
 1017600:	103ed526 	beq	r2,zero,1017158 <__alt_data_end+0xff017158>
 1017604:	d8803817 	ldw	r2,224(sp)
 1017608:	d9003417 	ldw	r4,208(sp)
 101760c:	d9403817 	ldw	r5,224(sp)
 1017610:	1887883a 	add	r3,r3,r2
 1017614:	d8801f17 	ldw	r2,124(sp)
 1017618:	41000015 	stw	r4,0(r8)
 101761c:	41400115 	stw	r5,4(r8)
 1017620:	10800044 	addi	r2,r2,1
 1017624:	d8c02015 	stw	r3,128(sp)
 1017628:	d8801f15 	stw	r2,124(sp)
 101762c:	010001c4 	movi	r4,7
 1017630:	2082af16 	blt	r4,r2,10180f0 <___svfprintf_internal_r+0x18e8>
 1017634:	42000204 	addi	r8,r8,8
 1017638:	d8803317 	ldw	r2,204(sp)
 101763c:	143fffc4 	addi	r16,r2,-1
 1017640:	043ec50e 	bge	zero,r16,1017158 <__alt_data_end+0xff017158>
 1017644:	04400404 	movi	r17,16
 1017648:	d8801f17 	ldw	r2,124(sp)
 101764c:	8c00860e 	bge	r17,r16,1017868 <___svfprintf_internal_r+0x1060>
 1017650:	014040f4 	movhi	r5,259
 1017654:	296a8c84 	addi	r5,r5,-21966
 1017658:	d9402b15 	stw	r5,172(sp)
 101765c:	058001c4 	movi	r22,7
 1017660:	dd002c17 	ldw	r20,176(sp)
 1017664:	00000306 	br	1017674 <___svfprintf_internal_r+0xe6c>
 1017668:	42000204 	addi	r8,r8,8
 101766c:	843ffc04 	addi	r16,r16,-16
 1017670:	8c00800e 	bge	r17,r16,1017874 <___svfprintf_internal_r+0x106c>
 1017674:	18c00404 	addi	r3,r3,16
 1017678:	10800044 	addi	r2,r2,1
 101767c:	45400015 	stw	r21,0(r8)
 1017680:	44400115 	stw	r17,4(r8)
 1017684:	d8c02015 	stw	r3,128(sp)
 1017688:	d8801f15 	stw	r2,124(sp)
 101768c:	b0bff60e 	bge	r22,r2,1017668 <__alt_data_end+0xff017668>
 1017690:	d9801e04 	addi	r6,sp,120
 1017694:	a00b883a 	mov	r5,r20
 1017698:	9809883a 	mov	r4,r19
 101769c:	101fed00 	call	101fed0 <__ssprint_r>
 10176a0:	103d3e1e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 10176a4:	d8c02017 	ldw	r3,128(sp)
 10176a8:	d8801f17 	ldw	r2,124(sp)
 10176ac:	da000404 	addi	r8,sp,16
 10176b0:	003fee06 	br	101766c <__alt_data_end+0xff01766c>
 10176b4:	d9403117 	ldw	r5,196(sp)
 10176b8:	d8802a17 	ldw	r2,168(sp)
 10176bc:	28adc83a 	sub	r22,r5,r2
 10176c0:	05be650e 	bge	zero,r22,1017058 <__alt_data_end+0xff017058>
 10176c4:	07000404 	movi	fp,16
 10176c8:	d8801f17 	ldw	r2,124(sp)
 10176cc:	e583a20e 	bge	fp,r22,1018558 <___svfprintf_internal_r+0x1d50>
 10176d0:	014040f4 	movhi	r5,259
 10176d4:	296a8c84 	addi	r5,r5,-21966
 10176d8:	dc403015 	stw	r17,192(sp)
 10176dc:	d9402b15 	stw	r5,172(sp)
 10176e0:	b023883a 	mov	r17,r22
 10176e4:	050001c4 	movi	r20,7
 10176e8:	902d883a 	mov	r22,r18
 10176ec:	8025883a 	mov	r18,r16
 10176f0:	dc002c17 	ldw	r16,176(sp)
 10176f4:	00000306 	br	1017704 <___svfprintf_internal_r+0xefc>
 10176f8:	8c7ffc04 	addi	r17,r17,-16
 10176fc:	42000204 	addi	r8,r8,8
 1017700:	e440110e 	bge	fp,r17,1017748 <___svfprintf_internal_r+0xf40>
 1017704:	18c00404 	addi	r3,r3,16
 1017708:	10800044 	addi	r2,r2,1
 101770c:	45400015 	stw	r21,0(r8)
 1017710:	47000115 	stw	fp,4(r8)
 1017714:	d8c02015 	stw	r3,128(sp)
 1017718:	d8801f15 	stw	r2,124(sp)
 101771c:	a0bff60e 	bge	r20,r2,10176f8 <__alt_data_end+0xff0176f8>
 1017720:	d9801e04 	addi	r6,sp,120
 1017724:	800b883a 	mov	r5,r16
 1017728:	9809883a 	mov	r4,r19
 101772c:	101fed00 	call	101fed0 <__ssprint_r>
 1017730:	103d1a1e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017734:	8c7ffc04 	addi	r17,r17,-16
 1017738:	d8c02017 	ldw	r3,128(sp)
 101773c:	d8801f17 	ldw	r2,124(sp)
 1017740:	da000404 	addi	r8,sp,16
 1017744:	e47fef16 	blt	fp,r17,1017704 <__alt_data_end+0xff017704>
 1017748:	9021883a 	mov	r16,r18
 101774c:	b025883a 	mov	r18,r22
 1017750:	882d883a 	mov	r22,r17
 1017754:	dc403017 	ldw	r17,192(sp)
 1017758:	d9002b17 	ldw	r4,172(sp)
 101775c:	1d87883a 	add	r3,r3,r22
 1017760:	10800044 	addi	r2,r2,1
 1017764:	41000015 	stw	r4,0(r8)
 1017768:	45800115 	stw	r22,4(r8)
 101776c:	d8c02015 	stw	r3,128(sp)
 1017770:	d8801f15 	stw	r2,124(sp)
 1017774:	010001c4 	movi	r4,7
 1017778:	20819a16 	blt	r4,r2,1017de4 <___svfprintf_internal_r+0x15dc>
 101777c:	42000204 	addi	r8,r8,8
 1017780:	003e3506 	br	1017058 <__alt_data_end+0xff017058>
 1017784:	d9403317 	ldw	r5,204(sp)
 1017788:	00800044 	movi	r2,1
 101778c:	18c00044 	addi	r3,r3,1
 1017790:	1141710e 	bge	r2,r5,1017d58 <___svfprintf_internal_r+0x1550>
 1017794:	dc401f17 	ldw	r17,124(sp)
 1017798:	00800044 	movi	r2,1
 101779c:	40800115 	stw	r2,4(r8)
 10177a0:	8c400044 	addi	r17,r17,1
 10177a4:	44000015 	stw	r16,0(r8)
 10177a8:	d8c02015 	stw	r3,128(sp)
 10177ac:	dc401f15 	stw	r17,124(sp)
 10177b0:	008001c4 	movi	r2,7
 10177b4:	14417416 	blt	r2,r17,1017d88 <___svfprintf_internal_r+0x1580>
 10177b8:	42000204 	addi	r8,r8,8
 10177bc:	d8803817 	ldw	r2,224(sp)
 10177c0:	d9003417 	ldw	r4,208(sp)
 10177c4:	8c400044 	addi	r17,r17,1
 10177c8:	10c7883a 	add	r3,r2,r3
 10177cc:	40800115 	stw	r2,4(r8)
 10177d0:	41000015 	stw	r4,0(r8)
 10177d4:	d8c02015 	stw	r3,128(sp)
 10177d8:	dc401f15 	stw	r17,124(sp)
 10177dc:	008001c4 	movi	r2,7
 10177e0:	14417216 	blt	r2,r17,1017dac <___svfprintf_internal_r+0x15a4>
 10177e4:	45800204 	addi	r22,r8,8
 10177e8:	d9003617 	ldw	r4,216(sp)
 10177ec:	d9403717 	ldw	r5,220(sp)
 10177f0:	000d883a 	mov	r6,zero
 10177f4:	000f883a 	mov	r7,zero
 10177f8:	d8c03d15 	stw	r3,244(sp)
 10177fc:	10250500 	call	1025050 <__eqdf2>
 1017800:	d8c03d17 	ldw	r3,244(sp)
 1017804:	1000b326 	beq	r2,zero,1017ad4 <___svfprintf_internal_r+0x12cc>
 1017808:	d9403317 	ldw	r5,204(sp)
 101780c:	84000044 	addi	r16,r16,1
 1017810:	8c400044 	addi	r17,r17,1
 1017814:	28bfffc4 	addi	r2,r5,-1
 1017818:	1887883a 	add	r3,r3,r2
 101781c:	b0800115 	stw	r2,4(r22)
 1017820:	b4000015 	stw	r16,0(r22)
 1017824:	d8c02015 	stw	r3,128(sp)
 1017828:	dc401f15 	stw	r17,124(sp)
 101782c:	008001c4 	movi	r2,7
 1017830:	1440d216 	blt	r2,r17,1017b7c <___svfprintf_internal_r+0x1374>
 1017834:	b5800204 	addi	r22,r22,8
 1017838:	d9003b17 	ldw	r4,236(sp)
 101783c:	df0022c4 	addi	fp,sp,139
 1017840:	8c400044 	addi	r17,r17,1
 1017844:	20c7883a 	add	r3,r4,r3
 1017848:	b7000015 	stw	fp,0(r22)
 101784c:	b1000115 	stw	r4,4(r22)
 1017850:	d8c02015 	stw	r3,128(sp)
 1017854:	dc401f15 	stw	r17,124(sp)
 1017858:	008001c4 	movi	r2,7
 101785c:	14400e16 	blt	r2,r17,1017898 <___svfprintf_internal_r+0x1090>
 1017860:	b2000204 	addi	r8,r22,8
 1017864:	003e3c06 	br	1017158 <__alt_data_end+0xff017158>
 1017868:	010040f4 	movhi	r4,259
 101786c:	212a8c84 	addi	r4,r4,-21966
 1017870:	d9002b15 	stw	r4,172(sp)
 1017874:	d9002b17 	ldw	r4,172(sp)
 1017878:	1c07883a 	add	r3,r3,r16
 101787c:	44000115 	stw	r16,4(r8)
 1017880:	41000015 	stw	r4,0(r8)
 1017884:	10800044 	addi	r2,r2,1
 1017888:	d8c02015 	stw	r3,128(sp)
 101788c:	d8801f15 	stw	r2,124(sp)
 1017890:	010001c4 	movi	r4,7
 1017894:	20be2f0e 	bge	r4,r2,1017154 <__alt_data_end+0xff017154>
 1017898:	d9402c17 	ldw	r5,176(sp)
 101789c:	d9801e04 	addi	r6,sp,120
 10178a0:	9809883a 	mov	r4,r19
 10178a4:	101fed00 	call	101fed0 <__ssprint_r>
 10178a8:	103cbc1e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 10178ac:	d8c02017 	ldw	r3,128(sp)
 10178b0:	da000404 	addi	r8,sp,16
 10178b4:	003e2806 	br	1017158 <__alt_data_end+0xff017158>
 10178b8:	d9402c17 	ldw	r5,176(sp)
 10178bc:	d9801e04 	addi	r6,sp,120
 10178c0:	9809883a 	mov	r4,r19
 10178c4:	101fed00 	call	101fed0 <__ssprint_r>
 10178c8:	103e5f26 	beq	r2,zero,1017248 <__alt_data_end+0xff017248>
 10178cc:	003cb306 	br	1016b9c <__alt_data_end+0xff016b9c>
 10178d0:	d9402c17 	ldw	r5,176(sp)
 10178d4:	d9801e04 	addi	r6,sp,120
 10178d8:	9809883a 	mov	r4,r19
 10178dc:	101fed00 	call	101fed0 <__ssprint_r>
 10178e0:	103cae1e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 10178e4:	d8c02017 	ldw	r3,128(sp)
 10178e8:	da000404 	addi	r8,sp,16
 10178ec:	003e0d06 	br	1017124 <__alt_data_end+0xff017124>
 10178f0:	d9402c17 	ldw	r5,176(sp)
 10178f4:	d9801e04 	addi	r6,sp,120
 10178f8:	9809883a 	mov	r4,r19
 10178fc:	101fed00 	call	101fed0 <__ssprint_r>
 1017900:	103ca61e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017904:	d8c02017 	ldw	r3,128(sp)
 1017908:	da000404 	addi	r8,sp,16
 101790c:	003dc106 	br	1017014 <__alt_data_end+0xff017014>
 1017910:	d9402c17 	ldw	r5,176(sp)
 1017914:	d9801e04 	addi	r6,sp,120
 1017918:	9809883a 	mov	r4,r19
 101791c:	101fed00 	call	101fed0 <__ssprint_r>
 1017920:	103c9e1e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017924:	d8c02017 	ldw	r3,128(sp)
 1017928:	da000404 	addi	r8,sp,16
 101792c:	003dc706 	br	101704c <__alt_data_end+0xff01704c>
 1017930:	d8802917 	ldw	r2,164(sp)
 1017934:	d8002785 	stb	zero,158(sp)
 1017938:	103f0816 	blt	r2,zero,101755c <__alt_data_end+0xff01755c>
 101793c:	00ffdfc4 	movi	r3,-129
 1017940:	a584b03a 	or	r2,r20,r22
 1017944:	90e4703a 	and	r18,r18,r3
 1017948:	103c8126 	beq	r2,zero,1016b50 <__alt_data_end+0xff016b50>
 101794c:	0039883a 	mov	fp,zero
 1017950:	003e7606 	br	101732c <__alt_data_end+0xff01732c>
 1017954:	9080040c 	andi	r2,r18,16
 1017958:	10013d26 	beq	r2,zero,1017e50 <___svfprintf_internal_r+0x1648>
 101795c:	d9002d17 	ldw	r4,180(sp)
 1017960:	d9402917 	ldw	r5,164(sp)
 1017964:	d8002785 	stb	zero,158(sp)
 1017968:	20800104 	addi	r2,r4,4
 101796c:	25000017 	ldw	r20,0(r4)
 1017970:	002d883a 	mov	r22,zero
 1017974:	28013f16 	blt	r5,zero,1017e74 <___svfprintf_internal_r+0x166c>
 1017978:	00ffdfc4 	movi	r3,-129
 101797c:	d8802d15 	stw	r2,180(sp)
 1017980:	90e4703a 	and	r18,r18,r3
 1017984:	a03d2b26 	beq	r20,zero,1016e34 <__alt_data_end+0xff016e34>
 1017988:	0039883a 	mov	fp,zero
 101798c:	003d2e06 	br	1016e48 <__alt_data_end+0xff016e48>
 1017990:	dc402617 	ldw	r17,152(sp)
 1017994:	0441830e 	bge	zero,r17,1017fa4 <___svfprintf_internal_r+0x179c>
 1017998:	dc403217 	ldw	r17,200(sp)
 101799c:	d8803317 	ldw	r2,204(sp)
 10179a0:	1440010e 	bge	r2,r17,10179a8 <___svfprintf_internal_r+0x11a0>
 10179a4:	1023883a 	mov	r17,r2
 10179a8:	04400a0e 	bge	zero,r17,10179d4 <___svfprintf_internal_r+0x11cc>
 10179ac:	d8801f17 	ldw	r2,124(sp)
 10179b0:	1c47883a 	add	r3,r3,r17
 10179b4:	44000015 	stw	r16,0(r8)
 10179b8:	10800044 	addi	r2,r2,1
 10179bc:	44400115 	stw	r17,4(r8)
 10179c0:	d8c02015 	stw	r3,128(sp)
 10179c4:	d8801f15 	stw	r2,124(sp)
 10179c8:	010001c4 	movi	r4,7
 10179cc:	20827516 	blt	r4,r2,10183a4 <___svfprintf_internal_r+0x1b9c>
 10179d0:	42000204 	addi	r8,r8,8
 10179d4:	88027b16 	blt	r17,zero,10183c4 <___svfprintf_internal_r+0x1bbc>
 10179d8:	d9003217 	ldw	r4,200(sp)
 10179dc:	2463c83a 	sub	r17,r4,r17
 10179e0:	0440990e 	bge	zero,r17,1017c48 <___svfprintf_internal_r+0x1440>
 10179e4:	05800404 	movi	r22,16
 10179e8:	d8801f17 	ldw	r2,124(sp)
 10179ec:	b441530e 	bge	r22,r17,1017f3c <___svfprintf_internal_r+0x1734>
 10179f0:	010040f4 	movhi	r4,259
 10179f4:	212a8c84 	addi	r4,r4,-21966
 10179f8:	d9002b15 	stw	r4,172(sp)
 10179fc:	070001c4 	movi	fp,7
 1017a00:	dd002c17 	ldw	r20,176(sp)
 1017a04:	00000306 	br	1017a14 <___svfprintf_internal_r+0x120c>
 1017a08:	42000204 	addi	r8,r8,8
 1017a0c:	8c7ffc04 	addi	r17,r17,-16
 1017a10:	b4414d0e 	bge	r22,r17,1017f48 <___svfprintf_internal_r+0x1740>
 1017a14:	18c00404 	addi	r3,r3,16
 1017a18:	10800044 	addi	r2,r2,1
 1017a1c:	45400015 	stw	r21,0(r8)
 1017a20:	45800115 	stw	r22,4(r8)
 1017a24:	d8c02015 	stw	r3,128(sp)
 1017a28:	d8801f15 	stw	r2,124(sp)
 1017a2c:	e0bff60e 	bge	fp,r2,1017a08 <__alt_data_end+0xff017a08>
 1017a30:	d9801e04 	addi	r6,sp,120
 1017a34:	a00b883a 	mov	r5,r20
 1017a38:	9809883a 	mov	r4,r19
 1017a3c:	101fed00 	call	101fed0 <__ssprint_r>
 1017a40:	103c561e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017a44:	d8c02017 	ldw	r3,128(sp)
 1017a48:	d8801f17 	ldw	r2,124(sp)
 1017a4c:	da000404 	addi	r8,sp,16
 1017a50:	003fee06 	br	1017a0c <__alt_data_end+0xff017a0c>
 1017a54:	d9402c17 	ldw	r5,176(sp)
 1017a58:	d9801e04 	addi	r6,sp,120
 1017a5c:	9809883a 	mov	r4,r19
 1017a60:	101fed00 	call	101fed0 <__ssprint_r>
 1017a64:	103c4d1e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017a68:	d8c02017 	ldw	r3,128(sp)
 1017a6c:	df002787 	ldb	fp,158(sp)
 1017a70:	da000404 	addi	r8,sp,16
 1017a74:	003d5a06 	br	1016fe0 <__alt_data_end+0xff016fe0>
 1017a78:	9080040c 	andi	r2,r18,16
 1017a7c:	10005c26 	beq	r2,zero,1017bf0 <___svfprintf_internal_r+0x13e8>
 1017a80:	d9402d17 	ldw	r5,180(sp)
 1017a84:	d8c02917 	ldw	r3,164(sp)
 1017a88:	d8002785 	stb	zero,158(sp)
 1017a8c:	28800104 	addi	r2,r5,4
 1017a90:	2d000017 	ldw	r20,0(r5)
 1017a94:	002d883a 	mov	r22,zero
 1017a98:	18005e16 	blt	r3,zero,1017c14 <___svfprintf_internal_r+0x140c>
 1017a9c:	00ffdfc4 	movi	r3,-129
 1017aa0:	d8802d15 	stw	r2,180(sp)
 1017aa4:	90e4703a 	and	r18,r18,r3
 1017aa8:	0039883a 	mov	fp,zero
 1017aac:	a03dfe26 	beq	r20,zero,10172a8 <__alt_data_end+0xff0172a8>
 1017ab0:	00800244 	movi	r2,9
 1017ab4:	153cb336 	bltu	r2,r20,1016d84 <__alt_data_end+0xff016d84>
 1017ab8:	a5000c04 	addi	r20,r20,48
 1017abc:	dc001dc4 	addi	r16,sp,119
 1017ac0:	dd001dc5 	stb	r20,119(sp)
 1017ac4:	d8c02817 	ldw	r3,160(sp)
 1017ac8:	1c07c83a 	sub	r3,r3,r16
 1017acc:	d8c02e15 	stw	r3,184(sp)
 1017ad0:	003cf506 	br	1016ea8 <__alt_data_end+0xff016ea8>
 1017ad4:	d8803317 	ldw	r2,204(sp)
 1017ad8:	143fffc4 	addi	r16,r2,-1
 1017adc:	043f560e 	bge	zero,r16,1017838 <__alt_data_end+0xff017838>
 1017ae0:	07000404 	movi	fp,16
 1017ae4:	e403530e 	bge	fp,r16,1018834 <___svfprintf_internal_r+0x202c>
 1017ae8:	014040f4 	movhi	r5,259
 1017aec:	296a8c84 	addi	r5,r5,-21966
 1017af0:	d9402b15 	stw	r5,172(sp)
 1017af4:	01c001c4 	movi	r7,7
 1017af8:	dd002c17 	ldw	r20,176(sp)
 1017afc:	00000306 	br	1017b0c <___svfprintf_internal_r+0x1304>
 1017b00:	843ffc04 	addi	r16,r16,-16
 1017b04:	b5800204 	addi	r22,r22,8
 1017b08:	e400130e 	bge	fp,r16,1017b58 <___svfprintf_internal_r+0x1350>
 1017b0c:	18c00404 	addi	r3,r3,16
 1017b10:	8c400044 	addi	r17,r17,1
 1017b14:	b5400015 	stw	r21,0(r22)
 1017b18:	b7000115 	stw	fp,4(r22)
 1017b1c:	d8c02015 	stw	r3,128(sp)
 1017b20:	dc401f15 	stw	r17,124(sp)
 1017b24:	3c7ff60e 	bge	r7,r17,1017b00 <__alt_data_end+0xff017b00>
 1017b28:	d9801e04 	addi	r6,sp,120
 1017b2c:	a00b883a 	mov	r5,r20
 1017b30:	9809883a 	mov	r4,r19
 1017b34:	d9c03d15 	stw	r7,244(sp)
 1017b38:	101fed00 	call	101fed0 <__ssprint_r>
 1017b3c:	d9c03d17 	ldw	r7,244(sp)
 1017b40:	103c161e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017b44:	843ffc04 	addi	r16,r16,-16
 1017b48:	d8c02017 	ldw	r3,128(sp)
 1017b4c:	dc401f17 	ldw	r17,124(sp)
 1017b50:	dd800404 	addi	r22,sp,16
 1017b54:	e43fed16 	blt	fp,r16,1017b0c <__alt_data_end+0xff017b0c>
 1017b58:	d8802b17 	ldw	r2,172(sp)
 1017b5c:	1c07883a 	add	r3,r3,r16
 1017b60:	8c400044 	addi	r17,r17,1
 1017b64:	b0800015 	stw	r2,0(r22)
 1017b68:	b4000115 	stw	r16,4(r22)
 1017b6c:	d8c02015 	stw	r3,128(sp)
 1017b70:	dc401f15 	stw	r17,124(sp)
 1017b74:	008001c4 	movi	r2,7
 1017b78:	147f2e0e 	bge	r2,r17,1017834 <__alt_data_end+0xff017834>
 1017b7c:	d9402c17 	ldw	r5,176(sp)
 1017b80:	d9801e04 	addi	r6,sp,120
 1017b84:	9809883a 	mov	r4,r19
 1017b88:	101fed00 	call	101fed0 <__ssprint_r>
 1017b8c:	103c031e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017b90:	d8c02017 	ldw	r3,128(sp)
 1017b94:	dc401f17 	ldw	r17,124(sp)
 1017b98:	dd800404 	addi	r22,sp,16
 1017b9c:	003f2606 	br	1017838 <__alt_data_end+0xff017838>
 1017ba0:	9080040c 	andi	r2,r18,16
 1017ba4:	1000c326 	beq	r2,zero,1017eb4 <___svfprintf_internal_r+0x16ac>
 1017ba8:	d8802d17 	ldw	r2,180(sp)
 1017bac:	15000017 	ldw	r20,0(r2)
 1017bb0:	10800104 	addi	r2,r2,4
 1017bb4:	d8802d15 	stw	r2,180(sp)
 1017bb8:	a02dd7fa 	srai	r22,r20,31
 1017bbc:	b005883a 	mov	r2,r22
 1017bc0:	103c680e 	bge	r2,zero,1016d64 <__alt_data_end+0xff016d64>
 1017bc4:	0529c83a 	sub	r20,zero,r20
 1017bc8:	a004c03a 	cmpne	r2,r20,zero
 1017bcc:	05adc83a 	sub	r22,zero,r22
 1017bd0:	b0adc83a 	sub	r22,r22,r2
 1017bd4:	d8802917 	ldw	r2,164(sp)
 1017bd8:	07000b44 	movi	fp,45
 1017bdc:	df002785 	stb	fp,158(sp)
 1017be0:	10022e16 	blt	r2,zero,101849c <___svfprintf_internal_r+0x1c94>
 1017be4:	00bfdfc4 	movi	r2,-129
 1017be8:	90a4703a 	and	r18,r18,r2
 1017bec:	003c6406 	br	1016d80 <__alt_data_end+0xff016d80>
 1017bf0:	9080100c 	andi	r2,r18,64
 1017bf4:	d8002785 	stb	zero,158(sp)
 1017bf8:	10012526 	beq	r2,zero,1018090 <___svfprintf_internal_r+0x1888>
 1017bfc:	d9002d17 	ldw	r4,180(sp)
 1017c00:	d9402917 	ldw	r5,164(sp)
 1017c04:	002d883a 	mov	r22,zero
 1017c08:	20800104 	addi	r2,r4,4
 1017c0c:	2500000b 	ldhu	r20,0(r4)
 1017c10:	283fa20e 	bge	r5,zero,1017a9c <__alt_data_end+0xff017a9c>
 1017c14:	d8802d15 	stw	r2,180(sp)
 1017c18:	0039883a 	mov	fp,zero
 1017c1c:	a584b03a 	or	r2,r20,r22
 1017c20:	103c571e 	bne	r2,zero,1016d80 <__alt_data_end+0xff016d80>
 1017c24:	00800044 	movi	r2,1
 1017c28:	003e5006 	br	101756c <__alt_data_end+0xff01756c>
 1017c2c:	d9402c17 	ldw	r5,176(sp)
 1017c30:	d9801e04 	addi	r6,sp,120
 1017c34:	9809883a 	mov	r4,r19
 1017c38:	101fed00 	call	101fed0 <__ssprint_r>
 1017c3c:	103bd71e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017c40:	d8c02017 	ldw	r3,128(sp)
 1017c44:	da000404 	addi	r8,sp,16
 1017c48:	d9003217 	ldw	r4,200(sp)
 1017c4c:	d8802617 	ldw	r2,152(sp)
 1017c50:	d9403317 	ldw	r5,204(sp)
 1017c54:	8123883a 	add	r17,r16,r4
 1017c58:	11400216 	blt	r2,r5,1017c64 <___svfprintf_internal_r+0x145c>
 1017c5c:	9100004c 	andi	r4,r18,1
 1017c60:	20000d26 	beq	r4,zero,1017c98 <___svfprintf_internal_r+0x1490>
 1017c64:	d9003817 	ldw	r4,224(sp)
 1017c68:	d9403417 	ldw	r5,208(sp)
 1017c6c:	1907883a 	add	r3,r3,r4
 1017c70:	d9001f17 	ldw	r4,124(sp)
 1017c74:	41400015 	stw	r5,0(r8)
 1017c78:	d9403817 	ldw	r5,224(sp)
 1017c7c:	21000044 	addi	r4,r4,1
 1017c80:	d8c02015 	stw	r3,128(sp)
 1017c84:	41400115 	stw	r5,4(r8)
 1017c88:	d9001f15 	stw	r4,124(sp)
 1017c8c:	014001c4 	movi	r5,7
 1017c90:	2901dc16 	blt	r5,r4,1018404 <___svfprintf_internal_r+0x1bfc>
 1017c94:	42000204 	addi	r8,r8,8
 1017c98:	d9003317 	ldw	r4,204(sp)
 1017c9c:	8121883a 	add	r16,r16,r4
 1017ca0:	2085c83a 	sub	r2,r4,r2
 1017ca4:	8461c83a 	sub	r16,r16,r17
 1017ca8:	1400010e 	bge	r2,r16,1017cb0 <___svfprintf_internal_r+0x14a8>
 1017cac:	1021883a 	mov	r16,r2
 1017cb0:	04000a0e 	bge	zero,r16,1017cdc <___svfprintf_internal_r+0x14d4>
 1017cb4:	d9001f17 	ldw	r4,124(sp)
 1017cb8:	1c07883a 	add	r3,r3,r16
 1017cbc:	44400015 	stw	r17,0(r8)
 1017cc0:	21000044 	addi	r4,r4,1
 1017cc4:	44000115 	stw	r16,4(r8)
 1017cc8:	d8c02015 	stw	r3,128(sp)
 1017ccc:	d9001f15 	stw	r4,124(sp)
 1017cd0:	014001c4 	movi	r5,7
 1017cd4:	2901e616 	blt	r5,r4,1018470 <___svfprintf_internal_r+0x1c68>
 1017cd8:	42000204 	addi	r8,r8,8
 1017cdc:	8001f616 	blt	r16,zero,10184b8 <___svfprintf_internal_r+0x1cb0>
 1017ce0:	1421c83a 	sub	r16,r2,r16
 1017ce4:	043d1c0e 	bge	zero,r16,1017158 <__alt_data_end+0xff017158>
 1017ce8:	04400404 	movi	r17,16
 1017cec:	d8801f17 	ldw	r2,124(sp)
 1017cf0:	8c3edd0e 	bge	r17,r16,1017868 <__alt_data_end+0xff017868>
 1017cf4:	014040f4 	movhi	r5,259
 1017cf8:	296a8c84 	addi	r5,r5,-21966
 1017cfc:	d9402b15 	stw	r5,172(sp)
 1017d00:	058001c4 	movi	r22,7
 1017d04:	dd002c17 	ldw	r20,176(sp)
 1017d08:	00000306 	br	1017d18 <___svfprintf_internal_r+0x1510>
 1017d0c:	42000204 	addi	r8,r8,8
 1017d10:	843ffc04 	addi	r16,r16,-16
 1017d14:	8c3ed70e 	bge	r17,r16,1017874 <__alt_data_end+0xff017874>
 1017d18:	18c00404 	addi	r3,r3,16
 1017d1c:	10800044 	addi	r2,r2,1
 1017d20:	45400015 	stw	r21,0(r8)
 1017d24:	44400115 	stw	r17,4(r8)
 1017d28:	d8c02015 	stw	r3,128(sp)
 1017d2c:	d8801f15 	stw	r2,124(sp)
 1017d30:	b0bff60e 	bge	r22,r2,1017d0c <__alt_data_end+0xff017d0c>
 1017d34:	d9801e04 	addi	r6,sp,120
 1017d38:	a00b883a 	mov	r5,r20
 1017d3c:	9809883a 	mov	r4,r19
 1017d40:	101fed00 	call	101fed0 <__ssprint_r>
 1017d44:	103b951e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017d48:	d8c02017 	ldw	r3,128(sp)
 1017d4c:	d8801f17 	ldw	r2,124(sp)
 1017d50:	da000404 	addi	r8,sp,16
 1017d54:	003fee06 	br	1017d10 <__alt_data_end+0xff017d10>
 1017d58:	9088703a 	and	r4,r18,r2
 1017d5c:	203e8d1e 	bne	r4,zero,1017794 <__alt_data_end+0xff017794>
 1017d60:	dc401f17 	ldw	r17,124(sp)
 1017d64:	40800115 	stw	r2,4(r8)
 1017d68:	44000015 	stw	r16,0(r8)
 1017d6c:	8c400044 	addi	r17,r17,1
 1017d70:	d8c02015 	stw	r3,128(sp)
 1017d74:	dc401f15 	stw	r17,124(sp)
 1017d78:	008001c4 	movi	r2,7
 1017d7c:	147f7f16 	blt	r2,r17,1017b7c <__alt_data_end+0xff017b7c>
 1017d80:	45800204 	addi	r22,r8,8
 1017d84:	003eac06 	br	1017838 <__alt_data_end+0xff017838>
 1017d88:	d9402c17 	ldw	r5,176(sp)
 1017d8c:	d9801e04 	addi	r6,sp,120
 1017d90:	9809883a 	mov	r4,r19
 1017d94:	101fed00 	call	101fed0 <__ssprint_r>
 1017d98:	103b801e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017d9c:	d8c02017 	ldw	r3,128(sp)
 1017da0:	dc401f17 	ldw	r17,124(sp)
 1017da4:	da000404 	addi	r8,sp,16
 1017da8:	003e8406 	br	10177bc <__alt_data_end+0xff0177bc>
 1017dac:	d9402c17 	ldw	r5,176(sp)
 1017db0:	d9801e04 	addi	r6,sp,120
 1017db4:	9809883a 	mov	r4,r19
 1017db8:	101fed00 	call	101fed0 <__ssprint_r>
 1017dbc:	103b771e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017dc0:	d8c02017 	ldw	r3,128(sp)
 1017dc4:	dc401f17 	ldw	r17,124(sp)
 1017dc8:	dd800404 	addi	r22,sp,16
 1017dcc:	003e8606 	br	10177e8 <__alt_data_end+0xff0177e8>
 1017dd0:	0029883a 	mov	r20,zero
 1017dd4:	a5000c04 	addi	r20,r20,48
 1017dd8:	dc001dc4 	addi	r16,sp,119
 1017ddc:	dd001dc5 	stb	r20,119(sp)
 1017de0:	003f3806 	br	1017ac4 <__alt_data_end+0xff017ac4>
 1017de4:	d9402c17 	ldw	r5,176(sp)
 1017de8:	d9801e04 	addi	r6,sp,120
 1017dec:	9809883a 	mov	r4,r19
 1017df0:	101fed00 	call	101fed0 <__ssprint_r>
 1017df4:	103b691e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017df8:	d8c02017 	ldw	r3,128(sp)
 1017dfc:	da000404 	addi	r8,sp,16
 1017e00:	003c9506 	br	1017058 <__alt_data_end+0xff017058>
 1017e04:	d9003617 	ldw	r4,216(sp)
 1017e08:	d9403717 	ldw	r5,220(sp)
 1017e0c:	da003e15 	stw	r8,248(sp)
 1017e10:	101f9c80 	call	101f9c8 <__fpclassifyd>
 1017e14:	da003e17 	ldw	r8,248(sp)
 1017e18:	1000bd1e 	bne	r2,zero,1018110 <___svfprintf_internal_r+0x1908>
 1017e1c:	008011c4 	movi	r2,71
 1017e20:	14411e0e 	bge	r2,r17,101829c <___svfprintf_internal_r+0x1a94>
 1017e24:	040040f4 	movhi	r16,259
 1017e28:	842a7f04 	addi	r16,r16,-22020
 1017e2c:	00c000c4 	movi	r3,3
 1017e30:	00bfdfc4 	movi	r2,-129
 1017e34:	d8c02a15 	stw	r3,168(sp)
 1017e38:	90a4703a 	and	r18,r18,r2
 1017e3c:	df002783 	ldbu	fp,158(sp)
 1017e40:	d8c02e15 	stw	r3,184(sp)
 1017e44:	d8002915 	stw	zero,164(sp)
 1017e48:	d8003215 	stw	zero,200(sp)
 1017e4c:	003c1c06 	br	1016ec0 <__alt_data_end+0xff016ec0>
 1017e50:	9080100c 	andi	r2,r18,64
 1017e54:	d8002785 	stb	zero,158(sp)
 1017e58:	10009426 	beq	r2,zero,10180ac <___svfprintf_internal_r+0x18a4>
 1017e5c:	d8c02d17 	ldw	r3,180(sp)
 1017e60:	d9002917 	ldw	r4,164(sp)
 1017e64:	002d883a 	mov	r22,zero
 1017e68:	18800104 	addi	r2,r3,4
 1017e6c:	1d00000b 	ldhu	r20,0(r3)
 1017e70:	203ec10e 	bge	r4,zero,1017978 <__alt_data_end+0xff017978>
 1017e74:	a586b03a 	or	r3,r20,r22
 1017e78:	d8802d15 	stw	r2,180(sp)
 1017e7c:	183ec21e 	bne	r3,zero,1017988 <__alt_data_end+0xff017988>
 1017e80:	0039883a 	mov	fp,zero
 1017e84:	0005883a 	mov	r2,zero
 1017e88:	003db806 	br	101756c <__alt_data_end+0xff01756c>
 1017e8c:	d8802d17 	ldw	r2,180(sp)
 1017e90:	d8c02d17 	ldw	r3,180(sp)
 1017e94:	d9002d17 	ldw	r4,180(sp)
 1017e98:	10800017 	ldw	r2,0(r2)
 1017e9c:	18c00117 	ldw	r3,4(r3)
 1017ea0:	21000204 	addi	r4,r4,8
 1017ea4:	d8803615 	stw	r2,216(sp)
 1017ea8:	d8c03715 	stw	r3,220(sp)
 1017eac:	d9002d15 	stw	r4,180(sp)
 1017eb0:	003b8206 	br	1016cbc <__alt_data_end+0xff016cbc>
 1017eb4:	9080100c 	andi	r2,r18,64
 1017eb8:	10010726 	beq	r2,zero,10182d8 <___svfprintf_internal_r+0x1ad0>
 1017ebc:	d8c02d17 	ldw	r3,180(sp)
 1017ec0:	1d00000f 	ldh	r20,0(r3)
 1017ec4:	18c00104 	addi	r3,r3,4
 1017ec8:	d8c02d15 	stw	r3,180(sp)
 1017ecc:	a02dd7fa 	srai	r22,r20,31
 1017ed0:	b005883a 	mov	r2,r22
 1017ed4:	003ba206 	br	1016d60 <__alt_data_end+0xff016d60>
 1017ed8:	9080100c 	andi	r2,r18,64
 1017edc:	10010526 	beq	r2,zero,10182f4 <___svfprintf_internal_r+0x1aec>
 1017ee0:	d9002d17 	ldw	r4,180(sp)
 1017ee4:	002d883a 	mov	r22,zero
 1017ee8:	2500000b 	ldhu	r20,0(r4)
 1017eec:	21000104 	addi	r4,r4,4
 1017ef0:	d9002d15 	stw	r4,180(sp)
 1017ef4:	003cfe06 	br	10172f0 <__alt_data_end+0xff0172f0>
 1017ef8:	bc400007 	ldb	r17,0(r23)
 1017efc:	003a9606 	br	1016958 <__alt_data_end+0xff016958>
 1017f00:	9080040c 	andi	r2,r18,16
 1017f04:	10010126 	beq	r2,zero,101830c <___svfprintf_internal_r+0x1b04>
 1017f08:	d9402d17 	ldw	r5,180(sp)
 1017f0c:	d8c02f17 	ldw	r3,188(sp)
 1017f10:	28800017 	ldw	r2,0(r5)
 1017f14:	29400104 	addi	r5,r5,4
 1017f18:	d9402d15 	stw	r5,180(sp)
 1017f1c:	10c00015 	stw	r3,0(r2)
 1017f20:	003a6406 	br	10168b4 <__alt_data_end+0xff0168b4>
 1017f24:	d9002917 	ldw	r4,164(sp)
 1017f28:	d8002785 	stb	zero,158(sp)
 1017f2c:	203d8d16 	blt	r4,zero,1017564 <__alt_data_end+0xff017564>
 1017f30:	00bfdfc4 	movi	r2,-129
 1017f34:	90a4703a 	and	r18,r18,r2
 1017f38:	003b0506 	br	1016b50 <__alt_data_end+0xff016b50>
 1017f3c:	014040f4 	movhi	r5,259
 1017f40:	296a8c84 	addi	r5,r5,-21966
 1017f44:	d9402b15 	stw	r5,172(sp)
 1017f48:	d9402b17 	ldw	r5,172(sp)
 1017f4c:	1c47883a 	add	r3,r3,r17
 1017f50:	10800044 	addi	r2,r2,1
 1017f54:	41400015 	stw	r5,0(r8)
 1017f58:	44400115 	stw	r17,4(r8)
 1017f5c:	d8c02015 	stw	r3,128(sp)
 1017f60:	d8801f15 	stw	r2,124(sp)
 1017f64:	010001c4 	movi	r4,7
 1017f68:	20bf3016 	blt	r4,r2,1017c2c <__alt_data_end+0xff017c2c>
 1017f6c:	42000204 	addi	r8,r8,8
 1017f70:	003f3506 	br	1017c48 <__alt_data_end+0xff017c48>
 1017f74:	010040f4 	movhi	r4,259
 1017f78:	212a8c84 	addi	r4,r4,-21966
 1017f7c:	d9002b15 	stw	r4,172(sp)
 1017f80:	003c5e06 	br	10170fc <__alt_data_end+0xff0170fc>
 1017f84:	d9402c17 	ldw	r5,176(sp)
 1017f88:	d9801e04 	addi	r6,sp,120
 1017f8c:	9809883a 	mov	r4,r19
 1017f90:	101fed00 	call	101fed0 <__ssprint_r>
 1017f94:	103b011e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1017f98:	d8c02017 	ldw	r3,128(sp)
 1017f9c:	da000404 	addi	r8,sp,16
 1017fa0:	003d9306 	br	10175f0 <__alt_data_end+0xff0175f0>
 1017fa4:	d8801f17 	ldw	r2,124(sp)
 1017fa8:	014040f4 	movhi	r5,259
 1017fac:	01000044 	movi	r4,1
 1017fb0:	18c00044 	addi	r3,r3,1
 1017fb4:	10800044 	addi	r2,r2,1
 1017fb8:	296a8c04 	addi	r5,r5,-21968
 1017fbc:	41000115 	stw	r4,4(r8)
 1017fc0:	41400015 	stw	r5,0(r8)
 1017fc4:	d8c02015 	stw	r3,128(sp)
 1017fc8:	d8801f15 	stw	r2,124(sp)
 1017fcc:	010001c4 	movi	r4,7
 1017fd0:	2080b516 	blt	r4,r2,10182a8 <___svfprintf_internal_r+0x1aa0>
 1017fd4:	42000204 	addi	r8,r8,8
 1017fd8:	8800041e 	bne	r17,zero,1017fec <___svfprintf_internal_r+0x17e4>
 1017fdc:	d8803317 	ldw	r2,204(sp)
 1017fe0:	1000021e 	bne	r2,zero,1017fec <___svfprintf_internal_r+0x17e4>
 1017fe4:	9080004c 	andi	r2,r18,1
 1017fe8:	103c5b26 	beq	r2,zero,1017158 <__alt_data_end+0xff017158>
 1017fec:	d9003817 	ldw	r4,224(sp)
 1017ff0:	d8801f17 	ldw	r2,124(sp)
 1017ff4:	d9403417 	ldw	r5,208(sp)
 1017ff8:	20c7883a 	add	r3,r4,r3
 1017ffc:	10800044 	addi	r2,r2,1
 1018000:	41000115 	stw	r4,4(r8)
 1018004:	41400015 	stw	r5,0(r8)
 1018008:	d8c02015 	stw	r3,128(sp)
 101800c:	d8801f15 	stw	r2,124(sp)
 1018010:	010001c4 	movi	r4,7
 1018014:	20818016 	blt	r4,r2,1018618 <___svfprintf_internal_r+0x1e10>
 1018018:	42000204 	addi	r8,r8,8
 101801c:	0463c83a 	sub	r17,zero,r17
 1018020:	0440cb0e 	bge	zero,r17,1018350 <___svfprintf_internal_r+0x1b48>
 1018024:	05800404 	movi	r22,16
 1018028:	b440e80e 	bge	r22,r17,10183cc <___svfprintf_internal_r+0x1bc4>
 101802c:	014040f4 	movhi	r5,259
 1018030:	296a8c84 	addi	r5,r5,-21966
 1018034:	d9402b15 	stw	r5,172(sp)
 1018038:	070001c4 	movi	fp,7
 101803c:	dd002c17 	ldw	r20,176(sp)
 1018040:	00000306 	br	1018050 <___svfprintf_internal_r+0x1848>
 1018044:	42000204 	addi	r8,r8,8
 1018048:	8c7ffc04 	addi	r17,r17,-16
 101804c:	b440e20e 	bge	r22,r17,10183d8 <___svfprintf_internal_r+0x1bd0>
 1018050:	18c00404 	addi	r3,r3,16
 1018054:	10800044 	addi	r2,r2,1
 1018058:	45400015 	stw	r21,0(r8)
 101805c:	45800115 	stw	r22,4(r8)
 1018060:	d8c02015 	stw	r3,128(sp)
 1018064:	d8801f15 	stw	r2,124(sp)
 1018068:	e0bff60e 	bge	fp,r2,1018044 <__alt_data_end+0xff018044>
 101806c:	d9801e04 	addi	r6,sp,120
 1018070:	a00b883a 	mov	r5,r20
 1018074:	9809883a 	mov	r4,r19
 1018078:	101fed00 	call	101fed0 <__ssprint_r>
 101807c:	103ac71e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1018080:	d8c02017 	ldw	r3,128(sp)
 1018084:	d8801f17 	ldw	r2,124(sp)
 1018088:	da000404 	addi	r8,sp,16
 101808c:	003fee06 	br	1018048 <__alt_data_end+0xff018048>
 1018090:	d8c02d17 	ldw	r3,180(sp)
 1018094:	d9002917 	ldw	r4,164(sp)
 1018098:	002d883a 	mov	r22,zero
 101809c:	18800104 	addi	r2,r3,4
 10180a0:	1d000017 	ldw	r20,0(r3)
 10180a4:	203e7d0e 	bge	r4,zero,1017a9c <__alt_data_end+0xff017a9c>
 10180a8:	003eda06 	br	1017c14 <__alt_data_end+0xff017c14>
 10180ac:	d9402d17 	ldw	r5,180(sp)
 10180b0:	d8c02917 	ldw	r3,164(sp)
 10180b4:	002d883a 	mov	r22,zero
 10180b8:	28800104 	addi	r2,r5,4
 10180bc:	2d000017 	ldw	r20,0(r5)
 10180c0:	183e2d0e 	bge	r3,zero,1017978 <__alt_data_end+0xff017978>
 10180c4:	003f6b06 	br	1017e74 <__alt_data_end+0xff017e74>
 10180c8:	d8c02d15 	stw	r3,180(sp)
 10180cc:	0039883a 	mov	fp,zero
 10180d0:	003ed206 	br	1017c1c <__alt_data_end+0xff017c1c>
 10180d4:	bc400043 	ldbu	r17,1(r23)
 10180d8:	94800814 	ori	r18,r18,32
 10180dc:	bdc00044 	addi	r23,r23,1
 10180e0:	8c403fcc 	andi	r17,r17,255
 10180e4:	8c40201c 	xori	r17,r17,128
 10180e8:	8c7fe004 	addi	r17,r17,-128
 10180ec:	003a1a06 	br	1016958 <__alt_data_end+0xff016958>
 10180f0:	d9402c17 	ldw	r5,176(sp)
 10180f4:	d9801e04 	addi	r6,sp,120
 10180f8:	9809883a 	mov	r4,r19
 10180fc:	101fed00 	call	101fed0 <__ssprint_r>
 1018100:	103aa61e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1018104:	d8c02017 	ldw	r3,128(sp)
 1018108:	da000404 	addi	r8,sp,16
 101810c:	003d4a06 	br	1017638 <__alt_data_end+0xff017638>
 1018110:	d9002917 	ldw	r4,164(sp)
 1018114:	05bff7c4 	movi	r22,-33
 1018118:	00bfffc4 	movi	r2,-1
 101811c:	8dac703a 	and	r22,r17,r22
 1018120:	20806a26 	beq	r4,r2,10182cc <___svfprintf_internal_r+0x1ac4>
 1018124:	008011c4 	movi	r2,71
 1018128:	b0813726 	beq	r22,r2,1018608 <___svfprintf_internal_r+0x1e00>
 101812c:	d9003717 	ldw	r4,220(sp)
 1018130:	90c04014 	ori	r3,r18,256
 1018134:	d8c02b15 	stw	r3,172(sp)
 1018138:	20015d16 	blt	r4,zero,10186b0 <___svfprintf_internal_r+0x1ea8>
 101813c:	dd003717 	ldw	r20,220(sp)
 1018140:	d8002a05 	stb	zero,168(sp)
 1018144:	00801984 	movi	r2,102
 1018148:	88814026 	beq	r17,r2,101864c <___svfprintf_internal_r+0x1e44>
 101814c:	00801184 	movi	r2,70
 1018150:	88817126 	beq	r17,r2,1018718 <___svfprintf_internal_r+0x1f10>
 1018154:	00801144 	movi	r2,69
 1018158:	b0816226 	beq	r22,r2,10186e4 <___svfprintf_internal_r+0x1edc>
 101815c:	d8c02917 	ldw	r3,164(sp)
 1018160:	d8802104 	addi	r2,sp,132
 1018164:	d8800315 	stw	r2,12(sp)
 1018168:	d9403617 	ldw	r5,216(sp)
 101816c:	d8802504 	addi	r2,sp,148
 1018170:	d8800215 	stw	r2,8(sp)
 1018174:	d8802604 	addi	r2,sp,152
 1018178:	d8c00015 	stw	r3,0(sp)
 101817c:	d8800115 	stw	r2,4(sp)
 1018180:	01c00084 	movi	r7,2
 1018184:	a00d883a 	mov	r6,r20
 1018188:	9809883a 	mov	r4,r19
 101818c:	d8c03d15 	stw	r3,244(sp)
 1018190:	da003e15 	stw	r8,248(sp)
 1018194:	101b03c0 	call	101b03c <_dtoa_r>
 1018198:	1021883a 	mov	r16,r2
 101819c:	008019c4 	movi	r2,103
 10181a0:	d8c03d17 	ldw	r3,244(sp)
 10181a4:	da003e17 	ldw	r8,248(sp)
 10181a8:	8880e726 	beq	r17,r2,1018548 <___svfprintf_internal_r+0x1d40>
 10181ac:	008011c4 	movi	r2,71
 10181b0:	8880d426 	beq	r17,r2,1018504 <___svfprintf_internal_r+0x1cfc>
 10181b4:	80f9883a 	add	fp,r16,r3
 10181b8:	d9003617 	ldw	r4,216(sp)
 10181bc:	000d883a 	mov	r6,zero
 10181c0:	000f883a 	mov	r7,zero
 10181c4:	a00b883a 	mov	r5,r20
 10181c8:	da003e15 	stw	r8,248(sp)
 10181cc:	10250500 	call	1025050 <__eqdf2>
 10181d0:	da003e17 	ldw	r8,248(sp)
 10181d4:	1000e426 	beq	r2,zero,1018568 <___svfprintf_internal_r+0x1d60>
 10181d8:	d8802117 	ldw	r2,132(sp)
 10181dc:	1700062e 	bgeu	r2,fp,10181f8 <___svfprintf_internal_r+0x19f0>
 10181e0:	01000c04 	movi	r4,48
 10181e4:	10c00044 	addi	r3,r2,1
 10181e8:	d8c02115 	stw	r3,132(sp)
 10181ec:	11000005 	stb	r4,0(r2)
 10181f0:	d8802117 	ldw	r2,132(sp)
 10181f4:	173ffb36 	bltu	r2,fp,10181e4 <__alt_data_end+0xff0181e4>
 10181f8:	1405c83a 	sub	r2,r2,r16
 10181fc:	d8803315 	stw	r2,204(sp)
 1018200:	008011c4 	movi	r2,71
 1018204:	b080c526 	beq	r22,r2,101851c <___svfprintf_internal_r+0x1d14>
 1018208:	00801944 	movi	r2,101
 101820c:	1441d90e 	bge	r2,r17,1018974 <___svfprintf_internal_r+0x216c>
 1018210:	d8c02617 	ldw	r3,152(sp)
 1018214:	00801984 	movi	r2,102
 1018218:	d8c03215 	stw	r3,200(sp)
 101821c:	88813426 	beq	r17,r2,10186f0 <___svfprintf_internal_r+0x1ee8>
 1018220:	d8c03217 	ldw	r3,200(sp)
 1018224:	d9003317 	ldw	r4,204(sp)
 1018228:	19012516 	blt	r3,r4,10186c0 <___svfprintf_internal_r+0x1eb8>
 101822c:	9480004c 	andi	r18,r18,1
 1018230:	9001841e 	bne	r18,zero,1018844 <___svfprintf_internal_r+0x203c>
 1018234:	1805883a 	mov	r2,r3
 1018238:	1801cc16 	blt	r3,zero,101896c <___svfprintf_internal_r+0x2164>
 101823c:	d8c03217 	ldw	r3,200(sp)
 1018240:	044019c4 	movi	r17,103
 1018244:	d8c02e15 	stw	r3,184(sp)
 1018248:	df002a07 	ldb	fp,168(sp)
 101824c:	e000a61e 	bne	fp,zero,10184e8 <___svfprintf_internal_r+0x1ce0>
 1018250:	df002783 	ldbu	fp,158(sp)
 1018254:	d8802a15 	stw	r2,168(sp)
 1018258:	dc802b17 	ldw	r18,172(sp)
 101825c:	d8002915 	stw	zero,164(sp)
 1018260:	003b1706 	br	1016ec0 <__alt_data_end+0xff016ec0>
 1018264:	040040f4 	movhi	r16,259
 1018268:	842a7c04 	addi	r16,r16,-22032
 101826c:	003aa606 	br	1016d08 <__alt_data_end+0xff016d08>
 1018270:	d9003917 	ldw	r4,228(sp)
 1018274:	04001004 	movi	r16,64
 1018278:	800b883a 	mov	r5,r16
 101827c:	101da1c0 	call	101da1c <_malloc_r>
 1018280:	d9002c17 	ldw	r4,176(sp)
 1018284:	20800015 	stw	r2,0(r4)
 1018288:	20800415 	stw	r2,16(r4)
 101828c:	1001cb26 	beq	r2,zero,10189bc <___svfprintf_internal_r+0x21b4>
 1018290:	d8802c17 	ldw	r2,176(sp)
 1018294:	14000515 	stw	r16,20(r2)
 1018298:	00397606 	br	1016874 <__alt_data_end+0xff016874>
 101829c:	040040f4 	movhi	r16,259
 10182a0:	842a7e04 	addi	r16,r16,-22024
 10182a4:	003ee106 	br	1017e2c <__alt_data_end+0xff017e2c>
 10182a8:	d9402c17 	ldw	r5,176(sp)
 10182ac:	d9801e04 	addi	r6,sp,120
 10182b0:	9809883a 	mov	r4,r19
 10182b4:	101fed00 	call	101fed0 <__ssprint_r>
 10182b8:	103a381e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 10182bc:	dc402617 	ldw	r17,152(sp)
 10182c0:	d8c02017 	ldw	r3,128(sp)
 10182c4:	da000404 	addi	r8,sp,16
 10182c8:	003f4306 	br	1017fd8 <__alt_data_end+0xff017fd8>
 10182cc:	01400184 	movi	r5,6
 10182d0:	d9402915 	stw	r5,164(sp)
 10182d4:	003f9506 	br	101812c <__alt_data_end+0xff01812c>
 10182d8:	d9002d17 	ldw	r4,180(sp)
 10182dc:	25000017 	ldw	r20,0(r4)
 10182e0:	21000104 	addi	r4,r4,4
 10182e4:	d9002d15 	stw	r4,180(sp)
 10182e8:	a02dd7fa 	srai	r22,r20,31
 10182ec:	b005883a 	mov	r2,r22
 10182f0:	003a9b06 	br	1016d60 <__alt_data_end+0xff016d60>
 10182f4:	d9402d17 	ldw	r5,180(sp)
 10182f8:	002d883a 	mov	r22,zero
 10182fc:	2d000017 	ldw	r20,0(r5)
 1018300:	29400104 	addi	r5,r5,4
 1018304:	d9402d15 	stw	r5,180(sp)
 1018308:	003bf906 	br	10172f0 <__alt_data_end+0xff0172f0>
 101830c:	9480100c 	andi	r18,r18,64
 1018310:	90006e26 	beq	r18,zero,10184cc <___svfprintf_internal_r+0x1cc4>
 1018314:	d9002d17 	ldw	r4,180(sp)
 1018318:	d9402f17 	ldw	r5,188(sp)
 101831c:	20800017 	ldw	r2,0(r4)
 1018320:	21000104 	addi	r4,r4,4
 1018324:	d9002d15 	stw	r4,180(sp)
 1018328:	1140000d 	sth	r5,0(r2)
 101832c:	00396106 	br	10168b4 <__alt_data_end+0xff0168b4>
 1018330:	d9402c17 	ldw	r5,176(sp)
 1018334:	d9801e04 	addi	r6,sp,120
 1018338:	9809883a 	mov	r4,r19
 101833c:	101fed00 	call	101fed0 <__ssprint_r>
 1018340:	103a161e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1018344:	d8c02017 	ldw	r3,128(sp)
 1018348:	d8801f17 	ldw	r2,124(sp)
 101834c:	da000404 	addi	r8,sp,16
 1018350:	d9403317 	ldw	r5,204(sp)
 1018354:	10800044 	addi	r2,r2,1
 1018358:	44000015 	stw	r16,0(r8)
 101835c:	28c7883a 	add	r3,r5,r3
 1018360:	003b7706 	br	1017140 <__alt_data_end+0xff017140>
 1018364:	8009883a 	mov	r4,r16
 1018368:	da003e15 	stw	r8,248(sp)
 101836c:	10165b40 	call	10165b4 <strlen>
 1018370:	d8802e15 	stw	r2,184(sp)
 1018374:	da003e17 	ldw	r8,248(sp)
 1018378:	103c280e 	bge	r2,zero,101741c <__alt_data_end+0xff01741c>
 101837c:	0005883a 	mov	r2,zero
 1018380:	003c2606 	br	101741c <__alt_data_end+0xff01741c>
 1018384:	00bfffc4 	movi	r2,-1
 1018388:	003a0906 	br	1016bb0 <__alt_data_end+0xff016bb0>
 101838c:	010040f4 	movhi	r4,259
 1018390:	212a9084 	addi	r4,r4,-21950
 1018394:	d9003515 	stw	r4,212(sp)
 1018398:	003b0606 	br	1016fb4 <__alt_data_end+0xff016fb4>
 101839c:	013fffc4 	movi	r4,-1
 10183a0:	003a2706 	br	1016c40 <__alt_data_end+0xff016c40>
 10183a4:	d9402c17 	ldw	r5,176(sp)
 10183a8:	d9801e04 	addi	r6,sp,120
 10183ac:	9809883a 	mov	r4,r19
 10183b0:	101fed00 	call	101fed0 <__ssprint_r>
 10183b4:	1039f91e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 10183b8:	d8c02017 	ldw	r3,128(sp)
 10183bc:	da000404 	addi	r8,sp,16
 10183c0:	003d8406 	br	10179d4 <__alt_data_end+0xff0179d4>
 10183c4:	0023883a 	mov	r17,zero
 10183c8:	003d8306 	br	10179d8 <__alt_data_end+0xff0179d8>
 10183cc:	010040f4 	movhi	r4,259
 10183d0:	212a8c84 	addi	r4,r4,-21966
 10183d4:	d9002b15 	stw	r4,172(sp)
 10183d8:	d9002b17 	ldw	r4,172(sp)
 10183dc:	1c47883a 	add	r3,r3,r17
 10183e0:	10800044 	addi	r2,r2,1
 10183e4:	41000015 	stw	r4,0(r8)
 10183e8:	44400115 	stw	r17,4(r8)
 10183ec:	d8c02015 	stw	r3,128(sp)
 10183f0:	d8801f15 	stw	r2,124(sp)
 10183f4:	010001c4 	movi	r4,7
 10183f8:	20bfcd16 	blt	r4,r2,1018330 <__alt_data_end+0xff018330>
 10183fc:	42000204 	addi	r8,r8,8
 1018400:	003fd306 	br	1018350 <__alt_data_end+0xff018350>
 1018404:	d9402c17 	ldw	r5,176(sp)
 1018408:	d9801e04 	addi	r6,sp,120
 101840c:	9809883a 	mov	r4,r19
 1018410:	101fed00 	call	101fed0 <__ssprint_r>
 1018414:	1039e11e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1018418:	d8802617 	ldw	r2,152(sp)
 101841c:	d8c02017 	ldw	r3,128(sp)
 1018420:	da000404 	addi	r8,sp,16
 1018424:	003e1c06 	br	1017c98 <__alt_data_end+0xff017c98>
 1018428:	d8802917 	ldw	r2,164(sp)
 101842c:	00c00184 	movi	r3,6
 1018430:	1880012e 	bgeu	r3,r2,1018438 <___svfprintf_internal_r+0x1c30>
 1018434:	1805883a 	mov	r2,r3
 1018438:	d8802e15 	stw	r2,184(sp)
 101843c:	1000f316 	blt	r2,zero,101880c <___svfprintf_internal_r+0x2004>
 1018440:	040040f4 	movhi	r16,259
 1018444:	d8802a15 	stw	r2,168(sp)
 1018448:	dd002d15 	stw	r20,180(sp)
 101844c:	d8002915 	stw	zero,164(sp)
 1018450:	d8003215 	stw	zero,200(sp)
 1018454:	842a8a04 	addi	r16,r16,-21976
 1018458:	0039883a 	mov	fp,zero
 101845c:	003a9f06 	br	1016edc <__alt_data_end+0xff016edc>
 1018460:	010040f4 	movhi	r4,259
 1018464:	212a9084 	addi	r4,r4,-21950
 1018468:	d9003515 	stw	r4,212(sp)
 101846c:	003b5f06 	br	10171ec <__alt_data_end+0xff0171ec>
 1018470:	d9402c17 	ldw	r5,176(sp)
 1018474:	d9801e04 	addi	r6,sp,120
 1018478:	9809883a 	mov	r4,r19
 101847c:	101fed00 	call	101fed0 <__ssprint_r>
 1018480:	1039c61e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 1018484:	d8802617 	ldw	r2,152(sp)
 1018488:	d9403317 	ldw	r5,204(sp)
 101848c:	d8c02017 	ldw	r3,128(sp)
 1018490:	da000404 	addi	r8,sp,16
 1018494:	2885c83a 	sub	r2,r5,r2
 1018498:	003e1006 	br	1017cdc <__alt_data_end+0xff017cdc>
 101849c:	00800044 	movi	r2,1
 10184a0:	10803fcc 	andi	r2,r2,255
 10184a4:	00c00044 	movi	r3,1
 10184a8:	10fa3526 	beq	r2,r3,1016d80 <__alt_data_end+0xff016d80>
 10184ac:	00c00084 	movi	r3,2
 10184b0:	10fb9e26 	beq	r2,r3,101732c <__alt_data_end+0xff01732c>
 10184b4:	003a6406 	br	1016e48 <__alt_data_end+0xff016e48>
 10184b8:	0021883a 	mov	r16,zero
 10184bc:	003e0806 	br	1017ce0 <__alt_data_end+0xff017ce0>
 10184c0:	07000b44 	movi	fp,45
 10184c4:	df002785 	stb	fp,158(sp)
 10184c8:	003a0b06 	br	1016cf8 <__alt_data_end+0xff016cf8>
 10184cc:	d8c02d17 	ldw	r3,180(sp)
 10184d0:	d9002f17 	ldw	r4,188(sp)
 10184d4:	18800017 	ldw	r2,0(r3)
 10184d8:	18c00104 	addi	r3,r3,4
 10184dc:	d8c02d15 	stw	r3,180(sp)
 10184e0:	11000015 	stw	r4,0(r2)
 10184e4:	0038f306 	br	10168b4 <__alt_data_end+0xff0168b4>
 10184e8:	00c00b44 	movi	r3,45
 10184ec:	d8c02785 	stb	r3,158(sp)
 10184f0:	d8802a15 	stw	r2,168(sp)
 10184f4:	dc802b17 	ldw	r18,172(sp)
 10184f8:	d8002915 	stw	zero,164(sp)
 10184fc:	07000b44 	movi	fp,45
 1018500:	003a7306 	br	1016ed0 <__alt_data_end+0xff016ed0>
 1018504:	9080004c 	andi	r2,r18,1
 1018508:	1000941e 	bne	r2,zero,101875c <___svfprintf_internal_r+0x1f54>
 101850c:	d8802117 	ldw	r2,132(sp)
 1018510:	1405c83a 	sub	r2,r2,r16
 1018514:	d8803315 	stw	r2,204(sp)
 1018518:	b441161e 	bne	r22,r17,1018974 <___svfprintf_internal_r+0x216c>
 101851c:	dd802617 	ldw	r22,152(sp)
 1018520:	00bfff44 	movi	r2,-3
 1018524:	b0801a16 	blt	r22,r2,1018590 <___svfprintf_internal_r+0x1d88>
 1018528:	d9402917 	ldw	r5,164(sp)
 101852c:	2d801816 	blt	r5,r22,1018590 <___svfprintf_internal_r+0x1d88>
 1018530:	dd803215 	stw	r22,200(sp)
 1018534:	003f3a06 	br	1018220 <__alt_data_end+0xff018220>
 1018538:	1025883a 	mov	r18,r2
 101853c:	0039883a 	mov	fp,zero
 1018540:	00800084 	movi	r2,2
 1018544:	003fd606 	br	10184a0 <__alt_data_end+0xff0184a0>
 1018548:	9080004c 	andi	r2,r18,1
 101854c:	103f191e 	bne	r2,zero,10181b4 <__alt_data_end+0xff0181b4>
 1018550:	d8802117 	ldw	r2,132(sp)
 1018554:	003f2806 	br	10181f8 <__alt_data_end+0xff0181f8>
 1018558:	010040f4 	movhi	r4,259
 101855c:	212a8c84 	addi	r4,r4,-21966
 1018560:	d9002b15 	stw	r4,172(sp)
 1018564:	003c7c06 	br	1017758 <__alt_data_end+0xff017758>
 1018568:	e005883a 	mov	r2,fp
 101856c:	003f2206 	br	10181f8 <__alt_data_end+0xff0181f8>
 1018570:	d9402917 	ldw	r5,164(sp)
 1018574:	df002783 	ldbu	fp,158(sp)
 1018578:	dd002d15 	stw	r20,180(sp)
 101857c:	d9402a15 	stw	r5,168(sp)
 1018580:	d9402e15 	stw	r5,184(sp)
 1018584:	d8002915 	stw	zero,164(sp)
 1018588:	d8003215 	stw	zero,200(sp)
 101858c:	003a4c06 	br	1016ec0 <__alt_data_end+0xff016ec0>
 1018590:	8c7fff84 	addi	r17,r17,-2
 1018594:	b5bfffc4 	addi	r22,r22,-1
 1018598:	dd802615 	stw	r22,152(sp)
 101859c:	dc4022c5 	stb	r17,139(sp)
 10185a0:	b000c316 	blt	r22,zero,10188b0 <___svfprintf_internal_r+0x20a8>
 10185a4:	00800ac4 	movi	r2,43
 10185a8:	d8802305 	stb	r2,140(sp)
 10185ac:	00800244 	movi	r2,9
 10185b0:	15806e16 	blt	r2,r22,101876c <___svfprintf_internal_r+0x1f64>
 10185b4:	00800c04 	movi	r2,48
 10185b8:	b5800c04 	addi	r22,r22,48
 10185bc:	d8802345 	stb	r2,141(sp)
 10185c0:	dd802385 	stb	r22,142(sp)
 10185c4:	d88023c4 	addi	r2,sp,143
 10185c8:	df0022c4 	addi	fp,sp,139
 10185cc:	d8c03317 	ldw	r3,204(sp)
 10185d0:	1739c83a 	sub	fp,r2,fp
 10185d4:	d9003317 	ldw	r4,204(sp)
 10185d8:	e0c7883a 	add	r3,fp,r3
 10185dc:	df003b15 	stw	fp,236(sp)
 10185e0:	d8c02e15 	stw	r3,184(sp)
 10185e4:	00800044 	movi	r2,1
 10185e8:	1100b70e 	bge	r2,r4,10188c8 <___svfprintf_internal_r+0x20c0>
 10185ec:	d8c02e17 	ldw	r3,184(sp)
 10185f0:	18c00044 	addi	r3,r3,1
 10185f4:	d8c02e15 	stw	r3,184(sp)
 10185f8:	1805883a 	mov	r2,r3
 10185fc:	1800b016 	blt	r3,zero,10188c0 <___svfprintf_internal_r+0x20b8>
 1018600:	d8003215 	stw	zero,200(sp)
 1018604:	003f1006 	br	1018248 <__alt_data_end+0xff018248>
 1018608:	d8802917 	ldw	r2,164(sp)
 101860c:	103ec71e 	bne	r2,zero,101812c <__alt_data_end+0xff01812c>
 1018610:	dc002915 	stw	r16,164(sp)
 1018614:	003ec506 	br	101812c <__alt_data_end+0xff01812c>
 1018618:	d9402c17 	ldw	r5,176(sp)
 101861c:	d9801e04 	addi	r6,sp,120
 1018620:	9809883a 	mov	r4,r19
 1018624:	101fed00 	call	101fed0 <__ssprint_r>
 1018628:	10395c1e 	bne	r2,zero,1016b9c <__alt_data_end+0xff016b9c>
 101862c:	dc402617 	ldw	r17,152(sp)
 1018630:	d8c02017 	ldw	r3,128(sp)
 1018634:	d8801f17 	ldw	r2,124(sp)
 1018638:	da000404 	addi	r8,sp,16
 101863c:	003e7706 	br	101801c <__alt_data_end+0xff01801c>
 1018640:	582f883a 	mov	r23,r11
 1018644:	d8002915 	stw	zero,164(sp)
 1018648:	0038c406 	br	101695c <__alt_data_end+0xff01695c>
 101864c:	d8c02917 	ldw	r3,164(sp)
 1018650:	d8802104 	addi	r2,sp,132
 1018654:	d8800315 	stw	r2,12(sp)
 1018658:	d9403617 	ldw	r5,216(sp)
 101865c:	d8802504 	addi	r2,sp,148
 1018660:	d8800215 	stw	r2,8(sp)
 1018664:	d8802604 	addi	r2,sp,152
 1018668:	d8c00015 	stw	r3,0(sp)
 101866c:	9809883a 	mov	r4,r19
 1018670:	d8800115 	stw	r2,4(sp)
 1018674:	01c000c4 	movi	r7,3
 1018678:	a00d883a 	mov	r6,r20
 101867c:	da003e15 	stw	r8,248(sp)
 1018680:	101b03c0 	call	101b03c <_dtoa_r>
 1018684:	d9002917 	ldw	r4,164(sp)
 1018688:	da003e17 	ldw	r8,248(sp)
 101868c:	1021883a 	mov	r16,r2
 1018690:	1139883a 	add	fp,r2,r4
 1018694:	2007883a 	mov	r3,r4
 1018698:	81000007 	ldb	r4,0(r16)
 101869c:	00800c04 	movi	r2,48
 10186a0:	20806f26 	beq	r4,r2,1018860 <___svfprintf_internal_r+0x2058>
 10186a4:	d8c02617 	ldw	r3,152(sp)
 10186a8:	e0f9883a 	add	fp,fp,r3
 10186ac:	003ec206 	br	10181b8 <__alt_data_end+0xff0181b8>
 10186b0:	00c00b44 	movi	r3,45
 10186b4:	2520003c 	xorhi	r20,r4,32768
 10186b8:	d8c02a05 	stb	r3,168(sp)
 10186bc:	003ea106 	br	1018144 <__alt_data_end+0xff018144>
 10186c0:	d8c03217 	ldw	r3,200(sp)
 10186c4:	00c0890e 	bge	zero,r3,10188ec <___svfprintf_internal_r+0x20e4>
 10186c8:	00800044 	movi	r2,1
 10186cc:	d9003317 	ldw	r4,204(sp)
 10186d0:	1105883a 	add	r2,r2,r4
 10186d4:	d8802e15 	stw	r2,184(sp)
 10186d8:	10005f16 	blt	r2,zero,1018858 <___svfprintf_internal_r+0x2050>
 10186dc:	044019c4 	movi	r17,103
 10186e0:	003ed906 	br	1018248 <__alt_data_end+0xff018248>
 10186e4:	d9002917 	ldw	r4,164(sp)
 10186e8:	20c00044 	addi	r3,r4,1
 10186ec:	003e9c06 	br	1018160 <__alt_data_end+0xff018160>
 10186f0:	d9002917 	ldw	r4,164(sp)
 10186f4:	00c0680e 	bge	zero,r3,1018898 <___svfprintf_internal_r+0x2090>
 10186f8:	2000461e 	bne	r4,zero,1018814 <___svfprintf_internal_r+0x200c>
 10186fc:	9480004c 	andi	r18,r18,1
 1018700:	9000441e 	bne	r18,zero,1018814 <___svfprintf_internal_r+0x200c>
 1018704:	1805883a 	mov	r2,r3
 1018708:	1800a016 	blt	r3,zero,101898c <___svfprintf_internal_r+0x2184>
 101870c:	d8c03217 	ldw	r3,200(sp)
 1018710:	d8c02e15 	stw	r3,184(sp)
 1018714:	003ecc06 	br	1018248 <__alt_data_end+0xff018248>
 1018718:	d9402917 	ldw	r5,164(sp)
 101871c:	d8802104 	addi	r2,sp,132
 1018720:	d8800315 	stw	r2,12(sp)
 1018724:	d9400015 	stw	r5,0(sp)
 1018728:	d8802504 	addi	r2,sp,148
 101872c:	d9403617 	ldw	r5,216(sp)
 1018730:	d8800215 	stw	r2,8(sp)
 1018734:	d8802604 	addi	r2,sp,152
 1018738:	d8800115 	stw	r2,4(sp)
 101873c:	01c000c4 	movi	r7,3
 1018740:	a00d883a 	mov	r6,r20
 1018744:	9809883a 	mov	r4,r19
 1018748:	da003e15 	stw	r8,248(sp)
 101874c:	101b03c0 	call	101b03c <_dtoa_r>
 1018750:	d8c02917 	ldw	r3,164(sp)
 1018754:	da003e17 	ldw	r8,248(sp)
 1018758:	1021883a 	mov	r16,r2
 101875c:	00801184 	movi	r2,70
 1018760:	80f9883a 	add	fp,r16,r3
 1018764:	88bfcc26 	beq	r17,r2,1018698 <__alt_data_end+0xff018698>
 1018768:	003e9306 	br	10181b8 <__alt_data_end+0xff0181b8>
 101876c:	df0022c4 	addi	fp,sp,139
 1018770:	dc002915 	stw	r16,164(sp)
 1018774:	9829883a 	mov	r20,r19
 1018778:	e021883a 	mov	r16,fp
 101877c:	4027883a 	mov	r19,r8
 1018780:	b009883a 	mov	r4,r22
 1018784:	01400284 	movi	r5,10
 1018788:	1023d8c0 	call	1023d8c <__modsi3>
 101878c:	10800c04 	addi	r2,r2,48
 1018790:	843fffc4 	addi	r16,r16,-1
 1018794:	b009883a 	mov	r4,r22
 1018798:	01400284 	movi	r5,10
 101879c:	80800005 	stb	r2,0(r16)
 10187a0:	1023d080 	call	1023d08 <__divsi3>
 10187a4:	102d883a 	mov	r22,r2
 10187a8:	00800244 	movi	r2,9
 10187ac:	15bff416 	blt	r2,r22,1018780 <__alt_data_end+0xff018780>
 10187b0:	9811883a 	mov	r8,r19
 10187b4:	b0800c04 	addi	r2,r22,48
 10187b8:	a027883a 	mov	r19,r20
 10187bc:	8029883a 	mov	r20,r16
 10187c0:	a17fffc4 	addi	r5,r20,-1
 10187c4:	a0bfffc5 	stb	r2,-1(r20)
 10187c8:	dc002917 	ldw	r16,164(sp)
 10187cc:	2f00752e 	bgeu	r5,fp,10189a4 <___svfprintf_internal_r+0x219c>
 10187d0:	d9c02384 	addi	r7,sp,142
 10187d4:	3d0fc83a 	sub	r7,r7,r20
 10187d8:	d9002344 	addi	r4,sp,141
 10187dc:	e1cf883a 	add	r7,fp,r7
 10187e0:	00000106 	br	10187e8 <___svfprintf_internal_r+0x1fe0>
 10187e4:	28800003 	ldbu	r2,0(r5)
 10187e8:	20800005 	stb	r2,0(r4)
 10187ec:	21000044 	addi	r4,r4,1
 10187f0:	29400044 	addi	r5,r5,1
 10187f4:	21fffb1e 	bne	r4,r7,10187e4 <__alt_data_end+0xff0187e4>
 10187f8:	d8802304 	addi	r2,sp,140
 10187fc:	1505c83a 	sub	r2,r2,r20
 1018800:	d8c02344 	addi	r3,sp,141
 1018804:	1885883a 	add	r2,r3,r2
 1018808:	003f7006 	br	10185cc <__alt_data_end+0xff0185cc>
 101880c:	0005883a 	mov	r2,zero
 1018810:	003f0b06 	br	1018440 <__alt_data_end+0xff018440>
 1018814:	d9002917 	ldw	r4,164(sp)
 1018818:	d8c03217 	ldw	r3,200(sp)
 101881c:	20800044 	addi	r2,r4,1
 1018820:	1885883a 	add	r2,r3,r2
 1018824:	d8802e15 	stw	r2,184(sp)
 1018828:	103e870e 	bge	r2,zero,1018248 <__alt_data_end+0xff018248>
 101882c:	0005883a 	mov	r2,zero
 1018830:	003e8506 	br	1018248 <__alt_data_end+0xff018248>
 1018834:	010040f4 	movhi	r4,259
 1018838:	212a8c84 	addi	r4,r4,-21966
 101883c:	d9002b15 	stw	r4,172(sp)
 1018840:	003cc506 	br	1017b58 <__alt_data_end+0xff017b58>
 1018844:	d8c03217 	ldw	r3,200(sp)
 1018848:	18c00044 	addi	r3,r3,1
 101884c:	d8c02e15 	stw	r3,184(sp)
 1018850:	1805883a 	mov	r2,r3
 1018854:	183fa10e 	bge	r3,zero,10186dc <__alt_data_end+0xff0186dc>
 1018858:	0005883a 	mov	r2,zero
 101885c:	003f9f06 	br	10186dc <__alt_data_end+0xff0186dc>
 1018860:	d9003617 	ldw	r4,216(sp)
 1018864:	000d883a 	mov	r6,zero
 1018868:	000f883a 	mov	r7,zero
 101886c:	a00b883a 	mov	r5,r20
 1018870:	d8c03d15 	stw	r3,244(sp)
 1018874:	da003e15 	stw	r8,248(sp)
 1018878:	10250500 	call	1025050 <__eqdf2>
 101887c:	d8c03d17 	ldw	r3,244(sp)
 1018880:	da003e17 	ldw	r8,248(sp)
 1018884:	103f8726 	beq	r2,zero,10186a4 <__alt_data_end+0xff0186a4>
 1018888:	00800044 	movi	r2,1
 101888c:	10c7c83a 	sub	r3,r2,r3
 1018890:	d8c02615 	stw	r3,152(sp)
 1018894:	003f8406 	br	10186a8 <__alt_data_end+0xff0186a8>
 1018898:	20000e1e 	bne	r4,zero,10188d4 <___svfprintf_internal_r+0x20cc>
 101889c:	9480004c 	andi	r18,r18,1
 10188a0:	90000c1e 	bne	r18,zero,10188d4 <___svfprintf_internal_r+0x20cc>
 10188a4:	00800044 	movi	r2,1
 10188a8:	d8802e15 	stw	r2,184(sp)
 10188ac:	003e6606 	br	1018248 <__alt_data_end+0xff018248>
 10188b0:	00800b44 	movi	r2,45
 10188b4:	05adc83a 	sub	r22,zero,r22
 10188b8:	d8802305 	stb	r2,140(sp)
 10188bc:	003f3b06 	br	10185ac <__alt_data_end+0xff0185ac>
 10188c0:	0005883a 	mov	r2,zero
 10188c4:	003f4e06 	br	1018600 <__alt_data_end+0xff018600>
 10188c8:	90a4703a 	and	r18,r18,r2
 10188cc:	903f4a26 	beq	r18,zero,10185f8 <__alt_data_end+0xff0185f8>
 10188d0:	003f4606 	br	10185ec <__alt_data_end+0xff0185ec>
 10188d4:	d8c02917 	ldw	r3,164(sp)
 10188d8:	18c00084 	addi	r3,r3,2
 10188dc:	d8c02e15 	stw	r3,184(sp)
 10188e0:	1805883a 	mov	r2,r3
 10188e4:	183e580e 	bge	r3,zero,1018248 <__alt_data_end+0xff018248>
 10188e8:	003fd006 	br	101882c <__alt_data_end+0xff01882c>
 10188ec:	00800084 	movi	r2,2
 10188f0:	10c5c83a 	sub	r2,r2,r3
 10188f4:	003f7506 	br	10186cc <__alt_data_end+0xff0186cc>
 10188f8:	d8802d17 	ldw	r2,180(sp)
 10188fc:	d9002d17 	ldw	r4,180(sp)
 1018900:	bc400043 	ldbu	r17,1(r23)
 1018904:	10800017 	ldw	r2,0(r2)
 1018908:	582f883a 	mov	r23,r11
 101890c:	d8802915 	stw	r2,164(sp)
 1018910:	20800104 	addi	r2,r4,4
 1018914:	d9002917 	ldw	r4,164(sp)
 1018918:	d8802d15 	stw	r2,180(sp)
 101891c:	203df00e 	bge	r4,zero,10180e0 <__alt_data_end+0xff0180e0>
 1018920:	8c403fcc 	andi	r17,r17,255
 1018924:	00bfffc4 	movi	r2,-1
 1018928:	8c40201c 	xori	r17,r17,128
 101892c:	d8802915 	stw	r2,164(sp)
 1018930:	8c7fe004 	addi	r17,r17,-128
 1018934:	00380806 	br	1016958 <__alt_data_end+0xff016958>
 1018938:	9080004c 	andi	r2,r18,1
 101893c:	0039883a 	mov	fp,zero
 1018940:	10000726 	beq	r2,zero,1018960 <___svfprintf_internal_r+0x2158>
 1018944:	d8c02817 	ldw	r3,160(sp)
 1018948:	dc001dc4 	addi	r16,sp,119
 101894c:	00800c04 	movi	r2,48
 1018950:	1c07c83a 	sub	r3,r3,r16
 1018954:	d8801dc5 	stb	r2,119(sp)
 1018958:	d8c02e15 	stw	r3,184(sp)
 101895c:	00395206 	br	1016ea8 <__alt_data_end+0xff016ea8>
 1018960:	d8002e15 	stw	zero,184(sp)
 1018964:	dc001e04 	addi	r16,sp,120
 1018968:	00394f06 	br	1016ea8 <__alt_data_end+0xff016ea8>
 101896c:	0005883a 	mov	r2,zero
 1018970:	003e3206 	br	101823c <__alt_data_end+0xff01823c>
 1018974:	dd802617 	ldw	r22,152(sp)
 1018978:	003f0606 	br	1018594 <__alt_data_end+0xff018594>
 101897c:	d9c02785 	stb	r7,158(sp)
 1018980:	003a5106 	br	10172c8 <__alt_data_end+0xff0172c8>
 1018984:	d9c02785 	stb	r7,158(sp)
 1018988:	003a3706 	br	1017268 <__alt_data_end+0xff017268>
 101898c:	0005883a 	mov	r2,zero
 1018990:	003f5e06 	br	101870c <__alt_data_end+0xff01870c>
 1018994:	d9c02785 	stb	r7,158(sp)
 1018998:	00391706 	br	1016df8 <__alt_data_end+0xff016df8>
 101899c:	d9c02785 	stb	r7,158(sp)
 10189a0:	0038e606 	br	1016d3c <__alt_data_end+0xff016d3c>
 10189a4:	d8802344 	addi	r2,sp,141
 10189a8:	003f0806 	br	10185cc <__alt_data_end+0xff0185cc>
 10189ac:	d9c02785 	stb	r7,158(sp)
 10189b0:	0038b706 	br	1016c90 <__alt_data_end+0xff016c90>
 10189b4:	d9c02785 	stb	r7,158(sp)
 10189b8:	003adc06 	br	101752c <__alt_data_end+0xff01752c>
 10189bc:	d9403917 	ldw	r5,228(sp)
 10189c0:	00800304 	movi	r2,12
 10189c4:	28800015 	stw	r2,0(r5)
 10189c8:	00bfffc4 	movi	r2,-1
 10189cc:	00387806 	br	1016bb0 <__alt_data_end+0xff016bb0>
 10189d0:	d9c02785 	stb	r7,158(sp)
 10189d4:	003abf06 	br	10174d4 <__alt_data_end+0xff0174d4>
 10189d8:	d9c02785 	stb	r7,158(sp)
 10189dc:	003a9b06 	br	101744c <__alt_data_end+0xff01744c>

010189e0 <_user_strerror>:
 10189e0:	0005883a 	mov	r2,zero
 10189e4:	f800283a 	ret

010189e8 <_vfiprintf_r>:
 10189e8:	deffff04 	addi	sp,sp,-4
 10189ec:	dfc00015 	stw	ra,0(sp)
 10189f0:	10213f00 	call	10213f0 <___vfiprintf_internal_r>
 10189f4:	dfc00017 	ldw	ra,0(sp)
 10189f8:	dec00104 	addi	sp,sp,4
 10189fc:	f800283a 	ret

01018a00 <___vfprintf_internal_r>:
 1018a00:	deffb804 	addi	sp,sp,-288
 1018a04:	dfc04715 	stw	ra,284(sp)
 1018a08:	ddc04515 	stw	r23,276(sp)
 1018a0c:	dd404315 	stw	r21,268(sp)
 1018a10:	d9002c15 	stw	r4,176(sp)
 1018a14:	282f883a 	mov	r23,r5
 1018a18:	302b883a 	mov	r21,r6
 1018a1c:	d9c02d15 	stw	r7,180(sp)
 1018a20:	df004615 	stw	fp,280(sp)
 1018a24:	dd804415 	stw	r22,272(sp)
 1018a28:	dd004215 	stw	r20,264(sp)
 1018a2c:	dcc04115 	stw	r19,260(sp)
 1018a30:	dc804015 	stw	r18,256(sp)
 1018a34:	dc403f15 	stw	r17,252(sp)
 1018a38:	dc003e15 	stw	r16,248(sp)
 1018a3c:	101d8300 	call	101d830 <_localeconv_r>
 1018a40:	10800017 	ldw	r2,0(r2)
 1018a44:	1009883a 	mov	r4,r2
 1018a48:	d8803415 	stw	r2,208(sp)
 1018a4c:	10165b40 	call	10165b4 <strlen>
 1018a50:	d8803715 	stw	r2,220(sp)
 1018a54:	d8802c17 	ldw	r2,176(sp)
 1018a58:	10000226 	beq	r2,zero,1018a64 <___vfprintf_internal_r+0x64>
 1018a5c:	10800e17 	ldw	r2,56(r2)
 1018a60:	1000f926 	beq	r2,zero,1018e48 <___vfprintf_internal_r+0x448>
 1018a64:	b880030b 	ldhu	r2,12(r23)
 1018a68:	10c8000c 	andi	r3,r2,8192
 1018a6c:	1800061e 	bne	r3,zero,1018a88 <___vfprintf_internal_r+0x88>
 1018a70:	b9001917 	ldw	r4,100(r23)
 1018a74:	00f7ffc4 	movi	r3,-8193
 1018a78:	10880014 	ori	r2,r2,8192
 1018a7c:	20c6703a 	and	r3,r4,r3
 1018a80:	b880030d 	sth	r2,12(r23)
 1018a84:	b8c01915 	stw	r3,100(r23)
 1018a88:	10c0020c 	andi	r3,r2,8
 1018a8c:	1800c126 	beq	r3,zero,1018d94 <___vfprintf_internal_r+0x394>
 1018a90:	b8c00417 	ldw	r3,16(r23)
 1018a94:	1800bf26 	beq	r3,zero,1018d94 <___vfprintf_internal_r+0x394>
 1018a98:	1080068c 	andi	r2,r2,26
 1018a9c:	00c00284 	movi	r3,10
 1018aa0:	10c0c426 	beq	r2,r3,1018db4 <___vfprintf_internal_r+0x3b4>
 1018aa4:	d8c00404 	addi	r3,sp,16
 1018aa8:	050040f4 	movhi	r20,259
 1018aac:	d9001e04 	addi	r4,sp,120
 1018ab0:	a52a9484 	addi	r20,r20,-21934
 1018ab4:	d8c01e15 	stw	r3,120(sp)
 1018ab8:	d8002015 	stw	zero,128(sp)
 1018abc:	d8001f15 	stw	zero,124(sp)
 1018ac0:	d8003315 	stw	zero,204(sp)
 1018ac4:	d8003615 	stw	zero,216(sp)
 1018ac8:	d8003815 	stw	zero,224(sp)
 1018acc:	1811883a 	mov	r8,r3
 1018ad0:	d8003915 	stw	zero,228(sp)
 1018ad4:	d8003a15 	stw	zero,232(sp)
 1018ad8:	d8002f15 	stw	zero,188(sp)
 1018adc:	d9002815 	stw	r4,160(sp)
 1018ae0:	a8800007 	ldb	r2,0(r21)
 1018ae4:	10027b26 	beq	r2,zero,10194d4 <___vfprintf_internal_r+0xad4>
 1018ae8:	00c00944 	movi	r3,37
 1018aec:	a821883a 	mov	r16,r21
 1018af0:	10c0021e 	bne	r2,r3,1018afc <___vfprintf_internal_r+0xfc>
 1018af4:	00001406 	br	1018b48 <___vfprintf_internal_r+0x148>
 1018af8:	10c00326 	beq	r2,r3,1018b08 <___vfprintf_internal_r+0x108>
 1018afc:	84000044 	addi	r16,r16,1
 1018b00:	80800007 	ldb	r2,0(r16)
 1018b04:	103ffc1e 	bne	r2,zero,1018af8 <__alt_data_end+0xff018af8>
 1018b08:	8563c83a 	sub	r17,r16,r21
 1018b0c:	88000e26 	beq	r17,zero,1018b48 <___vfprintf_internal_r+0x148>
 1018b10:	d8c02017 	ldw	r3,128(sp)
 1018b14:	d8801f17 	ldw	r2,124(sp)
 1018b18:	45400015 	stw	r21,0(r8)
 1018b1c:	1c47883a 	add	r3,r3,r17
 1018b20:	10800044 	addi	r2,r2,1
 1018b24:	d8c02015 	stw	r3,128(sp)
 1018b28:	44400115 	stw	r17,4(r8)
 1018b2c:	d8801f15 	stw	r2,124(sp)
 1018b30:	00c001c4 	movi	r3,7
 1018b34:	1880a716 	blt	r3,r2,1018dd4 <___vfprintf_internal_r+0x3d4>
 1018b38:	42000204 	addi	r8,r8,8
 1018b3c:	d9402f17 	ldw	r5,188(sp)
 1018b40:	2c4b883a 	add	r5,r5,r17
 1018b44:	d9402f15 	stw	r5,188(sp)
 1018b48:	80800007 	ldb	r2,0(r16)
 1018b4c:	1000a826 	beq	r2,zero,1018df0 <___vfprintf_internal_r+0x3f0>
 1018b50:	84400047 	ldb	r17,1(r16)
 1018b54:	00bfffc4 	movi	r2,-1
 1018b58:	85400044 	addi	r21,r16,1
 1018b5c:	d8002785 	stb	zero,158(sp)
 1018b60:	0007883a 	mov	r3,zero
 1018b64:	000f883a 	mov	r7,zero
 1018b68:	d8802915 	stw	r2,164(sp)
 1018b6c:	d8003115 	stw	zero,196(sp)
 1018b70:	0025883a 	mov	r18,zero
 1018b74:	01401604 	movi	r5,88
 1018b78:	01800244 	movi	r6,9
 1018b7c:	02800a84 	movi	r10,42
 1018b80:	02401b04 	movi	r9,108
 1018b84:	ad400044 	addi	r21,r21,1
 1018b88:	88bff804 	addi	r2,r17,-32
 1018b8c:	28830436 	bltu	r5,r2,10197a0 <___vfprintf_internal_r+0xda0>
 1018b90:	100490ba 	slli	r2,r2,2
 1018b94:	010040b4 	movhi	r4,258
 1018b98:	2122ea04 	addi	r4,r4,-29784
 1018b9c:	1105883a 	add	r2,r2,r4
 1018ba0:	10800017 	ldw	r2,0(r2)
 1018ba4:	1000683a 	jmp	r2
 1018ba8:	010196c0 	call	10196c <__reset-0xefe694>
 1018bac:	010197a0 	cmpeqi	r4,zero,1630
 1018bb0:	010197a0 	cmpeqi	r4,zero,1630
 1018bb4:	010196e0 	cmpeqi	r4,zero,1627
 1018bb8:	010197a0 	cmpeqi	r4,zero,1630
 1018bbc:	010197a0 	cmpeqi	r4,zero,1630
 1018bc0:	010197a0 	cmpeqi	r4,zero,1630
 1018bc4:	010197a0 	cmpeqi	r4,zero,1630
 1018bc8:	010197a0 	cmpeqi	r4,zero,1630
 1018bcc:	010197a0 	cmpeqi	r4,zero,1630
 1018bd0:	01018e54 	movui	r4,1593
 1018bd4:	010195fc 	xorhi	r4,zero,1623
 1018bd8:	010197a0 	cmpeqi	r4,zero,1630
 1018bdc:	01018d1c 	xori	r4,zero,1588
 1018be0:	01018e7c 	xorhi	r4,zero,1593
 1018be4:	010197a0 	cmpeqi	r4,zero,1630
 1018be8:	01018ebc 	xorhi	r4,zero,1594
 1018bec:	01018ec8 	cmpgei	r4,zero,1595
 1018bf0:	01018ec8 	cmpgei	r4,zero,1595
 1018bf4:	01018ec8 	cmpgei	r4,zero,1595
 1018bf8:	01018ec8 	cmpgei	r4,zero,1595
 1018bfc:	01018ec8 	cmpgei	r4,zero,1595
 1018c00:	01018ec8 	cmpgei	r4,zero,1595
 1018c04:	01018ec8 	cmpgei	r4,zero,1595
 1018c08:	01018ec8 	cmpgei	r4,zero,1595
 1018c0c:	01018ec8 	cmpgei	r4,zero,1595
 1018c10:	010197a0 	cmpeqi	r4,zero,1630
 1018c14:	010197a0 	cmpeqi	r4,zero,1630
 1018c18:	010197a0 	cmpeqi	r4,zero,1630
 1018c1c:	010197a0 	cmpeqi	r4,zero,1630
 1018c20:	010197a0 	cmpeqi	r4,zero,1630
 1018c24:	010197a0 	cmpeqi	r4,zero,1630
 1018c28:	010197a0 	cmpeqi	r4,zero,1630
 1018c2c:	010197a0 	cmpeqi	r4,zero,1630
 1018c30:	010197a0 	cmpeqi	r4,zero,1630
 1018c34:	010197a0 	cmpeqi	r4,zero,1630
 1018c38:	01018efc 	xorhi	r4,zero,1595
 1018c3c:	01018fb8 	rdprs	r4,zero,1598
 1018c40:	010197a0 	cmpeqi	r4,zero,1630
 1018c44:	01018fb8 	rdprs	r4,zero,1598
 1018c48:	010197a0 	cmpeqi	r4,zero,1630
 1018c4c:	010197a0 	cmpeqi	r4,zero,1630
 1018c50:	010197a0 	cmpeqi	r4,zero,1630
 1018c54:	010197a0 	cmpeqi	r4,zero,1630
 1018c58:	01019058 	cmpnei	r4,zero,1601
 1018c5c:	010197a0 	cmpeqi	r4,zero,1630
 1018c60:	010197a0 	cmpeqi	r4,zero,1630
 1018c64:	01019064 	muli	r4,zero,1601
 1018c68:	010197a0 	cmpeqi	r4,zero,1630
 1018c6c:	010197a0 	cmpeqi	r4,zero,1630
 1018c70:	010197a0 	cmpeqi	r4,zero,1630
 1018c74:	010197a0 	cmpeqi	r4,zero,1630
 1018c78:	010197a0 	cmpeqi	r4,zero,1630
 1018c7c:	010194dc 	xori	r4,zero,1619
 1018c80:	010197a0 	cmpeqi	r4,zero,1630
 1018c84:	010197a0 	cmpeqi	r4,zero,1630
 1018c88:	0101953c 	xorhi	r4,zero,1620
 1018c8c:	010197a0 	cmpeqi	r4,zero,1630
 1018c90:	010197a0 	cmpeqi	r4,zero,1630
 1018c94:	010197a0 	cmpeqi	r4,zero,1630
 1018c98:	010197a0 	cmpeqi	r4,zero,1630
 1018c9c:	010197a0 	cmpeqi	r4,zero,1630
 1018ca0:	010197a0 	cmpeqi	r4,zero,1630
 1018ca4:	010197a0 	cmpeqi	r4,zero,1630
 1018ca8:	010197a0 	cmpeqi	r4,zero,1630
 1018cac:	010197a0 	cmpeqi	r4,zero,1630
 1018cb0:	010197a0 	cmpeqi	r4,zero,1630
 1018cb4:	0101974c 	andi	r4,zero,1629
 1018cb8:	010196ec 	andhi	r4,zero,1627
 1018cbc:	01018fb8 	rdprs	r4,zero,1598
 1018cc0:	01018fb8 	rdprs	r4,zero,1598
 1018cc4:	01018fb8 	rdprs	r4,zero,1598
 1018cc8:	010196fc 	xorhi	r4,zero,1627
 1018ccc:	010196ec 	andhi	r4,zero,1627
 1018cd0:	010197a0 	cmpeqi	r4,zero,1630
 1018cd4:	010197a0 	cmpeqi	r4,zero,1630
 1018cd8:	01019708 	cmpgei	r4,zero,1628
 1018cdc:	010197a0 	cmpeqi	r4,zero,1630
 1018ce0:	01019718 	cmpnei	r4,zero,1628
 1018ce4:	010195ec 	andhi	r4,zero,1623
 1018ce8:	01018d28 	cmpgeui	r4,zero,1588
 1018cec:	0101960c 	andi	r4,zero,1624
 1018cf0:	010197a0 	cmpeqi	r4,zero,1630
 1018cf4:	01019618 	cmpnei	r4,zero,1624
 1018cf8:	010197a0 	cmpeqi	r4,zero,1630
 1018cfc:	01019674 	movhi	r4,1625
 1018d00:	010197a0 	cmpeqi	r4,zero,1630
 1018d04:	010197a0 	cmpeqi	r4,zero,1630
 1018d08:	01019684 	movi	r4,1626
 1018d0c:	d9003117 	ldw	r4,196(sp)
 1018d10:	d8802d15 	stw	r2,180(sp)
 1018d14:	0109c83a 	sub	r4,zero,r4
 1018d18:	d9003115 	stw	r4,196(sp)
 1018d1c:	94800114 	ori	r18,r18,4
 1018d20:	ac400007 	ldb	r17,0(r21)
 1018d24:	003f9706 	br	1018b84 <__alt_data_end+0xff018b84>
 1018d28:	00800c04 	movi	r2,48
 1018d2c:	d9002d17 	ldw	r4,180(sp)
 1018d30:	d9402917 	ldw	r5,164(sp)
 1018d34:	d8802705 	stb	r2,156(sp)
 1018d38:	00801e04 	movi	r2,120
 1018d3c:	d8802745 	stb	r2,157(sp)
 1018d40:	d8002785 	stb	zero,158(sp)
 1018d44:	20c00104 	addi	r3,r4,4
 1018d48:	24c00017 	ldw	r19,0(r4)
 1018d4c:	002d883a 	mov	r22,zero
 1018d50:	90800094 	ori	r2,r18,2
 1018d54:	28029a16 	blt	r5,zero,10197c0 <___vfprintf_internal_r+0xdc0>
 1018d58:	00bfdfc4 	movi	r2,-129
 1018d5c:	90a4703a 	and	r18,r18,r2
 1018d60:	d8c02d15 	stw	r3,180(sp)
 1018d64:	94800094 	ori	r18,r18,2
 1018d68:	9802871e 	bne	r19,zero,1019788 <___vfprintf_internal_r+0xd88>
 1018d6c:	008040f4 	movhi	r2,259
 1018d70:	10aa8504 	addi	r2,r2,-21996
 1018d74:	d8803915 	stw	r2,228(sp)
 1018d78:	04401e04 	movi	r17,120
 1018d7c:	d8802917 	ldw	r2,164(sp)
 1018d80:	0039883a 	mov	fp,zero
 1018d84:	1001e926 	beq	r2,zero,101952c <___vfprintf_internal_r+0xb2c>
 1018d88:	0027883a 	mov	r19,zero
 1018d8c:	002d883a 	mov	r22,zero
 1018d90:	00020506 	br	10195a8 <___vfprintf_internal_r+0xba8>
 1018d94:	d9002c17 	ldw	r4,176(sp)
 1018d98:	b80b883a 	mov	r5,r23
 1018d9c:	101acd00 	call	101acd0 <__swsetup_r>
 1018da0:	1005ac1e 	bne	r2,zero,101a454 <___vfprintf_internal_r+0x1a54>
 1018da4:	b880030b 	ldhu	r2,12(r23)
 1018da8:	00c00284 	movi	r3,10
 1018dac:	1080068c 	andi	r2,r2,26
 1018db0:	10ff3c1e 	bne	r2,r3,1018aa4 <__alt_data_end+0xff018aa4>
 1018db4:	b880038f 	ldh	r2,14(r23)
 1018db8:	103f3a16 	blt	r2,zero,1018aa4 <__alt_data_end+0xff018aa4>
 1018dbc:	d9c02d17 	ldw	r7,180(sp)
 1018dc0:	d9002c17 	ldw	r4,176(sp)
 1018dc4:	a80d883a 	mov	r6,r21
 1018dc8:	b80b883a 	mov	r5,r23
 1018dcc:	101ac140 	call	101ac14 <__sbprintf>
 1018dd0:	00001106 	br	1018e18 <___vfprintf_internal_r+0x418>
 1018dd4:	d9002c17 	ldw	r4,176(sp)
 1018dd8:	d9801e04 	addi	r6,sp,120
 1018ddc:	b80b883a 	mov	r5,r23
 1018de0:	10213d80 	call	10213d8 <__sprint_r>
 1018de4:	1000081e 	bne	r2,zero,1018e08 <___vfprintf_internal_r+0x408>
 1018de8:	da000404 	addi	r8,sp,16
 1018dec:	003f5306 	br	1018b3c <__alt_data_end+0xff018b3c>
 1018df0:	d8802017 	ldw	r2,128(sp)
 1018df4:	10000426 	beq	r2,zero,1018e08 <___vfprintf_internal_r+0x408>
 1018df8:	d9002c17 	ldw	r4,176(sp)
 1018dfc:	d9801e04 	addi	r6,sp,120
 1018e00:	b80b883a 	mov	r5,r23
 1018e04:	10213d80 	call	10213d8 <__sprint_r>
 1018e08:	b880030b 	ldhu	r2,12(r23)
 1018e0c:	1080100c 	andi	r2,r2,64
 1018e10:	1005901e 	bne	r2,zero,101a454 <___vfprintf_internal_r+0x1a54>
 1018e14:	d8802f17 	ldw	r2,188(sp)
 1018e18:	dfc04717 	ldw	ra,284(sp)
 1018e1c:	df004617 	ldw	fp,280(sp)
 1018e20:	ddc04517 	ldw	r23,276(sp)
 1018e24:	dd804417 	ldw	r22,272(sp)
 1018e28:	dd404317 	ldw	r21,268(sp)
 1018e2c:	dd004217 	ldw	r20,264(sp)
 1018e30:	dcc04117 	ldw	r19,260(sp)
 1018e34:	dc804017 	ldw	r18,256(sp)
 1018e38:	dc403f17 	ldw	r17,252(sp)
 1018e3c:	dc003e17 	ldw	r16,248(sp)
 1018e40:	dec04804 	addi	sp,sp,288
 1018e44:	f800283a 	ret
 1018e48:	d9002c17 	ldw	r4,176(sp)
 1018e4c:	101ccbc0 	call	101ccbc <__sinit>
 1018e50:	003f0406 	br	1018a64 <__alt_data_end+0xff018a64>
 1018e54:	d8802d17 	ldw	r2,180(sp)
 1018e58:	d9002d17 	ldw	r4,180(sp)
 1018e5c:	10800017 	ldw	r2,0(r2)
 1018e60:	d8803115 	stw	r2,196(sp)
 1018e64:	20800104 	addi	r2,r4,4
 1018e68:	d9003117 	ldw	r4,196(sp)
 1018e6c:	203fa716 	blt	r4,zero,1018d0c <__alt_data_end+0xff018d0c>
 1018e70:	d8802d15 	stw	r2,180(sp)
 1018e74:	ac400007 	ldb	r17,0(r21)
 1018e78:	003f4206 	br	1018b84 <__alt_data_end+0xff018b84>
 1018e7c:	ac400007 	ldb	r17,0(r21)
 1018e80:	aac00044 	addi	r11,r21,1
 1018e84:	8a872826 	beq	r17,r10,101ab28 <___vfprintf_internal_r+0x2128>
 1018e88:	88bff404 	addi	r2,r17,-48
 1018e8c:	0009883a 	mov	r4,zero
 1018e90:	30867d36 	bltu	r6,r2,101a888 <___vfprintf_internal_r+0x1e88>
 1018e94:	5c400007 	ldb	r17,0(r11)
 1018e98:	210002a4 	muli	r4,r4,10
 1018e9c:	5d400044 	addi	r21,r11,1
 1018ea0:	a817883a 	mov	r11,r21
 1018ea4:	2089883a 	add	r4,r4,r2
 1018ea8:	88bff404 	addi	r2,r17,-48
 1018eac:	30bff92e 	bgeu	r6,r2,1018e94 <__alt_data_end+0xff018e94>
 1018eb0:	2005c916 	blt	r4,zero,101a5d8 <___vfprintf_internal_r+0x1bd8>
 1018eb4:	d9002915 	stw	r4,164(sp)
 1018eb8:	003f3306 	br	1018b88 <__alt_data_end+0xff018b88>
 1018ebc:	94802014 	ori	r18,r18,128
 1018ec0:	ac400007 	ldb	r17,0(r21)
 1018ec4:	003f2f06 	br	1018b84 <__alt_data_end+0xff018b84>
 1018ec8:	a809883a 	mov	r4,r21
 1018ecc:	d8003115 	stw	zero,196(sp)
 1018ed0:	88bff404 	addi	r2,r17,-48
 1018ed4:	0017883a 	mov	r11,zero
 1018ed8:	24400007 	ldb	r17,0(r4)
 1018edc:	5ac002a4 	muli	r11,r11,10
 1018ee0:	ad400044 	addi	r21,r21,1
 1018ee4:	a809883a 	mov	r4,r21
 1018ee8:	12d7883a 	add	r11,r2,r11
 1018eec:	88bff404 	addi	r2,r17,-48
 1018ef0:	30bff92e 	bgeu	r6,r2,1018ed8 <__alt_data_end+0xff018ed8>
 1018ef4:	dac03115 	stw	r11,196(sp)
 1018ef8:	003f2306 	br	1018b88 <__alt_data_end+0xff018b88>
 1018efc:	18c03fcc 	andi	r3,r3,255
 1018f00:	18072b1e 	bne	r3,zero,101abb0 <___vfprintf_internal_r+0x21b0>
 1018f04:	94800414 	ori	r18,r18,16
 1018f08:	9080080c 	andi	r2,r18,32
 1018f0c:	10037b26 	beq	r2,zero,1019cfc <___vfprintf_internal_r+0x12fc>
 1018f10:	d9402d17 	ldw	r5,180(sp)
 1018f14:	28800117 	ldw	r2,4(r5)
 1018f18:	2cc00017 	ldw	r19,0(r5)
 1018f1c:	29400204 	addi	r5,r5,8
 1018f20:	d9402d15 	stw	r5,180(sp)
 1018f24:	102d883a 	mov	r22,r2
 1018f28:	10044b16 	blt	r2,zero,101a058 <___vfprintf_internal_r+0x1658>
 1018f2c:	d9402917 	ldw	r5,164(sp)
 1018f30:	df002783 	ldbu	fp,158(sp)
 1018f34:	2803bc16 	blt	r5,zero,1019e28 <___vfprintf_internal_r+0x1428>
 1018f38:	00ffdfc4 	movi	r3,-129
 1018f3c:	9d84b03a 	or	r2,r19,r22
 1018f40:	90e4703a 	and	r18,r18,r3
 1018f44:	10017726 	beq	r2,zero,1019524 <___vfprintf_internal_r+0xb24>
 1018f48:	b0038326 	beq	r22,zero,1019d58 <___vfprintf_internal_r+0x1358>
 1018f4c:	dc402a15 	stw	r17,168(sp)
 1018f50:	dc001e04 	addi	r16,sp,120
 1018f54:	b023883a 	mov	r17,r22
 1018f58:	402d883a 	mov	r22,r8
 1018f5c:	9809883a 	mov	r4,r19
 1018f60:	880b883a 	mov	r5,r17
 1018f64:	01800284 	movi	r6,10
 1018f68:	000f883a 	mov	r7,zero
 1018f6c:	10237d00 	call	10237d0 <__umoddi3>
 1018f70:	10800c04 	addi	r2,r2,48
 1018f74:	843fffc4 	addi	r16,r16,-1
 1018f78:	9809883a 	mov	r4,r19
 1018f7c:	880b883a 	mov	r5,r17
 1018f80:	80800005 	stb	r2,0(r16)
 1018f84:	01800284 	movi	r6,10
 1018f88:	000f883a 	mov	r7,zero
 1018f8c:	10232580 	call	1023258 <__udivdi3>
 1018f90:	1027883a 	mov	r19,r2
 1018f94:	10c4b03a 	or	r2,r2,r3
 1018f98:	1823883a 	mov	r17,r3
 1018f9c:	103fef1e 	bne	r2,zero,1018f5c <__alt_data_end+0xff018f5c>
 1018fa0:	d8c02817 	ldw	r3,160(sp)
 1018fa4:	dc402a17 	ldw	r17,168(sp)
 1018fa8:	b011883a 	mov	r8,r22
 1018fac:	1c07c83a 	sub	r3,r3,r16
 1018fb0:	d8c02e15 	stw	r3,184(sp)
 1018fb4:	00005906 	br	101911c <___vfprintf_internal_r+0x71c>
 1018fb8:	18c03fcc 	andi	r3,r3,255
 1018fbc:	1806fa1e 	bne	r3,zero,101aba8 <___vfprintf_internal_r+0x21a8>
 1018fc0:	9080020c 	andi	r2,r18,8
 1018fc4:	10048a26 	beq	r2,zero,101a1f0 <___vfprintf_internal_r+0x17f0>
 1018fc8:	d8c02d17 	ldw	r3,180(sp)
 1018fcc:	d9002d17 	ldw	r4,180(sp)
 1018fd0:	d9402d17 	ldw	r5,180(sp)
 1018fd4:	18c00017 	ldw	r3,0(r3)
 1018fd8:	21000117 	ldw	r4,4(r4)
 1018fdc:	29400204 	addi	r5,r5,8
 1018fe0:	d8c03615 	stw	r3,216(sp)
 1018fe4:	d9003815 	stw	r4,224(sp)
 1018fe8:	d9402d15 	stw	r5,180(sp)
 1018fec:	d9003617 	ldw	r4,216(sp)
 1018ff0:	d9403817 	ldw	r5,224(sp)
 1018ff4:	da003d15 	stw	r8,244(sp)
 1018ff8:	04000044 	movi	r16,1
 1018ffc:	101f9c80 	call	101f9c8 <__fpclassifyd>
 1019000:	da003d17 	ldw	r8,244(sp)
 1019004:	14041f1e 	bne	r2,r16,101a084 <___vfprintf_internal_r+0x1684>
 1019008:	d9003617 	ldw	r4,216(sp)
 101900c:	d9403817 	ldw	r5,224(sp)
 1019010:	000d883a 	mov	r6,zero
 1019014:	000f883a 	mov	r7,zero
 1019018:	10251b40 	call	10251b4 <__ledf2>
 101901c:	da003d17 	ldw	r8,244(sp)
 1019020:	1005be16 	blt	r2,zero,101a71c <___vfprintf_internal_r+0x1d1c>
 1019024:	df002783 	ldbu	fp,158(sp)
 1019028:	008011c4 	movi	r2,71
 101902c:	1445330e 	bge	r2,r17,101a4fc <___vfprintf_internal_r+0x1afc>
 1019030:	040040f4 	movhi	r16,259
 1019034:	842a7d04 	addi	r16,r16,-22028
 1019038:	00c000c4 	movi	r3,3
 101903c:	00bfdfc4 	movi	r2,-129
 1019040:	d8c02a15 	stw	r3,168(sp)
 1019044:	90a4703a 	and	r18,r18,r2
 1019048:	d8c02e15 	stw	r3,184(sp)
 101904c:	d8002915 	stw	zero,164(sp)
 1019050:	d8003215 	stw	zero,200(sp)
 1019054:	00003706 	br	1019134 <___vfprintf_internal_r+0x734>
 1019058:	94800214 	ori	r18,r18,8
 101905c:	ac400007 	ldb	r17,0(r21)
 1019060:	003ec806 	br	1018b84 <__alt_data_end+0xff018b84>
 1019064:	18c03fcc 	andi	r3,r3,255
 1019068:	1806db1e 	bne	r3,zero,101abd8 <___vfprintf_internal_r+0x21d8>
 101906c:	94800414 	ori	r18,r18,16
 1019070:	9080080c 	andi	r2,r18,32
 1019074:	1002d826 	beq	r2,zero,1019bd8 <___vfprintf_internal_r+0x11d8>
 1019078:	d9402d17 	ldw	r5,180(sp)
 101907c:	d8c02917 	ldw	r3,164(sp)
 1019080:	d8002785 	stb	zero,158(sp)
 1019084:	28800204 	addi	r2,r5,8
 1019088:	2cc00017 	ldw	r19,0(r5)
 101908c:	2d800117 	ldw	r22,4(r5)
 1019090:	18048f16 	blt	r3,zero,101a2d0 <___vfprintf_internal_r+0x18d0>
 1019094:	013fdfc4 	movi	r4,-129
 1019098:	9d86b03a 	or	r3,r19,r22
 101909c:	d8802d15 	stw	r2,180(sp)
 10190a0:	9124703a 	and	r18,r18,r4
 10190a4:	1802d91e 	bne	r3,zero,1019c0c <___vfprintf_internal_r+0x120c>
 10190a8:	d8c02917 	ldw	r3,164(sp)
 10190ac:	0039883a 	mov	fp,zero
 10190b0:	1805c326 	beq	r3,zero,101a7c0 <___vfprintf_internal_r+0x1dc0>
 10190b4:	0027883a 	mov	r19,zero
 10190b8:	002d883a 	mov	r22,zero
 10190bc:	dc001e04 	addi	r16,sp,120
 10190c0:	9806d0fa 	srli	r3,r19,3
 10190c4:	b008977a 	slli	r4,r22,29
 10190c8:	b02cd0fa 	srli	r22,r22,3
 10190cc:	9cc001cc 	andi	r19,r19,7
 10190d0:	98800c04 	addi	r2,r19,48
 10190d4:	843fffc4 	addi	r16,r16,-1
 10190d8:	20e6b03a 	or	r19,r4,r3
 10190dc:	80800005 	stb	r2,0(r16)
 10190e0:	9d86b03a 	or	r3,r19,r22
 10190e4:	183ff61e 	bne	r3,zero,10190c0 <__alt_data_end+0xff0190c0>
 10190e8:	90c0004c 	andi	r3,r18,1
 10190ec:	18013b26 	beq	r3,zero,10195dc <___vfprintf_internal_r+0xbdc>
 10190f0:	10803fcc 	andi	r2,r2,255
 10190f4:	1080201c 	xori	r2,r2,128
 10190f8:	10bfe004 	addi	r2,r2,-128
 10190fc:	00c00c04 	movi	r3,48
 1019100:	10c13626 	beq	r2,r3,10195dc <___vfprintf_internal_r+0xbdc>
 1019104:	80ffffc5 	stb	r3,-1(r16)
 1019108:	d8c02817 	ldw	r3,160(sp)
 101910c:	80bfffc4 	addi	r2,r16,-1
 1019110:	1021883a 	mov	r16,r2
 1019114:	1887c83a 	sub	r3,r3,r2
 1019118:	d8c02e15 	stw	r3,184(sp)
 101911c:	d8802e17 	ldw	r2,184(sp)
 1019120:	d9002917 	ldw	r4,164(sp)
 1019124:	1100010e 	bge	r2,r4,101912c <___vfprintf_internal_r+0x72c>
 1019128:	2005883a 	mov	r2,r4
 101912c:	d8802a15 	stw	r2,168(sp)
 1019130:	d8003215 	stw	zero,200(sp)
 1019134:	e7003fcc 	andi	fp,fp,255
 1019138:	e700201c 	xori	fp,fp,128
 101913c:	e73fe004 	addi	fp,fp,-128
 1019140:	e0000326 	beq	fp,zero,1019150 <___vfprintf_internal_r+0x750>
 1019144:	d8c02a17 	ldw	r3,168(sp)
 1019148:	18c00044 	addi	r3,r3,1
 101914c:	d8c02a15 	stw	r3,168(sp)
 1019150:	90c0008c 	andi	r3,r18,2
 1019154:	d8c02b15 	stw	r3,172(sp)
 1019158:	18000326 	beq	r3,zero,1019168 <___vfprintf_internal_r+0x768>
 101915c:	d8c02a17 	ldw	r3,168(sp)
 1019160:	18c00084 	addi	r3,r3,2
 1019164:	d8c02a15 	stw	r3,168(sp)
 1019168:	90c0210c 	andi	r3,r18,132
 101916c:	d8c03015 	stw	r3,192(sp)
 1019170:	1801a31e 	bne	r3,zero,1019800 <___vfprintf_internal_r+0xe00>
 1019174:	d9003117 	ldw	r4,196(sp)
 1019178:	d8c02a17 	ldw	r3,168(sp)
 101917c:	20e7c83a 	sub	r19,r4,r3
 1019180:	04c19f0e 	bge	zero,r19,1019800 <___vfprintf_internal_r+0xe00>
 1019184:	02400404 	movi	r9,16
 1019188:	d8c02017 	ldw	r3,128(sp)
 101918c:	d8801f17 	ldw	r2,124(sp)
 1019190:	4cc50d0e 	bge	r9,r19,101a5c8 <___vfprintf_internal_r+0x1bc8>
 1019194:	014040f4 	movhi	r5,259
 1019198:	296a9884 	addi	r5,r5,-21918
 101919c:	dc403b15 	stw	r17,236(sp)
 10191a0:	d9403515 	stw	r5,212(sp)
 10191a4:	9823883a 	mov	r17,r19
 10191a8:	482d883a 	mov	r22,r9
 10191ac:	9027883a 	mov	r19,r18
 10191b0:	070001c4 	movi	fp,7
 10191b4:	8025883a 	mov	r18,r16
 10191b8:	dc002c17 	ldw	r16,176(sp)
 10191bc:	00000306 	br	10191cc <___vfprintf_internal_r+0x7cc>
 10191c0:	8c7ffc04 	addi	r17,r17,-16
 10191c4:	42000204 	addi	r8,r8,8
 10191c8:	b440130e 	bge	r22,r17,1019218 <___vfprintf_internal_r+0x818>
 10191cc:	010040f4 	movhi	r4,259
 10191d0:	18c00404 	addi	r3,r3,16
 10191d4:	10800044 	addi	r2,r2,1
 10191d8:	212a9884 	addi	r4,r4,-21918
 10191dc:	41000015 	stw	r4,0(r8)
 10191e0:	45800115 	stw	r22,4(r8)
 10191e4:	d8c02015 	stw	r3,128(sp)
 10191e8:	d8801f15 	stw	r2,124(sp)
 10191ec:	e0bff40e 	bge	fp,r2,10191c0 <__alt_data_end+0xff0191c0>
 10191f0:	d9801e04 	addi	r6,sp,120
 10191f4:	b80b883a 	mov	r5,r23
 10191f8:	8009883a 	mov	r4,r16
 10191fc:	10213d80 	call	10213d8 <__sprint_r>
 1019200:	103f011e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019204:	8c7ffc04 	addi	r17,r17,-16
 1019208:	d8c02017 	ldw	r3,128(sp)
 101920c:	d8801f17 	ldw	r2,124(sp)
 1019210:	da000404 	addi	r8,sp,16
 1019214:	b47fed16 	blt	r22,r17,10191cc <__alt_data_end+0xff0191cc>
 1019218:	9021883a 	mov	r16,r18
 101921c:	9825883a 	mov	r18,r19
 1019220:	8827883a 	mov	r19,r17
 1019224:	dc403b17 	ldw	r17,236(sp)
 1019228:	d9403517 	ldw	r5,212(sp)
 101922c:	98c7883a 	add	r3,r19,r3
 1019230:	10800044 	addi	r2,r2,1
 1019234:	41400015 	stw	r5,0(r8)
 1019238:	44c00115 	stw	r19,4(r8)
 101923c:	d8c02015 	stw	r3,128(sp)
 1019240:	d8801f15 	stw	r2,124(sp)
 1019244:	010001c4 	movi	r4,7
 1019248:	2082a316 	blt	r4,r2,1019cd8 <___vfprintf_internal_r+0x12d8>
 101924c:	df002787 	ldb	fp,158(sp)
 1019250:	42000204 	addi	r8,r8,8
 1019254:	e0000c26 	beq	fp,zero,1019288 <___vfprintf_internal_r+0x888>
 1019258:	d8801f17 	ldw	r2,124(sp)
 101925c:	d9002784 	addi	r4,sp,158
 1019260:	18c00044 	addi	r3,r3,1
 1019264:	10800044 	addi	r2,r2,1
 1019268:	41000015 	stw	r4,0(r8)
 101926c:	01000044 	movi	r4,1
 1019270:	41000115 	stw	r4,4(r8)
 1019274:	d8c02015 	stw	r3,128(sp)
 1019278:	d8801f15 	stw	r2,124(sp)
 101927c:	010001c4 	movi	r4,7
 1019280:	20823c16 	blt	r4,r2,1019b74 <___vfprintf_internal_r+0x1174>
 1019284:	42000204 	addi	r8,r8,8
 1019288:	d8802b17 	ldw	r2,172(sp)
 101928c:	10000c26 	beq	r2,zero,10192c0 <___vfprintf_internal_r+0x8c0>
 1019290:	d8801f17 	ldw	r2,124(sp)
 1019294:	d9002704 	addi	r4,sp,156
 1019298:	18c00084 	addi	r3,r3,2
 101929c:	10800044 	addi	r2,r2,1
 10192a0:	41000015 	stw	r4,0(r8)
 10192a4:	01000084 	movi	r4,2
 10192a8:	41000115 	stw	r4,4(r8)
 10192ac:	d8c02015 	stw	r3,128(sp)
 10192b0:	d8801f15 	stw	r2,124(sp)
 10192b4:	010001c4 	movi	r4,7
 10192b8:	20823616 	blt	r4,r2,1019b94 <___vfprintf_internal_r+0x1194>
 10192bc:	42000204 	addi	r8,r8,8
 10192c0:	d9003017 	ldw	r4,192(sp)
 10192c4:	00802004 	movi	r2,128
 10192c8:	20819926 	beq	r4,r2,1019930 <___vfprintf_internal_r+0xf30>
 10192cc:	d9402917 	ldw	r5,164(sp)
 10192d0:	d8802e17 	ldw	r2,184(sp)
 10192d4:	28adc83a 	sub	r22,r5,r2
 10192d8:	0580310e 	bge	zero,r22,10193a0 <___vfprintf_internal_r+0x9a0>
 10192dc:	07000404 	movi	fp,16
 10192e0:	d8801f17 	ldw	r2,124(sp)
 10192e4:	e584140e 	bge	fp,r22,101a338 <___vfprintf_internal_r+0x1938>
 10192e8:	014040f4 	movhi	r5,259
 10192ec:	296a9484 	addi	r5,r5,-21934
 10192f0:	dc402915 	stw	r17,164(sp)
 10192f4:	d9402b15 	stw	r5,172(sp)
 10192f8:	b023883a 	mov	r17,r22
 10192fc:	04c001c4 	movi	r19,7
 1019300:	a82d883a 	mov	r22,r21
 1019304:	902b883a 	mov	r21,r18
 1019308:	8025883a 	mov	r18,r16
 101930c:	dc002c17 	ldw	r16,176(sp)
 1019310:	00000306 	br	1019320 <___vfprintf_internal_r+0x920>
 1019314:	8c7ffc04 	addi	r17,r17,-16
 1019318:	42000204 	addi	r8,r8,8
 101931c:	e440110e 	bge	fp,r17,1019364 <___vfprintf_internal_r+0x964>
 1019320:	18c00404 	addi	r3,r3,16
 1019324:	10800044 	addi	r2,r2,1
 1019328:	45000015 	stw	r20,0(r8)
 101932c:	47000115 	stw	fp,4(r8)
 1019330:	d8c02015 	stw	r3,128(sp)
 1019334:	d8801f15 	stw	r2,124(sp)
 1019338:	98bff60e 	bge	r19,r2,1019314 <__alt_data_end+0xff019314>
 101933c:	d9801e04 	addi	r6,sp,120
 1019340:	b80b883a 	mov	r5,r23
 1019344:	8009883a 	mov	r4,r16
 1019348:	10213d80 	call	10213d8 <__sprint_r>
 101934c:	103eae1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019350:	8c7ffc04 	addi	r17,r17,-16
 1019354:	d8c02017 	ldw	r3,128(sp)
 1019358:	d8801f17 	ldw	r2,124(sp)
 101935c:	da000404 	addi	r8,sp,16
 1019360:	e47fef16 	blt	fp,r17,1019320 <__alt_data_end+0xff019320>
 1019364:	9021883a 	mov	r16,r18
 1019368:	a825883a 	mov	r18,r21
 101936c:	b02b883a 	mov	r21,r22
 1019370:	882d883a 	mov	r22,r17
 1019374:	dc402917 	ldw	r17,164(sp)
 1019378:	d9002b17 	ldw	r4,172(sp)
 101937c:	1d87883a 	add	r3,r3,r22
 1019380:	10800044 	addi	r2,r2,1
 1019384:	41000015 	stw	r4,0(r8)
 1019388:	45800115 	stw	r22,4(r8)
 101938c:	d8c02015 	stw	r3,128(sp)
 1019390:	d8801f15 	stw	r2,124(sp)
 1019394:	010001c4 	movi	r4,7
 1019398:	2081ee16 	blt	r4,r2,1019b54 <___vfprintf_internal_r+0x1154>
 101939c:	42000204 	addi	r8,r8,8
 10193a0:	9080400c 	andi	r2,r18,256
 10193a4:	1001181e 	bne	r2,zero,1019808 <___vfprintf_internal_r+0xe08>
 10193a8:	d9402e17 	ldw	r5,184(sp)
 10193ac:	d8801f17 	ldw	r2,124(sp)
 10193b0:	44000015 	stw	r16,0(r8)
 10193b4:	1947883a 	add	r3,r3,r5
 10193b8:	10800044 	addi	r2,r2,1
 10193bc:	41400115 	stw	r5,4(r8)
 10193c0:	d8c02015 	stw	r3,128(sp)
 10193c4:	d8801f15 	stw	r2,124(sp)
 10193c8:	010001c4 	movi	r4,7
 10193cc:	2081d316 	blt	r4,r2,1019b1c <___vfprintf_internal_r+0x111c>
 10193d0:	42000204 	addi	r8,r8,8
 10193d4:	9480010c 	andi	r18,r18,4
 10193d8:	90003226 	beq	r18,zero,10194a4 <___vfprintf_internal_r+0xaa4>
 10193dc:	d9403117 	ldw	r5,196(sp)
 10193e0:	d8802a17 	ldw	r2,168(sp)
 10193e4:	28a1c83a 	sub	r16,r5,r2
 10193e8:	04002e0e 	bge	zero,r16,10194a4 <___vfprintf_internal_r+0xaa4>
 10193ec:	04400404 	movi	r17,16
 10193f0:	d8801f17 	ldw	r2,124(sp)
 10193f4:	8c04a20e 	bge	r17,r16,101a680 <___vfprintf_internal_r+0x1c80>
 10193f8:	014040f4 	movhi	r5,259
 10193fc:	296a9884 	addi	r5,r5,-21918
 1019400:	d9403515 	stw	r5,212(sp)
 1019404:	048001c4 	movi	r18,7
 1019408:	dcc02c17 	ldw	r19,176(sp)
 101940c:	00000306 	br	101941c <___vfprintf_internal_r+0xa1c>
 1019410:	843ffc04 	addi	r16,r16,-16
 1019414:	42000204 	addi	r8,r8,8
 1019418:	8c00130e 	bge	r17,r16,1019468 <___vfprintf_internal_r+0xa68>
 101941c:	010040f4 	movhi	r4,259
 1019420:	18c00404 	addi	r3,r3,16
 1019424:	10800044 	addi	r2,r2,1
 1019428:	212a9884 	addi	r4,r4,-21918
 101942c:	41000015 	stw	r4,0(r8)
 1019430:	44400115 	stw	r17,4(r8)
 1019434:	d8c02015 	stw	r3,128(sp)
 1019438:	d8801f15 	stw	r2,124(sp)
 101943c:	90bff40e 	bge	r18,r2,1019410 <__alt_data_end+0xff019410>
 1019440:	d9801e04 	addi	r6,sp,120
 1019444:	b80b883a 	mov	r5,r23
 1019448:	9809883a 	mov	r4,r19
 101944c:	10213d80 	call	10213d8 <__sprint_r>
 1019450:	103e6d1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019454:	843ffc04 	addi	r16,r16,-16
 1019458:	d8c02017 	ldw	r3,128(sp)
 101945c:	d8801f17 	ldw	r2,124(sp)
 1019460:	da000404 	addi	r8,sp,16
 1019464:	8c3fed16 	blt	r17,r16,101941c <__alt_data_end+0xff01941c>
 1019468:	d9403517 	ldw	r5,212(sp)
 101946c:	1c07883a 	add	r3,r3,r16
 1019470:	10800044 	addi	r2,r2,1
 1019474:	41400015 	stw	r5,0(r8)
 1019478:	44000115 	stw	r16,4(r8)
 101947c:	d8c02015 	stw	r3,128(sp)
 1019480:	d8801f15 	stw	r2,124(sp)
 1019484:	010001c4 	movi	r4,7
 1019488:	2080060e 	bge	r4,r2,10194a4 <___vfprintf_internal_r+0xaa4>
 101948c:	d9002c17 	ldw	r4,176(sp)
 1019490:	d9801e04 	addi	r6,sp,120
 1019494:	b80b883a 	mov	r5,r23
 1019498:	10213d80 	call	10213d8 <__sprint_r>
 101949c:	103e5a1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 10194a0:	d8c02017 	ldw	r3,128(sp)
 10194a4:	d8803117 	ldw	r2,196(sp)
 10194a8:	d9002a17 	ldw	r4,168(sp)
 10194ac:	1100010e 	bge	r2,r4,10194b4 <___vfprintf_internal_r+0xab4>
 10194b0:	2005883a 	mov	r2,r4
 10194b4:	d9402f17 	ldw	r5,188(sp)
 10194b8:	288b883a 	add	r5,r5,r2
 10194bc:	d9402f15 	stw	r5,188(sp)
 10194c0:	18019e1e 	bne	r3,zero,1019b3c <___vfprintf_internal_r+0x113c>
 10194c4:	a8800007 	ldb	r2,0(r21)
 10194c8:	d8001f15 	stw	zero,124(sp)
 10194cc:	da000404 	addi	r8,sp,16
 10194d0:	103d851e 	bne	r2,zero,1018ae8 <__alt_data_end+0xff018ae8>
 10194d4:	a821883a 	mov	r16,r21
 10194d8:	003d9b06 	br	1018b48 <__alt_data_end+0xff018b48>
 10194dc:	18c03fcc 	andi	r3,r3,255
 10194e0:	1805c11e 	bne	r3,zero,101abe8 <___vfprintf_internal_r+0x21e8>
 10194e4:	94800414 	ori	r18,r18,16
 10194e8:	9080080c 	andi	r2,r18,32
 10194ec:	10020c26 	beq	r2,zero,1019d20 <___vfprintf_internal_r+0x1320>
 10194f0:	d8802d17 	ldw	r2,180(sp)
 10194f4:	d9002917 	ldw	r4,164(sp)
 10194f8:	d8002785 	stb	zero,158(sp)
 10194fc:	10c00204 	addi	r3,r2,8
 1019500:	14c00017 	ldw	r19,0(r2)
 1019504:	15800117 	ldw	r22,4(r2)
 1019508:	20040f16 	blt	r4,zero,101a548 <___vfprintf_internal_r+0x1b48>
 101950c:	013fdfc4 	movi	r4,-129
 1019510:	9d84b03a 	or	r2,r19,r22
 1019514:	d8c02d15 	stw	r3,180(sp)
 1019518:	9124703a 	and	r18,r18,r4
 101951c:	0039883a 	mov	fp,zero
 1019520:	103e891e 	bne	r2,zero,1018f48 <__alt_data_end+0xff018f48>
 1019524:	d9002917 	ldw	r4,164(sp)
 1019528:	2002c11e 	bne	r4,zero,101a030 <___vfprintf_internal_r+0x1630>
 101952c:	d8002915 	stw	zero,164(sp)
 1019530:	d8002e15 	stw	zero,184(sp)
 1019534:	dc001e04 	addi	r16,sp,120
 1019538:	003ef806 	br	101911c <__alt_data_end+0xff01911c>
 101953c:	18c03fcc 	andi	r3,r3,255
 1019540:	18059d1e 	bne	r3,zero,101abb8 <___vfprintf_internal_r+0x21b8>
 1019544:	014040f4 	movhi	r5,259
 1019548:	296a8004 	addi	r5,r5,-22016
 101954c:	d9403915 	stw	r5,228(sp)
 1019550:	9080080c 	andi	r2,r18,32
 1019554:	10005226 	beq	r2,zero,10196a0 <___vfprintf_internal_r+0xca0>
 1019558:	d8802d17 	ldw	r2,180(sp)
 101955c:	14c00017 	ldw	r19,0(r2)
 1019560:	15800117 	ldw	r22,4(r2)
 1019564:	10800204 	addi	r2,r2,8
 1019568:	d8802d15 	stw	r2,180(sp)
 101956c:	9080004c 	andi	r2,r18,1
 1019570:	10019026 	beq	r2,zero,1019bb4 <___vfprintf_internal_r+0x11b4>
 1019574:	9d84b03a 	or	r2,r19,r22
 1019578:	10036926 	beq	r2,zero,101a320 <___vfprintf_internal_r+0x1920>
 101957c:	d8c02917 	ldw	r3,164(sp)
 1019580:	00800c04 	movi	r2,48
 1019584:	d8802705 	stb	r2,156(sp)
 1019588:	dc402745 	stb	r17,157(sp)
 101958c:	d8002785 	stb	zero,158(sp)
 1019590:	90800094 	ori	r2,r18,2
 1019594:	18045d16 	blt	r3,zero,101a70c <___vfprintf_internal_r+0x1d0c>
 1019598:	00bfdfc4 	movi	r2,-129
 101959c:	90a4703a 	and	r18,r18,r2
 10195a0:	94800094 	ori	r18,r18,2
 10195a4:	0039883a 	mov	fp,zero
 10195a8:	d9003917 	ldw	r4,228(sp)
 10195ac:	dc001e04 	addi	r16,sp,120
 10195b0:	988003cc 	andi	r2,r19,15
 10195b4:	b006973a 	slli	r3,r22,28
 10195b8:	2085883a 	add	r2,r4,r2
 10195bc:	9826d13a 	srli	r19,r19,4
 10195c0:	10800003 	ldbu	r2,0(r2)
 10195c4:	b02cd13a 	srli	r22,r22,4
 10195c8:	843fffc4 	addi	r16,r16,-1
 10195cc:	1ce6b03a 	or	r19,r3,r19
 10195d0:	80800005 	stb	r2,0(r16)
 10195d4:	9d84b03a 	or	r2,r19,r22
 10195d8:	103ff51e 	bne	r2,zero,10195b0 <__alt_data_end+0xff0195b0>
 10195dc:	d8c02817 	ldw	r3,160(sp)
 10195e0:	1c07c83a 	sub	r3,r3,r16
 10195e4:	d8c02e15 	stw	r3,184(sp)
 10195e8:	003ecc06 	br	101911c <__alt_data_end+0xff01911c>
 10195ec:	18c03fcc 	andi	r3,r3,255
 10195f0:	183e9f26 	beq	r3,zero,1019070 <__alt_data_end+0xff019070>
 10195f4:	d9c02785 	stb	r7,158(sp)
 10195f8:	003e9d06 	br	1019070 <__alt_data_end+0xff019070>
 10195fc:	00c00044 	movi	r3,1
 1019600:	01c00ac4 	movi	r7,43
 1019604:	ac400007 	ldb	r17,0(r21)
 1019608:	003d5e06 	br	1018b84 <__alt_data_end+0xff018b84>
 101960c:	94800814 	ori	r18,r18,32
 1019610:	ac400007 	ldb	r17,0(r21)
 1019614:	003d5b06 	br	1018b84 <__alt_data_end+0xff018b84>
 1019618:	d8c02d17 	ldw	r3,180(sp)
 101961c:	d8002785 	stb	zero,158(sp)
 1019620:	1c000017 	ldw	r16,0(r3)
 1019624:	1cc00104 	addi	r19,r3,4
 1019628:	80041926 	beq	r16,zero,101a690 <___vfprintf_internal_r+0x1c90>
 101962c:	d9002917 	ldw	r4,164(sp)
 1019630:	2003d016 	blt	r4,zero,101a574 <___vfprintf_internal_r+0x1b74>
 1019634:	200d883a 	mov	r6,r4
 1019638:	000b883a 	mov	r5,zero
 101963c:	8009883a 	mov	r4,r16
 1019640:	da003d15 	stw	r8,244(sp)
 1019644:	101e2280 	call	101e228 <memchr>
 1019648:	da003d17 	ldw	r8,244(sp)
 101964c:	10045426 	beq	r2,zero,101a7a0 <___vfprintf_internal_r+0x1da0>
 1019650:	1405c83a 	sub	r2,r2,r16
 1019654:	d8802e15 	stw	r2,184(sp)
 1019658:	1003cc16 	blt	r2,zero,101a58c <___vfprintf_internal_r+0x1b8c>
 101965c:	df002783 	ldbu	fp,158(sp)
 1019660:	d8802a15 	stw	r2,168(sp)
 1019664:	dcc02d15 	stw	r19,180(sp)
 1019668:	d8002915 	stw	zero,164(sp)
 101966c:	d8003215 	stw	zero,200(sp)
 1019670:	003eb006 	br	1019134 <__alt_data_end+0xff019134>
 1019674:	18c03fcc 	andi	r3,r3,255
 1019678:	183f9b26 	beq	r3,zero,10194e8 <__alt_data_end+0xff0194e8>
 101967c:	d9c02785 	stb	r7,158(sp)
 1019680:	003f9906 	br	10194e8 <__alt_data_end+0xff0194e8>
 1019684:	18c03fcc 	andi	r3,r3,255
 1019688:	1805551e 	bne	r3,zero,101abe0 <___vfprintf_internal_r+0x21e0>
 101968c:	014040f4 	movhi	r5,259
 1019690:	296a8504 	addi	r5,r5,-21996
 1019694:	d9403915 	stw	r5,228(sp)
 1019698:	9080080c 	andi	r2,r18,32
 101969c:	103fae1e 	bne	r2,zero,1019558 <__alt_data_end+0xff019558>
 10196a0:	9080040c 	andi	r2,r18,16
 10196a4:	1002de26 	beq	r2,zero,101a220 <___vfprintf_internal_r+0x1820>
 10196a8:	d8c02d17 	ldw	r3,180(sp)
 10196ac:	002d883a 	mov	r22,zero
 10196b0:	1cc00017 	ldw	r19,0(r3)
 10196b4:	18c00104 	addi	r3,r3,4
 10196b8:	d8c02d15 	stw	r3,180(sp)
 10196bc:	003fab06 	br	101956c <__alt_data_end+0xff01956c>
 10196c0:	38803fcc 	andi	r2,r7,255
 10196c4:	1080201c 	xori	r2,r2,128
 10196c8:	10bfe004 	addi	r2,r2,-128
 10196cc:	1002d21e 	bne	r2,zero,101a218 <___vfprintf_internal_r+0x1818>
 10196d0:	00c00044 	movi	r3,1
 10196d4:	01c00804 	movi	r7,32
 10196d8:	ac400007 	ldb	r17,0(r21)
 10196dc:	003d2906 	br	1018b84 <__alt_data_end+0xff018b84>
 10196e0:	94800054 	ori	r18,r18,1
 10196e4:	ac400007 	ldb	r17,0(r21)
 10196e8:	003d2606 	br	1018b84 <__alt_data_end+0xff018b84>
 10196ec:	18c03fcc 	andi	r3,r3,255
 10196f0:	183e0526 	beq	r3,zero,1018f08 <__alt_data_end+0xff018f08>
 10196f4:	d9c02785 	stb	r7,158(sp)
 10196f8:	003e0306 	br	1018f08 <__alt_data_end+0xff018f08>
 10196fc:	94801014 	ori	r18,r18,64
 1019700:	ac400007 	ldb	r17,0(r21)
 1019704:	003d1f06 	br	1018b84 <__alt_data_end+0xff018b84>
 1019708:	ac400007 	ldb	r17,0(r21)
 101970c:	8a438726 	beq	r17,r9,101a52c <___vfprintf_internal_r+0x1b2c>
 1019710:	94800414 	ori	r18,r18,16
 1019714:	003d1b06 	br	1018b84 <__alt_data_end+0xff018b84>
 1019718:	18c03fcc 	andi	r3,r3,255
 101971c:	1805341e 	bne	r3,zero,101abf0 <___vfprintf_internal_r+0x21f0>
 1019720:	9080080c 	andi	r2,r18,32
 1019724:	1002cd26 	beq	r2,zero,101a25c <___vfprintf_internal_r+0x185c>
 1019728:	d9402d17 	ldw	r5,180(sp)
 101972c:	d9002f17 	ldw	r4,188(sp)
 1019730:	28800017 	ldw	r2,0(r5)
 1019734:	2007d7fa 	srai	r3,r4,31
 1019738:	29400104 	addi	r5,r5,4
 101973c:	d9402d15 	stw	r5,180(sp)
 1019740:	11000015 	stw	r4,0(r2)
 1019744:	10c00115 	stw	r3,4(r2)
 1019748:	003ce506 	br	1018ae0 <__alt_data_end+0xff018ae0>
 101974c:	d8c02d17 	ldw	r3,180(sp)
 1019750:	d9002d17 	ldw	r4,180(sp)
 1019754:	d8002785 	stb	zero,158(sp)
 1019758:	18800017 	ldw	r2,0(r3)
 101975c:	21000104 	addi	r4,r4,4
 1019760:	00c00044 	movi	r3,1
 1019764:	d8c02a15 	stw	r3,168(sp)
 1019768:	d8801405 	stb	r2,80(sp)
 101976c:	d9002d15 	stw	r4,180(sp)
 1019770:	d8c02e15 	stw	r3,184(sp)
 1019774:	d8002915 	stw	zero,164(sp)
 1019778:	d8003215 	stw	zero,200(sp)
 101977c:	dc001404 	addi	r16,sp,80
 1019780:	0039883a 	mov	fp,zero
 1019784:	003e7206 	br	1019150 <__alt_data_end+0xff019150>
 1019788:	010040f4 	movhi	r4,259
 101978c:	212a8504 	addi	r4,r4,-21996
 1019790:	0039883a 	mov	fp,zero
 1019794:	d9003915 	stw	r4,228(sp)
 1019798:	04401e04 	movi	r17,120
 101979c:	003f8206 	br	10195a8 <__alt_data_end+0xff0195a8>
 10197a0:	18c03fcc 	andi	r3,r3,255
 10197a4:	1805061e 	bne	r3,zero,101abc0 <___vfprintf_internal_r+0x21c0>
 10197a8:	883d9126 	beq	r17,zero,1018df0 <__alt_data_end+0xff018df0>
 10197ac:	00c00044 	movi	r3,1
 10197b0:	d8c02a15 	stw	r3,168(sp)
 10197b4:	dc401405 	stb	r17,80(sp)
 10197b8:	d8002785 	stb	zero,158(sp)
 10197bc:	003fec06 	br	1019770 <__alt_data_end+0xff019770>
 10197c0:	014040f4 	movhi	r5,259
 10197c4:	296a8504 	addi	r5,r5,-21996
 10197c8:	d9403915 	stw	r5,228(sp)
 10197cc:	d8c02d15 	stw	r3,180(sp)
 10197d0:	1025883a 	mov	r18,r2
 10197d4:	04401e04 	movi	r17,120
 10197d8:	9d84b03a 	or	r2,r19,r22
 10197dc:	1000fc1e 	bne	r2,zero,1019bd0 <___vfprintf_internal_r+0x11d0>
 10197e0:	0039883a 	mov	fp,zero
 10197e4:	00800084 	movi	r2,2
 10197e8:	10803fcc 	andi	r2,r2,255
 10197ec:	00c00044 	movi	r3,1
 10197f0:	10c20f26 	beq	r2,r3,101a030 <___vfprintf_internal_r+0x1630>
 10197f4:	00c00084 	movi	r3,2
 10197f8:	10fd6326 	beq	r2,r3,1018d88 <__alt_data_end+0xff018d88>
 10197fc:	003e2d06 	br	10190b4 <__alt_data_end+0xff0190b4>
 1019800:	d8c02017 	ldw	r3,128(sp)
 1019804:	003e9306 	br	1019254 <__alt_data_end+0xff019254>
 1019808:	00801944 	movi	r2,101
 101980c:	14407e0e 	bge	r2,r17,1019a08 <___vfprintf_internal_r+0x1008>
 1019810:	d9003617 	ldw	r4,216(sp)
 1019814:	d9403817 	ldw	r5,224(sp)
 1019818:	000d883a 	mov	r6,zero
 101981c:	000f883a 	mov	r7,zero
 1019820:	d8c03c15 	stw	r3,240(sp)
 1019824:	da003d15 	stw	r8,244(sp)
 1019828:	10250500 	call	1025050 <__eqdf2>
 101982c:	d8c03c17 	ldw	r3,240(sp)
 1019830:	da003d17 	ldw	r8,244(sp)
 1019834:	1000f71e 	bne	r2,zero,1019c14 <___vfprintf_internal_r+0x1214>
 1019838:	d8801f17 	ldw	r2,124(sp)
 101983c:	010040f4 	movhi	r4,259
 1019840:	212a8c04 	addi	r4,r4,-21968
 1019844:	18c00044 	addi	r3,r3,1
 1019848:	10800044 	addi	r2,r2,1
 101984c:	41000015 	stw	r4,0(r8)
 1019850:	01000044 	movi	r4,1
 1019854:	41000115 	stw	r4,4(r8)
 1019858:	d8c02015 	stw	r3,128(sp)
 101985c:	d8801f15 	stw	r2,124(sp)
 1019860:	010001c4 	movi	r4,7
 1019864:	2082b816 	blt	r4,r2,101a348 <___vfprintf_internal_r+0x1948>
 1019868:	42000204 	addi	r8,r8,8
 101986c:	d8802617 	ldw	r2,152(sp)
 1019870:	d9403317 	ldw	r5,204(sp)
 1019874:	11400216 	blt	r2,r5,1019880 <___vfprintf_internal_r+0xe80>
 1019878:	9080004c 	andi	r2,r18,1
 101987c:	103ed526 	beq	r2,zero,10193d4 <__alt_data_end+0xff0193d4>
 1019880:	d8803717 	ldw	r2,220(sp)
 1019884:	d9003417 	ldw	r4,208(sp)
 1019888:	d9403717 	ldw	r5,220(sp)
 101988c:	1887883a 	add	r3,r3,r2
 1019890:	d8801f17 	ldw	r2,124(sp)
 1019894:	41000015 	stw	r4,0(r8)
 1019898:	41400115 	stw	r5,4(r8)
 101989c:	10800044 	addi	r2,r2,1
 10198a0:	d8c02015 	stw	r3,128(sp)
 10198a4:	d8801f15 	stw	r2,124(sp)
 10198a8:	010001c4 	movi	r4,7
 10198ac:	20832916 	blt	r4,r2,101a554 <___vfprintf_internal_r+0x1b54>
 10198b0:	42000204 	addi	r8,r8,8
 10198b4:	d8803317 	ldw	r2,204(sp)
 10198b8:	143fffc4 	addi	r16,r2,-1
 10198bc:	043ec50e 	bge	zero,r16,10193d4 <__alt_data_end+0xff0193d4>
 10198c0:	04400404 	movi	r17,16
 10198c4:	d8801f17 	ldw	r2,124(sp)
 10198c8:	8c00880e 	bge	r17,r16,1019aec <___vfprintf_internal_r+0x10ec>
 10198cc:	014040f4 	movhi	r5,259
 10198d0:	296a9484 	addi	r5,r5,-21934
 10198d4:	d9402b15 	stw	r5,172(sp)
 10198d8:	058001c4 	movi	r22,7
 10198dc:	dcc02c17 	ldw	r19,176(sp)
 10198e0:	00000306 	br	10198f0 <___vfprintf_internal_r+0xef0>
 10198e4:	42000204 	addi	r8,r8,8
 10198e8:	843ffc04 	addi	r16,r16,-16
 10198ec:	8c00820e 	bge	r17,r16,1019af8 <___vfprintf_internal_r+0x10f8>
 10198f0:	18c00404 	addi	r3,r3,16
 10198f4:	10800044 	addi	r2,r2,1
 10198f8:	45000015 	stw	r20,0(r8)
 10198fc:	44400115 	stw	r17,4(r8)
 1019900:	d8c02015 	stw	r3,128(sp)
 1019904:	d8801f15 	stw	r2,124(sp)
 1019908:	b0bff60e 	bge	r22,r2,10198e4 <__alt_data_end+0xff0198e4>
 101990c:	d9801e04 	addi	r6,sp,120
 1019910:	b80b883a 	mov	r5,r23
 1019914:	9809883a 	mov	r4,r19
 1019918:	10213d80 	call	10213d8 <__sprint_r>
 101991c:	103d3a1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019920:	d8c02017 	ldw	r3,128(sp)
 1019924:	d8801f17 	ldw	r2,124(sp)
 1019928:	da000404 	addi	r8,sp,16
 101992c:	003fee06 	br	10198e8 <__alt_data_end+0xff0198e8>
 1019930:	d9403117 	ldw	r5,196(sp)
 1019934:	d8802a17 	ldw	r2,168(sp)
 1019938:	28adc83a 	sub	r22,r5,r2
 101993c:	05be630e 	bge	zero,r22,10192cc <__alt_data_end+0xff0192cc>
 1019940:	07000404 	movi	fp,16
 1019944:	d8801f17 	ldw	r2,124(sp)
 1019948:	e5838f0e 	bge	fp,r22,101a788 <___vfprintf_internal_r+0x1d88>
 101994c:	014040f4 	movhi	r5,259
 1019950:	296a9484 	addi	r5,r5,-21934
 1019954:	dc403015 	stw	r17,192(sp)
 1019958:	d9402b15 	stw	r5,172(sp)
 101995c:	b023883a 	mov	r17,r22
 1019960:	04c001c4 	movi	r19,7
 1019964:	a82d883a 	mov	r22,r21
 1019968:	902b883a 	mov	r21,r18
 101996c:	8025883a 	mov	r18,r16
 1019970:	dc002c17 	ldw	r16,176(sp)
 1019974:	00000306 	br	1019984 <___vfprintf_internal_r+0xf84>
 1019978:	8c7ffc04 	addi	r17,r17,-16
 101997c:	42000204 	addi	r8,r8,8
 1019980:	e440110e 	bge	fp,r17,10199c8 <___vfprintf_internal_r+0xfc8>
 1019984:	18c00404 	addi	r3,r3,16
 1019988:	10800044 	addi	r2,r2,1
 101998c:	45000015 	stw	r20,0(r8)
 1019990:	47000115 	stw	fp,4(r8)
 1019994:	d8c02015 	stw	r3,128(sp)
 1019998:	d8801f15 	stw	r2,124(sp)
 101999c:	98bff60e 	bge	r19,r2,1019978 <__alt_data_end+0xff019978>
 10199a0:	d9801e04 	addi	r6,sp,120
 10199a4:	b80b883a 	mov	r5,r23
 10199a8:	8009883a 	mov	r4,r16
 10199ac:	10213d80 	call	10213d8 <__sprint_r>
 10199b0:	103d151e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 10199b4:	8c7ffc04 	addi	r17,r17,-16
 10199b8:	d8c02017 	ldw	r3,128(sp)
 10199bc:	d8801f17 	ldw	r2,124(sp)
 10199c0:	da000404 	addi	r8,sp,16
 10199c4:	e47fef16 	blt	fp,r17,1019984 <__alt_data_end+0xff019984>
 10199c8:	9021883a 	mov	r16,r18
 10199cc:	a825883a 	mov	r18,r21
 10199d0:	b02b883a 	mov	r21,r22
 10199d4:	882d883a 	mov	r22,r17
 10199d8:	dc403017 	ldw	r17,192(sp)
 10199dc:	d9002b17 	ldw	r4,172(sp)
 10199e0:	1d87883a 	add	r3,r3,r22
 10199e4:	10800044 	addi	r2,r2,1
 10199e8:	41000015 	stw	r4,0(r8)
 10199ec:	45800115 	stw	r22,4(r8)
 10199f0:	d8c02015 	stw	r3,128(sp)
 10199f4:	d8801f15 	stw	r2,124(sp)
 10199f8:	010001c4 	movi	r4,7
 10199fc:	20818e16 	blt	r4,r2,101a038 <___vfprintf_internal_r+0x1638>
 1019a00:	42000204 	addi	r8,r8,8
 1019a04:	003e3106 	br	10192cc <__alt_data_end+0xff0192cc>
 1019a08:	d9403317 	ldw	r5,204(sp)
 1019a0c:	00800044 	movi	r2,1
 1019a10:	18c00044 	addi	r3,r3,1
 1019a14:	1141530e 	bge	r2,r5,1019f64 <___vfprintf_internal_r+0x1564>
 1019a18:	dc401f17 	ldw	r17,124(sp)
 1019a1c:	00800044 	movi	r2,1
 1019a20:	40800115 	stw	r2,4(r8)
 1019a24:	8c400044 	addi	r17,r17,1
 1019a28:	44000015 	stw	r16,0(r8)
 1019a2c:	d8c02015 	stw	r3,128(sp)
 1019a30:	dc401f15 	stw	r17,124(sp)
 1019a34:	008001c4 	movi	r2,7
 1019a38:	14416b16 	blt	r2,r17,1019fe8 <___vfprintf_internal_r+0x15e8>
 1019a3c:	42000204 	addi	r8,r8,8
 1019a40:	d8803717 	ldw	r2,220(sp)
 1019a44:	d9003417 	ldw	r4,208(sp)
 1019a48:	8c400044 	addi	r17,r17,1
 1019a4c:	10c7883a 	add	r3,r2,r3
 1019a50:	40800115 	stw	r2,4(r8)
 1019a54:	41000015 	stw	r4,0(r8)
 1019a58:	d8c02015 	stw	r3,128(sp)
 1019a5c:	dc401f15 	stw	r17,124(sp)
 1019a60:	008001c4 	movi	r2,7
 1019a64:	14416916 	blt	r2,r17,101a00c <___vfprintf_internal_r+0x160c>
 1019a68:	45800204 	addi	r22,r8,8
 1019a6c:	d9003617 	ldw	r4,216(sp)
 1019a70:	d9403817 	ldw	r5,224(sp)
 1019a74:	000d883a 	mov	r6,zero
 1019a78:	000f883a 	mov	r7,zero
 1019a7c:	d8c03c15 	stw	r3,240(sp)
 1019a80:	10250500 	call	1025050 <__eqdf2>
 1019a84:	d8c03c17 	ldw	r3,240(sp)
 1019a88:	1000bc26 	beq	r2,zero,1019d7c <___vfprintf_internal_r+0x137c>
 1019a8c:	d9403317 	ldw	r5,204(sp)
 1019a90:	84000044 	addi	r16,r16,1
 1019a94:	8c400044 	addi	r17,r17,1
 1019a98:	28bfffc4 	addi	r2,r5,-1
 1019a9c:	1887883a 	add	r3,r3,r2
 1019aa0:	b0800115 	stw	r2,4(r22)
 1019aa4:	b4000015 	stw	r16,0(r22)
 1019aa8:	d8c02015 	stw	r3,128(sp)
 1019aac:	dc401f15 	stw	r17,124(sp)
 1019ab0:	008001c4 	movi	r2,7
 1019ab4:	14414316 	blt	r2,r17,1019fc4 <___vfprintf_internal_r+0x15c4>
 1019ab8:	b5800204 	addi	r22,r22,8
 1019abc:	d9003a17 	ldw	r4,232(sp)
 1019ac0:	df0022c4 	addi	fp,sp,139
 1019ac4:	8c400044 	addi	r17,r17,1
 1019ac8:	20c7883a 	add	r3,r4,r3
 1019acc:	b7000015 	stw	fp,0(r22)
 1019ad0:	b1000115 	stw	r4,4(r22)
 1019ad4:	d8c02015 	stw	r3,128(sp)
 1019ad8:	dc401f15 	stw	r17,124(sp)
 1019adc:	008001c4 	movi	r2,7
 1019ae0:	14400e16 	blt	r2,r17,1019b1c <___vfprintf_internal_r+0x111c>
 1019ae4:	b2000204 	addi	r8,r22,8
 1019ae8:	003e3a06 	br	10193d4 <__alt_data_end+0xff0193d4>
 1019aec:	010040f4 	movhi	r4,259
 1019af0:	212a9484 	addi	r4,r4,-21934
 1019af4:	d9002b15 	stw	r4,172(sp)
 1019af8:	d9002b17 	ldw	r4,172(sp)
 1019afc:	1c07883a 	add	r3,r3,r16
 1019b00:	44000115 	stw	r16,4(r8)
 1019b04:	41000015 	stw	r4,0(r8)
 1019b08:	10800044 	addi	r2,r2,1
 1019b0c:	d8c02015 	stw	r3,128(sp)
 1019b10:	d8801f15 	stw	r2,124(sp)
 1019b14:	010001c4 	movi	r4,7
 1019b18:	20be2d0e 	bge	r4,r2,10193d0 <__alt_data_end+0xff0193d0>
 1019b1c:	d9002c17 	ldw	r4,176(sp)
 1019b20:	d9801e04 	addi	r6,sp,120
 1019b24:	b80b883a 	mov	r5,r23
 1019b28:	10213d80 	call	10213d8 <__sprint_r>
 1019b2c:	103cb61e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019b30:	d8c02017 	ldw	r3,128(sp)
 1019b34:	da000404 	addi	r8,sp,16
 1019b38:	003e2606 	br	10193d4 <__alt_data_end+0xff0193d4>
 1019b3c:	d9002c17 	ldw	r4,176(sp)
 1019b40:	d9801e04 	addi	r6,sp,120
 1019b44:	b80b883a 	mov	r5,r23
 1019b48:	10213d80 	call	10213d8 <__sprint_r>
 1019b4c:	103e5d26 	beq	r2,zero,10194c4 <__alt_data_end+0xff0194c4>
 1019b50:	003cad06 	br	1018e08 <__alt_data_end+0xff018e08>
 1019b54:	d9002c17 	ldw	r4,176(sp)
 1019b58:	d9801e04 	addi	r6,sp,120
 1019b5c:	b80b883a 	mov	r5,r23
 1019b60:	10213d80 	call	10213d8 <__sprint_r>
 1019b64:	103ca81e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019b68:	d8c02017 	ldw	r3,128(sp)
 1019b6c:	da000404 	addi	r8,sp,16
 1019b70:	003e0b06 	br	10193a0 <__alt_data_end+0xff0193a0>
 1019b74:	d9002c17 	ldw	r4,176(sp)
 1019b78:	d9801e04 	addi	r6,sp,120
 1019b7c:	b80b883a 	mov	r5,r23
 1019b80:	10213d80 	call	10213d8 <__sprint_r>
 1019b84:	103ca01e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019b88:	d8c02017 	ldw	r3,128(sp)
 1019b8c:	da000404 	addi	r8,sp,16
 1019b90:	003dbd06 	br	1019288 <__alt_data_end+0xff019288>
 1019b94:	d9002c17 	ldw	r4,176(sp)
 1019b98:	d9801e04 	addi	r6,sp,120
 1019b9c:	b80b883a 	mov	r5,r23
 1019ba0:	10213d80 	call	10213d8 <__sprint_r>
 1019ba4:	103c981e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019ba8:	d8c02017 	ldw	r3,128(sp)
 1019bac:	da000404 	addi	r8,sp,16
 1019bb0:	003dc306 	br	10192c0 <__alt_data_end+0xff0192c0>
 1019bb4:	d8802917 	ldw	r2,164(sp)
 1019bb8:	d8002785 	stb	zero,158(sp)
 1019bbc:	103f0616 	blt	r2,zero,10197d8 <__alt_data_end+0xff0197d8>
 1019bc0:	00ffdfc4 	movi	r3,-129
 1019bc4:	9d84b03a 	or	r2,r19,r22
 1019bc8:	90e4703a 	and	r18,r18,r3
 1019bcc:	103c6b26 	beq	r2,zero,1018d7c <__alt_data_end+0xff018d7c>
 1019bd0:	0039883a 	mov	fp,zero
 1019bd4:	003e7406 	br	10195a8 <__alt_data_end+0xff0195a8>
 1019bd8:	9080040c 	andi	r2,r18,16
 1019bdc:	1001b326 	beq	r2,zero,101a2ac <___vfprintf_internal_r+0x18ac>
 1019be0:	d9002d17 	ldw	r4,180(sp)
 1019be4:	d9402917 	ldw	r5,164(sp)
 1019be8:	d8002785 	stb	zero,158(sp)
 1019bec:	20800104 	addi	r2,r4,4
 1019bf0:	24c00017 	ldw	r19,0(r4)
 1019bf4:	002d883a 	mov	r22,zero
 1019bf8:	2801b516 	blt	r5,zero,101a2d0 <___vfprintf_internal_r+0x18d0>
 1019bfc:	00ffdfc4 	movi	r3,-129
 1019c00:	d8802d15 	stw	r2,180(sp)
 1019c04:	90e4703a 	and	r18,r18,r3
 1019c08:	983d2726 	beq	r19,zero,10190a8 <__alt_data_end+0xff0190a8>
 1019c0c:	0039883a 	mov	fp,zero
 1019c10:	003d2a06 	br	10190bc <__alt_data_end+0xff0190bc>
 1019c14:	dc402617 	ldw	r17,152(sp)
 1019c18:	0441d30e 	bge	zero,r17,101a368 <___vfprintf_internal_r+0x1968>
 1019c1c:	dc403217 	ldw	r17,200(sp)
 1019c20:	d8803317 	ldw	r2,204(sp)
 1019c24:	1440010e 	bge	r2,r17,1019c2c <___vfprintf_internal_r+0x122c>
 1019c28:	1023883a 	mov	r17,r2
 1019c2c:	04400a0e 	bge	zero,r17,1019c58 <___vfprintf_internal_r+0x1258>
 1019c30:	d8801f17 	ldw	r2,124(sp)
 1019c34:	1c47883a 	add	r3,r3,r17
 1019c38:	44000015 	stw	r16,0(r8)
 1019c3c:	10800044 	addi	r2,r2,1
 1019c40:	44400115 	stw	r17,4(r8)
 1019c44:	d8c02015 	stw	r3,128(sp)
 1019c48:	d8801f15 	stw	r2,124(sp)
 1019c4c:	010001c4 	movi	r4,7
 1019c50:	20826516 	blt	r4,r2,101a5e8 <___vfprintf_internal_r+0x1be8>
 1019c54:	42000204 	addi	r8,r8,8
 1019c58:	88026116 	blt	r17,zero,101a5e0 <___vfprintf_internal_r+0x1be0>
 1019c5c:	d9003217 	ldw	r4,200(sp)
 1019c60:	2463c83a 	sub	r17,r4,r17
 1019c64:	04407b0e 	bge	zero,r17,1019e54 <___vfprintf_internal_r+0x1454>
 1019c68:	05800404 	movi	r22,16
 1019c6c:	d8801f17 	ldw	r2,124(sp)
 1019c70:	b4419d0e 	bge	r22,r17,101a2e8 <___vfprintf_internal_r+0x18e8>
 1019c74:	010040f4 	movhi	r4,259
 1019c78:	212a9484 	addi	r4,r4,-21934
 1019c7c:	d9002b15 	stw	r4,172(sp)
 1019c80:	070001c4 	movi	fp,7
 1019c84:	dcc02c17 	ldw	r19,176(sp)
 1019c88:	00000306 	br	1019c98 <___vfprintf_internal_r+0x1298>
 1019c8c:	42000204 	addi	r8,r8,8
 1019c90:	8c7ffc04 	addi	r17,r17,-16
 1019c94:	b441970e 	bge	r22,r17,101a2f4 <___vfprintf_internal_r+0x18f4>
 1019c98:	18c00404 	addi	r3,r3,16
 1019c9c:	10800044 	addi	r2,r2,1
 1019ca0:	45000015 	stw	r20,0(r8)
 1019ca4:	45800115 	stw	r22,4(r8)
 1019ca8:	d8c02015 	stw	r3,128(sp)
 1019cac:	d8801f15 	stw	r2,124(sp)
 1019cb0:	e0bff60e 	bge	fp,r2,1019c8c <__alt_data_end+0xff019c8c>
 1019cb4:	d9801e04 	addi	r6,sp,120
 1019cb8:	b80b883a 	mov	r5,r23
 1019cbc:	9809883a 	mov	r4,r19
 1019cc0:	10213d80 	call	10213d8 <__sprint_r>
 1019cc4:	103c501e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019cc8:	d8c02017 	ldw	r3,128(sp)
 1019ccc:	d8801f17 	ldw	r2,124(sp)
 1019cd0:	da000404 	addi	r8,sp,16
 1019cd4:	003fee06 	br	1019c90 <__alt_data_end+0xff019c90>
 1019cd8:	d9002c17 	ldw	r4,176(sp)
 1019cdc:	d9801e04 	addi	r6,sp,120
 1019ce0:	b80b883a 	mov	r5,r23
 1019ce4:	10213d80 	call	10213d8 <__sprint_r>
 1019ce8:	103c471e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019cec:	d8c02017 	ldw	r3,128(sp)
 1019cf0:	df002787 	ldb	fp,158(sp)
 1019cf4:	da000404 	addi	r8,sp,16
 1019cf8:	003d5606 	br	1019254 <__alt_data_end+0xff019254>
 1019cfc:	9080040c 	andi	r2,r18,16
 1019d00:	10016126 	beq	r2,zero,101a288 <___vfprintf_internal_r+0x1888>
 1019d04:	d8802d17 	ldw	r2,180(sp)
 1019d08:	14c00017 	ldw	r19,0(r2)
 1019d0c:	10800104 	addi	r2,r2,4
 1019d10:	d8802d15 	stw	r2,180(sp)
 1019d14:	982dd7fa 	srai	r22,r19,31
 1019d18:	b005883a 	mov	r2,r22
 1019d1c:	003c8206 	br	1018f28 <__alt_data_end+0xff018f28>
 1019d20:	9080040c 	andi	r2,r18,16
 1019d24:	10003526 	beq	r2,zero,1019dfc <___vfprintf_internal_r+0x13fc>
 1019d28:	d9402d17 	ldw	r5,180(sp)
 1019d2c:	d8c02917 	ldw	r3,164(sp)
 1019d30:	d8002785 	stb	zero,158(sp)
 1019d34:	28800104 	addi	r2,r5,4
 1019d38:	2cc00017 	ldw	r19,0(r5)
 1019d3c:	002d883a 	mov	r22,zero
 1019d40:	18003716 	blt	r3,zero,1019e20 <___vfprintf_internal_r+0x1420>
 1019d44:	00ffdfc4 	movi	r3,-129
 1019d48:	d8802d15 	stw	r2,180(sp)
 1019d4c:	90e4703a 	and	r18,r18,r3
 1019d50:	0039883a 	mov	fp,zero
 1019d54:	983df326 	beq	r19,zero,1019524 <__alt_data_end+0xff019524>
 1019d58:	00800244 	movi	r2,9
 1019d5c:	14fc7b36 	bltu	r2,r19,1018f4c <__alt_data_end+0xff018f4c>
 1019d60:	d8c02817 	ldw	r3,160(sp)
 1019d64:	dc001dc4 	addi	r16,sp,119
 1019d68:	9cc00c04 	addi	r19,r19,48
 1019d6c:	1c07c83a 	sub	r3,r3,r16
 1019d70:	dcc01dc5 	stb	r19,119(sp)
 1019d74:	d8c02e15 	stw	r3,184(sp)
 1019d78:	003ce806 	br	101911c <__alt_data_end+0xff01911c>
 1019d7c:	d8803317 	ldw	r2,204(sp)
 1019d80:	143fffc4 	addi	r16,r2,-1
 1019d84:	043f4d0e 	bge	zero,r16,1019abc <__alt_data_end+0xff019abc>
 1019d88:	07000404 	movi	fp,16
 1019d8c:	e400810e 	bge	fp,r16,1019f94 <___vfprintf_internal_r+0x1594>
 1019d90:	014040f4 	movhi	r5,259
 1019d94:	296a9484 	addi	r5,r5,-21934
 1019d98:	d9402b15 	stw	r5,172(sp)
 1019d9c:	01c001c4 	movi	r7,7
 1019da0:	dcc02c17 	ldw	r19,176(sp)
 1019da4:	00000306 	br	1019db4 <___vfprintf_internal_r+0x13b4>
 1019da8:	b5800204 	addi	r22,r22,8
 1019dac:	843ffc04 	addi	r16,r16,-16
 1019db0:	e4007b0e 	bge	fp,r16,1019fa0 <___vfprintf_internal_r+0x15a0>
 1019db4:	18c00404 	addi	r3,r3,16
 1019db8:	8c400044 	addi	r17,r17,1
 1019dbc:	b5000015 	stw	r20,0(r22)
 1019dc0:	b7000115 	stw	fp,4(r22)
 1019dc4:	d8c02015 	stw	r3,128(sp)
 1019dc8:	dc401f15 	stw	r17,124(sp)
 1019dcc:	3c7ff60e 	bge	r7,r17,1019da8 <__alt_data_end+0xff019da8>
 1019dd0:	d9801e04 	addi	r6,sp,120
 1019dd4:	b80b883a 	mov	r5,r23
 1019dd8:	9809883a 	mov	r4,r19
 1019ddc:	d9c03c15 	stw	r7,240(sp)
 1019de0:	10213d80 	call	10213d8 <__sprint_r>
 1019de4:	d9c03c17 	ldw	r7,240(sp)
 1019de8:	103c071e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019dec:	d8c02017 	ldw	r3,128(sp)
 1019df0:	dc401f17 	ldw	r17,124(sp)
 1019df4:	dd800404 	addi	r22,sp,16
 1019df8:	003fec06 	br	1019dac <__alt_data_end+0xff019dac>
 1019dfc:	9080100c 	andi	r2,r18,64
 1019e00:	d8002785 	stb	zero,158(sp)
 1019e04:	10010e26 	beq	r2,zero,101a240 <___vfprintf_internal_r+0x1840>
 1019e08:	d9002d17 	ldw	r4,180(sp)
 1019e0c:	d9402917 	ldw	r5,164(sp)
 1019e10:	002d883a 	mov	r22,zero
 1019e14:	20800104 	addi	r2,r4,4
 1019e18:	24c0000b 	ldhu	r19,0(r4)
 1019e1c:	283fc90e 	bge	r5,zero,1019d44 <__alt_data_end+0xff019d44>
 1019e20:	d8802d15 	stw	r2,180(sp)
 1019e24:	0039883a 	mov	fp,zero
 1019e28:	9d84b03a 	or	r2,r19,r22
 1019e2c:	103c461e 	bne	r2,zero,1018f48 <__alt_data_end+0xff018f48>
 1019e30:	00800044 	movi	r2,1
 1019e34:	003e6c06 	br	10197e8 <__alt_data_end+0xff0197e8>
 1019e38:	d9002c17 	ldw	r4,176(sp)
 1019e3c:	d9801e04 	addi	r6,sp,120
 1019e40:	b80b883a 	mov	r5,r23
 1019e44:	10213d80 	call	10213d8 <__sprint_r>
 1019e48:	103bef1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019e4c:	d8c02017 	ldw	r3,128(sp)
 1019e50:	da000404 	addi	r8,sp,16
 1019e54:	d9003217 	ldw	r4,200(sp)
 1019e58:	d8802617 	ldw	r2,152(sp)
 1019e5c:	d9403317 	ldw	r5,204(sp)
 1019e60:	8123883a 	add	r17,r16,r4
 1019e64:	11400216 	blt	r2,r5,1019e70 <___vfprintf_internal_r+0x1470>
 1019e68:	9100004c 	andi	r4,r18,1
 1019e6c:	20000d26 	beq	r4,zero,1019ea4 <___vfprintf_internal_r+0x14a4>
 1019e70:	d9003717 	ldw	r4,220(sp)
 1019e74:	d9403417 	ldw	r5,208(sp)
 1019e78:	1907883a 	add	r3,r3,r4
 1019e7c:	d9001f17 	ldw	r4,124(sp)
 1019e80:	41400015 	stw	r5,0(r8)
 1019e84:	d9403717 	ldw	r5,220(sp)
 1019e88:	21000044 	addi	r4,r4,1
 1019e8c:	d8c02015 	stw	r3,128(sp)
 1019e90:	41400115 	stw	r5,4(r8)
 1019e94:	d9001f15 	stw	r4,124(sp)
 1019e98:	014001c4 	movi	r5,7
 1019e9c:	2901e816 	blt	r5,r4,101a640 <___vfprintf_internal_r+0x1c40>
 1019ea0:	42000204 	addi	r8,r8,8
 1019ea4:	d9003317 	ldw	r4,204(sp)
 1019ea8:	8121883a 	add	r16,r16,r4
 1019eac:	2085c83a 	sub	r2,r4,r2
 1019eb0:	8461c83a 	sub	r16,r16,r17
 1019eb4:	1400010e 	bge	r2,r16,1019ebc <___vfprintf_internal_r+0x14bc>
 1019eb8:	1021883a 	mov	r16,r2
 1019ebc:	04000a0e 	bge	zero,r16,1019ee8 <___vfprintf_internal_r+0x14e8>
 1019ec0:	d9001f17 	ldw	r4,124(sp)
 1019ec4:	1c07883a 	add	r3,r3,r16
 1019ec8:	44400015 	stw	r17,0(r8)
 1019ecc:	21000044 	addi	r4,r4,1
 1019ed0:	44000115 	stw	r16,4(r8)
 1019ed4:	d8c02015 	stw	r3,128(sp)
 1019ed8:	d9001f15 	stw	r4,124(sp)
 1019edc:	014001c4 	movi	r5,7
 1019ee0:	2901fb16 	blt	r5,r4,101a6d0 <___vfprintf_internal_r+0x1cd0>
 1019ee4:	42000204 	addi	r8,r8,8
 1019ee8:	8001f716 	blt	r16,zero,101a6c8 <___vfprintf_internal_r+0x1cc8>
 1019eec:	1421c83a 	sub	r16,r2,r16
 1019ef0:	043d380e 	bge	zero,r16,10193d4 <__alt_data_end+0xff0193d4>
 1019ef4:	04400404 	movi	r17,16
 1019ef8:	d8801f17 	ldw	r2,124(sp)
 1019efc:	8c3efb0e 	bge	r17,r16,1019aec <__alt_data_end+0xff019aec>
 1019f00:	014040f4 	movhi	r5,259
 1019f04:	296a9484 	addi	r5,r5,-21934
 1019f08:	d9402b15 	stw	r5,172(sp)
 1019f0c:	058001c4 	movi	r22,7
 1019f10:	dcc02c17 	ldw	r19,176(sp)
 1019f14:	00000306 	br	1019f24 <___vfprintf_internal_r+0x1524>
 1019f18:	42000204 	addi	r8,r8,8
 1019f1c:	843ffc04 	addi	r16,r16,-16
 1019f20:	8c3ef50e 	bge	r17,r16,1019af8 <__alt_data_end+0xff019af8>
 1019f24:	18c00404 	addi	r3,r3,16
 1019f28:	10800044 	addi	r2,r2,1
 1019f2c:	45000015 	stw	r20,0(r8)
 1019f30:	44400115 	stw	r17,4(r8)
 1019f34:	d8c02015 	stw	r3,128(sp)
 1019f38:	d8801f15 	stw	r2,124(sp)
 1019f3c:	b0bff60e 	bge	r22,r2,1019f18 <__alt_data_end+0xff019f18>
 1019f40:	d9801e04 	addi	r6,sp,120
 1019f44:	b80b883a 	mov	r5,r23
 1019f48:	9809883a 	mov	r4,r19
 1019f4c:	10213d80 	call	10213d8 <__sprint_r>
 1019f50:	103bad1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019f54:	d8c02017 	ldw	r3,128(sp)
 1019f58:	d8801f17 	ldw	r2,124(sp)
 1019f5c:	da000404 	addi	r8,sp,16
 1019f60:	003fee06 	br	1019f1c <__alt_data_end+0xff019f1c>
 1019f64:	9088703a 	and	r4,r18,r2
 1019f68:	203eab1e 	bne	r4,zero,1019a18 <__alt_data_end+0xff019a18>
 1019f6c:	dc401f17 	ldw	r17,124(sp)
 1019f70:	40800115 	stw	r2,4(r8)
 1019f74:	44000015 	stw	r16,0(r8)
 1019f78:	8c400044 	addi	r17,r17,1
 1019f7c:	d8c02015 	stw	r3,128(sp)
 1019f80:	dc401f15 	stw	r17,124(sp)
 1019f84:	008001c4 	movi	r2,7
 1019f88:	14400e16 	blt	r2,r17,1019fc4 <___vfprintf_internal_r+0x15c4>
 1019f8c:	45800204 	addi	r22,r8,8
 1019f90:	003eca06 	br	1019abc <__alt_data_end+0xff019abc>
 1019f94:	010040f4 	movhi	r4,259
 1019f98:	212a9484 	addi	r4,r4,-21934
 1019f9c:	d9002b15 	stw	r4,172(sp)
 1019fa0:	d8802b17 	ldw	r2,172(sp)
 1019fa4:	1c07883a 	add	r3,r3,r16
 1019fa8:	8c400044 	addi	r17,r17,1
 1019fac:	b0800015 	stw	r2,0(r22)
 1019fb0:	b4000115 	stw	r16,4(r22)
 1019fb4:	d8c02015 	stw	r3,128(sp)
 1019fb8:	dc401f15 	stw	r17,124(sp)
 1019fbc:	008001c4 	movi	r2,7
 1019fc0:	147ebd0e 	bge	r2,r17,1019ab8 <__alt_data_end+0xff019ab8>
 1019fc4:	d9002c17 	ldw	r4,176(sp)
 1019fc8:	d9801e04 	addi	r6,sp,120
 1019fcc:	b80b883a 	mov	r5,r23
 1019fd0:	10213d80 	call	10213d8 <__sprint_r>
 1019fd4:	103b8c1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019fd8:	d8c02017 	ldw	r3,128(sp)
 1019fdc:	dc401f17 	ldw	r17,124(sp)
 1019fe0:	dd800404 	addi	r22,sp,16
 1019fe4:	003eb506 	br	1019abc <__alt_data_end+0xff019abc>
 1019fe8:	d9002c17 	ldw	r4,176(sp)
 1019fec:	d9801e04 	addi	r6,sp,120
 1019ff0:	b80b883a 	mov	r5,r23
 1019ff4:	10213d80 	call	10213d8 <__sprint_r>
 1019ff8:	103b831e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 1019ffc:	d8c02017 	ldw	r3,128(sp)
 101a000:	dc401f17 	ldw	r17,124(sp)
 101a004:	da000404 	addi	r8,sp,16
 101a008:	003e8d06 	br	1019a40 <__alt_data_end+0xff019a40>
 101a00c:	d9002c17 	ldw	r4,176(sp)
 101a010:	d9801e04 	addi	r6,sp,120
 101a014:	b80b883a 	mov	r5,r23
 101a018:	10213d80 	call	10213d8 <__sprint_r>
 101a01c:	103b7a1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a020:	d8c02017 	ldw	r3,128(sp)
 101a024:	dc401f17 	ldw	r17,124(sp)
 101a028:	dd800404 	addi	r22,sp,16
 101a02c:	003e8f06 	br	1019a6c <__alt_data_end+0xff019a6c>
 101a030:	0027883a 	mov	r19,zero
 101a034:	003f4a06 	br	1019d60 <__alt_data_end+0xff019d60>
 101a038:	d9002c17 	ldw	r4,176(sp)
 101a03c:	d9801e04 	addi	r6,sp,120
 101a040:	b80b883a 	mov	r5,r23
 101a044:	10213d80 	call	10213d8 <__sprint_r>
 101a048:	103b6f1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a04c:	d8c02017 	ldw	r3,128(sp)
 101a050:	da000404 	addi	r8,sp,16
 101a054:	003c9d06 	br	10192cc <__alt_data_end+0xff0192cc>
 101a058:	04e7c83a 	sub	r19,zero,r19
 101a05c:	9804c03a 	cmpne	r2,r19,zero
 101a060:	05adc83a 	sub	r22,zero,r22
 101a064:	b0adc83a 	sub	r22,r22,r2
 101a068:	d8802917 	ldw	r2,164(sp)
 101a06c:	07000b44 	movi	fp,45
 101a070:	df002785 	stb	fp,158(sp)
 101a074:	10017b16 	blt	r2,zero,101a664 <___vfprintf_internal_r+0x1c64>
 101a078:	00bfdfc4 	movi	r2,-129
 101a07c:	90a4703a 	and	r18,r18,r2
 101a080:	003bb106 	br	1018f48 <__alt_data_end+0xff018f48>
 101a084:	d9003617 	ldw	r4,216(sp)
 101a088:	d9403817 	ldw	r5,224(sp)
 101a08c:	da003d15 	stw	r8,244(sp)
 101a090:	101f9c80 	call	101f9c8 <__fpclassifyd>
 101a094:	da003d17 	ldw	r8,244(sp)
 101a098:	1000f026 	beq	r2,zero,101a45c <___vfprintf_internal_r+0x1a5c>
 101a09c:	d9002917 	ldw	r4,164(sp)
 101a0a0:	05bff7c4 	movi	r22,-33
 101a0a4:	00bfffc4 	movi	r2,-1
 101a0a8:	8dac703a 	and	r22,r17,r22
 101a0ac:	20820026 	beq	r4,r2,101a8b0 <___vfprintf_internal_r+0x1eb0>
 101a0b0:	008011c4 	movi	r2,71
 101a0b4:	b081f726 	beq	r22,r2,101a894 <___vfprintf_internal_r+0x1e94>
 101a0b8:	d9003817 	ldw	r4,224(sp)
 101a0bc:	90c04014 	ori	r3,r18,256
 101a0c0:	d8c02b15 	stw	r3,172(sp)
 101a0c4:	20021516 	blt	r4,zero,101a91c <___vfprintf_internal_r+0x1f1c>
 101a0c8:	dcc03817 	ldw	r19,224(sp)
 101a0cc:	d8002a05 	stb	zero,168(sp)
 101a0d0:	00801984 	movi	r2,102
 101a0d4:	8881f926 	beq	r17,r2,101a8bc <___vfprintf_internal_r+0x1ebc>
 101a0d8:	00801184 	movi	r2,70
 101a0dc:	88821c26 	beq	r17,r2,101a950 <___vfprintf_internal_r+0x1f50>
 101a0e0:	00801144 	movi	r2,69
 101a0e4:	b081ef26 	beq	r22,r2,101a8a4 <___vfprintf_internal_r+0x1ea4>
 101a0e8:	d8c02917 	ldw	r3,164(sp)
 101a0ec:	d8802104 	addi	r2,sp,132
 101a0f0:	d8800315 	stw	r2,12(sp)
 101a0f4:	d9403617 	ldw	r5,216(sp)
 101a0f8:	d8802504 	addi	r2,sp,148
 101a0fc:	d9002c17 	ldw	r4,176(sp)
 101a100:	d8800215 	stw	r2,8(sp)
 101a104:	d8802604 	addi	r2,sp,152
 101a108:	d8c00015 	stw	r3,0(sp)
 101a10c:	d8800115 	stw	r2,4(sp)
 101a110:	01c00084 	movi	r7,2
 101a114:	980d883a 	mov	r6,r19
 101a118:	d8c03c15 	stw	r3,240(sp)
 101a11c:	da003d15 	stw	r8,244(sp)
 101a120:	101b03c0 	call	101b03c <_dtoa_r>
 101a124:	1021883a 	mov	r16,r2
 101a128:	008019c4 	movi	r2,103
 101a12c:	d8c03c17 	ldw	r3,240(sp)
 101a130:	da003d17 	ldw	r8,244(sp)
 101a134:	88817126 	beq	r17,r2,101a6fc <___vfprintf_internal_r+0x1cfc>
 101a138:	008011c4 	movi	r2,71
 101a13c:	88829226 	beq	r17,r2,101ab88 <___vfprintf_internal_r+0x2188>
 101a140:	80f9883a 	add	fp,r16,r3
 101a144:	d9003617 	ldw	r4,216(sp)
 101a148:	000d883a 	mov	r6,zero
 101a14c:	000f883a 	mov	r7,zero
 101a150:	980b883a 	mov	r5,r19
 101a154:	da003d15 	stw	r8,244(sp)
 101a158:	10250500 	call	1025050 <__eqdf2>
 101a15c:	da003d17 	ldw	r8,244(sp)
 101a160:	10018d26 	beq	r2,zero,101a798 <___vfprintf_internal_r+0x1d98>
 101a164:	d8802117 	ldw	r2,132(sp)
 101a168:	1700062e 	bgeu	r2,fp,101a184 <___vfprintf_internal_r+0x1784>
 101a16c:	01000c04 	movi	r4,48
 101a170:	10c00044 	addi	r3,r2,1
 101a174:	d8c02115 	stw	r3,132(sp)
 101a178:	11000005 	stb	r4,0(r2)
 101a17c:	d8802117 	ldw	r2,132(sp)
 101a180:	173ffb36 	bltu	r2,fp,101a170 <__alt_data_end+0xff01a170>
 101a184:	1405c83a 	sub	r2,r2,r16
 101a188:	d8803315 	stw	r2,204(sp)
 101a18c:	008011c4 	movi	r2,71
 101a190:	b0817626 	beq	r22,r2,101a76c <___vfprintf_internal_r+0x1d6c>
 101a194:	00801944 	movi	r2,101
 101a198:	1442810e 	bge	r2,r17,101aba0 <___vfprintf_internal_r+0x21a0>
 101a19c:	d8c02617 	ldw	r3,152(sp)
 101a1a0:	00801984 	movi	r2,102
 101a1a4:	d8c03215 	stw	r3,200(sp)
 101a1a8:	8881fe26 	beq	r17,r2,101a9a4 <___vfprintf_internal_r+0x1fa4>
 101a1ac:	d8c03217 	ldw	r3,200(sp)
 101a1b0:	d9003317 	ldw	r4,204(sp)
 101a1b4:	1901dd16 	blt	r3,r4,101a92c <___vfprintf_internal_r+0x1f2c>
 101a1b8:	9480004c 	andi	r18,r18,1
 101a1bc:	90022b1e 	bne	r18,zero,101aa6c <___vfprintf_internal_r+0x206c>
 101a1c0:	1805883a 	mov	r2,r3
 101a1c4:	18028016 	blt	r3,zero,101abc8 <___vfprintf_internal_r+0x21c8>
 101a1c8:	d8c03217 	ldw	r3,200(sp)
 101a1cc:	044019c4 	movi	r17,103
 101a1d0:	d8c02e15 	stw	r3,184(sp)
 101a1d4:	df002a07 	ldb	fp,168(sp)
 101a1d8:	e001531e 	bne	fp,zero,101a728 <___vfprintf_internal_r+0x1d28>
 101a1dc:	df002783 	ldbu	fp,158(sp)
 101a1e0:	d8802a15 	stw	r2,168(sp)
 101a1e4:	dc802b17 	ldw	r18,172(sp)
 101a1e8:	d8002915 	stw	zero,164(sp)
 101a1ec:	003bd106 	br	1019134 <__alt_data_end+0xff019134>
 101a1f0:	d8802d17 	ldw	r2,180(sp)
 101a1f4:	d8c02d17 	ldw	r3,180(sp)
 101a1f8:	d9002d17 	ldw	r4,180(sp)
 101a1fc:	10800017 	ldw	r2,0(r2)
 101a200:	18c00117 	ldw	r3,4(r3)
 101a204:	21000204 	addi	r4,r4,8
 101a208:	d8803615 	stw	r2,216(sp)
 101a20c:	d8c03815 	stw	r3,224(sp)
 101a210:	d9002d15 	stw	r4,180(sp)
 101a214:	003b7506 	br	1018fec <__alt_data_end+0xff018fec>
 101a218:	ac400007 	ldb	r17,0(r21)
 101a21c:	003a5906 	br	1018b84 <__alt_data_end+0xff018b84>
 101a220:	9080100c 	andi	r2,r18,64
 101a224:	1000a826 	beq	r2,zero,101a4c8 <___vfprintf_internal_r+0x1ac8>
 101a228:	d9002d17 	ldw	r4,180(sp)
 101a22c:	002d883a 	mov	r22,zero
 101a230:	24c0000b 	ldhu	r19,0(r4)
 101a234:	21000104 	addi	r4,r4,4
 101a238:	d9002d15 	stw	r4,180(sp)
 101a23c:	003ccb06 	br	101956c <__alt_data_end+0xff01956c>
 101a240:	d8c02d17 	ldw	r3,180(sp)
 101a244:	d9002917 	ldw	r4,164(sp)
 101a248:	002d883a 	mov	r22,zero
 101a24c:	18800104 	addi	r2,r3,4
 101a250:	1cc00017 	ldw	r19,0(r3)
 101a254:	203ebb0e 	bge	r4,zero,1019d44 <__alt_data_end+0xff019d44>
 101a258:	003ef106 	br	1019e20 <__alt_data_end+0xff019e20>
 101a25c:	9080040c 	andi	r2,r18,16
 101a260:	1000921e 	bne	r2,zero,101a4ac <___vfprintf_internal_r+0x1aac>
 101a264:	9480100c 	andi	r18,r18,64
 101a268:	90013926 	beq	r18,zero,101a750 <___vfprintf_internal_r+0x1d50>
 101a26c:	d9002d17 	ldw	r4,180(sp)
 101a270:	d9402f17 	ldw	r5,188(sp)
 101a274:	20800017 	ldw	r2,0(r4)
 101a278:	21000104 	addi	r4,r4,4
 101a27c:	d9002d15 	stw	r4,180(sp)
 101a280:	1140000d 	sth	r5,0(r2)
 101a284:	003a1606 	br	1018ae0 <__alt_data_end+0xff018ae0>
 101a288:	9080100c 	andi	r2,r18,64
 101a28c:	10008026 	beq	r2,zero,101a490 <___vfprintf_internal_r+0x1a90>
 101a290:	d8c02d17 	ldw	r3,180(sp)
 101a294:	1cc0000f 	ldh	r19,0(r3)
 101a298:	18c00104 	addi	r3,r3,4
 101a29c:	d8c02d15 	stw	r3,180(sp)
 101a2a0:	982dd7fa 	srai	r22,r19,31
 101a2a4:	b005883a 	mov	r2,r22
 101a2a8:	003b1f06 	br	1018f28 <__alt_data_end+0xff018f28>
 101a2ac:	9080100c 	andi	r2,r18,64
 101a2b0:	d8002785 	stb	zero,158(sp)
 101a2b4:	10008a1e 	bne	r2,zero,101a4e0 <___vfprintf_internal_r+0x1ae0>
 101a2b8:	d9402d17 	ldw	r5,180(sp)
 101a2bc:	d8c02917 	ldw	r3,164(sp)
 101a2c0:	002d883a 	mov	r22,zero
 101a2c4:	28800104 	addi	r2,r5,4
 101a2c8:	2cc00017 	ldw	r19,0(r5)
 101a2cc:	183e4b0e 	bge	r3,zero,1019bfc <__alt_data_end+0xff019bfc>
 101a2d0:	9d86b03a 	or	r3,r19,r22
 101a2d4:	d8802d15 	stw	r2,180(sp)
 101a2d8:	183e4c1e 	bne	r3,zero,1019c0c <__alt_data_end+0xff019c0c>
 101a2dc:	0039883a 	mov	fp,zero
 101a2e0:	0005883a 	mov	r2,zero
 101a2e4:	003d4006 	br	10197e8 <__alt_data_end+0xff0197e8>
 101a2e8:	014040f4 	movhi	r5,259
 101a2ec:	296a9484 	addi	r5,r5,-21934
 101a2f0:	d9402b15 	stw	r5,172(sp)
 101a2f4:	d9402b17 	ldw	r5,172(sp)
 101a2f8:	1c47883a 	add	r3,r3,r17
 101a2fc:	10800044 	addi	r2,r2,1
 101a300:	41400015 	stw	r5,0(r8)
 101a304:	44400115 	stw	r17,4(r8)
 101a308:	d8c02015 	stw	r3,128(sp)
 101a30c:	d8801f15 	stw	r2,124(sp)
 101a310:	010001c4 	movi	r4,7
 101a314:	20bec816 	blt	r4,r2,1019e38 <__alt_data_end+0xff019e38>
 101a318:	42000204 	addi	r8,r8,8
 101a31c:	003ecd06 	br	1019e54 <__alt_data_end+0xff019e54>
 101a320:	d9002917 	ldw	r4,164(sp)
 101a324:	d8002785 	stb	zero,158(sp)
 101a328:	203d2d16 	blt	r4,zero,10197e0 <__alt_data_end+0xff0197e0>
 101a32c:	00bfdfc4 	movi	r2,-129
 101a330:	90a4703a 	and	r18,r18,r2
 101a334:	003a9106 	br	1018d7c <__alt_data_end+0xff018d7c>
 101a338:	010040f4 	movhi	r4,259
 101a33c:	212a9484 	addi	r4,r4,-21934
 101a340:	d9002b15 	stw	r4,172(sp)
 101a344:	003c0c06 	br	1019378 <__alt_data_end+0xff019378>
 101a348:	d9002c17 	ldw	r4,176(sp)
 101a34c:	d9801e04 	addi	r6,sp,120
 101a350:	b80b883a 	mov	r5,r23
 101a354:	10213d80 	call	10213d8 <__sprint_r>
 101a358:	103aab1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a35c:	d8c02017 	ldw	r3,128(sp)
 101a360:	da000404 	addi	r8,sp,16
 101a364:	003d4106 	br	101986c <__alt_data_end+0xff01986c>
 101a368:	d8801f17 	ldw	r2,124(sp)
 101a36c:	014040f4 	movhi	r5,259
 101a370:	01000044 	movi	r4,1
 101a374:	18c00044 	addi	r3,r3,1
 101a378:	10800044 	addi	r2,r2,1
 101a37c:	296a8c04 	addi	r5,r5,-21968
 101a380:	41000115 	stw	r4,4(r8)
 101a384:	41400015 	stw	r5,0(r8)
 101a388:	d8c02015 	stw	r3,128(sp)
 101a38c:	d8801f15 	stw	r2,124(sp)
 101a390:	010001c4 	movi	r4,7
 101a394:	20805c16 	blt	r4,r2,101a508 <___vfprintf_internal_r+0x1b08>
 101a398:	42000204 	addi	r8,r8,8
 101a39c:	8800041e 	bne	r17,zero,101a3b0 <___vfprintf_internal_r+0x19b0>
 101a3a0:	d8803317 	ldw	r2,204(sp)
 101a3a4:	1000021e 	bne	r2,zero,101a3b0 <___vfprintf_internal_r+0x19b0>
 101a3a8:	9080004c 	andi	r2,r18,1
 101a3ac:	103c0926 	beq	r2,zero,10193d4 <__alt_data_end+0xff0193d4>
 101a3b0:	d9003717 	ldw	r4,220(sp)
 101a3b4:	d8801f17 	ldw	r2,124(sp)
 101a3b8:	d9403417 	ldw	r5,208(sp)
 101a3bc:	20c7883a 	add	r3,r4,r3
 101a3c0:	10800044 	addi	r2,r2,1
 101a3c4:	41000115 	stw	r4,4(r8)
 101a3c8:	41400015 	stw	r5,0(r8)
 101a3cc:	d8c02015 	stw	r3,128(sp)
 101a3d0:	d8801f15 	stw	r2,124(sp)
 101a3d4:	010001c4 	movi	r4,7
 101a3d8:	20812116 	blt	r4,r2,101a860 <___vfprintf_internal_r+0x1e60>
 101a3dc:	42000204 	addi	r8,r8,8
 101a3e0:	0463c83a 	sub	r17,zero,r17
 101a3e4:	0440730e 	bge	zero,r17,101a5b4 <___vfprintf_internal_r+0x1bb4>
 101a3e8:	05800404 	movi	r22,16
 101a3ec:	b440860e 	bge	r22,r17,101a608 <___vfprintf_internal_r+0x1c08>
 101a3f0:	014040f4 	movhi	r5,259
 101a3f4:	296a9484 	addi	r5,r5,-21934
 101a3f8:	d9402b15 	stw	r5,172(sp)
 101a3fc:	070001c4 	movi	fp,7
 101a400:	dcc02c17 	ldw	r19,176(sp)
 101a404:	00000306 	br	101a414 <___vfprintf_internal_r+0x1a14>
 101a408:	42000204 	addi	r8,r8,8
 101a40c:	8c7ffc04 	addi	r17,r17,-16
 101a410:	b440800e 	bge	r22,r17,101a614 <___vfprintf_internal_r+0x1c14>
 101a414:	18c00404 	addi	r3,r3,16
 101a418:	10800044 	addi	r2,r2,1
 101a41c:	45000015 	stw	r20,0(r8)
 101a420:	45800115 	stw	r22,4(r8)
 101a424:	d8c02015 	stw	r3,128(sp)
 101a428:	d8801f15 	stw	r2,124(sp)
 101a42c:	e0bff60e 	bge	fp,r2,101a408 <__alt_data_end+0xff01a408>
 101a430:	d9801e04 	addi	r6,sp,120
 101a434:	b80b883a 	mov	r5,r23
 101a438:	9809883a 	mov	r4,r19
 101a43c:	10213d80 	call	10213d8 <__sprint_r>
 101a440:	103a711e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a444:	d8c02017 	ldw	r3,128(sp)
 101a448:	d8801f17 	ldw	r2,124(sp)
 101a44c:	da000404 	addi	r8,sp,16
 101a450:	003fee06 	br	101a40c <__alt_data_end+0xff01a40c>
 101a454:	00bfffc4 	movi	r2,-1
 101a458:	003a6f06 	br	1018e18 <__alt_data_end+0xff018e18>
 101a45c:	008011c4 	movi	r2,71
 101a460:	1440b816 	blt	r2,r17,101a744 <___vfprintf_internal_r+0x1d44>
 101a464:	040040f4 	movhi	r16,259
 101a468:	842a7e04 	addi	r16,r16,-22024
 101a46c:	00c000c4 	movi	r3,3
 101a470:	00bfdfc4 	movi	r2,-129
 101a474:	d8c02a15 	stw	r3,168(sp)
 101a478:	90a4703a 	and	r18,r18,r2
 101a47c:	df002783 	ldbu	fp,158(sp)
 101a480:	d8c02e15 	stw	r3,184(sp)
 101a484:	d8002915 	stw	zero,164(sp)
 101a488:	d8003215 	stw	zero,200(sp)
 101a48c:	003b2906 	br	1019134 <__alt_data_end+0xff019134>
 101a490:	d9002d17 	ldw	r4,180(sp)
 101a494:	24c00017 	ldw	r19,0(r4)
 101a498:	21000104 	addi	r4,r4,4
 101a49c:	d9002d15 	stw	r4,180(sp)
 101a4a0:	982dd7fa 	srai	r22,r19,31
 101a4a4:	b005883a 	mov	r2,r22
 101a4a8:	003a9f06 	br	1018f28 <__alt_data_end+0xff018f28>
 101a4ac:	d9402d17 	ldw	r5,180(sp)
 101a4b0:	d8c02f17 	ldw	r3,188(sp)
 101a4b4:	28800017 	ldw	r2,0(r5)
 101a4b8:	29400104 	addi	r5,r5,4
 101a4bc:	d9402d15 	stw	r5,180(sp)
 101a4c0:	10c00015 	stw	r3,0(r2)
 101a4c4:	00398606 	br	1018ae0 <__alt_data_end+0xff018ae0>
 101a4c8:	d9402d17 	ldw	r5,180(sp)
 101a4cc:	002d883a 	mov	r22,zero
 101a4d0:	2cc00017 	ldw	r19,0(r5)
 101a4d4:	29400104 	addi	r5,r5,4
 101a4d8:	d9402d15 	stw	r5,180(sp)
 101a4dc:	003c2306 	br	101956c <__alt_data_end+0xff01956c>
 101a4e0:	d8c02d17 	ldw	r3,180(sp)
 101a4e4:	d9002917 	ldw	r4,164(sp)
 101a4e8:	002d883a 	mov	r22,zero
 101a4ec:	18800104 	addi	r2,r3,4
 101a4f0:	1cc0000b 	ldhu	r19,0(r3)
 101a4f4:	203dc10e 	bge	r4,zero,1019bfc <__alt_data_end+0xff019bfc>
 101a4f8:	003f7506 	br	101a2d0 <__alt_data_end+0xff01a2d0>
 101a4fc:	040040f4 	movhi	r16,259
 101a500:	842a7c04 	addi	r16,r16,-22032
 101a504:	003acc06 	br	1019038 <__alt_data_end+0xff019038>
 101a508:	d9002c17 	ldw	r4,176(sp)
 101a50c:	d9801e04 	addi	r6,sp,120
 101a510:	b80b883a 	mov	r5,r23
 101a514:	10213d80 	call	10213d8 <__sprint_r>
 101a518:	103a3b1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a51c:	dc402617 	ldw	r17,152(sp)
 101a520:	d8c02017 	ldw	r3,128(sp)
 101a524:	da000404 	addi	r8,sp,16
 101a528:	003f9c06 	br	101a39c <__alt_data_end+0xff01a39c>
 101a52c:	ac400043 	ldbu	r17,1(r21)
 101a530:	94800814 	ori	r18,r18,32
 101a534:	ad400044 	addi	r21,r21,1
 101a538:	8c403fcc 	andi	r17,r17,255
 101a53c:	8c40201c 	xori	r17,r17,128
 101a540:	8c7fe004 	addi	r17,r17,-128
 101a544:	00398f06 	br	1018b84 <__alt_data_end+0xff018b84>
 101a548:	d8c02d15 	stw	r3,180(sp)
 101a54c:	0039883a 	mov	fp,zero
 101a550:	003e3506 	br	1019e28 <__alt_data_end+0xff019e28>
 101a554:	d9002c17 	ldw	r4,176(sp)
 101a558:	d9801e04 	addi	r6,sp,120
 101a55c:	b80b883a 	mov	r5,r23
 101a560:	10213d80 	call	10213d8 <__sprint_r>
 101a564:	103a281e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a568:	d8c02017 	ldw	r3,128(sp)
 101a56c:	da000404 	addi	r8,sp,16
 101a570:	003cd006 	br	10198b4 <__alt_data_end+0xff0198b4>
 101a574:	8009883a 	mov	r4,r16
 101a578:	da003d15 	stw	r8,244(sp)
 101a57c:	10165b40 	call	10165b4 <strlen>
 101a580:	d8802e15 	stw	r2,184(sp)
 101a584:	da003d17 	ldw	r8,244(sp)
 101a588:	103c340e 	bge	r2,zero,101965c <__alt_data_end+0xff01965c>
 101a58c:	0005883a 	mov	r2,zero
 101a590:	003c3206 	br	101965c <__alt_data_end+0xff01965c>
 101a594:	d9002c17 	ldw	r4,176(sp)
 101a598:	d9801e04 	addi	r6,sp,120
 101a59c:	b80b883a 	mov	r5,r23
 101a5a0:	10213d80 	call	10213d8 <__sprint_r>
 101a5a4:	103a181e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a5a8:	d8c02017 	ldw	r3,128(sp)
 101a5ac:	d8801f17 	ldw	r2,124(sp)
 101a5b0:	da000404 	addi	r8,sp,16
 101a5b4:	d9403317 	ldw	r5,204(sp)
 101a5b8:	10800044 	addi	r2,r2,1
 101a5bc:	44000015 	stw	r16,0(r8)
 101a5c0:	28c7883a 	add	r3,r5,r3
 101a5c4:	003b7d06 	br	10193bc <__alt_data_end+0xff0193bc>
 101a5c8:	010040f4 	movhi	r4,259
 101a5cc:	212a9884 	addi	r4,r4,-21918
 101a5d0:	d9003515 	stw	r4,212(sp)
 101a5d4:	003b1406 	br	1019228 <__alt_data_end+0xff019228>
 101a5d8:	013fffc4 	movi	r4,-1
 101a5dc:	003a3506 	br	1018eb4 <__alt_data_end+0xff018eb4>
 101a5e0:	0023883a 	mov	r17,zero
 101a5e4:	003d9d06 	br	1019c5c <__alt_data_end+0xff019c5c>
 101a5e8:	d9002c17 	ldw	r4,176(sp)
 101a5ec:	d9801e04 	addi	r6,sp,120
 101a5f0:	b80b883a 	mov	r5,r23
 101a5f4:	10213d80 	call	10213d8 <__sprint_r>
 101a5f8:	103a031e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a5fc:	d8c02017 	ldw	r3,128(sp)
 101a600:	da000404 	addi	r8,sp,16
 101a604:	003d9406 	br	1019c58 <__alt_data_end+0xff019c58>
 101a608:	010040f4 	movhi	r4,259
 101a60c:	212a9484 	addi	r4,r4,-21934
 101a610:	d9002b15 	stw	r4,172(sp)
 101a614:	d9002b17 	ldw	r4,172(sp)
 101a618:	1c47883a 	add	r3,r3,r17
 101a61c:	10800044 	addi	r2,r2,1
 101a620:	41000015 	stw	r4,0(r8)
 101a624:	44400115 	stw	r17,4(r8)
 101a628:	d8c02015 	stw	r3,128(sp)
 101a62c:	d8801f15 	stw	r2,124(sp)
 101a630:	010001c4 	movi	r4,7
 101a634:	20bfd716 	blt	r4,r2,101a594 <__alt_data_end+0xff01a594>
 101a638:	42000204 	addi	r8,r8,8
 101a63c:	003fdd06 	br	101a5b4 <__alt_data_end+0xff01a5b4>
 101a640:	d9002c17 	ldw	r4,176(sp)
 101a644:	d9801e04 	addi	r6,sp,120
 101a648:	b80b883a 	mov	r5,r23
 101a64c:	10213d80 	call	10213d8 <__sprint_r>
 101a650:	1039ed1e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a654:	d8802617 	ldw	r2,152(sp)
 101a658:	d8c02017 	ldw	r3,128(sp)
 101a65c:	da000404 	addi	r8,sp,16
 101a660:	003e1006 	br	1019ea4 <__alt_data_end+0xff019ea4>
 101a664:	00800044 	movi	r2,1
 101a668:	10803fcc 	andi	r2,r2,255
 101a66c:	00c00044 	movi	r3,1
 101a670:	10fa3526 	beq	r2,r3,1018f48 <__alt_data_end+0xff018f48>
 101a674:	00c00084 	movi	r3,2
 101a678:	10fbcb26 	beq	r2,r3,10195a8 <__alt_data_end+0xff0195a8>
 101a67c:	003a8f06 	br	10190bc <__alt_data_end+0xff0190bc>
 101a680:	010040f4 	movhi	r4,259
 101a684:	212a9884 	addi	r4,r4,-21918
 101a688:	d9003515 	stw	r4,212(sp)
 101a68c:	003b7606 	br	1019468 <__alt_data_end+0xff019468>
 101a690:	d8802917 	ldw	r2,164(sp)
 101a694:	00c00184 	movi	r3,6
 101a698:	1880012e 	bgeu	r3,r2,101a6a0 <___vfprintf_internal_r+0x1ca0>
 101a69c:	1805883a 	mov	r2,r3
 101a6a0:	d8802e15 	stw	r2,184(sp)
 101a6a4:	1000ef16 	blt	r2,zero,101aa64 <___vfprintf_internal_r+0x2064>
 101a6a8:	040040f4 	movhi	r16,259
 101a6ac:	d8802a15 	stw	r2,168(sp)
 101a6b0:	dcc02d15 	stw	r19,180(sp)
 101a6b4:	d8002915 	stw	zero,164(sp)
 101a6b8:	d8003215 	stw	zero,200(sp)
 101a6bc:	842a8a04 	addi	r16,r16,-21976
 101a6c0:	0039883a 	mov	fp,zero
 101a6c4:	003aa206 	br	1019150 <__alt_data_end+0xff019150>
 101a6c8:	0021883a 	mov	r16,zero
 101a6cc:	003e0706 	br	1019eec <__alt_data_end+0xff019eec>
 101a6d0:	d9002c17 	ldw	r4,176(sp)
 101a6d4:	d9801e04 	addi	r6,sp,120
 101a6d8:	b80b883a 	mov	r5,r23
 101a6dc:	10213d80 	call	10213d8 <__sprint_r>
 101a6e0:	1039c91e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a6e4:	d8802617 	ldw	r2,152(sp)
 101a6e8:	d9403317 	ldw	r5,204(sp)
 101a6ec:	d8c02017 	ldw	r3,128(sp)
 101a6f0:	da000404 	addi	r8,sp,16
 101a6f4:	2885c83a 	sub	r2,r5,r2
 101a6f8:	003dfb06 	br	1019ee8 <__alt_data_end+0xff019ee8>
 101a6fc:	9080004c 	andi	r2,r18,1
 101a700:	103e8f1e 	bne	r2,zero,101a140 <__alt_data_end+0xff01a140>
 101a704:	d8802117 	ldw	r2,132(sp)
 101a708:	003e9e06 	br	101a184 <__alt_data_end+0xff01a184>
 101a70c:	1025883a 	mov	r18,r2
 101a710:	0039883a 	mov	fp,zero
 101a714:	00800084 	movi	r2,2
 101a718:	003fd306 	br	101a668 <__alt_data_end+0xff01a668>
 101a71c:	07000b44 	movi	fp,45
 101a720:	df002785 	stb	fp,158(sp)
 101a724:	003a4006 	br	1019028 <__alt_data_end+0xff019028>
 101a728:	00c00b44 	movi	r3,45
 101a72c:	d8c02785 	stb	r3,158(sp)
 101a730:	d8802a15 	stw	r2,168(sp)
 101a734:	dc802b17 	ldw	r18,172(sp)
 101a738:	d8002915 	stw	zero,164(sp)
 101a73c:	07000b44 	movi	fp,45
 101a740:	003a8006 	br	1019144 <__alt_data_end+0xff019144>
 101a744:	040040f4 	movhi	r16,259
 101a748:	842a7f04 	addi	r16,r16,-22020
 101a74c:	003f4706 	br	101a46c <__alt_data_end+0xff01a46c>
 101a750:	d8c02d17 	ldw	r3,180(sp)
 101a754:	d9002f17 	ldw	r4,188(sp)
 101a758:	18800017 	ldw	r2,0(r3)
 101a75c:	18c00104 	addi	r3,r3,4
 101a760:	d8c02d15 	stw	r3,180(sp)
 101a764:	11000015 	stw	r4,0(r2)
 101a768:	0038dd06 	br	1018ae0 <__alt_data_end+0xff018ae0>
 101a76c:	dd802617 	ldw	r22,152(sp)
 101a770:	00bfff44 	movi	r2,-3
 101a774:	b0801c16 	blt	r22,r2,101a7e8 <___vfprintf_internal_r+0x1de8>
 101a778:	d9402917 	ldw	r5,164(sp)
 101a77c:	2d801a16 	blt	r5,r22,101a7e8 <___vfprintf_internal_r+0x1de8>
 101a780:	dd803215 	stw	r22,200(sp)
 101a784:	003e8906 	br	101a1ac <__alt_data_end+0xff01a1ac>
 101a788:	010040f4 	movhi	r4,259
 101a78c:	212a9484 	addi	r4,r4,-21934
 101a790:	d9002b15 	stw	r4,172(sp)
 101a794:	003c9106 	br	10199dc <__alt_data_end+0xff0199dc>
 101a798:	e005883a 	mov	r2,fp
 101a79c:	003e7906 	br	101a184 <__alt_data_end+0xff01a184>
 101a7a0:	d9402917 	ldw	r5,164(sp)
 101a7a4:	df002783 	ldbu	fp,158(sp)
 101a7a8:	dcc02d15 	stw	r19,180(sp)
 101a7ac:	d9402a15 	stw	r5,168(sp)
 101a7b0:	d9402e15 	stw	r5,184(sp)
 101a7b4:	d8002915 	stw	zero,164(sp)
 101a7b8:	d8003215 	stw	zero,200(sp)
 101a7bc:	003a5d06 	br	1019134 <__alt_data_end+0xff019134>
 101a7c0:	9080004c 	andi	r2,r18,1
 101a7c4:	0039883a 	mov	fp,zero
 101a7c8:	10000426 	beq	r2,zero,101a7dc <___vfprintf_internal_r+0x1ddc>
 101a7cc:	00800c04 	movi	r2,48
 101a7d0:	dc001dc4 	addi	r16,sp,119
 101a7d4:	d8801dc5 	stb	r2,119(sp)
 101a7d8:	003b8006 	br	10195dc <__alt_data_end+0xff0195dc>
 101a7dc:	d8002e15 	stw	zero,184(sp)
 101a7e0:	dc001e04 	addi	r16,sp,120
 101a7e4:	003a4d06 	br	101911c <__alt_data_end+0xff01911c>
 101a7e8:	8c7fff84 	addi	r17,r17,-2
 101a7ec:	b5bfffc4 	addi	r22,r22,-1
 101a7f0:	dd802615 	stw	r22,152(sp)
 101a7f4:	dc4022c5 	stb	r17,139(sp)
 101a7f8:	b000bf16 	blt	r22,zero,101aaf8 <___vfprintf_internal_r+0x20f8>
 101a7fc:	00800ac4 	movi	r2,43
 101a800:	d8802305 	stb	r2,140(sp)
 101a804:	00800244 	movi	r2,9
 101a808:	15807016 	blt	r2,r22,101a9cc <___vfprintf_internal_r+0x1fcc>
 101a80c:	00800c04 	movi	r2,48
 101a810:	b5800c04 	addi	r22,r22,48
 101a814:	d8802345 	stb	r2,141(sp)
 101a818:	dd802385 	stb	r22,142(sp)
 101a81c:	d88023c4 	addi	r2,sp,143
 101a820:	df0022c4 	addi	fp,sp,139
 101a824:	d8c03317 	ldw	r3,204(sp)
 101a828:	1739c83a 	sub	fp,r2,fp
 101a82c:	d9003317 	ldw	r4,204(sp)
 101a830:	e0c7883a 	add	r3,fp,r3
 101a834:	df003a15 	stw	fp,232(sp)
 101a838:	d8c02e15 	stw	r3,184(sp)
 101a83c:	00800044 	movi	r2,1
 101a840:	1100b30e 	bge	r2,r4,101ab10 <___vfprintf_internal_r+0x2110>
 101a844:	d8c02e17 	ldw	r3,184(sp)
 101a848:	18c00044 	addi	r3,r3,1
 101a84c:	d8c02e15 	stw	r3,184(sp)
 101a850:	1805883a 	mov	r2,r3
 101a854:	1800ac16 	blt	r3,zero,101ab08 <___vfprintf_internal_r+0x2108>
 101a858:	d8003215 	stw	zero,200(sp)
 101a85c:	003e5d06 	br	101a1d4 <__alt_data_end+0xff01a1d4>
 101a860:	d9002c17 	ldw	r4,176(sp)
 101a864:	d9801e04 	addi	r6,sp,120
 101a868:	b80b883a 	mov	r5,r23
 101a86c:	10213d80 	call	10213d8 <__sprint_r>
 101a870:	1039651e 	bne	r2,zero,1018e08 <__alt_data_end+0xff018e08>
 101a874:	dc402617 	ldw	r17,152(sp)
 101a878:	d8c02017 	ldw	r3,128(sp)
 101a87c:	d8801f17 	ldw	r2,124(sp)
 101a880:	da000404 	addi	r8,sp,16
 101a884:	003ed606 	br	101a3e0 <__alt_data_end+0xff01a3e0>
 101a888:	582b883a 	mov	r21,r11
 101a88c:	d8002915 	stw	zero,164(sp)
 101a890:	0038bd06 	br	1018b88 <__alt_data_end+0xff018b88>
 101a894:	d8802917 	ldw	r2,164(sp)
 101a898:	103e071e 	bne	r2,zero,101a0b8 <__alt_data_end+0xff01a0b8>
 101a89c:	dc002915 	stw	r16,164(sp)
 101a8a0:	003e0506 	br	101a0b8 <__alt_data_end+0xff01a0b8>
 101a8a4:	d9002917 	ldw	r4,164(sp)
 101a8a8:	20c00044 	addi	r3,r4,1
 101a8ac:	003e0f06 	br	101a0ec <__alt_data_end+0xff01a0ec>
 101a8b0:	01400184 	movi	r5,6
 101a8b4:	d9402915 	stw	r5,164(sp)
 101a8b8:	003dff06 	br	101a0b8 <__alt_data_end+0xff01a0b8>
 101a8bc:	d8802104 	addi	r2,sp,132
 101a8c0:	d8800315 	stw	r2,12(sp)
 101a8c4:	d8802504 	addi	r2,sp,148
 101a8c8:	d8800215 	stw	r2,8(sp)
 101a8cc:	d8802604 	addi	r2,sp,152
 101a8d0:	d8800115 	stw	r2,4(sp)
 101a8d4:	d8802917 	ldw	r2,164(sp)
 101a8d8:	d9403617 	ldw	r5,216(sp)
 101a8dc:	d9002c17 	ldw	r4,176(sp)
 101a8e0:	d8800015 	stw	r2,0(sp)
 101a8e4:	01c000c4 	movi	r7,3
 101a8e8:	980d883a 	mov	r6,r19
 101a8ec:	da003d15 	stw	r8,244(sp)
 101a8f0:	101b03c0 	call	101b03c <_dtoa_r>
 101a8f4:	d8c02917 	ldw	r3,164(sp)
 101a8f8:	da003d17 	ldw	r8,244(sp)
 101a8fc:	1021883a 	mov	r16,r2
 101a900:	10f9883a 	add	fp,r2,r3
 101a904:	81000007 	ldb	r4,0(r16)
 101a908:	00800c04 	movi	r2,48
 101a90c:	20805e26 	beq	r4,r2,101aa88 <___vfprintf_internal_r+0x2088>
 101a910:	d8c02617 	ldw	r3,152(sp)
 101a914:	e0f9883a 	add	fp,fp,r3
 101a918:	003e0a06 	br	101a144 <__alt_data_end+0xff01a144>
 101a91c:	00c00b44 	movi	r3,45
 101a920:	24e0003c 	xorhi	r19,r4,32768
 101a924:	d8c02a05 	stb	r3,168(sp)
 101a928:	003de906 	br	101a0d0 <__alt_data_end+0xff01a0d0>
 101a92c:	d8c03217 	ldw	r3,200(sp)
 101a930:	00c07a0e 	bge	zero,r3,101ab1c <___vfprintf_internal_r+0x211c>
 101a934:	00800044 	movi	r2,1
 101a938:	d9003317 	ldw	r4,204(sp)
 101a93c:	1105883a 	add	r2,r2,r4
 101a940:	d8802e15 	stw	r2,184(sp)
 101a944:	10004e16 	blt	r2,zero,101aa80 <___vfprintf_internal_r+0x2080>
 101a948:	044019c4 	movi	r17,103
 101a94c:	003e2106 	br	101a1d4 <__alt_data_end+0xff01a1d4>
 101a950:	d9002917 	ldw	r4,164(sp)
 101a954:	d8802104 	addi	r2,sp,132
 101a958:	d8800315 	stw	r2,12(sp)
 101a95c:	d9000015 	stw	r4,0(sp)
 101a960:	d8802504 	addi	r2,sp,148
 101a964:	d9403617 	ldw	r5,216(sp)
 101a968:	d9002c17 	ldw	r4,176(sp)
 101a96c:	d8800215 	stw	r2,8(sp)
 101a970:	d8802604 	addi	r2,sp,152
 101a974:	d8800115 	stw	r2,4(sp)
 101a978:	01c000c4 	movi	r7,3
 101a97c:	980d883a 	mov	r6,r19
 101a980:	da003d15 	stw	r8,244(sp)
 101a984:	101b03c0 	call	101b03c <_dtoa_r>
 101a988:	d8c02917 	ldw	r3,164(sp)
 101a98c:	da003d17 	ldw	r8,244(sp)
 101a990:	1021883a 	mov	r16,r2
 101a994:	00801184 	movi	r2,70
 101a998:	80f9883a 	add	fp,r16,r3
 101a99c:	88bfd926 	beq	r17,r2,101a904 <__alt_data_end+0xff01a904>
 101a9a0:	003de806 	br	101a144 <__alt_data_end+0xff01a144>
 101a9a4:	d9002917 	ldw	r4,164(sp)
 101a9a8:	00c04d0e 	bge	zero,r3,101aae0 <___vfprintf_internal_r+0x20e0>
 101a9ac:	2000441e 	bne	r4,zero,101aac0 <___vfprintf_internal_r+0x20c0>
 101a9b0:	9480004c 	andi	r18,r18,1
 101a9b4:	9000421e 	bne	r18,zero,101aac0 <___vfprintf_internal_r+0x20c0>
 101a9b8:	1805883a 	mov	r2,r3
 101a9bc:	18007016 	blt	r3,zero,101ab80 <___vfprintf_internal_r+0x2180>
 101a9c0:	d8c03217 	ldw	r3,200(sp)
 101a9c4:	d8c02e15 	stw	r3,184(sp)
 101a9c8:	003e0206 	br	101a1d4 <__alt_data_end+0xff01a1d4>
 101a9cc:	df0022c4 	addi	fp,sp,139
 101a9d0:	dc002915 	stw	r16,164(sp)
 101a9d4:	4027883a 	mov	r19,r8
 101a9d8:	e021883a 	mov	r16,fp
 101a9dc:	b009883a 	mov	r4,r22
 101a9e0:	01400284 	movi	r5,10
 101a9e4:	1023d8c0 	call	1023d8c <__modsi3>
 101a9e8:	10800c04 	addi	r2,r2,48
 101a9ec:	843fffc4 	addi	r16,r16,-1
 101a9f0:	b009883a 	mov	r4,r22
 101a9f4:	01400284 	movi	r5,10
 101a9f8:	80800005 	stb	r2,0(r16)
 101a9fc:	1023d080 	call	1023d08 <__divsi3>
 101aa00:	102d883a 	mov	r22,r2
 101aa04:	00800244 	movi	r2,9
 101aa08:	15bff416 	blt	r2,r22,101a9dc <__alt_data_end+0xff01a9dc>
 101aa0c:	9811883a 	mov	r8,r19
 101aa10:	b0800c04 	addi	r2,r22,48
 101aa14:	8027883a 	mov	r19,r16
 101aa18:	997fffc4 	addi	r5,r19,-1
 101aa1c:	98bfffc5 	stb	r2,-1(r19)
 101aa20:	dc002917 	ldw	r16,164(sp)
 101aa24:	2f006a2e 	bgeu	r5,fp,101abd0 <___vfprintf_internal_r+0x21d0>
 101aa28:	d9c02384 	addi	r7,sp,142
 101aa2c:	3ccfc83a 	sub	r7,r7,r19
 101aa30:	d9002344 	addi	r4,sp,141
 101aa34:	e1cf883a 	add	r7,fp,r7
 101aa38:	00000106 	br	101aa40 <___vfprintf_internal_r+0x2040>
 101aa3c:	28800003 	ldbu	r2,0(r5)
 101aa40:	20800005 	stb	r2,0(r4)
 101aa44:	21000044 	addi	r4,r4,1
 101aa48:	29400044 	addi	r5,r5,1
 101aa4c:	393ffb1e 	bne	r7,r4,101aa3c <__alt_data_end+0xff01aa3c>
 101aa50:	d8802304 	addi	r2,sp,140
 101aa54:	14c5c83a 	sub	r2,r2,r19
 101aa58:	d8c02344 	addi	r3,sp,141
 101aa5c:	1885883a 	add	r2,r3,r2
 101aa60:	003f7006 	br	101a824 <__alt_data_end+0xff01a824>
 101aa64:	0005883a 	mov	r2,zero
 101aa68:	003f0f06 	br	101a6a8 <__alt_data_end+0xff01a6a8>
 101aa6c:	d8c03217 	ldw	r3,200(sp)
 101aa70:	18c00044 	addi	r3,r3,1
 101aa74:	d8c02e15 	stw	r3,184(sp)
 101aa78:	1805883a 	mov	r2,r3
 101aa7c:	183fb20e 	bge	r3,zero,101a948 <__alt_data_end+0xff01a948>
 101aa80:	0005883a 	mov	r2,zero
 101aa84:	003fb006 	br	101a948 <__alt_data_end+0xff01a948>
 101aa88:	d9003617 	ldw	r4,216(sp)
 101aa8c:	000d883a 	mov	r6,zero
 101aa90:	000f883a 	mov	r7,zero
 101aa94:	980b883a 	mov	r5,r19
 101aa98:	d8c03c15 	stw	r3,240(sp)
 101aa9c:	da003d15 	stw	r8,244(sp)
 101aaa0:	10250500 	call	1025050 <__eqdf2>
 101aaa4:	d8c03c17 	ldw	r3,240(sp)
 101aaa8:	da003d17 	ldw	r8,244(sp)
 101aaac:	103f9826 	beq	r2,zero,101a910 <__alt_data_end+0xff01a910>
 101aab0:	00800044 	movi	r2,1
 101aab4:	10c7c83a 	sub	r3,r2,r3
 101aab8:	d8c02615 	stw	r3,152(sp)
 101aabc:	003f9506 	br	101a914 <__alt_data_end+0xff01a914>
 101aac0:	d9002917 	ldw	r4,164(sp)
 101aac4:	d8c03217 	ldw	r3,200(sp)
 101aac8:	20800044 	addi	r2,r4,1
 101aacc:	1885883a 	add	r2,r3,r2
 101aad0:	d8802e15 	stw	r2,184(sp)
 101aad4:	103dbf0e 	bge	r2,zero,101a1d4 <__alt_data_end+0xff01a1d4>
 101aad8:	0005883a 	mov	r2,zero
 101aadc:	003dbd06 	br	101a1d4 <__alt_data_end+0xff01a1d4>
 101aae0:	2000211e 	bne	r4,zero,101ab68 <___vfprintf_internal_r+0x2168>
 101aae4:	9480004c 	andi	r18,r18,1
 101aae8:	90001f1e 	bne	r18,zero,101ab68 <___vfprintf_internal_r+0x2168>
 101aaec:	00800044 	movi	r2,1
 101aaf0:	d8802e15 	stw	r2,184(sp)
 101aaf4:	003db706 	br	101a1d4 <__alt_data_end+0xff01a1d4>
 101aaf8:	00800b44 	movi	r2,45
 101aafc:	05adc83a 	sub	r22,zero,r22
 101ab00:	d8802305 	stb	r2,140(sp)
 101ab04:	003f3f06 	br	101a804 <__alt_data_end+0xff01a804>
 101ab08:	0005883a 	mov	r2,zero
 101ab0c:	003f5206 	br	101a858 <__alt_data_end+0xff01a858>
 101ab10:	90a4703a 	and	r18,r18,r2
 101ab14:	903f4e26 	beq	r18,zero,101a850 <__alt_data_end+0xff01a850>
 101ab18:	003f4a06 	br	101a844 <__alt_data_end+0xff01a844>
 101ab1c:	00800084 	movi	r2,2
 101ab20:	10c5c83a 	sub	r2,r2,r3
 101ab24:	003f8406 	br	101a938 <__alt_data_end+0xff01a938>
 101ab28:	d8802d17 	ldw	r2,180(sp)
 101ab2c:	d9002d17 	ldw	r4,180(sp)
 101ab30:	ac400043 	ldbu	r17,1(r21)
 101ab34:	10800017 	ldw	r2,0(r2)
 101ab38:	582b883a 	mov	r21,r11
 101ab3c:	d8802915 	stw	r2,164(sp)
 101ab40:	20800104 	addi	r2,r4,4
 101ab44:	d9002917 	ldw	r4,164(sp)
 101ab48:	d8802d15 	stw	r2,180(sp)
 101ab4c:	203e7a0e 	bge	r4,zero,101a538 <__alt_data_end+0xff01a538>
 101ab50:	8c403fcc 	andi	r17,r17,255
 101ab54:	00bfffc4 	movi	r2,-1
 101ab58:	8c40201c 	xori	r17,r17,128
 101ab5c:	d8802915 	stw	r2,164(sp)
 101ab60:	8c7fe004 	addi	r17,r17,-128
 101ab64:	00380706 	br	1018b84 <__alt_data_end+0xff018b84>
 101ab68:	d8c02917 	ldw	r3,164(sp)
 101ab6c:	18c00084 	addi	r3,r3,2
 101ab70:	d8c02e15 	stw	r3,184(sp)
 101ab74:	1805883a 	mov	r2,r3
 101ab78:	183d960e 	bge	r3,zero,101a1d4 <__alt_data_end+0xff01a1d4>
 101ab7c:	003fd606 	br	101aad8 <__alt_data_end+0xff01aad8>
 101ab80:	0005883a 	mov	r2,zero
 101ab84:	003f8e06 	br	101a9c0 <__alt_data_end+0xff01a9c0>
 101ab88:	9080004c 	andi	r2,r18,1
 101ab8c:	103f811e 	bne	r2,zero,101a994 <__alt_data_end+0xff01a994>
 101ab90:	d8802117 	ldw	r2,132(sp)
 101ab94:	1405c83a 	sub	r2,r2,r16
 101ab98:	d8803315 	stw	r2,204(sp)
 101ab9c:	b47ef326 	beq	r22,r17,101a76c <__alt_data_end+0xff01a76c>
 101aba0:	dd802617 	ldw	r22,152(sp)
 101aba4:	003f1106 	br	101a7ec <__alt_data_end+0xff01a7ec>
 101aba8:	d9c02785 	stb	r7,158(sp)
 101abac:	00390406 	br	1018fc0 <__alt_data_end+0xff018fc0>
 101abb0:	d9c02785 	stb	r7,158(sp)
 101abb4:	0038d306 	br	1018f04 <__alt_data_end+0xff018f04>
 101abb8:	d9c02785 	stb	r7,158(sp)
 101abbc:	003a6106 	br	1019544 <__alt_data_end+0xff019544>
 101abc0:	d9c02785 	stb	r7,158(sp)
 101abc4:	003af806 	br	10197a8 <__alt_data_end+0xff0197a8>
 101abc8:	0005883a 	mov	r2,zero
 101abcc:	003d7e06 	br	101a1c8 <__alt_data_end+0xff01a1c8>
 101abd0:	d8802344 	addi	r2,sp,141
 101abd4:	003f1306 	br	101a824 <__alt_data_end+0xff01a824>
 101abd8:	d9c02785 	stb	r7,158(sp)
 101abdc:	00392306 	br	101906c <__alt_data_end+0xff01906c>
 101abe0:	d9c02785 	stb	r7,158(sp)
 101abe4:	003aa906 	br	101968c <__alt_data_end+0xff01968c>
 101abe8:	d9c02785 	stb	r7,158(sp)
 101abec:	003a3d06 	br	10194e4 <__alt_data_end+0xff0194e4>
 101abf0:	d9c02785 	stb	r7,158(sp)
 101abf4:	003aca06 	br	1019720 <__alt_data_end+0xff019720>

0101abf8 <__vfprintf_internal>:
 101abf8:	008040f4 	movhi	r2,259
 101abfc:	10b25d04 	addi	r2,r2,-13964
 101ac00:	300f883a 	mov	r7,r6
 101ac04:	280d883a 	mov	r6,r5
 101ac08:	200b883a 	mov	r5,r4
 101ac0c:	11000017 	ldw	r4,0(r2)
 101ac10:	1018a001 	jmpi	1018a00 <___vfprintf_internal_r>

0101ac14 <__sbprintf>:
 101ac14:	2880030b 	ldhu	r2,12(r5)
 101ac18:	2ac01917 	ldw	r11,100(r5)
 101ac1c:	2a80038b 	ldhu	r10,14(r5)
 101ac20:	2a400717 	ldw	r9,28(r5)
 101ac24:	2a000917 	ldw	r8,36(r5)
 101ac28:	defee204 	addi	sp,sp,-1144
 101ac2c:	00c10004 	movi	r3,1024
 101ac30:	dc011a15 	stw	r16,1128(sp)
 101ac34:	10bfff4c 	andi	r2,r2,65533
 101ac38:	2821883a 	mov	r16,r5
 101ac3c:	d8cb883a 	add	r5,sp,r3
 101ac40:	dc811c15 	stw	r18,1136(sp)
 101ac44:	dc411b15 	stw	r17,1132(sp)
 101ac48:	dfc11d15 	stw	ra,1140(sp)
 101ac4c:	2025883a 	mov	r18,r4
 101ac50:	d881030d 	sth	r2,1036(sp)
 101ac54:	dac11915 	stw	r11,1124(sp)
 101ac58:	da81038d 	sth	r10,1038(sp)
 101ac5c:	da410715 	stw	r9,1052(sp)
 101ac60:	da010915 	stw	r8,1060(sp)
 101ac64:	dec10015 	stw	sp,1024(sp)
 101ac68:	dec10415 	stw	sp,1040(sp)
 101ac6c:	d8c10215 	stw	r3,1032(sp)
 101ac70:	d8c10515 	stw	r3,1044(sp)
 101ac74:	d8010615 	stw	zero,1048(sp)
 101ac78:	1018a000 	call	1018a00 <___vfprintf_internal_r>
 101ac7c:	1023883a 	mov	r17,r2
 101ac80:	10000416 	blt	r2,zero,101ac94 <__sbprintf+0x80>
 101ac84:	d9410004 	addi	r5,sp,1024
 101ac88:	9009883a 	mov	r4,r18
 101ac8c:	101c8e00 	call	101c8e0 <_fflush_r>
 101ac90:	10000d1e 	bne	r2,zero,101acc8 <__sbprintf+0xb4>
 101ac94:	d881030b 	ldhu	r2,1036(sp)
 101ac98:	1080100c 	andi	r2,r2,64
 101ac9c:	10000326 	beq	r2,zero,101acac <__sbprintf+0x98>
 101aca0:	8080030b 	ldhu	r2,12(r16)
 101aca4:	10801014 	ori	r2,r2,64
 101aca8:	8080030d 	sth	r2,12(r16)
 101acac:	8805883a 	mov	r2,r17
 101acb0:	dfc11d17 	ldw	ra,1140(sp)
 101acb4:	dc811c17 	ldw	r18,1136(sp)
 101acb8:	dc411b17 	ldw	r17,1132(sp)
 101acbc:	dc011a17 	ldw	r16,1128(sp)
 101acc0:	dec11e04 	addi	sp,sp,1144
 101acc4:	f800283a 	ret
 101acc8:	047fffc4 	movi	r17,-1
 101accc:	003ff106 	br	101ac94 <__alt_data_end+0xff01ac94>

0101acd0 <__swsetup_r>:
 101acd0:	008040f4 	movhi	r2,259
 101acd4:	defffd04 	addi	sp,sp,-12
 101acd8:	10b25d04 	addi	r2,r2,-13964
 101acdc:	dc400115 	stw	r17,4(sp)
 101ace0:	2023883a 	mov	r17,r4
 101ace4:	11000017 	ldw	r4,0(r2)
 101ace8:	dc000015 	stw	r16,0(sp)
 101acec:	dfc00215 	stw	ra,8(sp)
 101acf0:	2821883a 	mov	r16,r5
 101acf4:	20000226 	beq	r4,zero,101ad00 <__swsetup_r+0x30>
 101acf8:	20800e17 	ldw	r2,56(r4)
 101acfc:	10003126 	beq	r2,zero,101adc4 <__swsetup_r+0xf4>
 101ad00:	8080030b 	ldhu	r2,12(r16)
 101ad04:	10c0020c 	andi	r3,r2,8
 101ad08:	1009883a 	mov	r4,r2
 101ad0c:	18000f26 	beq	r3,zero,101ad4c <__swsetup_r+0x7c>
 101ad10:	80c00417 	ldw	r3,16(r16)
 101ad14:	18001526 	beq	r3,zero,101ad6c <__swsetup_r+0x9c>
 101ad18:	1100004c 	andi	r4,r2,1
 101ad1c:	20001c1e 	bne	r4,zero,101ad90 <__swsetup_r+0xc0>
 101ad20:	1080008c 	andi	r2,r2,2
 101ad24:	1000291e 	bne	r2,zero,101adcc <__swsetup_r+0xfc>
 101ad28:	80800517 	ldw	r2,20(r16)
 101ad2c:	80800215 	stw	r2,8(r16)
 101ad30:	18001c26 	beq	r3,zero,101ada4 <__swsetup_r+0xd4>
 101ad34:	0005883a 	mov	r2,zero
 101ad38:	dfc00217 	ldw	ra,8(sp)
 101ad3c:	dc400117 	ldw	r17,4(sp)
 101ad40:	dc000017 	ldw	r16,0(sp)
 101ad44:	dec00304 	addi	sp,sp,12
 101ad48:	f800283a 	ret
 101ad4c:	2080040c 	andi	r2,r4,16
 101ad50:	10002e26 	beq	r2,zero,101ae0c <__swsetup_r+0x13c>
 101ad54:	2080010c 	andi	r2,r4,4
 101ad58:	10001e1e 	bne	r2,zero,101add4 <__swsetup_r+0x104>
 101ad5c:	80c00417 	ldw	r3,16(r16)
 101ad60:	20800214 	ori	r2,r4,8
 101ad64:	8080030d 	sth	r2,12(r16)
 101ad68:	183feb1e 	bne	r3,zero,101ad18 <__alt_data_end+0xff01ad18>
 101ad6c:	1100a00c 	andi	r4,r2,640
 101ad70:	01408004 	movi	r5,512
 101ad74:	217fe826 	beq	r4,r5,101ad18 <__alt_data_end+0xff01ad18>
 101ad78:	800b883a 	mov	r5,r16
 101ad7c:	8809883a 	mov	r4,r17
 101ad80:	101d8600 	call	101d860 <__smakebuf_r>
 101ad84:	8080030b 	ldhu	r2,12(r16)
 101ad88:	80c00417 	ldw	r3,16(r16)
 101ad8c:	003fe206 	br	101ad18 <__alt_data_end+0xff01ad18>
 101ad90:	80800517 	ldw	r2,20(r16)
 101ad94:	80000215 	stw	zero,8(r16)
 101ad98:	0085c83a 	sub	r2,zero,r2
 101ad9c:	80800615 	stw	r2,24(r16)
 101ada0:	183fe41e 	bne	r3,zero,101ad34 <__alt_data_end+0xff01ad34>
 101ada4:	80c0030b 	ldhu	r3,12(r16)
 101ada8:	0005883a 	mov	r2,zero
 101adac:	1900200c 	andi	r4,r3,128
 101adb0:	203fe126 	beq	r4,zero,101ad38 <__alt_data_end+0xff01ad38>
 101adb4:	18c01014 	ori	r3,r3,64
 101adb8:	80c0030d 	sth	r3,12(r16)
 101adbc:	00bfffc4 	movi	r2,-1
 101adc0:	003fdd06 	br	101ad38 <__alt_data_end+0xff01ad38>
 101adc4:	101ccbc0 	call	101ccbc <__sinit>
 101adc8:	003fcd06 	br	101ad00 <__alt_data_end+0xff01ad00>
 101adcc:	0005883a 	mov	r2,zero
 101add0:	003fd606 	br	101ad2c <__alt_data_end+0xff01ad2c>
 101add4:	81400c17 	ldw	r5,48(r16)
 101add8:	28000626 	beq	r5,zero,101adf4 <__swsetup_r+0x124>
 101addc:	80801004 	addi	r2,r16,64
 101ade0:	28800326 	beq	r5,r2,101adf0 <__swsetup_r+0x120>
 101ade4:	8809883a 	mov	r4,r17
 101ade8:	101ce300 	call	101ce30 <_free_r>
 101adec:	8100030b 	ldhu	r4,12(r16)
 101adf0:	80000c15 	stw	zero,48(r16)
 101adf4:	80c00417 	ldw	r3,16(r16)
 101adf8:	00bff6c4 	movi	r2,-37
 101adfc:	1108703a 	and	r4,r2,r4
 101ae00:	80000115 	stw	zero,4(r16)
 101ae04:	80c00015 	stw	r3,0(r16)
 101ae08:	003fd506 	br	101ad60 <__alt_data_end+0xff01ad60>
 101ae0c:	00800244 	movi	r2,9
 101ae10:	88800015 	stw	r2,0(r17)
 101ae14:	20801014 	ori	r2,r4,64
 101ae18:	8080030d 	sth	r2,12(r16)
 101ae1c:	00bfffc4 	movi	r2,-1
 101ae20:	003fc506 	br	101ad38 <__alt_data_end+0xff01ad38>

0101ae24 <abort>:
 101ae24:	deffff04 	addi	sp,sp,-4
 101ae28:	01000184 	movi	r4,6
 101ae2c:	dfc00015 	stw	ra,0(sp)
 101ae30:	101fce40 	call	101fce4 <raise>
 101ae34:	01000044 	movi	r4,1
 101ae38:	102671c0 	call	102671c <_exit>

0101ae3c <quorem>:
 101ae3c:	defff704 	addi	sp,sp,-36
 101ae40:	dc800215 	stw	r18,8(sp)
 101ae44:	20800417 	ldw	r2,16(r4)
 101ae48:	2c800417 	ldw	r18,16(r5)
 101ae4c:	dfc00815 	stw	ra,32(sp)
 101ae50:	ddc00715 	stw	r23,28(sp)
 101ae54:	dd800615 	stw	r22,24(sp)
 101ae58:	dd400515 	stw	r21,20(sp)
 101ae5c:	dd000415 	stw	r20,16(sp)
 101ae60:	dcc00315 	stw	r19,12(sp)
 101ae64:	dc400115 	stw	r17,4(sp)
 101ae68:	dc000015 	stw	r16,0(sp)
 101ae6c:	14807116 	blt	r2,r18,101b034 <quorem+0x1f8>
 101ae70:	94bfffc4 	addi	r18,r18,-1
 101ae74:	94ad883a 	add	r22,r18,r18
 101ae78:	b5ad883a 	add	r22,r22,r22
 101ae7c:	2c400504 	addi	r17,r5,20
 101ae80:	8da9883a 	add	r20,r17,r22
 101ae84:	25400504 	addi	r21,r4,20
 101ae88:	282f883a 	mov	r23,r5
 101ae8c:	adad883a 	add	r22,r21,r22
 101ae90:	a1400017 	ldw	r5,0(r20)
 101ae94:	2021883a 	mov	r16,r4
 101ae98:	b1000017 	ldw	r4,0(r22)
 101ae9c:	29400044 	addi	r5,r5,1
 101aea0:	1023e000 	call	1023e00 <__udivsi3>
 101aea4:	1027883a 	mov	r19,r2
 101aea8:	10002c26 	beq	r2,zero,101af5c <quorem+0x120>
 101aeac:	a813883a 	mov	r9,r21
 101aeb0:	880b883a 	mov	r5,r17
 101aeb4:	0009883a 	mov	r4,zero
 101aeb8:	000d883a 	mov	r6,zero
 101aebc:	2a000017 	ldw	r8,0(r5)
 101aec0:	49c00017 	ldw	r7,0(r9)
 101aec4:	29400104 	addi	r5,r5,4
 101aec8:	40bfffcc 	andi	r2,r8,65535
 101aecc:	14c5383a 	mul	r2,r2,r19
 101aed0:	4010d43a 	srli	r8,r8,16
 101aed4:	38ffffcc 	andi	r3,r7,65535
 101aed8:	1105883a 	add	r2,r2,r4
 101aedc:	1008d43a 	srli	r4,r2,16
 101aee0:	44d1383a 	mul	r8,r8,r19
 101aee4:	198d883a 	add	r6,r3,r6
 101aee8:	10ffffcc 	andi	r3,r2,65535
 101aeec:	30c7c83a 	sub	r3,r6,r3
 101aef0:	380ed43a 	srli	r7,r7,16
 101aef4:	4105883a 	add	r2,r8,r4
 101aef8:	180dd43a 	srai	r6,r3,16
 101aefc:	113fffcc 	andi	r4,r2,65535
 101af00:	390fc83a 	sub	r7,r7,r4
 101af04:	398d883a 	add	r6,r7,r6
 101af08:	300e943a 	slli	r7,r6,16
 101af0c:	18ffffcc 	andi	r3,r3,65535
 101af10:	1008d43a 	srli	r4,r2,16
 101af14:	38ceb03a 	or	r7,r7,r3
 101af18:	49c00015 	stw	r7,0(r9)
 101af1c:	300dd43a 	srai	r6,r6,16
 101af20:	4a400104 	addi	r9,r9,4
 101af24:	a17fe52e 	bgeu	r20,r5,101aebc <__alt_data_end+0xff01aebc>
 101af28:	b0800017 	ldw	r2,0(r22)
 101af2c:	10000b1e 	bne	r2,zero,101af5c <quorem+0x120>
 101af30:	b0bfff04 	addi	r2,r22,-4
 101af34:	a880082e 	bgeu	r21,r2,101af58 <quorem+0x11c>
 101af38:	b0ffff17 	ldw	r3,-4(r22)
 101af3c:	18000326 	beq	r3,zero,101af4c <quorem+0x110>
 101af40:	00000506 	br	101af58 <quorem+0x11c>
 101af44:	10c00017 	ldw	r3,0(r2)
 101af48:	1800031e 	bne	r3,zero,101af58 <quorem+0x11c>
 101af4c:	10bfff04 	addi	r2,r2,-4
 101af50:	94bfffc4 	addi	r18,r18,-1
 101af54:	a8bffb36 	bltu	r21,r2,101af44 <__alt_data_end+0xff01af44>
 101af58:	84800415 	stw	r18,16(r16)
 101af5c:	b80b883a 	mov	r5,r23
 101af60:	8009883a 	mov	r4,r16
 101af64:	101ed300 	call	101ed30 <__mcmp>
 101af68:	10002616 	blt	r2,zero,101b004 <quorem+0x1c8>
 101af6c:	9cc00044 	addi	r19,r19,1
 101af70:	a805883a 	mov	r2,r21
 101af74:	000b883a 	mov	r5,zero
 101af78:	11000017 	ldw	r4,0(r2)
 101af7c:	89800017 	ldw	r6,0(r17)
 101af80:	10800104 	addi	r2,r2,4
 101af84:	20ffffcc 	andi	r3,r4,65535
 101af88:	194b883a 	add	r5,r3,r5
 101af8c:	30ffffcc 	andi	r3,r6,65535
 101af90:	28c7c83a 	sub	r3,r5,r3
 101af94:	300cd43a 	srli	r6,r6,16
 101af98:	2008d43a 	srli	r4,r4,16
 101af9c:	180bd43a 	srai	r5,r3,16
 101afa0:	18ffffcc 	andi	r3,r3,65535
 101afa4:	2189c83a 	sub	r4,r4,r6
 101afa8:	2149883a 	add	r4,r4,r5
 101afac:	200c943a 	slli	r6,r4,16
 101afb0:	8c400104 	addi	r17,r17,4
 101afb4:	200bd43a 	srai	r5,r4,16
 101afb8:	30c6b03a 	or	r3,r6,r3
 101afbc:	10ffff15 	stw	r3,-4(r2)
 101afc0:	a47fed2e 	bgeu	r20,r17,101af78 <__alt_data_end+0xff01af78>
 101afc4:	9485883a 	add	r2,r18,r18
 101afc8:	1085883a 	add	r2,r2,r2
 101afcc:	a887883a 	add	r3,r21,r2
 101afd0:	18800017 	ldw	r2,0(r3)
 101afd4:	10000b1e 	bne	r2,zero,101b004 <quorem+0x1c8>
 101afd8:	18bfff04 	addi	r2,r3,-4
 101afdc:	a880082e 	bgeu	r21,r2,101b000 <quorem+0x1c4>
 101afe0:	18ffff17 	ldw	r3,-4(r3)
 101afe4:	18000326 	beq	r3,zero,101aff4 <quorem+0x1b8>
 101afe8:	00000506 	br	101b000 <quorem+0x1c4>
 101afec:	10c00017 	ldw	r3,0(r2)
 101aff0:	1800031e 	bne	r3,zero,101b000 <quorem+0x1c4>
 101aff4:	10bfff04 	addi	r2,r2,-4
 101aff8:	94bfffc4 	addi	r18,r18,-1
 101affc:	a8bffb36 	bltu	r21,r2,101afec <__alt_data_end+0xff01afec>
 101b000:	84800415 	stw	r18,16(r16)
 101b004:	9805883a 	mov	r2,r19
 101b008:	dfc00817 	ldw	ra,32(sp)
 101b00c:	ddc00717 	ldw	r23,28(sp)
 101b010:	dd800617 	ldw	r22,24(sp)
 101b014:	dd400517 	ldw	r21,20(sp)
 101b018:	dd000417 	ldw	r20,16(sp)
 101b01c:	dcc00317 	ldw	r19,12(sp)
 101b020:	dc800217 	ldw	r18,8(sp)
 101b024:	dc400117 	ldw	r17,4(sp)
 101b028:	dc000017 	ldw	r16,0(sp)
 101b02c:	dec00904 	addi	sp,sp,36
 101b030:	f800283a 	ret
 101b034:	0005883a 	mov	r2,zero
 101b038:	003ff306 	br	101b008 <__alt_data_end+0xff01b008>

0101b03c <_dtoa_r>:
 101b03c:	20801017 	ldw	r2,64(r4)
 101b040:	deffde04 	addi	sp,sp,-136
 101b044:	df002015 	stw	fp,128(sp)
 101b048:	dcc01b15 	stw	r19,108(sp)
 101b04c:	dc801a15 	stw	r18,104(sp)
 101b050:	dc401915 	stw	r17,100(sp)
 101b054:	dc001815 	stw	r16,96(sp)
 101b058:	dfc02115 	stw	ra,132(sp)
 101b05c:	ddc01f15 	stw	r23,124(sp)
 101b060:	dd801e15 	stw	r22,120(sp)
 101b064:	dd401d15 	stw	r21,116(sp)
 101b068:	dd001c15 	stw	r20,112(sp)
 101b06c:	d9c00315 	stw	r7,12(sp)
 101b070:	2039883a 	mov	fp,r4
 101b074:	3023883a 	mov	r17,r6
 101b078:	2825883a 	mov	r18,r5
 101b07c:	dc002417 	ldw	r16,144(sp)
 101b080:	3027883a 	mov	r19,r6
 101b084:	10000826 	beq	r2,zero,101b0a8 <_dtoa_r+0x6c>
 101b088:	21801117 	ldw	r6,68(r4)
 101b08c:	00c00044 	movi	r3,1
 101b090:	100b883a 	mov	r5,r2
 101b094:	1986983a 	sll	r3,r3,r6
 101b098:	11800115 	stw	r6,4(r2)
 101b09c:	10c00215 	stw	r3,8(r2)
 101b0a0:	101e5100 	call	101e510 <_Bfree>
 101b0a4:	e0001015 	stw	zero,64(fp)
 101b0a8:	88002e16 	blt	r17,zero,101b164 <_dtoa_r+0x128>
 101b0ac:	80000015 	stw	zero,0(r16)
 101b0b0:	889ffc2c 	andhi	r2,r17,32752
 101b0b4:	00dffc34 	movhi	r3,32752
 101b0b8:	10c01c26 	beq	r2,r3,101b12c <_dtoa_r+0xf0>
 101b0bc:	000d883a 	mov	r6,zero
 101b0c0:	000f883a 	mov	r7,zero
 101b0c4:	9009883a 	mov	r4,r18
 101b0c8:	980b883a 	mov	r5,r19
 101b0cc:	10250500 	call	1025050 <__eqdf2>
 101b0d0:	10002b1e 	bne	r2,zero,101b180 <_dtoa_r+0x144>
 101b0d4:	d9c02317 	ldw	r7,140(sp)
 101b0d8:	00800044 	movi	r2,1
 101b0dc:	38800015 	stw	r2,0(r7)
 101b0e0:	d8802517 	ldw	r2,148(sp)
 101b0e4:	10019e26 	beq	r2,zero,101b760 <_dtoa_r+0x724>
 101b0e8:	d8c02517 	ldw	r3,148(sp)
 101b0ec:	008040f4 	movhi	r2,259
 101b0f0:	10aa8c44 	addi	r2,r2,-21967
 101b0f4:	18800015 	stw	r2,0(r3)
 101b0f8:	10bfffc4 	addi	r2,r2,-1
 101b0fc:	dfc02117 	ldw	ra,132(sp)
 101b100:	df002017 	ldw	fp,128(sp)
 101b104:	ddc01f17 	ldw	r23,124(sp)
 101b108:	dd801e17 	ldw	r22,120(sp)
 101b10c:	dd401d17 	ldw	r21,116(sp)
 101b110:	dd001c17 	ldw	r20,112(sp)
 101b114:	dcc01b17 	ldw	r19,108(sp)
 101b118:	dc801a17 	ldw	r18,104(sp)
 101b11c:	dc401917 	ldw	r17,100(sp)
 101b120:	dc001817 	ldw	r16,96(sp)
 101b124:	dec02204 	addi	sp,sp,136
 101b128:	f800283a 	ret
 101b12c:	d8c02317 	ldw	r3,140(sp)
 101b130:	0089c3c4 	movi	r2,9999
 101b134:	18800015 	stw	r2,0(r3)
 101b138:	90017726 	beq	r18,zero,101b718 <_dtoa_r+0x6dc>
 101b13c:	008040f4 	movhi	r2,259
 101b140:	10aaa004 	addi	r2,r2,-21888
 101b144:	d9002517 	ldw	r4,148(sp)
 101b148:	203fec26 	beq	r4,zero,101b0fc <__alt_data_end+0xff01b0fc>
 101b14c:	10c000c7 	ldb	r3,3(r2)
 101b150:	1801781e 	bne	r3,zero,101b734 <_dtoa_r+0x6f8>
 101b154:	10c000c4 	addi	r3,r2,3
 101b158:	d9802517 	ldw	r6,148(sp)
 101b15c:	30c00015 	stw	r3,0(r6)
 101b160:	003fe606 	br	101b0fc <__alt_data_end+0xff01b0fc>
 101b164:	04e00034 	movhi	r19,32768
 101b168:	9cffffc4 	addi	r19,r19,-1
 101b16c:	00800044 	movi	r2,1
 101b170:	8ce6703a 	and	r19,r17,r19
 101b174:	80800015 	stw	r2,0(r16)
 101b178:	9823883a 	mov	r17,r19
 101b17c:	003fcc06 	br	101b0b0 <__alt_data_end+0xff01b0b0>
 101b180:	d8800204 	addi	r2,sp,8
 101b184:	d8800015 	stw	r2,0(sp)
 101b188:	d9c00104 	addi	r7,sp,4
 101b18c:	900b883a 	mov	r5,r18
 101b190:	980d883a 	mov	r6,r19
 101b194:	e009883a 	mov	r4,fp
 101b198:	8820d53a 	srli	r16,r17,20
 101b19c:	101f0fc0 	call	101f0fc <__d2b>
 101b1a0:	d8800915 	stw	r2,36(sp)
 101b1a4:	8001651e 	bne	r16,zero,101b73c <_dtoa_r+0x700>
 101b1a8:	dd800217 	ldw	r22,8(sp)
 101b1ac:	dc000117 	ldw	r16,4(sp)
 101b1b0:	00800804 	movi	r2,32
 101b1b4:	b421883a 	add	r16,r22,r16
 101b1b8:	80c10c84 	addi	r3,r16,1074
 101b1bc:	10c2d10e 	bge	r2,r3,101bd04 <_dtoa_r+0xcc8>
 101b1c0:	00801004 	movi	r2,64
 101b1c4:	81010484 	addi	r4,r16,1042
 101b1c8:	10c7c83a 	sub	r3,r2,r3
 101b1cc:	9108d83a 	srl	r4,r18,r4
 101b1d0:	88e2983a 	sll	r17,r17,r3
 101b1d4:	2448b03a 	or	r4,r4,r17
 101b1d8:	10264180 	call	1026418 <__floatunsidf>
 101b1dc:	017f8434 	movhi	r5,65040
 101b1e0:	01800044 	movi	r6,1
 101b1e4:	1009883a 	mov	r4,r2
 101b1e8:	194b883a 	add	r5,r3,r5
 101b1ec:	843fffc4 	addi	r16,r16,-1
 101b1f0:	d9801115 	stw	r6,68(sp)
 101b1f4:	000d883a 	mov	r6,zero
 101b1f8:	01cffe34 	movhi	r7,16376
 101b1fc:	10259c00 	call	10259c0 <__subdf3>
 101b200:	0198dbf4 	movhi	r6,25455
 101b204:	01cff4f4 	movhi	r7,16339
 101b208:	3190d844 	addi	r6,r6,17249
 101b20c:	39e1e9c4 	addi	r7,r7,-30809
 101b210:	1009883a 	mov	r4,r2
 101b214:	180b883a 	mov	r5,r3
 101b218:	10252a80 	call	10252a8 <__muldf3>
 101b21c:	01a2d874 	movhi	r6,35681
 101b220:	01cff1f4 	movhi	r7,16327
 101b224:	31b22cc4 	addi	r6,r6,-14157
 101b228:	39e28a04 	addi	r7,r7,-30168
 101b22c:	180b883a 	mov	r5,r3
 101b230:	1009883a 	mov	r4,r2
 101b234:	1023ebc0 	call	1023ebc <__adddf3>
 101b238:	8009883a 	mov	r4,r16
 101b23c:	1029883a 	mov	r20,r2
 101b240:	1823883a 	mov	r17,r3
 101b244:	102633c0 	call	102633c <__floatsidf>
 101b248:	019427f4 	movhi	r6,20639
 101b24c:	01cff4f4 	movhi	r7,16339
 101b250:	319e7ec4 	addi	r6,r6,31227
 101b254:	39d104c4 	addi	r7,r7,17427
 101b258:	1009883a 	mov	r4,r2
 101b25c:	180b883a 	mov	r5,r3
 101b260:	10252a80 	call	10252a8 <__muldf3>
 101b264:	100d883a 	mov	r6,r2
 101b268:	180f883a 	mov	r7,r3
 101b26c:	a009883a 	mov	r4,r20
 101b270:	880b883a 	mov	r5,r17
 101b274:	1023ebc0 	call	1023ebc <__adddf3>
 101b278:	1009883a 	mov	r4,r2
 101b27c:	180b883a 	mov	r5,r3
 101b280:	1029883a 	mov	r20,r2
 101b284:	1823883a 	mov	r17,r3
 101b288:	10262bc0 	call	10262bc <__fixdfsi>
 101b28c:	000d883a 	mov	r6,zero
 101b290:	000f883a 	mov	r7,zero
 101b294:	a009883a 	mov	r4,r20
 101b298:	880b883a 	mov	r5,r17
 101b29c:	d8800515 	stw	r2,20(sp)
 101b2a0:	10251b40 	call	10251b4 <__ledf2>
 101b2a4:	10028716 	blt	r2,zero,101bcc4 <_dtoa_r+0xc88>
 101b2a8:	d8c00517 	ldw	r3,20(sp)
 101b2ac:	00800584 	movi	r2,22
 101b2b0:	10c27536 	bltu	r2,r3,101bc88 <_dtoa_r+0xc4c>
 101b2b4:	180490fa 	slli	r2,r3,3
 101b2b8:	00c040f4 	movhi	r3,259
 101b2bc:	18eabb04 	addi	r3,r3,-21780
 101b2c0:	1885883a 	add	r2,r3,r2
 101b2c4:	11000017 	ldw	r4,0(r2)
 101b2c8:	11400117 	ldw	r5,4(r2)
 101b2cc:	900d883a 	mov	r6,r18
 101b2d0:	980f883a 	mov	r7,r19
 101b2d4:	10250d80 	call	10250d8 <__gedf2>
 101b2d8:	00828d0e 	bge	zero,r2,101bd10 <_dtoa_r+0xcd4>
 101b2dc:	d9000517 	ldw	r4,20(sp)
 101b2e0:	d8000e15 	stw	zero,56(sp)
 101b2e4:	213fffc4 	addi	r4,r4,-1
 101b2e8:	d9000515 	stw	r4,20(sp)
 101b2ec:	b42dc83a 	sub	r22,r22,r16
 101b2f0:	b5bfffc4 	addi	r22,r22,-1
 101b2f4:	b0026f16 	blt	r22,zero,101bcb4 <_dtoa_r+0xc78>
 101b2f8:	d8000815 	stw	zero,32(sp)
 101b2fc:	d9c00517 	ldw	r7,20(sp)
 101b300:	38026416 	blt	r7,zero,101bc94 <_dtoa_r+0xc58>
 101b304:	b1ed883a 	add	r22,r22,r7
 101b308:	d9c00d15 	stw	r7,52(sp)
 101b30c:	d8000a15 	stw	zero,40(sp)
 101b310:	d9800317 	ldw	r6,12(sp)
 101b314:	00800244 	movi	r2,9
 101b318:	11811436 	bltu	r2,r6,101b76c <_dtoa_r+0x730>
 101b31c:	00800144 	movi	r2,5
 101b320:	1184e10e 	bge	r2,r6,101c6a8 <_dtoa_r+0x166c>
 101b324:	31bfff04 	addi	r6,r6,-4
 101b328:	d9800315 	stw	r6,12(sp)
 101b32c:	0023883a 	mov	r17,zero
 101b330:	d9800317 	ldw	r6,12(sp)
 101b334:	008000c4 	movi	r2,3
 101b338:	30836726 	beq	r6,r2,101c0d8 <_dtoa_r+0x109c>
 101b33c:	1183410e 	bge	r2,r6,101c044 <_dtoa_r+0x1008>
 101b340:	d9c00317 	ldw	r7,12(sp)
 101b344:	00800104 	movi	r2,4
 101b348:	38827c26 	beq	r7,r2,101bd3c <_dtoa_r+0xd00>
 101b34c:	00800144 	movi	r2,5
 101b350:	3884c41e 	bne	r7,r2,101c664 <_dtoa_r+0x1628>
 101b354:	00800044 	movi	r2,1
 101b358:	d8800b15 	stw	r2,44(sp)
 101b35c:	d8c00517 	ldw	r3,20(sp)
 101b360:	d9002217 	ldw	r4,136(sp)
 101b364:	1907883a 	add	r3,r3,r4
 101b368:	19800044 	addi	r6,r3,1
 101b36c:	d8c00c15 	stw	r3,48(sp)
 101b370:	d9800615 	stw	r6,24(sp)
 101b374:	0183a40e 	bge	zero,r6,101c208 <_dtoa_r+0x11cc>
 101b378:	d9800617 	ldw	r6,24(sp)
 101b37c:	3021883a 	mov	r16,r6
 101b380:	e0001115 	stw	zero,68(fp)
 101b384:	008005c4 	movi	r2,23
 101b388:	1184c92e 	bgeu	r2,r6,101c6b0 <_dtoa_r+0x1674>
 101b38c:	00c00044 	movi	r3,1
 101b390:	00800104 	movi	r2,4
 101b394:	1085883a 	add	r2,r2,r2
 101b398:	11000504 	addi	r4,r2,20
 101b39c:	180b883a 	mov	r5,r3
 101b3a0:	18c00044 	addi	r3,r3,1
 101b3a4:	313ffb2e 	bgeu	r6,r4,101b394 <__alt_data_end+0xff01b394>
 101b3a8:	e1401115 	stw	r5,68(fp)
 101b3ac:	e009883a 	mov	r4,fp
 101b3b0:	101e4680 	call	101e468 <_Balloc>
 101b3b4:	d8800715 	stw	r2,28(sp)
 101b3b8:	e0801015 	stw	r2,64(fp)
 101b3bc:	00800384 	movi	r2,14
 101b3c0:	1400f736 	bltu	r2,r16,101b7a0 <_dtoa_r+0x764>
 101b3c4:	8800f626 	beq	r17,zero,101b7a0 <_dtoa_r+0x764>
 101b3c8:	d9c00517 	ldw	r7,20(sp)
 101b3cc:	01c39a0e 	bge	zero,r7,101c238 <_dtoa_r+0x11fc>
 101b3d0:	388003cc 	andi	r2,r7,15
 101b3d4:	100490fa 	slli	r2,r2,3
 101b3d8:	382bd13a 	srai	r21,r7,4
 101b3dc:	00c040f4 	movhi	r3,259
 101b3e0:	18eabb04 	addi	r3,r3,-21780
 101b3e4:	1885883a 	add	r2,r3,r2
 101b3e8:	a8c0040c 	andi	r3,r21,16
 101b3ec:	12400017 	ldw	r9,0(r2)
 101b3f0:	12000117 	ldw	r8,4(r2)
 101b3f4:	18037926 	beq	r3,zero,101c1dc <_dtoa_r+0x11a0>
 101b3f8:	008040f4 	movhi	r2,259
 101b3fc:	10aab104 	addi	r2,r2,-21820
 101b400:	11800817 	ldw	r6,32(r2)
 101b404:	11c00917 	ldw	r7,36(r2)
 101b408:	9009883a 	mov	r4,r18
 101b40c:	980b883a 	mov	r5,r19
 101b410:	da001715 	stw	r8,92(sp)
 101b414:	da401615 	stw	r9,88(sp)
 101b418:	10247680 	call	1024768 <__divdf3>
 101b41c:	da001717 	ldw	r8,92(sp)
 101b420:	da401617 	ldw	r9,88(sp)
 101b424:	ad4003cc 	andi	r21,r21,15
 101b428:	040000c4 	movi	r16,3
 101b42c:	1023883a 	mov	r17,r2
 101b430:	1829883a 	mov	r20,r3
 101b434:	a8001126 	beq	r21,zero,101b47c <_dtoa_r+0x440>
 101b438:	05c040f4 	movhi	r23,259
 101b43c:	bdeab104 	addi	r23,r23,-21820
 101b440:	4805883a 	mov	r2,r9
 101b444:	4007883a 	mov	r3,r8
 101b448:	a980004c 	andi	r6,r21,1
 101b44c:	1009883a 	mov	r4,r2
 101b450:	a82bd07a 	srai	r21,r21,1
 101b454:	180b883a 	mov	r5,r3
 101b458:	30000426 	beq	r6,zero,101b46c <_dtoa_r+0x430>
 101b45c:	b9800017 	ldw	r6,0(r23)
 101b460:	b9c00117 	ldw	r7,4(r23)
 101b464:	84000044 	addi	r16,r16,1
 101b468:	10252a80 	call	10252a8 <__muldf3>
 101b46c:	bdc00204 	addi	r23,r23,8
 101b470:	a83ff51e 	bne	r21,zero,101b448 <__alt_data_end+0xff01b448>
 101b474:	1013883a 	mov	r9,r2
 101b478:	1811883a 	mov	r8,r3
 101b47c:	480d883a 	mov	r6,r9
 101b480:	400f883a 	mov	r7,r8
 101b484:	8809883a 	mov	r4,r17
 101b488:	a00b883a 	mov	r5,r20
 101b48c:	10247680 	call	1024768 <__divdf3>
 101b490:	d8800f15 	stw	r2,60(sp)
 101b494:	d8c01015 	stw	r3,64(sp)
 101b498:	d8c00e17 	ldw	r3,56(sp)
 101b49c:	18000626 	beq	r3,zero,101b4b8 <_dtoa_r+0x47c>
 101b4a0:	d9000f17 	ldw	r4,60(sp)
 101b4a4:	d9401017 	ldw	r5,64(sp)
 101b4a8:	000d883a 	mov	r6,zero
 101b4ac:	01cffc34 	movhi	r7,16368
 101b4b0:	10251b40 	call	10251b4 <__ledf2>
 101b4b4:	10040b16 	blt	r2,zero,101c4e4 <_dtoa_r+0x14a8>
 101b4b8:	8009883a 	mov	r4,r16
 101b4bc:	102633c0 	call	102633c <__floatsidf>
 101b4c0:	d9800f17 	ldw	r6,60(sp)
 101b4c4:	d9c01017 	ldw	r7,64(sp)
 101b4c8:	1009883a 	mov	r4,r2
 101b4cc:	180b883a 	mov	r5,r3
 101b4d0:	10252a80 	call	10252a8 <__muldf3>
 101b4d4:	000d883a 	mov	r6,zero
 101b4d8:	01d00734 	movhi	r7,16412
 101b4dc:	1009883a 	mov	r4,r2
 101b4e0:	180b883a 	mov	r5,r3
 101b4e4:	1023ebc0 	call	1023ebc <__adddf3>
 101b4e8:	1021883a 	mov	r16,r2
 101b4ec:	d8800617 	ldw	r2,24(sp)
 101b4f0:	047f3034 	movhi	r17,64704
 101b4f4:	1c63883a 	add	r17,r3,r17
 101b4f8:	10031826 	beq	r2,zero,101c15c <_dtoa_r+0x1120>
 101b4fc:	d8c00517 	ldw	r3,20(sp)
 101b500:	db000617 	ldw	r12,24(sp)
 101b504:	d8c01315 	stw	r3,76(sp)
 101b508:	d9000b17 	ldw	r4,44(sp)
 101b50c:	20038f26 	beq	r4,zero,101c34c <_dtoa_r+0x1310>
 101b510:	60bfffc4 	addi	r2,r12,-1
 101b514:	100490fa 	slli	r2,r2,3
 101b518:	00c040f4 	movhi	r3,259
 101b51c:	18eabb04 	addi	r3,r3,-21780
 101b520:	1885883a 	add	r2,r3,r2
 101b524:	11800017 	ldw	r6,0(r2)
 101b528:	11c00117 	ldw	r7,4(r2)
 101b52c:	d8800717 	ldw	r2,28(sp)
 101b530:	0009883a 	mov	r4,zero
 101b534:	014ff834 	movhi	r5,16352
 101b538:	db001615 	stw	r12,88(sp)
 101b53c:	15c00044 	addi	r23,r2,1
 101b540:	10247680 	call	1024768 <__divdf3>
 101b544:	800d883a 	mov	r6,r16
 101b548:	880f883a 	mov	r7,r17
 101b54c:	1009883a 	mov	r4,r2
 101b550:	180b883a 	mov	r5,r3
 101b554:	10259c00 	call	10259c0 <__subdf3>
 101b558:	d9401017 	ldw	r5,64(sp)
 101b55c:	d9000f17 	ldw	r4,60(sp)
 101b560:	102b883a 	mov	r21,r2
 101b564:	d8c01215 	stw	r3,72(sp)
 101b568:	10262bc0 	call	10262bc <__fixdfsi>
 101b56c:	1009883a 	mov	r4,r2
 101b570:	1029883a 	mov	r20,r2
 101b574:	102633c0 	call	102633c <__floatsidf>
 101b578:	d9000f17 	ldw	r4,60(sp)
 101b57c:	d9401017 	ldw	r5,64(sp)
 101b580:	100d883a 	mov	r6,r2
 101b584:	180f883a 	mov	r7,r3
 101b588:	10259c00 	call	10259c0 <__subdf3>
 101b58c:	1823883a 	mov	r17,r3
 101b590:	d8c00717 	ldw	r3,28(sp)
 101b594:	d9401217 	ldw	r5,72(sp)
 101b598:	a2000c04 	addi	r8,r20,48
 101b59c:	1021883a 	mov	r16,r2
 101b5a0:	1a000005 	stb	r8,0(r3)
 101b5a4:	800d883a 	mov	r6,r16
 101b5a8:	880f883a 	mov	r7,r17
 101b5ac:	a809883a 	mov	r4,r21
 101b5b0:	4029883a 	mov	r20,r8
 101b5b4:	10250d80 	call	10250d8 <__gedf2>
 101b5b8:	00841d16 	blt	zero,r2,101c630 <_dtoa_r+0x15f4>
 101b5bc:	800d883a 	mov	r6,r16
 101b5c0:	880f883a 	mov	r7,r17
 101b5c4:	0009883a 	mov	r4,zero
 101b5c8:	014ffc34 	movhi	r5,16368
 101b5cc:	10259c00 	call	10259c0 <__subdf3>
 101b5d0:	d9401217 	ldw	r5,72(sp)
 101b5d4:	100d883a 	mov	r6,r2
 101b5d8:	180f883a 	mov	r7,r3
 101b5dc:	a809883a 	mov	r4,r21
 101b5e0:	10250d80 	call	10250d8 <__gedf2>
 101b5e4:	db001617 	ldw	r12,88(sp)
 101b5e8:	00840e16 	blt	zero,r2,101c624 <_dtoa_r+0x15e8>
 101b5ec:	00800044 	movi	r2,1
 101b5f0:	13006b0e 	bge	r2,r12,101b7a0 <_dtoa_r+0x764>
 101b5f4:	d9000717 	ldw	r4,28(sp)
 101b5f8:	dd800f15 	stw	r22,60(sp)
 101b5fc:	dcc01015 	stw	r19,64(sp)
 101b600:	2319883a 	add	r12,r4,r12
 101b604:	dcc01217 	ldw	r19,72(sp)
 101b608:	602d883a 	mov	r22,r12
 101b60c:	dc801215 	stw	r18,72(sp)
 101b610:	b825883a 	mov	r18,r23
 101b614:	00000906 	br	101b63c <_dtoa_r+0x600>
 101b618:	10259c00 	call	10259c0 <__subdf3>
 101b61c:	a80d883a 	mov	r6,r21
 101b620:	980f883a 	mov	r7,r19
 101b624:	1009883a 	mov	r4,r2
 101b628:	180b883a 	mov	r5,r3
 101b62c:	10251b40 	call	10251b4 <__ledf2>
 101b630:	1003e816 	blt	r2,zero,101c5d4 <_dtoa_r+0x1598>
 101b634:	b825883a 	mov	r18,r23
 101b638:	bd83e926 	beq	r23,r22,101c5e0 <_dtoa_r+0x15a4>
 101b63c:	a809883a 	mov	r4,r21
 101b640:	980b883a 	mov	r5,r19
 101b644:	000d883a 	mov	r6,zero
 101b648:	01d00934 	movhi	r7,16420
 101b64c:	10252a80 	call	10252a8 <__muldf3>
 101b650:	000d883a 	mov	r6,zero
 101b654:	01d00934 	movhi	r7,16420
 101b658:	8009883a 	mov	r4,r16
 101b65c:	880b883a 	mov	r5,r17
 101b660:	102b883a 	mov	r21,r2
 101b664:	1827883a 	mov	r19,r3
 101b668:	10252a80 	call	10252a8 <__muldf3>
 101b66c:	180b883a 	mov	r5,r3
 101b670:	1009883a 	mov	r4,r2
 101b674:	1821883a 	mov	r16,r3
 101b678:	1023883a 	mov	r17,r2
 101b67c:	10262bc0 	call	10262bc <__fixdfsi>
 101b680:	1009883a 	mov	r4,r2
 101b684:	1029883a 	mov	r20,r2
 101b688:	102633c0 	call	102633c <__floatsidf>
 101b68c:	8809883a 	mov	r4,r17
 101b690:	800b883a 	mov	r5,r16
 101b694:	100d883a 	mov	r6,r2
 101b698:	180f883a 	mov	r7,r3
 101b69c:	10259c00 	call	10259c0 <__subdf3>
 101b6a0:	a5000c04 	addi	r20,r20,48
 101b6a4:	a80d883a 	mov	r6,r21
 101b6a8:	980f883a 	mov	r7,r19
 101b6ac:	1009883a 	mov	r4,r2
 101b6b0:	180b883a 	mov	r5,r3
 101b6b4:	95000005 	stb	r20,0(r18)
 101b6b8:	1021883a 	mov	r16,r2
 101b6bc:	1823883a 	mov	r17,r3
 101b6c0:	10251b40 	call	10251b4 <__ledf2>
 101b6c4:	bdc00044 	addi	r23,r23,1
 101b6c8:	800d883a 	mov	r6,r16
 101b6cc:	880f883a 	mov	r7,r17
 101b6d0:	0009883a 	mov	r4,zero
 101b6d4:	014ffc34 	movhi	r5,16368
 101b6d8:	103fcf0e 	bge	r2,zero,101b618 <__alt_data_end+0xff01b618>
 101b6dc:	d8c01317 	ldw	r3,76(sp)
 101b6e0:	d8c00515 	stw	r3,20(sp)
 101b6e4:	d9400917 	ldw	r5,36(sp)
 101b6e8:	e009883a 	mov	r4,fp
 101b6ec:	101e5100 	call	101e510 <_Bfree>
 101b6f0:	d9000517 	ldw	r4,20(sp)
 101b6f4:	d9802317 	ldw	r6,140(sp)
 101b6f8:	d9c02517 	ldw	r7,148(sp)
 101b6fc:	b8000005 	stb	zero,0(r23)
 101b700:	20800044 	addi	r2,r4,1
 101b704:	30800015 	stw	r2,0(r6)
 101b708:	3802aa26 	beq	r7,zero,101c1b4 <_dtoa_r+0x1178>
 101b70c:	3dc00015 	stw	r23,0(r7)
 101b710:	d8800717 	ldw	r2,28(sp)
 101b714:	003e7906 	br	101b0fc <__alt_data_end+0xff01b0fc>
 101b718:	00800434 	movhi	r2,16
 101b71c:	10bfffc4 	addi	r2,r2,-1
 101b720:	88a2703a 	and	r17,r17,r2
 101b724:	883e851e 	bne	r17,zero,101b13c <__alt_data_end+0xff01b13c>
 101b728:	008040f4 	movhi	r2,259
 101b72c:	10aa9d04 	addi	r2,r2,-21900
 101b730:	003e8406 	br	101b144 <__alt_data_end+0xff01b144>
 101b734:	10c00204 	addi	r3,r2,8
 101b738:	003e8706 	br	101b158 <__alt_data_end+0xff01b158>
 101b73c:	01400434 	movhi	r5,16
 101b740:	297fffc4 	addi	r5,r5,-1
 101b744:	994a703a 	and	r5,r19,r5
 101b748:	9009883a 	mov	r4,r18
 101b74c:	843f0044 	addi	r16,r16,-1023
 101b750:	294ffc34 	orhi	r5,r5,16368
 101b754:	dd800217 	ldw	r22,8(sp)
 101b758:	d8001115 	stw	zero,68(sp)
 101b75c:	003ea506 	br	101b1f4 <__alt_data_end+0xff01b1f4>
 101b760:	008040f4 	movhi	r2,259
 101b764:	10aa8c04 	addi	r2,r2,-21968
 101b768:	003e6406 	br	101b0fc <__alt_data_end+0xff01b0fc>
 101b76c:	e0001115 	stw	zero,68(fp)
 101b770:	000b883a 	mov	r5,zero
 101b774:	e009883a 	mov	r4,fp
 101b778:	101e4680 	call	101e468 <_Balloc>
 101b77c:	01bfffc4 	movi	r6,-1
 101b780:	01c00044 	movi	r7,1
 101b784:	d8800715 	stw	r2,28(sp)
 101b788:	d9800c15 	stw	r6,48(sp)
 101b78c:	e0801015 	stw	r2,64(fp)
 101b790:	d8000315 	stw	zero,12(sp)
 101b794:	d9c00b15 	stw	r7,44(sp)
 101b798:	d9800615 	stw	r6,24(sp)
 101b79c:	d8002215 	stw	zero,136(sp)
 101b7a0:	d8800117 	ldw	r2,4(sp)
 101b7a4:	10008916 	blt	r2,zero,101b9cc <_dtoa_r+0x990>
 101b7a8:	d9000517 	ldw	r4,20(sp)
 101b7ac:	00c00384 	movi	r3,14
 101b7b0:	19008616 	blt	r3,r4,101b9cc <_dtoa_r+0x990>
 101b7b4:	200490fa 	slli	r2,r4,3
 101b7b8:	00c040f4 	movhi	r3,259
 101b7bc:	d9802217 	ldw	r6,136(sp)
 101b7c0:	18eabb04 	addi	r3,r3,-21780
 101b7c4:	1885883a 	add	r2,r3,r2
 101b7c8:	14000017 	ldw	r16,0(r2)
 101b7cc:	14400117 	ldw	r17,4(r2)
 101b7d0:	30016316 	blt	r6,zero,101bd60 <_dtoa_r+0xd24>
 101b7d4:	800d883a 	mov	r6,r16
 101b7d8:	880f883a 	mov	r7,r17
 101b7dc:	9009883a 	mov	r4,r18
 101b7e0:	980b883a 	mov	r5,r19
 101b7e4:	10247680 	call	1024768 <__divdf3>
 101b7e8:	180b883a 	mov	r5,r3
 101b7ec:	1009883a 	mov	r4,r2
 101b7f0:	10262bc0 	call	10262bc <__fixdfsi>
 101b7f4:	1009883a 	mov	r4,r2
 101b7f8:	102b883a 	mov	r21,r2
 101b7fc:	102633c0 	call	102633c <__floatsidf>
 101b800:	800d883a 	mov	r6,r16
 101b804:	880f883a 	mov	r7,r17
 101b808:	1009883a 	mov	r4,r2
 101b80c:	180b883a 	mov	r5,r3
 101b810:	10252a80 	call	10252a8 <__muldf3>
 101b814:	100d883a 	mov	r6,r2
 101b818:	180f883a 	mov	r7,r3
 101b81c:	9009883a 	mov	r4,r18
 101b820:	980b883a 	mov	r5,r19
 101b824:	10259c00 	call	10259c0 <__subdf3>
 101b828:	d9c00717 	ldw	r7,28(sp)
 101b82c:	1009883a 	mov	r4,r2
 101b830:	a8800c04 	addi	r2,r21,48
 101b834:	38800005 	stb	r2,0(r7)
 101b838:	3dc00044 	addi	r23,r7,1
 101b83c:	d9c00617 	ldw	r7,24(sp)
 101b840:	01800044 	movi	r6,1
 101b844:	180b883a 	mov	r5,r3
 101b848:	2005883a 	mov	r2,r4
 101b84c:	39803826 	beq	r7,r6,101b930 <_dtoa_r+0x8f4>
 101b850:	000d883a 	mov	r6,zero
 101b854:	01d00934 	movhi	r7,16420
 101b858:	10252a80 	call	10252a8 <__muldf3>
 101b85c:	000d883a 	mov	r6,zero
 101b860:	000f883a 	mov	r7,zero
 101b864:	1009883a 	mov	r4,r2
 101b868:	180b883a 	mov	r5,r3
 101b86c:	1025883a 	mov	r18,r2
 101b870:	1827883a 	mov	r19,r3
 101b874:	10250500 	call	1025050 <__eqdf2>
 101b878:	103f9a26 	beq	r2,zero,101b6e4 <__alt_data_end+0xff01b6e4>
 101b87c:	d9c00617 	ldw	r7,24(sp)
 101b880:	d8c00717 	ldw	r3,28(sp)
 101b884:	b829883a 	mov	r20,r23
 101b888:	38bfffc4 	addi	r2,r7,-1
 101b88c:	18ad883a 	add	r22,r3,r2
 101b890:	00000a06 	br	101b8bc <_dtoa_r+0x880>
 101b894:	10252a80 	call	10252a8 <__muldf3>
 101b898:	000d883a 	mov	r6,zero
 101b89c:	000f883a 	mov	r7,zero
 101b8a0:	1009883a 	mov	r4,r2
 101b8a4:	180b883a 	mov	r5,r3
 101b8a8:	1025883a 	mov	r18,r2
 101b8ac:	1827883a 	mov	r19,r3
 101b8b0:	b829883a 	mov	r20,r23
 101b8b4:	10250500 	call	1025050 <__eqdf2>
 101b8b8:	103f8a26 	beq	r2,zero,101b6e4 <__alt_data_end+0xff01b6e4>
 101b8bc:	800d883a 	mov	r6,r16
 101b8c0:	880f883a 	mov	r7,r17
 101b8c4:	9009883a 	mov	r4,r18
 101b8c8:	980b883a 	mov	r5,r19
 101b8cc:	10247680 	call	1024768 <__divdf3>
 101b8d0:	180b883a 	mov	r5,r3
 101b8d4:	1009883a 	mov	r4,r2
 101b8d8:	10262bc0 	call	10262bc <__fixdfsi>
 101b8dc:	1009883a 	mov	r4,r2
 101b8e0:	102b883a 	mov	r21,r2
 101b8e4:	102633c0 	call	102633c <__floatsidf>
 101b8e8:	800d883a 	mov	r6,r16
 101b8ec:	880f883a 	mov	r7,r17
 101b8f0:	1009883a 	mov	r4,r2
 101b8f4:	180b883a 	mov	r5,r3
 101b8f8:	10252a80 	call	10252a8 <__muldf3>
 101b8fc:	100d883a 	mov	r6,r2
 101b900:	180f883a 	mov	r7,r3
 101b904:	9009883a 	mov	r4,r18
 101b908:	980b883a 	mov	r5,r19
 101b90c:	10259c00 	call	10259c0 <__subdf3>
 101b910:	aa000c04 	addi	r8,r21,48
 101b914:	a2000005 	stb	r8,0(r20)
 101b918:	000d883a 	mov	r6,zero
 101b91c:	01d00934 	movhi	r7,16420
 101b920:	1009883a 	mov	r4,r2
 101b924:	180b883a 	mov	r5,r3
 101b928:	a5c00044 	addi	r23,r20,1
 101b92c:	b53fd91e 	bne	r22,r20,101b894 <__alt_data_end+0xff01b894>
 101b930:	100d883a 	mov	r6,r2
 101b934:	180f883a 	mov	r7,r3
 101b938:	1009883a 	mov	r4,r2
 101b93c:	180b883a 	mov	r5,r3
 101b940:	1023ebc0 	call	1023ebc <__adddf3>
 101b944:	100d883a 	mov	r6,r2
 101b948:	180f883a 	mov	r7,r3
 101b94c:	8009883a 	mov	r4,r16
 101b950:	880b883a 	mov	r5,r17
 101b954:	1027883a 	mov	r19,r2
 101b958:	1825883a 	mov	r18,r3
 101b95c:	10251b40 	call	10251b4 <__ledf2>
 101b960:	10000816 	blt	r2,zero,101b984 <_dtoa_r+0x948>
 101b964:	980d883a 	mov	r6,r19
 101b968:	900f883a 	mov	r7,r18
 101b96c:	8009883a 	mov	r4,r16
 101b970:	880b883a 	mov	r5,r17
 101b974:	10250500 	call	1025050 <__eqdf2>
 101b978:	103f5a1e 	bne	r2,zero,101b6e4 <__alt_data_end+0xff01b6e4>
 101b97c:	ad40004c 	andi	r21,r21,1
 101b980:	a83f5826 	beq	r21,zero,101b6e4 <__alt_data_end+0xff01b6e4>
 101b984:	bd3fffc3 	ldbu	r20,-1(r23)
 101b988:	b8bfffc4 	addi	r2,r23,-1
 101b98c:	1007883a 	mov	r3,r2
 101b990:	01400e44 	movi	r5,57
 101b994:	d9800717 	ldw	r6,28(sp)
 101b998:	00000506 	br	101b9b0 <_dtoa_r+0x974>
 101b99c:	18ffffc4 	addi	r3,r3,-1
 101b9a0:	11824726 	beq	r2,r6,101c2c0 <_dtoa_r+0x1284>
 101b9a4:	1d000003 	ldbu	r20,0(r3)
 101b9a8:	102f883a 	mov	r23,r2
 101b9ac:	10bfffc4 	addi	r2,r2,-1
 101b9b0:	a1003fcc 	andi	r4,r20,255
 101b9b4:	2100201c 	xori	r4,r4,128
 101b9b8:	213fe004 	addi	r4,r4,-128
 101b9bc:	217ff726 	beq	r4,r5,101b99c <__alt_data_end+0xff01b99c>
 101b9c0:	a2000044 	addi	r8,r20,1
 101b9c4:	12000005 	stb	r8,0(r2)
 101b9c8:	003f4606 	br	101b6e4 <__alt_data_end+0xff01b6e4>
 101b9cc:	d9000b17 	ldw	r4,44(sp)
 101b9d0:	2000c826 	beq	r4,zero,101bcf4 <_dtoa_r+0xcb8>
 101b9d4:	d9800317 	ldw	r6,12(sp)
 101b9d8:	00c00044 	movi	r3,1
 101b9dc:	1980f90e 	bge	r3,r6,101bdc4 <_dtoa_r+0xd88>
 101b9e0:	d8800617 	ldw	r2,24(sp)
 101b9e4:	d8c00a17 	ldw	r3,40(sp)
 101b9e8:	157fffc4 	addi	r21,r2,-1
 101b9ec:	1d41f316 	blt	r3,r21,101c1bc <_dtoa_r+0x1180>
 101b9f0:	1d6bc83a 	sub	r21,r3,r21
 101b9f4:	d9c00617 	ldw	r7,24(sp)
 101b9f8:	3802aa16 	blt	r7,zero,101c4a4 <_dtoa_r+0x1468>
 101b9fc:	dd000817 	ldw	r20,32(sp)
 101ba00:	d8800617 	ldw	r2,24(sp)
 101ba04:	d8c00817 	ldw	r3,32(sp)
 101ba08:	01400044 	movi	r5,1
 101ba0c:	e009883a 	mov	r4,fp
 101ba10:	1887883a 	add	r3,r3,r2
 101ba14:	d8c00815 	stw	r3,32(sp)
 101ba18:	b0ad883a 	add	r22,r22,r2
 101ba1c:	101e8740 	call	101e874 <__i2b>
 101ba20:	1023883a 	mov	r17,r2
 101ba24:	a0000826 	beq	r20,zero,101ba48 <_dtoa_r+0xa0c>
 101ba28:	0580070e 	bge	zero,r22,101ba48 <_dtoa_r+0xa0c>
 101ba2c:	a005883a 	mov	r2,r20
 101ba30:	b500b916 	blt	r22,r20,101bd18 <_dtoa_r+0xcdc>
 101ba34:	d9000817 	ldw	r4,32(sp)
 101ba38:	a0a9c83a 	sub	r20,r20,r2
 101ba3c:	b0adc83a 	sub	r22,r22,r2
 101ba40:	2089c83a 	sub	r4,r4,r2
 101ba44:	d9000815 	stw	r4,32(sp)
 101ba48:	d9800a17 	ldw	r6,40(sp)
 101ba4c:	0181810e 	bge	zero,r6,101c054 <_dtoa_r+0x1018>
 101ba50:	d9c00b17 	ldw	r7,44(sp)
 101ba54:	3800b326 	beq	r7,zero,101bd24 <_dtoa_r+0xce8>
 101ba58:	a800b226 	beq	r21,zero,101bd24 <_dtoa_r+0xce8>
 101ba5c:	880b883a 	mov	r5,r17
 101ba60:	a80d883a 	mov	r6,r21
 101ba64:	e009883a 	mov	r4,fp
 101ba68:	101eaa80 	call	101eaa8 <__pow5mult>
 101ba6c:	d9800917 	ldw	r6,36(sp)
 101ba70:	100b883a 	mov	r5,r2
 101ba74:	e009883a 	mov	r4,fp
 101ba78:	1023883a 	mov	r17,r2
 101ba7c:	101e8b00 	call	101e8b0 <__multiply>
 101ba80:	1021883a 	mov	r16,r2
 101ba84:	d8800a17 	ldw	r2,40(sp)
 101ba88:	d9400917 	ldw	r5,36(sp)
 101ba8c:	e009883a 	mov	r4,fp
 101ba90:	1545c83a 	sub	r2,r2,r21
 101ba94:	d8800a15 	stw	r2,40(sp)
 101ba98:	101e5100 	call	101e510 <_Bfree>
 101ba9c:	d8c00a17 	ldw	r3,40(sp)
 101baa0:	18009f1e 	bne	r3,zero,101bd20 <_dtoa_r+0xce4>
 101baa4:	05c00044 	movi	r23,1
 101baa8:	e009883a 	mov	r4,fp
 101baac:	b80b883a 	mov	r5,r23
 101bab0:	101e8740 	call	101e874 <__i2b>
 101bab4:	d9000d17 	ldw	r4,52(sp)
 101bab8:	102b883a 	mov	r21,r2
 101babc:	2000ce26 	beq	r4,zero,101bdf8 <_dtoa_r+0xdbc>
 101bac0:	200d883a 	mov	r6,r4
 101bac4:	100b883a 	mov	r5,r2
 101bac8:	e009883a 	mov	r4,fp
 101bacc:	101eaa80 	call	101eaa8 <__pow5mult>
 101bad0:	d9800317 	ldw	r6,12(sp)
 101bad4:	102b883a 	mov	r21,r2
 101bad8:	b981810e 	bge	r23,r6,101c0e0 <_dtoa_r+0x10a4>
 101badc:	0027883a 	mov	r19,zero
 101bae0:	a8800417 	ldw	r2,16(r21)
 101bae4:	05c00804 	movi	r23,32
 101bae8:	10800104 	addi	r2,r2,4
 101baec:	1085883a 	add	r2,r2,r2
 101baf0:	1085883a 	add	r2,r2,r2
 101baf4:	a885883a 	add	r2,r21,r2
 101baf8:	11000017 	ldw	r4,0(r2)
 101bafc:	101e75c0 	call	101e75c <__hi0bits>
 101bb00:	b885c83a 	sub	r2,r23,r2
 101bb04:	1585883a 	add	r2,r2,r22
 101bb08:	108007cc 	andi	r2,r2,31
 101bb0c:	1000b326 	beq	r2,zero,101bddc <_dtoa_r+0xda0>
 101bb10:	00c00804 	movi	r3,32
 101bb14:	1887c83a 	sub	r3,r3,r2
 101bb18:	01000104 	movi	r4,4
 101bb1c:	20c2cd0e 	bge	r4,r3,101c654 <_dtoa_r+0x1618>
 101bb20:	00c00704 	movi	r3,28
 101bb24:	1885c83a 	sub	r2,r3,r2
 101bb28:	d8c00817 	ldw	r3,32(sp)
 101bb2c:	a0a9883a 	add	r20,r20,r2
 101bb30:	b0ad883a 	add	r22,r22,r2
 101bb34:	1887883a 	add	r3,r3,r2
 101bb38:	d8c00815 	stw	r3,32(sp)
 101bb3c:	d9800817 	ldw	r6,32(sp)
 101bb40:	0180040e 	bge	zero,r6,101bb54 <_dtoa_r+0xb18>
 101bb44:	800b883a 	mov	r5,r16
 101bb48:	e009883a 	mov	r4,fp
 101bb4c:	101ebe80 	call	101ebe8 <__lshift>
 101bb50:	1021883a 	mov	r16,r2
 101bb54:	0580050e 	bge	zero,r22,101bb6c <_dtoa_r+0xb30>
 101bb58:	a80b883a 	mov	r5,r21
 101bb5c:	b00d883a 	mov	r6,r22
 101bb60:	e009883a 	mov	r4,fp
 101bb64:	101ebe80 	call	101ebe8 <__lshift>
 101bb68:	102b883a 	mov	r21,r2
 101bb6c:	d9c00e17 	ldw	r7,56(sp)
 101bb70:	3801211e 	bne	r7,zero,101bff8 <_dtoa_r+0xfbc>
 101bb74:	d9800617 	ldw	r6,24(sp)
 101bb78:	0181380e 	bge	zero,r6,101c05c <_dtoa_r+0x1020>
 101bb7c:	d8c00b17 	ldw	r3,44(sp)
 101bb80:	1800ab1e 	bne	r3,zero,101be30 <_dtoa_r+0xdf4>
 101bb84:	dc800717 	ldw	r18,28(sp)
 101bb88:	dcc00617 	ldw	r19,24(sp)
 101bb8c:	9029883a 	mov	r20,r18
 101bb90:	00000206 	br	101bb9c <_dtoa_r+0xb60>
 101bb94:	101e5380 	call	101e538 <__multadd>
 101bb98:	1021883a 	mov	r16,r2
 101bb9c:	a80b883a 	mov	r5,r21
 101bba0:	8009883a 	mov	r4,r16
 101bba4:	101ae3c0 	call	101ae3c <quorem>
 101bba8:	10800c04 	addi	r2,r2,48
 101bbac:	90800005 	stb	r2,0(r18)
 101bbb0:	94800044 	addi	r18,r18,1
 101bbb4:	9507c83a 	sub	r3,r18,r20
 101bbb8:	000f883a 	mov	r7,zero
 101bbbc:	01800284 	movi	r6,10
 101bbc0:	800b883a 	mov	r5,r16
 101bbc4:	e009883a 	mov	r4,fp
 101bbc8:	1cfff216 	blt	r3,r19,101bb94 <__alt_data_end+0xff01bb94>
 101bbcc:	1011883a 	mov	r8,r2
 101bbd0:	d8800617 	ldw	r2,24(sp)
 101bbd4:	0082370e 	bge	zero,r2,101c4b4 <_dtoa_r+0x1478>
 101bbd8:	d9000717 	ldw	r4,28(sp)
 101bbdc:	0025883a 	mov	r18,zero
 101bbe0:	20af883a 	add	r23,r4,r2
 101bbe4:	01800044 	movi	r6,1
 101bbe8:	800b883a 	mov	r5,r16
 101bbec:	e009883a 	mov	r4,fp
 101bbf0:	da001715 	stw	r8,92(sp)
 101bbf4:	101ebe80 	call	101ebe8 <__lshift>
 101bbf8:	a80b883a 	mov	r5,r21
 101bbfc:	1009883a 	mov	r4,r2
 101bc00:	d8800915 	stw	r2,36(sp)
 101bc04:	101ed300 	call	101ed30 <__mcmp>
 101bc08:	da001717 	ldw	r8,92(sp)
 101bc0c:	0081800e 	bge	zero,r2,101c210 <_dtoa_r+0x11d4>
 101bc10:	b93fffc3 	ldbu	r4,-1(r23)
 101bc14:	b8bfffc4 	addi	r2,r23,-1
 101bc18:	1007883a 	mov	r3,r2
 101bc1c:	01800e44 	movi	r6,57
 101bc20:	d9c00717 	ldw	r7,28(sp)
 101bc24:	00000506 	br	101bc3c <_dtoa_r+0xc00>
 101bc28:	18ffffc4 	addi	r3,r3,-1
 101bc2c:	11c12326 	beq	r2,r7,101c0bc <_dtoa_r+0x1080>
 101bc30:	19000003 	ldbu	r4,0(r3)
 101bc34:	102f883a 	mov	r23,r2
 101bc38:	10bfffc4 	addi	r2,r2,-1
 101bc3c:	21403fcc 	andi	r5,r4,255
 101bc40:	2940201c 	xori	r5,r5,128
 101bc44:	297fe004 	addi	r5,r5,-128
 101bc48:	29bff726 	beq	r5,r6,101bc28 <__alt_data_end+0xff01bc28>
 101bc4c:	21000044 	addi	r4,r4,1
 101bc50:	11000005 	stb	r4,0(r2)
 101bc54:	a80b883a 	mov	r5,r21
 101bc58:	e009883a 	mov	r4,fp
 101bc5c:	101e5100 	call	101e510 <_Bfree>
 101bc60:	883ea026 	beq	r17,zero,101b6e4 <__alt_data_end+0xff01b6e4>
 101bc64:	90000426 	beq	r18,zero,101bc78 <_dtoa_r+0xc3c>
 101bc68:	94400326 	beq	r18,r17,101bc78 <_dtoa_r+0xc3c>
 101bc6c:	900b883a 	mov	r5,r18
 101bc70:	e009883a 	mov	r4,fp
 101bc74:	101e5100 	call	101e510 <_Bfree>
 101bc78:	880b883a 	mov	r5,r17
 101bc7c:	e009883a 	mov	r4,fp
 101bc80:	101e5100 	call	101e510 <_Bfree>
 101bc84:	003e9706 	br	101b6e4 <__alt_data_end+0xff01b6e4>
 101bc88:	01800044 	movi	r6,1
 101bc8c:	d9800e15 	stw	r6,56(sp)
 101bc90:	003d9606 	br	101b2ec <__alt_data_end+0xff01b2ec>
 101bc94:	d8800817 	ldw	r2,32(sp)
 101bc98:	d8c00517 	ldw	r3,20(sp)
 101bc9c:	d8000d15 	stw	zero,52(sp)
 101bca0:	10c5c83a 	sub	r2,r2,r3
 101bca4:	00c9c83a 	sub	r4,zero,r3
 101bca8:	d8800815 	stw	r2,32(sp)
 101bcac:	d9000a15 	stw	r4,40(sp)
 101bcb0:	003d9706 	br	101b310 <__alt_data_end+0xff01b310>
 101bcb4:	05adc83a 	sub	r22,zero,r22
 101bcb8:	dd800815 	stw	r22,32(sp)
 101bcbc:	002d883a 	mov	r22,zero
 101bcc0:	003d8e06 	br	101b2fc <__alt_data_end+0xff01b2fc>
 101bcc4:	d9000517 	ldw	r4,20(sp)
 101bcc8:	102633c0 	call	102633c <__floatsidf>
 101bccc:	100d883a 	mov	r6,r2
 101bcd0:	180f883a 	mov	r7,r3
 101bcd4:	a009883a 	mov	r4,r20
 101bcd8:	880b883a 	mov	r5,r17
 101bcdc:	10250500 	call	1025050 <__eqdf2>
 101bce0:	103d7126 	beq	r2,zero,101b2a8 <__alt_data_end+0xff01b2a8>
 101bce4:	d9c00517 	ldw	r7,20(sp)
 101bce8:	39ffffc4 	addi	r7,r7,-1
 101bcec:	d9c00515 	stw	r7,20(sp)
 101bcf0:	003d6d06 	br	101b2a8 <__alt_data_end+0xff01b2a8>
 101bcf4:	dd400a17 	ldw	r21,40(sp)
 101bcf8:	dd000817 	ldw	r20,32(sp)
 101bcfc:	0023883a 	mov	r17,zero
 101bd00:	003f4806 	br	101ba24 <__alt_data_end+0xff01ba24>
 101bd04:	10e3c83a 	sub	r17,r2,r3
 101bd08:	9448983a 	sll	r4,r18,r17
 101bd0c:	003d3206 	br	101b1d8 <__alt_data_end+0xff01b1d8>
 101bd10:	d8000e15 	stw	zero,56(sp)
 101bd14:	003d7506 	br	101b2ec <__alt_data_end+0xff01b2ec>
 101bd18:	b005883a 	mov	r2,r22
 101bd1c:	003f4506 	br	101ba34 <__alt_data_end+0xff01ba34>
 101bd20:	dc000915 	stw	r16,36(sp)
 101bd24:	d9800a17 	ldw	r6,40(sp)
 101bd28:	d9400917 	ldw	r5,36(sp)
 101bd2c:	e009883a 	mov	r4,fp
 101bd30:	101eaa80 	call	101eaa8 <__pow5mult>
 101bd34:	1021883a 	mov	r16,r2
 101bd38:	003f5a06 	br	101baa4 <__alt_data_end+0xff01baa4>
 101bd3c:	01c00044 	movi	r7,1
 101bd40:	d9c00b15 	stw	r7,44(sp)
 101bd44:	d8802217 	ldw	r2,136(sp)
 101bd48:	0081280e 	bge	zero,r2,101c1ec <_dtoa_r+0x11b0>
 101bd4c:	100d883a 	mov	r6,r2
 101bd50:	1021883a 	mov	r16,r2
 101bd54:	d8800c15 	stw	r2,48(sp)
 101bd58:	d8800615 	stw	r2,24(sp)
 101bd5c:	003d8806 	br	101b380 <__alt_data_end+0xff01b380>
 101bd60:	d8800617 	ldw	r2,24(sp)
 101bd64:	00be9b16 	blt	zero,r2,101b7d4 <__alt_data_end+0xff01b7d4>
 101bd68:	10010f1e 	bne	r2,zero,101c1a8 <_dtoa_r+0x116c>
 101bd6c:	880b883a 	mov	r5,r17
 101bd70:	000d883a 	mov	r6,zero
 101bd74:	01d00534 	movhi	r7,16404
 101bd78:	8009883a 	mov	r4,r16
 101bd7c:	10252a80 	call	10252a8 <__muldf3>
 101bd80:	900d883a 	mov	r6,r18
 101bd84:	980f883a 	mov	r7,r19
 101bd88:	1009883a 	mov	r4,r2
 101bd8c:	180b883a 	mov	r5,r3
 101bd90:	10250d80 	call	10250d8 <__gedf2>
 101bd94:	002b883a 	mov	r21,zero
 101bd98:	0023883a 	mov	r17,zero
 101bd9c:	1000bf16 	blt	r2,zero,101c09c <_dtoa_r+0x1060>
 101bda0:	d9802217 	ldw	r6,136(sp)
 101bda4:	ddc00717 	ldw	r23,28(sp)
 101bda8:	018c303a 	nor	r6,zero,r6
 101bdac:	d9800515 	stw	r6,20(sp)
 101bdb0:	a80b883a 	mov	r5,r21
 101bdb4:	e009883a 	mov	r4,fp
 101bdb8:	101e5100 	call	101e510 <_Bfree>
 101bdbc:	883e4926 	beq	r17,zero,101b6e4 <__alt_data_end+0xff01b6e4>
 101bdc0:	003fad06 	br	101bc78 <__alt_data_end+0xff01bc78>
 101bdc4:	d9c01117 	ldw	r7,68(sp)
 101bdc8:	3801bc26 	beq	r7,zero,101c4bc <_dtoa_r+0x1480>
 101bdcc:	10810cc4 	addi	r2,r2,1075
 101bdd0:	dd400a17 	ldw	r21,40(sp)
 101bdd4:	dd000817 	ldw	r20,32(sp)
 101bdd8:	003f0a06 	br	101ba04 <__alt_data_end+0xff01ba04>
 101bddc:	00800704 	movi	r2,28
 101bde0:	d9000817 	ldw	r4,32(sp)
 101bde4:	a0a9883a 	add	r20,r20,r2
 101bde8:	b0ad883a 	add	r22,r22,r2
 101bdec:	2089883a 	add	r4,r4,r2
 101bdf0:	d9000815 	stw	r4,32(sp)
 101bdf4:	003f5106 	br	101bb3c <__alt_data_end+0xff01bb3c>
 101bdf8:	d8c00317 	ldw	r3,12(sp)
 101bdfc:	b8c1fc0e 	bge	r23,r3,101c5f0 <_dtoa_r+0x15b4>
 101be00:	0027883a 	mov	r19,zero
 101be04:	b805883a 	mov	r2,r23
 101be08:	003f3e06 	br	101bb04 <__alt_data_end+0xff01bb04>
 101be0c:	880b883a 	mov	r5,r17
 101be10:	e009883a 	mov	r4,fp
 101be14:	000f883a 	mov	r7,zero
 101be18:	01800284 	movi	r6,10
 101be1c:	101e5380 	call	101e538 <__multadd>
 101be20:	d9000c17 	ldw	r4,48(sp)
 101be24:	1023883a 	mov	r17,r2
 101be28:	0102040e 	bge	zero,r4,101c63c <_dtoa_r+0x1600>
 101be2c:	d9000615 	stw	r4,24(sp)
 101be30:	0500050e 	bge	zero,r20,101be48 <_dtoa_r+0xe0c>
 101be34:	880b883a 	mov	r5,r17
 101be38:	a00d883a 	mov	r6,r20
 101be3c:	e009883a 	mov	r4,fp
 101be40:	101ebe80 	call	101ebe8 <__lshift>
 101be44:	1023883a 	mov	r17,r2
 101be48:	9801241e 	bne	r19,zero,101c2dc <_dtoa_r+0x12a0>
 101be4c:	8829883a 	mov	r20,r17
 101be50:	d9000617 	ldw	r4,24(sp)
 101be54:	dcc00717 	ldw	r19,28(sp)
 101be58:	9480004c 	andi	r18,r18,1
 101be5c:	20bfffc4 	addi	r2,r4,-1
 101be60:	9885883a 	add	r2,r19,r2
 101be64:	d8800415 	stw	r2,16(sp)
 101be68:	dc800615 	stw	r18,24(sp)
 101be6c:	a80b883a 	mov	r5,r21
 101be70:	8009883a 	mov	r4,r16
 101be74:	101ae3c0 	call	101ae3c <quorem>
 101be78:	880b883a 	mov	r5,r17
 101be7c:	8009883a 	mov	r4,r16
 101be80:	102f883a 	mov	r23,r2
 101be84:	101ed300 	call	101ed30 <__mcmp>
 101be88:	a80b883a 	mov	r5,r21
 101be8c:	a00d883a 	mov	r6,r20
 101be90:	e009883a 	mov	r4,fp
 101be94:	102d883a 	mov	r22,r2
 101be98:	101ed900 	call	101ed90 <__mdiff>
 101be9c:	1007883a 	mov	r3,r2
 101bea0:	10800317 	ldw	r2,12(r2)
 101bea4:	bc800c04 	addi	r18,r23,48
 101bea8:	180b883a 	mov	r5,r3
 101beac:	10004e1e 	bne	r2,zero,101bfe8 <_dtoa_r+0xfac>
 101beb0:	8009883a 	mov	r4,r16
 101beb4:	d8c01615 	stw	r3,88(sp)
 101beb8:	101ed300 	call	101ed30 <__mcmp>
 101bebc:	d8c01617 	ldw	r3,88(sp)
 101bec0:	e009883a 	mov	r4,fp
 101bec4:	d8801615 	stw	r2,88(sp)
 101bec8:	180b883a 	mov	r5,r3
 101becc:	101e5100 	call	101e510 <_Bfree>
 101bed0:	d8801617 	ldw	r2,88(sp)
 101bed4:	1000041e 	bne	r2,zero,101bee8 <_dtoa_r+0xeac>
 101bed8:	d9800317 	ldw	r6,12(sp)
 101bedc:	3000021e 	bne	r6,zero,101bee8 <_dtoa_r+0xeac>
 101bee0:	d8c00617 	ldw	r3,24(sp)
 101bee4:	18003726 	beq	r3,zero,101bfc4 <_dtoa_r+0xf88>
 101bee8:	b0002016 	blt	r22,zero,101bf6c <_dtoa_r+0xf30>
 101beec:	b000041e 	bne	r22,zero,101bf00 <_dtoa_r+0xec4>
 101bef0:	d9000317 	ldw	r4,12(sp)
 101bef4:	2000021e 	bne	r4,zero,101bf00 <_dtoa_r+0xec4>
 101bef8:	d8c00617 	ldw	r3,24(sp)
 101befc:	18001b26 	beq	r3,zero,101bf6c <_dtoa_r+0xf30>
 101bf00:	00810716 	blt	zero,r2,101c320 <_dtoa_r+0x12e4>
 101bf04:	d8c00417 	ldw	r3,16(sp)
 101bf08:	9d800044 	addi	r22,r19,1
 101bf0c:	9c800005 	stb	r18,0(r19)
 101bf10:	b02f883a 	mov	r23,r22
 101bf14:	98c10626 	beq	r19,r3,101c330 <_dtoa_r+0x12f4>
 101bf18:	800b883a 	mov	r5,r16
 101bf1c:	000f883a 	mov	r7,zero
 101bf20:	01800284 	movi	r6,10
 101bf24:	e009883a 	mov	r4,fp
 101bf28:	101e5380 	call	101e538 <__multadd>
 101bf2c:	1021883a 	mov	r16,r2
 101bf30:	000f883a 	mov	r7,zero
 101bf34:	01800284 	movi	r6,10
 101bf38:	880b883a 	mov	r5,r17
 101bf3c:	e009883a 	mov	r4,fp
 101bf40:	8d002526 	beq	r17,r20,101bfd8 <_dtoa_r+0xf9c>
 101bf44:	101e5380 	call	101e538 <__multadd>
 101bf48:	a00b883a 	mov	r5,r20
 101bf4c:	000f883a 	mov	r7,zero
 101bf50:	01800284 	movi	r6,10
 101bf54:	e009883a 	mov	r4,fp
 101bf58:	1023883a 	mov	r17,r2
 101bf5c:	101e5380 	call	101e538 <__multadd>
 101bf60:	1029883a 	mov	r20,r2
 101bf64:	b027883a 	mov	r19,r22
 101bf68:	003fc006 	br	101be6c <__alt_data_end+0xff01be6c>
 101bf6c:	9011883a 	mov	r8,r18
 101bf70:	00800e0e 	bge	zero,r2,101bfac <_dtoa_r+0xf70>
 101bf74:	800b883a 	mov	r5,r16
 101bf78:	01800044 	movi	r6,1
 101bf7c:	e009883a 	mov	r4,fp
 101bf80:	da001715 	stw	r8,92(sp)
 101bf84:	101ebe80 	call	101ebe8 <__lshift>
 101bf88:	a80b883a 	mov	r5,r21
 101bf8c:	1009883a 	mov	r4,r2
 101bf90:	1021883a 	mov	r16,r2
 101bf94:	101ed300 	call	101ed30 <__mcmp>
 101bf98:	da001717 	ldw	r8,92(sp)
 101bf9c:	0081960e 	bge	zero,r2,101c5f8 <_dtoa_r+0x15bc>
 101bfa0:	00800e44 	movi	r2,57
 101bfa4:	40817026 	beq	r8,r2,101c568 <_dtoa_r+0x152c>
 101bfa8:	ba000c44 	addi	r8,r23,49
 101bfac:	8825883a 	mov	r18,r17
 101bfb0:	9dc00044 	addi	r23,r19,1
 101bfb4:	9a000005 	stb	r8,0(r19)
 101bfb8:	a023883a 	mov	r17,r20
 101bfbc:	dc000915 	stw	r16,36(sp)
 101bfc0:	003f2406 	br	101bc54 <__alt_data_end+0xff01bc54>
 101bfc4:	00800e44 	movi	r2,57
 101bfc8:	9011883a 	mov	r8,r18
 101bfcc:	90816626 	beq	r18,r2,101c568 <_dtoa_r+0x152c>
 101bfd0:	05bff516 	blt	zero,r22,101bfa8 <__alt_data_end+0xff01bfa8>
 101bfd4:	003ff506 	br	101bfac <__alt_data_end+0xff01bfac>
 101bfd8:	101e5380 	call	101e538 <__multadd>
 101bfdc:	1023883a 	mov	r17,r2
 101bfe0:	1029883a 	mov	r20,r2
 101bfe4:	003fdf06 	br	101bf64 <__alt_data_end+0xff01bf64>
 101bfe8:	e009883a 	mov	r4,fp
 101bfec:	101e5100 	call	101e510 <_Bfree>
 101bff0:	00800044 	movi	r2,1
 101bff4:	003fbc06 	br	101bee8 <__alt_data_end+0xff01bee8>
 101bff8:	a80b883a 	mov	r5,r21
 101bffc:	8009883a 	mov	r4,r16
 101c000:	101ed300 	call	101ed30 <__mcmp>
 101c004:	103edb0e 	bge	r2,zero,101bb74 <__alt_data_end+0xff01bb74>
 101c008:	800b883a 	mov	r5,r16
 101c00c:	000f883a 	mov	r7,zero
 101c010:	01800284 	movi	r6,10
 101c014:	e009883a 	mov	r4,fp
 101c018:	101e5380 	call	101e538 <__multadd>
 101c01c:	1021883a 	mov	r16,r2
 101c020:	d8800517 	ldw	r2,20(sp)
 101c024:	d8c00b17 	ldw	r3,44(sp)
 101c028:	10bfffc4 	addi	r2,r2,-1
 101c02c:	d8800515 	stw	r2,20(sp)
 101c030:	183f761e 	bne	r3,zero,101be0c <__alt_data_end+0xff01be0c>
 101c034:	d9000c17 	ldw	r4,48(sp)
 101c038:	0101730e 	bge	zero,r4,101c608 <_dtoa_r+0x15cc>
 101c03c:	d9000615 	stw	r4,24(sp)
 101c040:	003ed006 	br	101bb84 <__alt_data_end+0xff01bb84>
 101c044:	00800084 	movi	r2,2
 101c048:	3081861e 	bne	r6,r2,101c664 <_dtoa_r+0x1628>
 101c04c:	d8000b15 	stw	zero,44(sp)
 101c050:	003f3c06 	br	101bd44 <__alt_data_end+0xff01bd44>
 101c054:	dc000917 	ldw	r16,36(sp)
 101c058:	003e9206 	br	101baa4 <__alt_data_end+0xff01baa4>
 101c05c:	d9c00317 	ldw	r7,12(sp)
 101c060:	00800084 	movi	r2,2
 101c064:	11fec50e 	bge	r2,r7,101bb7c <__alt_data_end+0xff01bb7c>
 101c068:	d9000617 	ldw	r4,24(sp)
 101c06c:	20013c1e 	bne	r4,zero,101c560 <_dtoa_r+0x1524>
 101c070:	a80b883a 	mov	r5,r21
 101c074:	000f883a 	mov	r7,zero
 101c078:	01800144 	movi	r6,5
 101c07c:	e009883a 	mov	r4,fp
 101c080:	101e5380 	call	101e538 <__multadd>
 101c084:	100b883a 	mov	r5,r2
 101c088:	8009883a 	mov	r4,r16
 101c08c:	102b883a 	mov	r21,r2
 101c090:	101ed300 	call	101ed30 <__mcmp>
 101c094:	dc000915 	stw	r16,36(sp)
 101c098:	00bf410e 	bge	zero,r2,101bda0 <__alt_data_end+0xff01bda0>
 101c09c:	d9c00717 	ldw	r7,28(sp)
 101c0a0:	00800c44 	movi	r2,49
 101c0a4:	38800005 	stb	r2,0(r7)
 101c0a8:	d8800517 	ldw	r2,20(sp)
 101c0ac:	3dc00044 	addi	r23,r7,1
 101c0b0:	10800044 	addi	r2,r2,1
 101c0b4:	d8800515 	stw	r2,20(sp)
 101c0b8:	003f3d06 	br	101bdb0 <__alt_data_end+0xff01bdb0>
 101c0bc:	d9800517 	ldw	r6,20(sp)
 101c0c0:	d9c00717 	ldw	r7,28(sp)
 101c0c4:	00800c44 	movi	r2,49
 101c0c8:	31800044 	addi	r6,r6,1
 101c0cc:	d9800515 	stw	r6,20(sp)
 101c0d0:	38800005 	stb	r2,0(r7)
 101c0d4:	003edf06 	br	101bc54 <__alt_data_end+0xff01bc54>
 101c0d8:	d8000b15 	stw	zero,44(sp)
 101c0dc:	003c9f06 	br	101b35c <__alt_data_end+0xff01b35c>
 101c0e0:	903e7e1e 	bne	r18,zero,101badc <__alt_data_end+0xff01badc>
 101c0e4:	00800434 	movhi	r2,16
 101c0e8:	10bfffc4 	addi	r2,r2,-1
 101c0ec:	9884703a 	and	r2,r19,r2
 101c0f0:	1000ea1e 	bne	r2,zero,101c49c <_dtoa_r+0x1460>
 101c0f4:	9cdffc2c 	andhi	r19,r19,32752
 101c0f8:	9800e826 	beq	r19,zero,101c49c <_dtoa_r+0x1460>
 101c0fc:	d9c00817 	ldw	r7,32(sp)
 101c100:	b5800044 	addi	r22,r22,1
 101c104:	04c00044 	movi	r19,1
 101c108:	39c00044 	addi	r7,r7,1
 101c10c:	d9c00815 	stw	r7,32(sp)
 101c110:	d8800d17 	ldw	r2,52(sp)
 101c114:	103e721e 	bne	r2,zero,101bae0 <__alt_data_end+0xff01bae0>
 101c118:	00800044 	movi	r2,1
 101c11c:	003e7906 	br	101bb04 <__alt_data_end+0xff01bb04>
 101c120:	8009883a 	mov	r4,r16
 101c124:	102633c0 	call	102633c <__floatsidf>
 101c128:	d9800f17 	ldw	r6,60(sp)
 101c12c:	d9c01017 	ldw	r7,64(sp)
 101c130:	1009883a 	mov	r4,r2
 101c134:	180b883a 	mov	r5,r3
 101c138:	10252a80 	call	10252a8 <__muldf3>
 101c13c:	000d883a 	mov	r6,zero
 101c140:	01d00734 	movhi	r7,16412
 101c144:	1009883a 	mov	r4,r2
 101c148:	180b883a 	mov	r5,r3
 101c14c:	1023ebc0 	call	1023ebc <__adddf3>
 101c150:	047f3034 	movhi	r17,64704
 101c154:	1021883a 	mov	r16,r2
 101c158:	1c63883a 	add	r17,r3,r17
 101c15c:	d9000f17 	ldw	r4,60(sp)
 101c160:	d9401017 	ldw	r5,64(sp)
 101c164:	000d883a 	mov	r6,zero
 101c168:	01d00534 	movhi	r7,16404
 101c16c:	10259c00 	call	10259c0 <__subdf3>
 101c170:	800d883a 	mov	r6,r16
 101c174:	880f883a 	mov	r7,r17
 101c178:	1009883a 	mov	r4,r2
 101c17c:	180b883a 	mov	r5,r3
 101c180:	102b883a 	mov	r21,r2
 101c184:	1829883a 	mov	r20,r3
 101c188:	10250d80 	call	10250d8 <__gedf2>
 101c18c:	00806c16 	blt	zero,r2,101c340 <_dtoa_r+0x1304>
 101c190:	89e0003c 	xorhi	r7,r17,32768
 101c194:	800d883a 	mov	r6,r16
 101c198:	a809883a 	mov	r4,r21
 101c19c:	a00b883a 	mov	r5,r20
 101c1a0:	10251b40 	call	10251b4 <__ledf2>
 101c1a4:	103d7e0e 	bge	r2,zero,101b7a0 <__alt_data_end+0xff01b7a0>
 101c1a8:	002b883a 	mov	r21,zero
 101c1ac:	0023883a 	mov	r17,zero
 101c1b0:	003efb06 	br	101bda0 <__alt_data_end+0xff01bda0>
 101c1b4:	d8800717 	ldw	r2,28(sp)
 101c1b8:	003bd006 	br	101b0fc <__alt_data_end+0xff01b0fc>
 101c1bc:	d9000a17 	ldw	r4,40(sp)
 101c1c0:	d9800d17 	ldw	r6,52(sp)
 101c1c4:	dd400a15 	stw	r21,40(sp)
 101c1c8:	a905c83a 	sub	r2,r21,r4
 101c1cc:	308d883a 	add	r6,r6,r2
 101c1d0:	d9800d15 	stw	r6,52(sp)
 101c1d4:	002b883a 	mov	r21,zero
 101c1d8:	003e0606 	br	101b9f4 <__alt_data_end+0xff01b9f4>
 101c1dc:	9023883a 	mov	r17,r18
 101c1e0:	9829883a 	mov	r20,r19
 101c1e4:	04000084 	movi	r16,2
 101c1e8:	003c9206 	br	101b434 <__alt_data_end+0xff01b434>
 101c1ec:	04000044 	movi	r16,1
 101c1f0:	dc000c15 	stw	r16,48(sp)
 101c1f4:	dc000615 	stw	r16,24(sp)
 101c1f8:	dc002215 	stw	r16,136(sp)
 101c1fc:	e0001115 	stw	zero,68(fp)
 101c200:	000b883a 	mov	r5,zero
 101c204:	003c6906 	br	101b3ac <__alt_data_end+0xff01b3ac>
 101c208:	3021883a 	mov	r16,r6
 101c20c:	003ffb06 	br	101c1fc <__alt_data_end+0xff01c1fc>
 101c210:	1000021e 	bne	r2,zero,101c21c <_dtoa_r+0x11e0>
 101c214:	4200004c 	andi	r8,r8,1
 101c218:	403e7d1e 	bne	r8,zero,101bc10 <__alt_data_end+0xff01bc10>
 101c21c:	01000c04 	movi	r4,48
 101c220:	00000106 	br	101c228 <_dtoa_r+0x11ec>
 101c224:	102f883a 	mov	r23,r2
 101c228:	b8bfffc4 	addi	r2,r23,-1
 101c22c:	10c00007 	ldb	r3,0(r2)
 101c230:	193ffc26 	beq	r3,r4,101c224 <__alt_data_end+0xff01c224>
 101c234:	003e8706 	br	101bc54 <__alt_data_end+0xff01bc54>
 101c238:	d8800517 	ldw	r2,20(sp)
 101c23c:	00a3c83a 	sub	r17,zero,r2
 101c240:	8800a426 	beq	r17,zero,101c4d4 <_dtoa_r+0x1498>
 101c244:	888003cc 	andi	r2,r17,15
 101c248:	100490fa 	slli	r2,r2,3
 101c24c:	00c040f4 	movhi	r3,259
 101c250:	18eabb04 	addi	r3,r3,-21780
 101c254:	1885883a 	add	r2,r3,r2
 101c258:	11800017 	ldw	r6,0(r2)
 101c25c:	11c00117 	ldw	r7,4(r2)
 101c260:	9009883a 	mov	r4,r18
 101c264:	980b883a 	mov	r5,r19
 101c268:	8823d13a 	srai	r17,r17,4
 101c26c:	10252a80 	call	10252a8 <__muldf3>
 101c270:	d8800f15 	stw	r2,60(sp)
 101c274:	d8c01015 	stw	r3,64(sp)
 101c278:	8800e826 	beq	r17,zero,101c61c <_dtoa_r+0x15e0>
 101c27c:	050040f4 	movhi	r20,259
 101c280:	a52ab104 	addi	r20,r20,-21820
 101c284:	04000084 	movi	r16,2
 101c288:	8980004c 	andi	r6,r17,1
 101c28c:	1009883a 	mov	r4,r2
 101c290:	8823d07a 	srai	r17,r17,1
 101c294:	180b883a 	mov	r5,r3
 101c298:	30000426 	beq	r6,zero,101c2ac <_dtoa_r+0x1270>
 101c29c:	a1800017 	ldw	r6,0(r20)
 101c2a0:	a1c00117 	ldw	r7,4(r20)
 101c2a4:	84000044 	addi	r16,r16,1
 101c2a8:	10252a80 	call	10252a8 <__muldf3>
 101c2ac:	a5000204 	addi	r20,r20,8
 101c2b0:	883ff51e 	bne	r17,zero,101c288 <__alt_data_end+0xff01c288>
 101c2b4:	d8800f15 	stw	r2,60(sp)
 101c2b8:	d8c01015 	stw	r3,64(sp)
 101c2bc:	003c7606 	br	101b498 <__alt_data_end+0xff01b498>
 101c2c0:	00c00c04 	movi	r3,48
 101c2c4:	10c00005 	stb	r3,0(r2)
 101c2c8:	d8c00517 	ldw	r3,20(sp)
 101c2cc:	bd3fffc3 	ldbu	r20,-1(r23)
 101c2d0:	18c00044 	addi	r3,r3,1
 101c2d4:	d8c00515 	stw	r3,20(sp)
 101c2d8:	003db906 	br	101b9c0 <__alt_data_end+0xff01b9c0>
 101c2dc:	89400117 	ldw	r5,4(r17)
 101c2e0:	e009883a 	mov	r4,fp
 101c2e4:	101e4680 	call	101e468 <_Balloc>
 101c2e8:	89800417 	ldw	r6,16(r17)
 101c2ec:	89400304 	addi	r5,r17,12
 101c2f0:	11000304 	addi	r4,r2,12
 101c2f4:	31800084 	addi	r6,r6,2
 101c2f8:	318d883a 	add	r6,r6,r6
 101c2fc:	318d883a 	add	r6,r6,r6
 101c300:	1027883a 	mov	r19,r2
 101c304:	10158f40 	call	10158f4 <memcpy>
 101c308:	01800044 	movi	r6,1
 101c30c:	980b883a 	mov	r5,r19
 101c310:	e009883a 	mov	r4,fp
 101c314:	101ebe80 	call	101ebe8 <__lshift>
 101c318:	1029883a 	mov	r20,r2
 101c31c:	003ecc06 	br	101be50 <__alt_data_end+0xff01be50>
 101c320:	00800e44 	movi	r2,57
 101c324:	90809026 	beq	r18,r2,101c568 <_dtoa_r+0x152c>
 101c328:	92000044 	addi	r8,r18,1
 101c32c:	003f1f06 	br	101bfac <__alt_data_end+0xff01bfac>
 101c330:	9011883a 	mov	r8,r18
 101c334:	8825883a 	mov	r18,r17
 101c338:	a023883a 	mov	r17,r20
 101c33c:	003e2906 	br	101bbe4 <__alt_data_end+0xff01bbe4>
 101c340:	002b883a 	mov	r21,zero
 101c344:	0023883a 	mov	r17,zero
 101c348:	003f5406 	br	101c09c <__alt_data_end+0xff01c09c>
 101c34c:	61bfffc4 	addi	r6,r12,-1
 101c350:	300490fa 	slli	r2,r6,3
 101c354:	00c040f4 	movhi	r3,259
 101c358:	18eabb04 	addi	r3,r3,-21780
 101c35c:	1885883a 	add	r2,r3,r2
 101c360:	11000017 	ldw	r4,0(r2)
 101c364:	11400117 	ldw	r5,4(r2)
 101c368:	d8800717 	ldw	r2,28(sp)
 101c36c:	880f883a 	mov	r7,r17
 101c370:	d9801215 	stw	r6,72(sp)
 101c374:	800d883a 	mov	r6,r16
 101c378:	db001615 	stw	r12,88(sp)
 101c37c:	15c00044 	addi	r23,r2,1
 101c380:	10252a80 	call	10252a8 <__muldf3>
 101c384:	d9401017 	ldw	r5,64(sp)
 101c388:	d9000f17 	ldw	r4,60(sp)
 101c38c:	d8c01515 	stw	r3,84(sp)
 101c390:	d8801415 	stw	r2,80(sp)
 101c394:	10262bc0 	call	10262bc <__fixdfsi>
 101c398:	1009883a 	mov	r4,r2
 101c39c:	1021883a 	mov	r16,r2
 101c3a0:	102633c0 	call	102633c <__floatsidf>
 101c3a4:	d9000f17 	ldw	r4,60(sp)
 101c3a8:	d9401017 	ldw	r5,64(sp)
 101c3ac:	100d883a 	mov	r6,r2
 101c3b0:	180f883a 	mov	r7,r3
 101c3b4:	10259c00 	call	10259c0 <__subdf3>
 101c3b8:	1829883a 	mov	r20,r3
 101c3bc:	d8c00717 	ldw	r3,28(sp)
 101c3c0:	84000c04 	addi	r16,r16,48
 101c3c4:	1023883a 	mov	r17,r2
 101c3c8:	1c000005 	stb	r16,0(r3)
 101c3cc:	db001617 	ldw	r12,88(sp)
 101c3d0:	00800044 	movi	r2,1
 101c3d4:	60802226 	beq	r12,r2,101c460 <_dtoa_r+0x1424>
 101c3d8:	d9c00717 	ldw	r7,28(sp)
 101c3dc:	8805883a 	mov	r2,r17
 101c3e0:	b82b883a 	mov	r21,r23
 101c3e4:	3b19883a 	add	r12,r7,r12
 101c3e8:	6023883a 	mov	r17,r12
 101c3ec:	a007883a 	mov	r3,r20
 101c3f0:	dc800f15 	stw	r18,60(sp)
 101c3f4:	000d883a 	mov	r6,zero
 101c3f8:	01d00934 	movhi	r7,16420
 101c3fc:	1009883a 	mov	r4,r2
 101c400:	180b883a 	mov	r5,r3
 101c404:	10252a80 	call	10252a8 <__muldf3>
 101c408:	180b883a 	mov	r5,r3
 101c40c:	1009883a 	mov	r4,r2
 101c410:	1829883a 	mov	r20,r3
 101c414:	1025883a 	mov	r18,r2
 101c418:	10262bc0 	call	10262bc <__fixdfsi>
 101c41c:	1009883a 	mov	r4,r2
 101c420:	1021883a 	mov	r16,r2
 101c424:	102633c0 	call	102633c <__floatsidf>
 101c428:	100d883a 	mov	r6,r2
 101c42c:	180f883a 	mov	r7,r3
 101c430:	9009883a 	mov	r4,r18
 101c434:	a00b883a 	mov	r5,r20
 101c438:	84000c04 	addi	r16,r16,48
 101c43c:	10259c00 	call	10259c0 <__subdf3>
 101c440:	ad400044 	addi	r21,r21,1
 101c444:	ac3fffc5 	stb	r16,-1(r21)
 101c448:	ac7fea1e 	bne	r21,r17,101c3f4 <__alt_data_end+0xff01c3f4>
 101c44c:	1023883a 	mov	r17,r2
 101c450:	d8801217 	ldw	r2,72(sp)
 101c454:	dc800f17 	ldw	r18,60(sp)
 101c458:	1829883a 	mov	r20,r3
 101c45c:	b8af883a 	add	r23,r23,r2
 101c460:	d9001417 	ldw	r4,80(sp)
 101c464:	d9401517 	ldw	r5,84(sp)
 101c468:	000d883a 	mov	r6,zero
 101c46c:	01cff834 	movhi	r7,16352
 101c470:	1023ebc0 	call	1023ebc <__adddf3>
 101c474:	880d883a 	mov	r6,r17
 101c478:	a00f883a 	mov	r7,r20
 101c47c:	1009883a 	mov	r4,r2
 101c480:	180b883a 	mov	r5,r3
 101c484:	10251b40 	call	10251b4 <__ledf2>
 101c488:	10003e0e 	bge	r2,zero,101c584 <_dtoa_r+0x1548>
 101c48c:	d9001317 	ldw	r4,76(sp)
 101c490:	bd3fffc3 	ldbu	r20,-1(r23)
 101c494:	d9000515 	stw	r4,20(sp)
 101c498:	003d3b06 	br	101b988 <__alt_data_end+0xff01b988>
 101c49c:	0027883a 	mov	r19,zero
 101c4a0:	003f1b06 	br	101c110 <__alt_data_end+0xff01c110>
 101c4a4:	d8800817 	ldw	r2,32(sp)
 101c4a8:	11e9c83a 	sub	r20,r2,r7
 101c4ac:	0005883a 	mov	r2,zero
 101c4b0:	003d5406 	br	101ba04 <__alt_data_end+0xff01ba04>
 101c4b4:	00800044 	movi	r2,1
 101c4b8:	003dc706 	br	101bbd8 <__alt_data_end+0xff01bbd8>
 101c4bc:	d8c00217 	ldw	r3,8(sp)
 101c4c0:	00800d84 	movi	r2,54
 101c4c4:	dd400a17 	ldw	r21,40(sp)
 101c4c8:	10c5c83a 	sub	r2,r2,r3
 101c4cc:	dd000817 	ldw	r20,32(sp)
 101c4d0:	003d4c06 	br	101ba04 <__alt_data_end+0xff01ba04>
 101c4d4:	dc800f15 	stw	r18,60(sp)
 101c4d8:	dcc01015 	stw	r19,64(sp)
 101c4dc:	04000084 	movi	r16,2
 101c4e0:	003bed06 	br	101b498 <__alt_data_end+0xff01b498>
 101c4e4:	d9000617 	ldw	r4,24(sp)
 101c4e8:	203f0d26 	beq	r4,zero,101c120 <__alt_data_end+0xff01c120>
 101c4ec:	d9800c17 	ldw	r6,48(sp)
 101c4f0:	01bcab0e 	bge	zero,r6,101b7a0 <__alt_data_end+0xff01b7a0>
 101c4f4:	d9401017 	ldw	r5,64(sp)
 101c4f8:	d9000f17 	ldw	r4,60(sp)
 101c4fc:	000d883a 	mov	r6,zero
 101c500:	01d00934 	movhi	r7,16420
 101c504:	10252a80 	call	10252a8 <__muldf3>
 101c508:	81000044 	addi	r4,r16,1
 101c50c:	d8800f15 	stw	r2,60(sp)
 101c510:	d8c01015 	stw	r3,64(sp)
 101c514:	102633c0 	call	102633c <__floatsidf>
 101c518:	d9800f17 	ldw	r6,60(sp)
 101c51c:	d9c01017 	ldw	r7,64(sp)
 101c520:	1009883a 	mov	r4,r2
 101c524:	180b883a 	mov	r5,r3
 101c528:	10252a80 	call	10252a8 <__muldf3>
 101c52c:	01d00734 	movhi	r7,16412
 101c530:	000d883a 	mov	r6,zero
 101c534:	1009883a 	mov	r4,r2
 101c538:	180b883a 	mov	r5,r3
 101c53c:	1023ebc0 	call	1023ebc <__adddf3>
 101c540:	d9c00517 	ldw	r7,20(sp)
 101c544:	047f3034 	movhi	r17,64704
 101c548:	1021883a 	mov	r16,r2
 101c54c:	39ffffc4 	addi	r7,r7,-1
 101c550:	d9c01315 	stw	r7,76(sp)
 101c554:	1c63883a 	add	r17,r3,r17
 101c558:	db000c17 	ldw	r12,48(sp)
 101c55c:	003bea06 	br	101b508 <__alt_data_end+0xff01b508>
 101c560:	dc000915 	stw	r16,36(sp)
 101c564:	003e0e06 	br	101bda0 <__alt_data_end+0xff01bda0>
 101c568:	01000e44 	movi	r4,57
 101c56c:	8825883a 	mov	r18,r17
 101c570:	9dc00044 	addi	r23,r19,1
 101c574:	99000005 	stb	r4,0(r19)
 101c578:	a023883a 	mov	r17,r20
 101c57c:	dc000915 	stw	r16,36(sp)
 101c580:	003da406 	br	101bc14 <__alt_data_end+0xff01bc14>
 101c584:	d9801417 	ldw	r6,80(sp)
 101c588:	d9c01517 	ldw	r7,84(sp)
 101c58c:	0009883a 	mov	r4,zero
 101c590:	014ff834 	movhi	r5,16352
 101c594:	10259c00 	call	10259c0 <__subdf3>
 101c598:	880d883a 	mov	r6,r17
 101c59c:	a00f883a 	mov	r7,r20
 101c5a0:	1009883a 	mov	r4,r2
 101c5a4:	180b883a 	mov	r5,r3
 101c5a8:	10250d80 	call	10250d8 <__gedf2>
 101c5ac:	00bc7c0e 	bge	zero,r2,101b7a0 <__alt_data_end+0xff01b7a0>
 101c5b0:	01000c04 	movi	r4,48
 101c5b4:	00000106 	br	101c5bc <_dtoa_r+0x1580>
 101c5b8:	102f883a 	mov	r23,r2
 101c5bc:	b8bfffc4 	addi	r2,r23,-1
 101c5c0:	10c00007 	ldb	r3,0(r2)
 101c5c4:	193ffc26 	beq	r3,r4,101c5b8 <__alt_data_end+0xff01c5b8>
 101c5c8:	d9801317 	ldw	r6,76(sp)
 101c5cc:	d9800515 	stw	r6,20(sp)
 101c5d0:	003c4406 	br	101b6e4 <__alt_data_end+0xff01b6e4>
 101c5d4:	d9801317 	ldw	r6,76(sp)
 101c5d8:	d9800515 	stw	r6,20(sp)
 101c5dc:	003cea06 	br	101b988 <__alt_data_end+0xff01b988>
 101c5e0:	dd800f17 	ldw	r22,60(sp)
 101c5e4:	dcc01017 	ldw	r19,64(sp)
 101c5e8:	dc801217 	ldw	r18,72(sp)
 101c5ec:	003c6c06 	br	101b7a0 <__alt_data_end+0xff01b7a0>
 101c5f0:	903e031e 	bne	r18,zero,101be00 <__alt_data_end+0xff01be00>
 101c5f4:	003ebb06 	br	101c0e4 <__alt_data_end+0xff01c0e4>
 101c5f8:	103e6c1e 	bne	r2,zero,101bfac <__alt_data_end+0xff01bfac>
 101c5fc:	4080004c 	andi	r2,r8,1
 101c600:	103e6a26 	beq	r2,zero,101bfac <__alt_data_end+0xff01bfac>
 101c604:	003e6606 	br	101bfa0 <__alt_data_end+0xff01bfa0>
 101c608:	d8c00317 	ldw	r3,12(sp)
 101c60c:	00800084 	movi	r2,2
 101c610:	10c02916 	blt	r2,r3,101c6b8 <_dtoa_r+0x167c>
 101c614:	d9000c17 	ldw	r4,48(sp)
 101c618:	003e8806 	br	101c03c <__alt_data_end+0xff01c03c>
 101c61c:	04000084 	movi	r16,2
 101c620:	003b9d06 	br	101b498 <__alt_data_end+0xff01b498>
 101c624:	d9001317 	ldw	r4,76(sp)
 101c628:	d9000515 	stw	r4,20(sp)
 101c62c:	003cd606 	br	101b988 <__alt_data_end+0xff01b988>
 101c630:	d8801317 	ldw	r2,76(sp)
 101c634:	d8800515 	stw	r2,20(sp)
 101c638:	003c2a06 	br	101b6e4 <__alt_data_end+0xff01b6e4>
 101c63c:	d9800317 	ldw	r6,12(sp)
 101c640:	00800084 	movi	r2,2
 101c644:	11801516 	blt	r2,r6,101c69c <_dtoa_r+0x1660>
 101c648:	d9c00c17 	ldw	r7,48(sp)
 101c64c:	d9c00615 	stw	r7,24(sp)
 101c650:	003df706 	br	101be30 <__alt_data_end+0xff01be30>
 101c654:	193d3926 	beq	r3,r4,101bb3c <__alt_data_end+0xff01bb3c>
 101c658:	00c00f04 	movi	r3,60
 101c65c:	1885c83a 	sub	r2,r3,r2
 101c660:	003ddf06 	br	101bde0 <__alt_data_end+0xff01bde0>
 101c664:	e009883a 	mov	r4,fp
 101c668:	e0001115 	stw	zero,68(fp)
 101c66c:	000b883a 	mov	r5,zero
 101c670:	101e4680 	call	101e468 <_Balloc>
 101c674:	d8800715 	stw	r2,28(sp)
 101c678:	d8c00717 	ldw	r3,28(sp)
 101c67c:	00bfffc4 	movi	r2,-1
 101c680:	01000044 	movi	r4,1
 101c684:	d8800c15 	stw	r2,48(sp)
 101c688:	e0c01015 	stw	r3,64(fp)
 101c68c:	d9000b15 	stw	r4,44(sp)
 101c690:	d8800615 	stw	r2,24(sp)
 101c694:	d8002215 	stw	zero,136(sp)
 101c698:	003c4106 	br	101b7a0 <__alt_data_end+0xff01b7a0>
 101c69c:	d8c00c17 	ldw	r3,48(sp)
 101c6a0:	d8c00615 	stw	r3,24(sp)
 101c6a4:	003e7006 	br	101c068 <__alt_data_end+0xff01c068>
 101c6a8:	04400044 	movi	r17,1
 101c6ac:	003b2006 	br	101b330 <__alt_data_end+0xff01b330>
 101c6b0:	000b883a 	mov	r5,zero
 101c6b4:	003b3d06 	br	101b3ac <__alt_data_end+0xff01b3ac>
 101c6b8:	d8800c17 	ldw	r2,48(sp)
 101c6bc:	d8800615 	stw	r2,24(sp)
 101c6c0:	003e6906 	br	101c068 <__alt_data_end+0xff01c068>

0101c6c4 <__sflush_r>:
 101c6c4:	2880030b 	ldhu	r2,12(r5)
 101c6c8:	defffb04 	addi	sp,sp,-20
 101c6cc:	dcc00315 	stw	r19,12(sp)
 101c6d0:	dc400115 	stw	r17,4(sp)
 101c6d4:	dfc00415 	stw	ra,16(sp)
 101c6d8:	dc800215 	stw	r18,8(sp)
 101c6dc:	dc000015 	stw	r16,0(sp)
 101c6e0:	10c0020c 	andi	r3,r2,8
 101c6e4:	2823883a 	mov	r17,r5
 101c6e8:	2027883a 	mov	r19,r4
 101c6ec:	1800311e 	bne	r3,zero,101c7b4 <__sflush_r+0xf0>
 101c6f0:	28c00117 	ldw	r3,4(r5)
 101c6f4:	10820014 	ori	r2,r2,2048
 101c6f8:	2880030d 	sth	r2,12(r5)
 101c6fc:	00c04b0e 	bge	zero,r3,101c82c <__sflush_r+0x168>
 101c700:	8a000a17 	ldw	r8,40(r17)
 101c704:	40002326 	beq	r8,zero,101c794 <__sflush_r+0xd0>
 101c708:	9c000017 	ldw	r16,0(r19)
 101c70c:	10c4000c 	andi	r3,r2,4096
 101c710:	98000015 	stw	zero,0(r19)
 101c714:	18004826 	beq	r3,zero,101c838 <__sflush_r+0x174>
 101c718:	89801417 	ldw	r6,80(r17)
 101c71c:	10c0010c 	andi	r3,r2,4
 101c720:	18000626 	beq	r3,zero,101c73c <__sflush_r+0x78>
 101c724:	88c00117 	ldw	r3,4(r17)
 101c728:	88800c17 	ldw	r2,48(r17)
 101c72c:	30cdc83a 	sub	r6,r6,r3
 101c730:	10000226 	beq	r2,zero,101c73c <__sflush_r+0x78>
 101c734:	88800f17 	ldw	r2,60(r17)
 101c738:	308dc83a 	sub	r6,r6,r2
 101c73c:	89400717 	ldw	r5,28(r17)
 101c740:	000f883a 	mov	r7,zero
 101c744:	9809883a 	mov	r4,r19
 101c748:	403ee83a 	callr	r8
 101c74c:	00ffffc4 	movi	r3,-1
 101c750:	10c04426 	beq	r2,r3,101c864 <__sflush_r+0x1a0>
 101c754:	88c0030b 	ldhu	r3,12(r17)
 101c758:	89000417 	ldw	r4,16(r17)
 101c75c:	88000115 	stw	zero,4(r17)
 101c760:	197dffcc 	andi	r5,r3,63487
 101c764:	8940030d 	sth	r5,12(r17)
 101c768:	89000015 	stw	r4,0(r17)
 101c76c:	18c4000c 	andi	r3,r3,4096
 101c770:	18002c1e 	bne	r3,zero,101c824 <__sflush_r+0x160>
 101c774:	89400c17 	ldw	r5,48(r17)
 101c778:	9c000015 	stw	r16,0(r19)
 101c77c:	28000526 	beq	r5,zero,101c794 <__sflush_r+0xd0>
 101c780:	88801004 	addi	r2,r17,64
 101c784:	28800226 	beq	r5,r2,101c790 <__sflush_r+0xcc>
 101c788:	9809883a 	mov	r4,r19
 101c78c:	101ce300 	call	101ce30 <_free_r>
 101c790:	88000c15 	stw	zero,48(r17)
 101c794:	0005883a 	mov	r2,zero
 101c798:	dfc00417 	ldw	ra,16(sp)
 101c79c:	dcc00317 	ldw	r19,12(sp)
 101c7a0:	dc800217 	ldw	r18,8(sp)
 101c7a4:	dc400117 	ldw	r17,4(sp)
 101c7a8:	dc000017 	ldw	r16,0(sp)
 101c7ac:	dec00504 	addi	sp,sp,20
 101c7b0:	f800283a 	ret
 101c7b4:	2c800417 	ldw	r18,16(r5)
 101c7b8:	903ff626 	beq	r18,zero,101c794 <__alt_data_end+0xff01c794>
 101c7bc:	2c000017 	ldw	r16,0(r5)
 101c7c0:	108000cc 	andi	r2,r2,3
 101c7c4:	2c800015 	stw	r18,0(r5)
 101c7c8:	84a1c83a 	sub	r16,r16,r18
 101c7cc:	1000131e 	bne	r2,zero,101c81c <__sflush_r+0x158>
 101c7d0:	28800517 	ldw	r2,20(r5)
 101c7d4:	88800215 	stw	r2,8(r17)
 101c7d8:	04000316 	blt	zero,r16,101c7e8 <__sflush_r+0x124>
 101c7dc:	003fed06 	br	101c794 <__alt_data_end+0xff01c794>
 101c7e0:	90a5883a 	add	r18,r18,r2
 101c7e4:	043feb0e 	bge	zero,r16,101c794 <__alt_data_end+0xff01c794>
 101c7e8:	88800917 	ldw	r2,36(r17)
 101c7ec:	89400717 	ldw	r5,28(r17)
 101c7f0:	800f883a 	mov	r7,r16
 101c7f4:	900d883a 	mov	r6,r18
 101c7f8:	9809883a 	mov	r4,r19
 101c7fc:	103ee83a 	callr	r2
 101c800:	80a1c83a 	sub	r16,r16,r2
 101c804:	00bff616 	blt	zero,r2,101c7e0 <__alt_data_end+0xff01c7e0>
 101c808:	88c0030b 	ldhu	r3,12(r17)
 101c80c:	00bfffc4 	movi	r2,-1
 101c810:	18c01014 	ori	r3,r3,64
 101c814:	88c0030d 	sth	r3,12(r17)
 101c818:	003fdf06 	br	101c798 <__alt_data_end+0xff01c798>
 101c81c:	0005883a 	mov	r2,zero
 101c820:	003fec06 	br	101c7d4 <__alt_data_end+0xff01c7d4>
 101c824:	88801415 	stw	r2,80(r17)
 101c828:	003fd206 	br	101c774 <__alt_data_end+0xff01c774>
 101c82c:	28c00f17 	ldw	r3,60(r5)
 101c830:	00ffb316 	blt	zero,r3,101c700 <__alt_data_end+0xff01c700>
 101c834:	003fd706 	br	101c794 <__alt_data_end+0xff01c794>
 101c838:	89400717 	ldw	r5,28(r17)
 101c83c:	000d883a 	mov	r6,zero
 101c840:	01c00044 	movi	r7,1
 101c844:	9809883a 	mov	r4,r19
 101c848:	403ee83a 	callr	r8
 101c84c:	100d883a 	mov	r6,r2
 101c850:	00bfffc4 	movi	r2,-1
 101c854:	30801426 	beq	r6,r2,101c8a8 <__sflush_r+0x1e4>
 101c858:	8880030b 	ldhu	r2,12(r17)
 101c85c:	8a000a17 	ldw	r8,40(r17)
 101c860:	003fae06 	br	101c71c <__alt_data_end+0xff01c71c>
 101c864:	98c00017 	ldw	r3,0(r19)
 101c868:	183fba26 	beq	r3,zero,101c754 <__alt_data_end+0xff01c754>
 101c86c:	01000744 	movi	r4,29
 101c870:	19000626 	beq	r3,r4,101c88c <__sflush_r+0x1c8>
 101c874:	01000584 	movi	r4,22
 101c878:	19000426 	beq	r3,r4,101c88c <__sflush_r+0x1c8>
 101c87c:	88c0030b 	ldhu	r3,12(r17)
 101c880:	18c01014 	ori	r3,r3,64
 101c884:	88c0030d 	sth	r3,12(r17)
 101c888:	003fc306 	br	101c798 <__alt_data_end+0xff01c798>
 101c88c:	8880030b 	ldhu	r2,12(r17)
 101c890:	88c00417 	ldw	r3,16(r17)
 101c894:	88000115 	stw	zero,4(r17)
 101c898:	10bdffcc 	andi	r2,r2,63487
 101c89c:	8880030d 	sth	r2,12(r17)
 101c8a0:	88c00015 	stw	r3,0(r17)
 101c8a4:	003fb306 	br	101c774 <__alt_data_end+0xff01c774>
 101c8a8:	98800017 	ldw	r2,0(r19)
 101c8ac:	103fea26 	beq	r2,zero,101c858 <__alt_data_end+0xff01c858>
 101c8b0:	00c00744 	movi	r3,29
 101c8b4:	10c00226 	beq	r2,r3,101c8c0 <__sflush_r+0x1fc>
 101c8b8:	00c00584 	movi	r3,22
 101c8bc:	10c0031e 	bne	r2,r3,101c8cc <__sflush_r+0x208>
 101c8c0:	9c000015 	stw	r16,0(r19)
 101c8c4:	0005883a 	mov	r2,zero
 101c8c8:	003fb306 	br	101c798 <__alt_data_end+0xff01c798>
 101c8cc:	88c0030b 	ldhu	r3,12(r17)
 101c8d0:	3005883a 	mov	r2,r6
 101c8d4:	18c01014 	ori	r3,r3,64
 101c8d8:	88c0030d 	sth	r3,12(r17)
 101c8dc:	003fae06 	br	101c798 <__alt_data_end+0xff01c798>

0101c8e0 <_fflush_r>:
 101c8e0:	defffd04 	addi	sp,sp,-12
 101c8e4:	dc000115 	stw	r16,4(sp)
 101c8e8:	dfc00215 	stw	ra,8(sp)
 101c8ec:	2021883a 	mov	r16,r4
 101c8f0:	20000226 	beq	r4,zero,101c8fc <_fflush_r+0x1c>
 101c8f4:	20800e17 	ldw	r2,56(r4)
 101c8f8:	10000c26 	beq	r2,zero,101c92c <_fflush_r+0x4c>
 101c8fc:	2880030f 	ldh	r2,12(r5)
 101c900:	1000051e 	bne	r2,zero,101c918 <_fflush_r+0x38>
 101c904:	0005883a 	mov	r2,zero
 101c908:	dfc00217 	ldw	ra,8(sp)
 101c90c:	dc000117 	ldw	r16,4(sp)
 101c910:	dec00304 	addi	sp,sp,12
 101c914:	f800283a 	ret
 101c918:	8009883a 	mov	r4,r16
 101c91c:	dfc00217 	ldw	ra,8(sp)
 101c920:	dc000117 	ldw	r16,4(sp)
 101c924:	dec00304 	addi	sp,sp,12
 101c928:	101c6c41 	jmpi	101c6c4 <__sflush_r>
 101c92c:	d9400015 	stw	r5,0(sp)
 101c930:	101ccbc0 	call	101ccbc <__sinit>
 101c934:	d9400017 	ldw	r5,0(sp)
 101c938:	003ff006 	br	101c8fc <__alt_data_end+0xff01c8fc>

0101c93c <fflush>:
 101c93c:	20000526 	beq	r4,zero,101c954 <fflush+0x18>
 101c940:	008040f4 	movhi	r2,259
 101c944:	10b25d04 	addi	r2,r2,-13964
 101c948:	200b883a 	mov	r5,r4
 101c94c:	11000017 	ldw	r4,0(r2)
 101c950:	101c8e01 	jmpi	101c8e0 <_fflush_r>
 101c954:	008040f4 	movhi	r2,259
 101c958:	10b25c04 	addi	r2,r2,-13968
 101c95c:	11000017 	ldw	r4,0(r2)
 101c960:	014040b4 	movhi	r5,258
 101c964:	29723804 	addi	r5,r5,-14112
 101c968:	101d6c01 	jmpi	101d6c0 <_fwalk_reent>

0101c96c <__fp_unlock>:
 101c96c:	0005883a 	mov	r2,zero
 101c970:	f800283a 	ret

0101c974 <_cleanup_r>:
 101c974:	014040b4 	movhi	r5,258
 101c978:	294aa704 	addi	r5,r5,10908
 101c97c:	101d6c01 	jmpi	101d6c0 <_fwalk_reent>

0101c980 <__sinit.part.1>:
 101c980:	defff704 	addi	sp,sp,-36
 101c984:	00c040b4 	movhi	r3,258
 101c988:	dfc00815 	stw	ra,32(sp)
 101c98c:	ddc00715 	stw	r23,28(sp)
 101c990:	dd800615 	stw	r22,24(sp)
 101c994:	dd400515 	stw	r21,20(sp)
 101c998:	dd000415 	stw	r20,16(sp)
 101c99c:	dcc00315 	stw	r19,12(sp)
 101c9a0:	dc800215 	stw	r18,8(sp)
 101c9a4:	dc400115 	stw	r17,4(sp)
 101c9a8:	dc000015 	stw	r16,0(sp)
 101c9ac:	18f25d04 	addi	r3,r3,-13964
 101c9b0:	24000117 	ldw	r16,4(r4)
 101c9b4:	20c00f15 	stw	r3,60(r4)
 101c9b8:	2080bb04 	addi	r2,r4,748
 101c9bc:	00c000c4 	movi	r3,3
 101c9c0:	20c0b915 	stw	r3,740(r4)
 101c9c4:	2080ba15 	stw	r2,744(r4)
 101c9c8:	2000b815 	stw	zero,736(r4)
 101c9cc:	05c00204 	movi	r23,8
 101c9d0:	00800104 	movi	r2,4
 101c9d4:	2025883a 	mov	r18,r4
 101c9d8:	b80d883a 	mov	r6,r23
 101c9dc:	81001704 	addi	r4,r16,92
 101c9e0:	000b883a 	mov	r5,zero
 101c9e4:	80000015 	stw	zero,0(r16)
 101c9e8:	80000115 	stw	zero,4(r16)
 101c9ec:	80000215 	stw	zero,8(r16)
 101c9f0:	8080030d 	sth	r2,12(r16)
 101c9f4:	80001915 	stw	zero,100(r16)
 101c9f8:	8000038d 	sth	zero,14(r16)
 101c9fc:	80000415 	stw	zero,16(r16)
 101ca00:	80000515 	stw	zero,20(r16)
 101ca04:	80000615 	stw	zero,24(r16)
 101ca08:	1015a3c0 	call	1015a3c <memset>
 101ca0c:	058040b4 	movhi	r22,258
 101ca10:	94400217 	ldw	r17,8(r18)
 101ca14:	054040b4 	movhi	r21,258
 101ca18:	050040b4 	movhi	r20,258
 101ca1c:	04c040b4 	movhi	r19,258
 101ca20:	b5bf6504 	addi	r22,r22,-620
 101ca24:	ad7f7c04 	addi	r21,r21,-528
 101ca28:	a53f9b04 	addi	r20,r20,-404
 101ca2c:	9cffb204 	addi	r19,r19,-312
 101ca30:	85800815 	stw	r22,32(r16)
 101ca34:	85400915 	stw	r21,36(r16)
 101ca38:	85000a15 	stw	r20,40(r16)
 101ca3c:	84c00b15 	stw	r19,44(r16)
 101ca40:	84000715 	stw	r16,28(r16)
 101ca44:	00800284 	movi	r2,10
 101ca48:	8880030d 	sth	r2,12(r17)
 101ca4c:	00800044 	movi	r2,1
 101ca50:	b80d883a 	mov	r6,r23
 101ca54:	89001704 	addi	r4,r17,92
 101ca58:	000b883a 	mov	r5,zero
 101ca5c:	88000015 	stw	zero,0(r17)
 101ca60:	88000115 	stw	zero,4(r17)
 101ca64:	88000215 	stw	zero,8(r17)
 101ca68:	88001915 	stw	zero,100(r17)
 101ca6c:	8880038d 	sth	r2,14(r17)
 101ca70:	88000415 	stw	zero,16(r17)
 101ca74:	88000515 	stw	zero,20(r17)
 101ca78:	88000615 	stw	zero,24(r17)
 101ca7c:	1015a3c0 	call	1015a3c <memset>
 101ca80:	94000317 	ldw	r16,12(r18)
 101ca84:	00800484 	movi	r2,18
 101ca88:	8c400715 	stw	r17,28(r17)
 101ca8c:	8d800815 	stw	r22,32(r17)
 101ca90:	8d400915 	stw	r21,36(r17)
 101ca94:	8d000a15 	stw	r20,40(r17)
 101ca98:	8cc00b15 	stw	r19,44(r17)
 101ca9c:	8080030d 	sth	r2,12(r16)
 101caa0:	00800084 	movi	r2,2
 101caa4:	80000015 	stw	zero,0(r16)
 101caa8:	80000115 	stw	zero,4(r16)
 101caac:	80000215 	stw	zero,8(r16)
 101cab0:	80001915 	stw	zero,100(r16)
 101cab4:	8080038d 	sth	r2,14(r16)
 101cab8:	80000415 	stw	zero,16(r16)
 101cabc:	80000515 	stw	zero,20(r16)
 101cac0:	80000615 	stw	zero,24(r16)
 101cac4:	b80d883a 	mov	r6,r23
 101cac8:	000b883a 	mov	r5,zero
 101cacc:	81001704 	addi	r4,r16,92
 101cad0:	1015a3c0 	call	1015a3c <memset>
 101cad4:	00800044 	movi	r2,1
 101cad8:	84000715 	stw	r16,28(r16)
 101cadc:	85800815 	stw	r22,32(r16)
 101cae0:	85400915 	stw	r21,36(r16)
 101cae4:	85000a15 	stw	r20,40(r16)
 101cae8:	84c00b15 	stw	r19,44(r16)
 101caec:	90800e15 	stw	r2,56(r18)
 101caf0:	dfc00817 	ldw	ra,32(sp)
 101caf4:	ddc00717 	ldw	r23,28(sp)
 101caf8:	dd800617 	ldw	r22,24(sp)
 101cafc:	dd400517 	ldw	r21,20(sp)
 101cb00:	dd000417 	ldw	r20,16(sp)
 101cb04:	dcc00317 	ldw	r19,12(sp)
 101cb08:	dc800217 	ldw	r18,8(sp)
 101cb0c:	dc400117 	ldw	r17,4(sp)
 101cb10:	dc000017 	ldw	r16,0(sp)
 101cb14:	dec00904 	addi	sp,sp,36
 101cb18:	f800283a 	ret

0101cb1c <__fp_lock>:
 101cb1c:	0005883a 	mov	r2,zero
 101cb20:	f800283a 	ret

0101cb24 <__sfmoreglue>:
 101cb24:	defffc04 	addi	sp,sp,-16
 101cb28:	dc400115 	stw	r17,4(sp)
 101cb2c:	2c7fffc4 	addi	r17,r5,-1
 101cb30:	8c401a24 	muli	r17,r17,104
 101cb34:	dc800215 	stw	r18,8(sp)
 101cb38:	2825883a 	mov	r18,r5
 101cb3c:	89401d04 	addi	r5,r17,116
 101cb40:	dc000015 	stw	r16,0(sp)
 101cb44:	dfc00315 	stw	ra,12(sp)
 101cb48:	101da1c0 	call	101da1c <_malloc_r>
 101cb4c:	1021883a 	mov	r16,r2
 101cb50:	10000726 	beq	r2,zero,101cb70 <__sfmoreglue+0x4c>
 101cb54:	11000304 	addi	r4,r2,12
 101cb58:	10000015 	stw	zero,0(r2)
 101cb5c:	14800115 	stw	r18,4(r2)
 101cb60:	11000215 	stw	r4,8(r2)
 101cb64:	89801a04 	addi	r6,r17,104
 101cb68:	000b883a 	mov	r5,zero
 101cb6c:	1015a3c0 	call	1015a3c <memset>
 101cb70:	8005883a 	mov	r2,r16
 101cb74:	dfc00317 	ldw	ra,12(sp)
 101cb78:	dc800217 	ldw	r18,8(sp)
 101cb7c:	dc400117 	ldw	r17,4(sp)
 101cb80:	dc000017 	ldw	r16,0(sp)
 101cb84:	dec00404 	addi	sp,sp,16
 101cb88:	f800283a 	ret

0101cb8c <__sfp>:
 101cb8c:	defffb04 	addi	sp,sp,-20
 101cb90:	dc000015 	stw	r16,0(sp)
 101cb94:	040040f4 	movhi	r16,259
 101cb98:	84325c04 	addi	r16,r16,-13968
 101cb9c:	dcc00315 	stw	r19,12(sp)
 101cba0:	2027883a 	mov	r19,r4
 101cba4:	81000017 	ldw	r4,0(r16)
 101cba8:	dfc00415 	stw	ra,16(sp)
 101cbac:	dc800215 	stw	r18,8(sp)
 101cbb0:	20800e17 	ldw	r2,56(r4)
 101cbb4:	dc400115 	stw	r17,4(sp)
 101cbb8:	1000021e 	bne	r2,zero,101cbc4 <__sfp+0x38>
 101cbbc:	101c9800 	call	101c980 <__sinit.part.1>
 101cbc0:	81000017 	ldw	r4,0(r16)
 101cbc4:	2480b804 	addi	r18,r4,736
 101cbc8:	047fffc4 	movi	r17,-1
 101cbcc:	91000117 	ldw	r4,4(r18)
 101cbd0:	94000217 	ldw	r16,8(r18)
 101cbd4:	213fffc4 	addi	r4,r4,-1
 101cbd8:	20000a16 	blt	r4,zero,101cc04 <__sfp+0x78>
 101cbdc:	8080030f 	ldh	r2,12(r16)
 101cbe0:	10000c26 	beq	r2,zero,101cc14 <__sfp+0x88>
 101cbe4:	80c01d04 	addi	r3,r16,116
 101cbe8:	00000206 	br	101cbf4 <__sfp+0x68>
 101cbec:	18bfe60f 	ldh	r2,-104(r3)
 101cbf0:	10000826 	beq	r2,zero,101cc14 <__sfp+0x88>
 101cbf4:	213fffc4 	addi	r4,r4,-1
 101cbf8:	1c3ffd04 	addi	r16,r3,-12
 101cbfc:	18c01a04 	addi	r3,r3,104
 101cc00:	247ffa1e 	bne	r4,r17,101cbec <__alt_data_end+0xff01cbec>
 101cc04:	90800017 	ldw	r2,0(r18)
 101cc08:	10001d26 	beq	r2,zero,101cc80 <__sfp+0xf4>
 101cc0c:	1025883a 	mov	r18,r2
 101cc10:	003fee06 	br	101cbcc <__alt_data_end+0xff01cbcc>
 101cc14:	00bfffc4 	movi	r2,-1
 101cc18:	8080038d 	sth	r2,14(r16)
 101cc1c:	00800044 	movi	r2,1
 101cc20:	8080030d 	sth	r2,12(r16)
 101cc24:	80001915 	stw	zero,100(r16)
 101cc28:	80000015 	stw	zero,0(r16)
 101cc2c:	80000215 	stw	zero,8(r16)
 101cc30:	80000115 	stw	zero,4(r16)
 101cc34:	80000415 	stw	zero,16(r16)
 101cc38:	80000515 	stw	zero,20(r16)
 101cc3c:	80000615 	stw	zero,24(r16)
 101cc40:	01800204 	movi	r6,8
 101cc44:	000b883a 	mov	r5,zero
 101cc48:	81001704 	addi	r4,r16,92
 101cc4c:	1015a3c0 	call	1015a3c <memset>
 101cc50:	8005883a 	mov	r2,r16
 101cc54:	80000c15 	stw	zero,48(r16)
 101cc58:	80000d15 	stw	zero,52(r16)
 101cc5c:	80001115 	stw	zero,68(r16)
 101cc60:	80001215 	stw	zero,72(r16)
 101cc64:	dfc00417 	ldw	ra,16(sp)
 101cc68:	dcc00317 	ldw	r19,12(sp)
 101cc6c:	dc800217 	ldw	r18,8(sp)
 101cc70:	dc400117 	ldw	r17,4(sp)
 101cc74:	dc000017 	ldw	r16,0(sp)
 101cc78:	dec00504 	addi	sp,sp,20
 101cc7c:	f800283a 	ret
 101cc80:	01400104 	movi	r5,4
 101cc84:	9809883a 	mov	r4,r19
 101cc88:	101cb240 	call	101cb24 <__sfmoreglue>
 101cc8c:	90800015 	stw	r2,0(r18)
 101cc90:	103fde1e 	bne	r2,zero,101cc0c <__alt_data_end+0xff01cc0c>
 101cc94:	00800304 	movi	r2,12
 101cc98:	98800015 	stw	r2,0(r19)
 101cc9c:	0005883a 	mov	r2,zero
 101cca0:	003ff006 	br	101cc64 <__alt_data_end+0xff01cc64>

0101cca4 <_cleanup>:
 101cca4:	008040f4 	movhi	r2,259
 101cca8:	10b25c04 	addi	r2,r2,-13968
 101ccac:	11000017 	ldw	r4,0(r2)
 101ccb0:	014040b4 	movhi	r5,258
 101ccb4:	294aa704 	addi	r5,r5,10908
 101ccb8:	101d6c01 	jmpi	101d6c0 <_fwalk_reent>

0101ccbc <__sinit>:
 101ccbc:	20800e17 	ldw	r2,56(r4)
 101ccc0:	10000126 	beq	r2,zero,101ccc8 <__sinit+0xc>
 101ccc4:	f800283a 	ret
 101ccc8:	101c9801 	jmpi	101c980 <__sinit.part.1>

0101cccc <__sfp_lock_acquire>:
 101cccc:	f800283a 	ret

0101ccd0 <__sfp_lock_release>:
 101ccd0:	f800283a 	ret

0101ccd4 <__sinit_lock_acquire>:
 101ccd4:	f800283a 	ret

0101ccd8 <__sinit_lock_release>:
 101ccd8:	f800283a 	ret

0101ccdc <__fp_lock_all>:
 101ccdc:	008040f4 	movhi	r2,259
 101cce0:	10b25d04 	addi	r2,r2,-13964
 101cce4:	11000017 	ldw	r4,0(r2)
 101cce8:	014040b4 	movhi	r5,258
 101ccec:	2972c704 	addi	r5,r5,-13540
 101ccf0:	101d5fc1 	jmpi	101d5fc <_fwalk>

0101ccf4 <__fp_unlock_all>:
 101ccf4:	008040f4 	movhi	r2,259
 101ccf8:	10b25d04 	addi	r2,r2,-13964
 101ccfc:	11000017 	ldw	r4,0(r2)
 101cd00:	014040b4 	movhi	r5,258
 101cd04:	29725b04 	addi	r5,r5,-13972
 101cd08:	101d5fc1 	jmpi	101d5fc <_fwalk>

0101cd0c <_malloc_trim_r>:
 101cd0c:	defffb04 	addi	sp,sp,-20
 101cd10:	dcc00315 	stw	r19,12(sp)
 101cd14:	04c040f4 	movhi	r19,259
 101cd18:	dc800215 	stw	r18,8(sp)
 101cd1c:	dc400115 	stw	r17,4(sp)
 101cd20:	dc000015 	stw	r16,0(sp)
 101cd24:	dfc00415 	stw	ra,16(sp)
 101cd28:	2821883a 	mov	r16,r5
 101cd2c:	9cecca04 	addi	r19,r19,-19672
 101cd30:	2025883a 	mov	r18,r4
 101cd34:	1026ed00 	call	1026ed0 <__malloc_lock>
 101cd38:	98800217 	ldw	r2,8(r19)
 101cd3c:	14400117 	ldw	r17,4(r2)
 101cd40:	00bfff04 	movi	r2,-4
 101cd44:	88a2703a 	and	r17,r17,r2
 101cd48:	8c21c83a 	sub	r16,r17,r16
 101cd4c:	8403fbc4 	addi	r16,r16,4079
 101cd50:	8020d33a 	srli	r16,r16,12
 101cd54:	0083ffc4 	movi	r2,4095
 101cd58:	843fffc4 	addi	r16,r16,-1
 101cd5c:	8020933a 	slli	r16,r16,12
 101cd60:	1400060e 	bge	r2,r16,101cd7c <_malloc_trim_r+0x70>
 101cd64:	000b883a 	mov	r5,zero
 101cd68:	9009883a 	mov	r4,r18
 101cd6c:	101fa3c0 	call	101fa3c <_sbrk_r>
 101cd70:	98c00217 	ldw	r3,8(r19)
 101cd74:	1c47883a 	add	r3,r3,r17
 101cd78:	10c00a26 	beq	r2,r3,101cda4 <_malloc_trim_r+0x98>
 101cd7c:	9009883a 	mov	r4,r18
 101cd80:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101cd84:	0005883a 	mov	r2,zero
 101cd88:	dfc00417 	ldw	ra,16(sp)
 101cd8c:	dcc00317 	ldw	r19,12(sp)
 101cd90:	dc800217 	ldw	r18,8(sp)
 101cd94:	dc400117 	ldw	r17,4(sp)
 101cd98:	dc000017 	ldw	r16,0(sp)
 101cd9c:	dec00504 	addi	sp,sp,20
 101cda0:	f800283a 	ret
 101cda4:	040bc83a 	sub	r5,zero,r16
 101cda8:	9009883a 	mov	r4,r18
 101cdac:	101fa3c0 	call	101fa3c <_sbrk_r>
 101cdb0:	00ffffc4 	movi	r3,-1
 101cdb4:	10c00d26 	beq	r2,r3,101cdec <_malloc_trim_r+0xe0>
 101cdb8:	00c060f4 	movhi	r3,387
 101cdbc:	18fae704 	addi	r3,r3,-5220
 101cdc0:	18800017 	ldw	r2,0(r3)
 101cdc4:	99000217 	ldw	r4,8(r19)
 101cdc8:	8c23c83a 	sub	r17,r17,r16
 101cdcc:	8c400054 	ori	r17,r17,1
 101cdd0:	1421c83a 	sub	r16,r2,r16
 101cdd4:	24400115 	stw	r17,4(r4)
 101cdd8:	9009883a 	mov	r4,r18
 101cddc:	1c000015 	stw	r16,0(r3)
 101cde0:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101cde4:	00800044 	movi	r2,1
 101cde8:	003fe706 	br	101cd88 <__alt_data_end+0xff01cd88>
 101cdec:	000b883a 	mov	r5,zero
 101cdf0:	9009883a 	mov	r4,r18
 101cdf4:	101fa3c0 	call	101fa3c <_sbrk_r>
 101cdf8:	99000217 	ldw	r4,8(r19)
 101cdfc:	014003c4 	movi	r5,15
 101ce00:	1107c83a 	sub	r3,r2,r4
 101ce04:	28ffdd0e 	bge	r5,r3,101cd7c <__alt_data_end+0xff01cd7c>
 101ce08:	014040f4 	movhi	r5,259
 101ce0c:	29725f04 	addi	r5,r5,-13956
 101ce10:	29400017 	ldw	r5,0(r5)
 101ce14:	18c00054 	ori	r3,r3,1
 101ce18:	20c00115 	stw	r3,4(r4)
 101ce1c:	00c060f4 	movhi	r3,387
 101ce20:	1145c83a 	sub	r2,r2,r5
 101ce24:	18fae704 	addi	r3,r3,-5220
 101ce28:	18800015 	stw	r2,0(r3)
 101ce2c:	003fd306 	br	101cd7c <__alt_data_end+0xff01cd7c>

0101ce30 <_free_r>:
 101ce30:	28004126 	beq	r5,zero,101cf38 <_free_r+0x108>
 101ce34:	defffd04 	addi	sp,sp,-12
 101ce38:	dc400115 	stw	r17,4(sp)
 101ce3c:	dc000015 	stw	r16,0(sp)
 101ce40:	2023883a 	mov	r17,r4
 101ce44:	2821883a 	mov	r16,r5
 101ce48:	dfc00215 	stw	ra,8(sp)
 101ce4c:	1026ed00 	call	1026ed0 <__malloc_lock>
 101ce50:	81ffff17 	ldw	r7,-4(r16)
 101ce54:	00bfff84 	movi	r2,-2
 101ce58:	010040f4 	movhi	r4,259
 101ce5c:	81bffe04 	addi	r6,r16,-8
 101ce60:	3884703a 	and	r2,r7,r2
 101ce64:	212cca04 	addi	r4,r4,-19672
 101ce68:	308b883a 	add	r5,r6,r2
 101ce6c:	2a400117 	ldw	r9,4(r5)
 101ce70:	22000217 	ldw	r8,8(r4)
 101ce74:	00ffff04 	movi	r3,-4
 101ce78:	48c6703a 	and	r3,r9,r3
 101ce7c:	2a005726 	beq	r5,r8,101cfdc <_free_r+0x1ac>
 101ce80:	28c00115 	stw	r3,4(r5)
 101ce84:	39c0004c 	andi	r7,r7,1
 101ce88:	3800091e 	bne	r7,zero,101ceb0 <_free_r+0x80>
 101ce8c:	823ffe17 	ldw	r8,-8(r16)
 101ce90:	22400204 	addi	r9,r4,8
 101ce94:	320dc83a 	sub	r6,r6,r8
 101ce98:	31c00217 	ldw	r7,8(r6)
 101ce9c:	1205883a 	add	r2,r2,r8
 101cea0:	3a406526 	beq	r7,r9,101d038 <_free_r+0x208>
 101cea4:	32000317 	ldw	r8,12(r6)
 101cea8:	3a000315 	stw	r8,12(r7)
 101ceac:	41c00215 	stw	r7,8(r8)
 101ceb0:	28cf883a 	add	r7,r5,r3
 101ceb4:	39c00117 	ldw	r7,4(r7)
 101ceb8:	39c0004c 	andi	r7,r7,1
 101cebc:	38003a26 	beq	r7,zero,101cfa8 <_free_r+0x178>
 101cec0:	10c00054 	ori	r3,r2,1
 101cec4:	30c00115 	stw	r3,4(r6)
 101cec8:	3087883a 	add	r3,r6,r2
 101cecc:	18800015 	stw	r2,0(r3)
 101ced0:	00c07fc4 	movi	r3,511
 101ced4:	18801936 	bltu	r3,r2,101cf3c <_free_r+0x10c>
 101ced8:	1004d0fa 	srli	r2,r2,3
 101cedc:	01c00044 	movi	r7,1
 101cee0:	21400117 	ldw	r5,4(r4)
 101cee4:	10c00044 	addi	r3,r2,1
 101cee8:	18c7883a 	add	r3,r3,r3
 101ceec:	1005d0ba 	srai	r2,r2,2
 101cef0:	18c7883a 	add	r3,r3,r3
 101cef4:	18c7883a 	add	r3,r3,r3
 101cef8:	1907883a 	add	r3,r3,r4
 101cefc:	3884983a 	sll	r2,r7,r2
 101cf00:	19c00017 	ldw	r7,0(r3)
 101cf04:	1a3ffe04 	addi	r8,r3,-8
 101cf08:	1144b03a 	or	r2,r2,r5
 101cf0c:	32000315 	stw	r8,12(r6)
 101cf10:	31c00215 	stw	r7,8(r6)
 101cf14:	20800115 	stw	r2,4(r4)
 101cf18:	19800015 	stw	r6,0(r3)
 101cf1c:	39800315 	stw	r6,12(r7)
 101cf20:	8809883a 	mov	r4,r17
 101cf24:	dfc00217 	ldw	ra,8(sp)
 101cf28:	dc400117 	ldw	r17,4(sp)
 101cf2c:	dc000017 	ldw	r16,0(sp)
 101cf30:	dec00304 	addi	sp,sp,12
 101cf34:	1026ef41 	jmpi	1026ef4 <__malloc_unlock>
 101cf38:	f800283a 	ret
 101cf3c:	100ad27a 	srli	r5,r2,9
 101cf40:	00c00104 	movi	r3,4
 101cf44:	19404a36 	bltu	r3,r5,101d070 <_free_r+0x240>
 101cf48:	100ad1ba 	srli	r5,r2,6
 101cf4c:	28c00e44 	addi	r3,r5,57
 101cf50:	18c7883a 	add	r3,r3,r3
 101cf54:	29400e04 	addi	r5,r5,56
 101cf58:	18c7883a 	add	r3,r3,r3
 101cf5c:	18c7883a 	add	r3,r3,r3
 101cf60:	1909883a 	add	r4,r3,r4
 101cf64:	20c00017 	ldw	r3,0(r4)
 101cf68:	01c040f4 	movhi	r7,259
 101cf6c:	213ffe04 	addi	r4,r4,-8
 101cf70:	39ecca04 	addi	r7,r7,-19672
 101cf74:	20c04426 	beq	r4,r3,101d088 <_free_r+0x258>
 101cf78:	01ffff04 	movi	r7,-4
 101cf7c:	19400117 	ldw	r5,4(r3)
 101cf80:	29ca703a 	and	r5,r5,r7
 101cf84:	1140022e 	bgeu	r2,r5,101cf90 <_free_r+0x160>
 101cf88:	18c00217 	ldw	r3,8(r3)
 101cf8c:	20fffb1e 	bne	r4,r3,101cf7c <__alt_data_end+0xff01cf7c>
 101cf90:	19000317 	ldw	r4,12(r3)
 101cf94:	31000315 	stw	r4,12(r6)
 101cf98:	30c00215 	stw	r3,8(r6)
 101cf9c:	21800215 	stw	r6,8(r4)
 101cfa0:	19800315 	stw	r6,12(r3)
 101cfa4:	003fde06 	br	101cf20 <__alt_data_end+0xff01cf20>
 101cfa8:	29c00217 	ldw	r7,8(r5)
 101cfac:	10c5883a 	add	r2,r2,r3
 101cfb0:	00c040f4 	movhi	r3,259
 101cfb4:	18eccc04 	addi	r3,r3,-19664
 101cfb8:	38c03b26 	beq	r7,r3,101d0a8 <_free_r+0x278>
 101cfbc:	2a000317 	ldw	r8,12(r5)
 101cfc0:	11400054 	ori	r5,r2,1
 101cfc4:	3087883a 	add	r3,r6,r2
 101cfc8:	3a000315 	stw	r8,12(r7)
 101cfcc:	41c00215 	stw	r7,8(r8)
 101cfd0:	31400115 	stw	r5,4(r6)
 101cfd4:	18800015 	stw	r2,0(r3)
 101cfd8:	003fbd06 	br	101ced0 <__alt_data_end+0xff01ced0>
 101cfdc:	39c0004c 	andi	r7,r7,1
 101cfe0:	10c5883a 	add	r2,r2,r3
 101cfe4:	3800071e 	bne	r7,zero,101d004 <_free_r+0x1d4>
 101cfe8:	81fffe17 	ldw	r7,-8(r16)
 101cfec:	31cdc83a 	sub	r6,r6,r7
 101cff0:	30c00317 	ldw	r3,12(r6)
 101cff4:	31400217 	ldw	r5,8(r6)
 101cff8:	11c5883a 	add	r2,r2,r7
 101cffc:	28c00315 	stw	r3,12(r5)
 101d000:	19400215 	stw	r5,8(r3)
 101d004:	10c00054 	ori	r3,r2,1
 101d008:	30c00115 	stw	r3,4(r6)
 101d00c:	00c040f4 	movhi	r3,259
 101d010:	18f26004 	addi	r3,r3,-13952
 101d014:	18c00017 	ldw	r3,0(r3)
 101d018:	21800215 	stw	r6,8(r4)
 101d01c:	10ffc036 	bltu	r2,r3,101cf20 <__alt_data_end+0xff01cf20>
 101d020:	008040f4 	movhi	r2,259
 101d024:	10b9ac04 	addi	r2,r2,-6480
 101d028:	11400017 	ldw	r5,0(r2)
 101d02c:	8809883a 	mov	r4,r17
 101d030:	101cd0c0 	call	101cd0c <_malloc_trim_r>
 101d034:	003fba06 	br	101cf20 <__alt_data_end+0xff01cf20>
 101d038:	28c9883a 	add	r4,r5,r3
 101d03c:	21000117 	ldw	r4,4(r4)
 101d040:	2100004c 	andi	r4,r4,1
 101d044:	2000391e 	bne	r4,zero,101d12c <_free_r+0x2fc>
 101d048:	29c00217 	ldw	r7,8(r5)
 101d04c:	29000317 	ldw	r4,12(r5)
 101d050:	1885883a 	add	r2,r3,r2
 101d054:	10c00054 	ori	r3,r2,1
 101d058:	39000315 	stw	r4,12(r7)
 101d05c:	21c00215 	stw	r7,8(r4)
 101d060:	30c00115 	stw	r3,4(r6)
 101d064:	308d883a 	add	r6,r6,r2
 101d068:	30800015 	stw	r2,0(r6)
 101d06c:	003fac06 	br	101cf20 <__alt_data_end+0xff01cf20>
 101d070:	00c00504 	movi	r3,20
 101d074:	19401536 	bltu	r3,r5,101d0cc <_free_r+0x29c>
 101d078:	28c01704 	addi	r3,r5,92
 101d07c:	18c7883a 	add	r3,r3,r3
 101d080:	294016c4 	addi	r5,r5,91
 101d084:	003fb406 	br	101cf58 <__alt_data_end+0xff01cf58>
 101d088:	280bd0ba 	srai	r5,r5,2
 101d08c:	00c00044 	movi	r3,1
 101d090:	38800117 	ldw	r2,4(r7)
 101d094:	194a983a 	sll	r5,r3,r5
 101d098:	2007883a 	mov	r3,r4
 101d09c:	2884b03a 	or	r2,r5,r2
 101d0a0:	38800115 	stw	r2,4(r7)
 101d0a4:	003fbb06 	br	101cf94 <__alt_data_end+0xff01cf94>
 101d0a8:	21800515 	stw	r6,20(r4)
 101d0ac:	21800415 	stw	r6,16(r4)
 101d0b0:	10c00054 	ori	r3,r2,1
 101d0b4:	31c00315 	stw	r7,12(r6)
 101d0b8:	31c00215 	stw	r7,8(r6)
 101d0bc:	30c00115 	stw	r3,4(r6)
 101d0c0:	308d883a 	add	r6,r6,r2
 101d0c4:	30800015 	stw	r2,0(r6)
 101d0c8:	003f9506 	br	101cf20 <__alt_data_end+0xff01cf20>
 101d0cc:	00c01504 	movi	r3,84
 101d0d0:	19400536 	bltu	r3,r5,101d0e8 <_free_r+0x2b8>
 101d0d4:	100ad33a 	srli	r5,r2,12
 101d0d8:	28c01bc4 	addi	r3,r5,111
 101d0dc:	18c7883a 	add	r3,r3,r3
 101d0e0:	29401b84 	addi	r5,r5,110
 101d0e4:	003f9c06 	br	101cf58 <__alt_data_end+0xff01cf58>
 101d0e8:	00c05504 	movi	r3,340
 101d0ec:	19400536 	bltu	r3,r5,101d104 <_free_r+0x2d4>
 101d0f0:	100ad3fa 	srli	r5,r2,15
 101d0f4:	28c01e04 	addi	r3,r5,120
 101d0f8:	18c7883a 	add	r3,r3,r3
 101d0fc:	29401dc4 	addi	r5,r5,119
 101d100:	003f9506 	br	101cf58 <__alt_data_end+0xff01cf58>
 101d104:	00c15504 	movi	r3,1364
 101d108:	19400536 	bltu	r3,r5,101d120 <_free_r+0x2f0>
 101d10c:	100ad4ba 	srli	r5,r2,18
 101d110:	28c01f44 	addi	r3,r5,125
 101d114:	18c7883a 	add	r3,r3,r3
 101d118:	29401f04 	addi	r5,r5,124
 101d11c:	003f8e06 	br	101cf58 <__alt_data_end+0xff01cf58>
 101d120:	00c03f84 	movi	r3,254
 101d124:	01401f84 	movi	r5,126
 101d128:	003f8b06 	br	101cf58 <__alt_data_end+0xff01cf58>
 101d12c:	10c00054 	ori	r3,r2,1
 101d130:	30c00115 	stw	r3,4(r6)
 101d134:	308d883a 	add	r6,r6,r2
 101d138:	30800015 	stw	r2,0(r6)
 101d13c:	003f7806 	br	101cf20 <__alt_data_end+0xff01cf20>

0101d140 <__sfvwrite_r>:
 101d140:	30800217 	ldw	r2,8(r6)
 101d144:	10006726 	beq	r2,zero,101d2e4 <__sfvwrite_r+0x1a4>
 101d148:	28c0030b 	ldhu	r3,12(r5)
 101d14c:	defff404 	addi	sp,sp,-48
 101d150:	dd400715 	stw	r21,28(sp)
 101d154:	dd000615 	stw	r20,24(sp)
 101d158:	dc000215 	stw	r16,8(sp)
 101d15c:	dfc00b15 	stw	ra,44(sp)
 101d160:	df000a15 	stw	fp,40(sp)
 101d164:	ddc00915 	stw	r23,36(sp)
 101d168:	dd800815 	stw	r22,32(sp)
 101d16c:	dcc00515 	stw	r19,20(sp)
 101d170:	dc800415 	stw	r18,16(sp)
 101d174:	dc400315 	stw	r17,12(sp)
 101d178:	1880020c 	andi	r2,r3,8
 101d17c:	2821883a 	mov	r16,r5
 101d180:	202b883a 	mov	r21,r4
 101d184:	3029883a 	mov	r20,r6
 101d188:	10002726 	beq	r2,zero,101d228 <__sfvwrite_r+0xe8>
 101d18c:	28800417 	ldw	r2,16(r5)
 101d190:	10002526 	beq	r2,zero,101d228 <__sfvwrite_r+0xe8>
 101d194:	1880008c 	andi	r2,r3,2
 101d198:	a4400017 	ldw	r17,0(r20)
 101d19c:	10002a26 	beq	r2,zero,101d248 <__sfvwrite_r+0x108>
 101d1a0:	05a00034 	movhi	r22,32768
 101d1a4:	0027883a 	mov	r19,zero
 101d1a8:	0025883a 	mov	r18,zero
 101d1ac:	b5bf0004 	addi	r22,r22,-1024
 101d1b0:	980d883a 	mov	r6,r19
 101d1b4:	a809883a 	mov	r4,r21
 101d1b8:	90004626 	beq	r18,zero,101d2d4 <__sfvwrite_r+0x194>
 101d1bc:	900f883a 	mov	r7,r18
 101d1c0:	b480022e 	bgeu	r22,r18,101d1cc <__sfvwrite_r+0x8c>
 101d1c4:	01e00034 	movhi	r7,32768
 101d1c8:	39ff0004 	addi	r7,r7,-1024
 101d1cc:	80800917 	ldw	r2,36(r16)
 101d1d0:	81400717 	ldw	r5,28(r16)
 101d1d4:	103ee83a 	callr	r2
 101d1d8:	0080570e 	bge	zero,r2,101d338 <__sfvwrite_r+0x1f8>
 101d1dc:	a0c00217 	ldw	r3,8(r20)
 101d1e0:	98a7883a 	add	r19,r19,r2
 101d1e4:	90a5c83a 	sub	r18,r18,r2
 101d1e8:	1885c83a 	sub	r2,r3,r2
 101d1ec:	a0800215 	stw	r2,8(r20)
 101d1f0:	103fef1e 	bne	r2,zero,101d1b0 <__alt_data_end+0xff01d1b0>
 101d1f4:	0005883a 	mov	r2,zero
 101d1f8:	dfc00b17 	ldw	ra,44(sp)
 101d1fc:	df000a17 	ldw	fp,40(sp)
 101d200:	ddc00917 	ldw	r23,36(sp)
 101d204:	dd800817 	ldw	r22,32(sp)
 101d208:	dd400717 	ldw	r21,28(sp)
 101d20c:	dd000617 	ldw	r20,24(sp)
 101d210:	dcc00517 	ldw	r19,20(sp)
 101d214:	dc800417 	ldw	r18,16(sp)
 101d218:	dc400317 	ldw	r17,12(sp)
 101d21c:	dc000217 	ldw	r16,8(sp)
 101d220:	dec00c04 	addi	sp,sp,48
 101d224:	f800283a 	ret
 101d228:	800b883a 	mov	r5,r16
 101d22c:	a809883a 	mov	r4,r21
 101d230:	101acd00 	call	101acd0 <__swsetup_r>
 101d234:	1000eb1e 	bne	r2,zero,101d5e4 <__sfvwrite_r+0x4a4>
 101d238:	80c0030b 	ldhu	r3,12(r16)
 101d23c:	a4400017 	ldw	r17,0(r20)
 101d240:	1880008c 	andi	r2,r3,2
 101d244:	103fd61e 	bne	r2,zero,101d1a0 <__alt_data_end+0xff01d1a0>
 101d248:	1880004c 	andi	r2,r3,1
 101d24c:	10003f1e 	bne	r2,zero,101d34c <__sfvwrite_r+0x20c>
 101d250:	0039883a 	mov	fp,zero
 101d254:	0025883a 	mov	r18,zero
 101d258:	90001a26 	beq	r18,zero,101d2c4 <__sfvwrite_r+0x184>
 101d25c:	1880800c 	andi	r2,r3,512
 101d260:	84c00217 	ldw	r19,8(r16)
 101d264:	10002126 	beq	r2,zero,101d2ec <__sfvwrite_r+0x1ac>
 101d268:	982f883a 	mov	r23,r19
 101d26c:	94c09336 	bltu	r18,r19,101d4bc <__sfvwrite_r+0x37c>
 101d270:	1881200c 	andi	r2,r3,1152
 101d274:	10009e1e 	bne	r2,zero,101d4f0 <__sfvwrite_r+0x3b0>
 101d278:	81000017 	ldw	r4,0(r16)
 101d27c:	b80d883a 	mov	r6,r23
 101d280:	e00b883a 	mov	r5,fp
 101d284:	101e30c0 	call	101e30c <memmove>
 101d288:	80c00217 	ldw	r3,8(r16)
 101d28c:	81000017 	ldw	r4,0(r16)
 101d290:	9005883a 	mov	r2,r18
 101d294:	1ce7c83a 	sub	r19,r3,r19
 101d298:	25cf883a 	add	r7,r4,r23
 101d29c:	84c00215 	stw	r19,8(r16)
 101d2a0:	81c00015 	stw	r7,0(r16)
 101d2a4:	a0c00217 	ldw	r3,8(r20)
 101d2a8:	e0b9883a 	add	fp,fp,r2
 101d2ac:	90a5c83a 	sub	r18,r18,r2
 101d2b0:	18a7c83a 	sub	r19,r3,r2
 101d2b4:	a4c00215 	stw	r19,8(r20)
 101d2b8:	983fce26 	beq	r19,zero,101d1f4 <__alt_data_end+0xff01d1f4>
 101d2bc:	80c0030b 	ldhu	r3,12(r16)
 101d2c0:	903fe61e 	bne	r18,zero,101d25c <__alt_data_end+0xff01d25c>
 101d2c4:	8f000017 	ldw	fp,0(r17)
 101d2c8:	8c800117 	ldw	r18,4(r17)
 101d2cc:	8c400204 	addi	r17,r17,8
 101d2d0:	003fe106 	br	101d258 <__alt_data_end+0xff01d258>
 101d2d4:	8cc00017 	ldw	r19,0(r17)
 101d2d8:	8c800117 	ldw	r18,4(r17)
 101d2dc:	8c400204 	addi	r17,r17,8
 101d2e0:	003fb306 	br	101d1b0 <__alt_data_end+0xff01d1b0>
 101d2e4:	0005883a 	mov	r2,zero
 101d2e8:	f800283a 	ret
 101d2ec:	81000017 	ldw	r4,0(r16)
 101d2f0:	80800417 	ldw	r2,16(r16)
 101d2f4:	11005736 	bltu	r2,r4,101d454 <__sfvwrite_r+0x314>
 101d2f8:	85c00517 	ldw	r23,20(r16)
 101d2fc:	95c05536 	bltu	r18,r23,101d454 <__sfvwrite_r+0x314>
 101d300:	00a00034 	movhi	r2,32768
 101d304:	10bfffc4 	addi	r2,r2,-1
 101d308:	9009883a 	mov	r4,r18
 101d30c:	1480012e 	bgeu	r2,r18,101d314 <__sfvwrite_r+0x1d4>
 101d310:	1009883a 	mov	r4,r2
 101d314:	b80b883a 	mov	r5,r23
 101d318:	1023d080 	call	1023d08 <__divsi3>
 101d31c:	15cf383a 	mul	r7,r2,r23
 101d320:	81400717 	ldw	r5,28(r16)
 101d324:	80800917 	ldw	r2,36(r16)
 101d328:	e00d883a 	mov	r6,fp
 101d32c:	a809883a 	mov	r4,r21
 101d330:	103ee83a 	callr	r2
 101d334:	00bfdb16 	blt	zero,r2,101d2a4 <__alt_data_end+0xff01d2a4>
 101d338:	8080030b 	ldhu	r2,12(r16)
 101d33c:	10801014 	ori	r2,r2,64
 101d340:	8080030d 	sth	r2,12(r16)
 101d344:	00bfffc4 	movi	r2,-1
 101d348:	003fab06 	br	101d1f8 <__alt_data_end+0xff01d1f8>
 101d34c:	0027883a 	mov	r19,zero
 101d350:	0011883a 	mov	r8,zero
 101d354:	0039883a 	mov	fp,zero
 101d358:	0025883a 	mov	r18,zero
 101d35c:	90001f26 	beq	r18,zero,101d3dc <__sfvwrite_r+0x29c>
 101d360:	40005a26 	beq	r8,zero,101d4cc <__sfvwrite_r+0x38c>
 101d364:	982d883a 	mov	r22,r19
 101d368:	94c0012e 	bgeu	r18,r19,101d370 <__sfvwrite_r+0x230>
 101d36c:	902d883a 	mov	r22,r18
 101d370:	81000017 	ldw	r4,0(r16)
 101d374:	80800417 	ldw	r2,16(r16)
 101d378:	b02f883a 	mov	r23,r22
 101d37c:	81c00517 	ldw	r7,20(r16)
 101d380:	1100032e 	bgeu	r2,r4,101d390 <__sfvwrite_r+0x250>
 101d384:	80c00217 	ldw	r3,8(r16)
 101d388:	38c7883a 	add	r3,r7,r3
 101d38c:	1d801816 	blt	r3,r22,101d3f0 <__sfvwrite_r+0x2b0>
 101d390:	b1c03e16 	blt	r22,r7,101d48c <__sfvwrite_r+0x34c>
 101d394:	80800917 	ldw	r2,36(r16)
 101d398:	81400717 	ldw	r5,28(r16)
 101d39c:	e00d883a 	mov	r6,fp
 101d3a0:	da000115 	stw	r8,4(sp)
 101d3a4:	a809883a 	mov	r4,r21
 101d3a8:	103ee83a 	callr	r2
 101d3ac:	102f883a 	mov	r23,r2
 101d3b0:	da000117 	ldw	r8,4(sp)
 101d3b4:	00bfe00e 	bge	zero,r2,101d338 <__alt_data_end+0xff01d338>
 101d3b8:	9de7c83a 	sub	r19,r19,r23
 101d3bc:	98001f26 	beq	r19,zero,101d43c <__sfvwrite_r+0x2fc>
 101d3c0:	a0800217 	ldw	r2,8(r20)
 101d3c4:	e5f9883a 	add	fp,fp,r23
 101d3c8:	95e5c83a 	sub	r18,r18,r23
 101d3cc:	15efc83a 	sub	r23,r2,r23
 101d3d0:	a5c00215 	stw	r23,8(r20)
 101d3d4:	b83f8726 	beq	r23,zero,101d1f4 <__alt_data_end+0xff01d1f4>
 101d3d8:	903fe11e 	bne	r18,zero,101d360 <__alt_data_end+0xff01d360>
 101d3dc:	8f000017 	ldw	fp,0(r17)
 101d3e0:	8c800117 	ldw	r18,4(r17)
 101d3e4:	0011883a 	mov	r8,zero
 101d3e8:	8c400204 	addi	r17,r17,8
 101d3ec:	003fdb06 	br	101d35c <__alt_data_end+0xff01d35c>
 101d3f0:	180d883a 	mov	r6,r3
 101d3f4:	e00b883a 	mov	r5,fp
 101d3f8:	da000115 	stw	r8,4(sp)
 101d3fc:	d8c00015 	stw	r3,0(sp)
 101d400:	101e30c0 	call	101e30c <memmove>
 101d404:	d8c00017 	ldw	r3,0(sp)
 101d408:	80800017 	ldw	r2,0(r16)
 101d40c:	800b883a 	mov	r5,r16
 101d410:	a809883a 	mov	r4,r21
 101d414:	10c5883a 	add	r2,r2,r3
 101d418:	80800015 	stw	r2,0(r16)
 101d41c:	d8c00015 	stw	r3,0(sp)
 101d420:	101c8e00 	call	101c8e0 <_fflush_r>
 101d424:	d8c00017 	ldw	r3,0(sp)
 101d428:	da000117 	ldw	r8,4(sp)
 101d42c:	103fc21e 	bne	r2,zero,101d338 <__alt_data_end+0xff01d338>
 101d430:	182f883a 	mov	r23,r3
 101d434:	9de7c83a 	sub	r19,r19,r23
 101d438:	983fe11e 	bne	r19,zero,101d3c0 <__alt_data_end+0xff01d3c0>
 101d43c:	800b883a 	mov	r5,r16
 101d440:	a809883a 	mov	r4,r21
 101d444:	101c8e00 	call	101c8e0 <_fflush_r>
 101d448:	103fbb1e 	bne	r2,zero,101d338 <__alt_data_end+0xff01d338>
 101d44c:	0011883a 	mov	r8,zero
 101d450:	003fdb06 	br	101d3c0 <__alt_data_end+0xff01d3c0>
 101d454:	94c0012e 	bgeu	r18,r19,101d45c <__sfvwrite_r+0x31c>
 101d458:	9027883a 	mov	r19,r18
 101d45c:	980d883a 	mov	r6,r19
 101d460:	e00b883a 	mov	r5,fp
 101d464:	101e30c0 	call	101e30c <memmove>
 101d468:	80800217 	ldw	r2,8(r16)
 101d46c:	80c00017 	ldw	r3,0(r16)
 101d470:	14c5c83a 	sub	r2,r2,r19
 101d474:	1cc7883a 	add	r3,r3,r19
 101d478:	80800215 	stw	r2,8(r16)
 101d47c:	80c00015 	stw	r3,0(r16)
 101d480:	10004326 	beq	r2,zero,101d590 <__sfvwrite_r+0x450>
 101d484:	9805883a 	mov	r2,r19
 101d488:	003f8606 	br	101d2a4 <__alt_data_end+0xff01d2a4>
 101d48c:	b00d883a 	mov	r6,r22
 101d490:	e00b883a 	mov	r5,fp
 101d494:	da000115 	stw	r8,4(sp)
 101d498:	101e30c0 	call	101e30c <memmove>
 101d49c:	80800217 	ldw	r2,8(r16)
 101d4a0:	80c00017 	ldw	r3,0(r16)
 101d4a4:	da000117 	ldw	r8,4(sp)
 101d4a8:	1585c83a 	sub	r2,r2,r22
 101d4ac:	1dad883a 	add	r22,r3,r22
 101d4b0:	80800215 	stw	r2,8(r16)
 101d4b4:	85800015 	stw	r22,0(r16)
 101d4b8:	003fbf06 	br	101d3b8 <__alt_data_end+0xff01d3b8>
 101d4bc:	81000017 	ldw	r4,0(r16)
 101d4c0:	9027883a 	mov	r19,r18
 101d4c4:	902f883a 	mov	r23,r18
 101d4c8:	003f6c06 	br	101d27c <__alt_data_end+0xff01d27c>
 101d4cc:	900d883a 	mov	r6,r18
 101d4d0:	01400284 	movi	r5,10
 101d4d4:	e009883a 	mov	r4,fp
 101d4d8:	101e2280 	call	101e228 <memchr>
 101d4dc:	10003e26 	beq	r2,zero,101d5d8 <__sfvwrite_r+0x498>
 101d4e0:	10800044 	addi	r2,r2,1
 101d4e4:	1727c83a 	sub	r19,r2,fp
 101d4e8:	02000044 	movi	r8,1
 101d4ec:	003f9d06 	br	101d364 <__alt_data_end+0xff01d364>
 101d4f0:	80800517 	ldw	r2,20(r16)
 101d4f4:	81400417 	ldw	r5,16(r16)
 101d4f8:	81c00017 	ldw	r7,0(r16)
 101d4fc:	10a7883a 	add	r19,r2,r2
 101d500:	9885883a 	add	r2,r19,r2
 101d504:	1026d7fa 	srli	r19,r2,31
 101d508:	396dc83a 	sub	r22,r7,r5
 101d50c:	b1000044 	addi	r4,r22,1
 101d510:	9885883a 	add	r2,r19,r2
 101d514:	1027d07a 	srai	r19,r2,1
 101d518:	2485883a 	add	r2,r4,r18
 101d51c:	980d883a 	mov	r6,r19
 101d520:	9880022e 	bgeu	r19,r2,101d52c <__sfvwrite_r+0x3ec>
 101d524:	1027883a 	mov	r19,r2
 101d528:	100d883a 	mov	r6,r2
 101d52c:	18c1000c 	andi	r3,r3,1024
 101d530:	18001c26 	beq	r3,zero,101d5a4 <__sfvwrite_r+0x464>
 101d534:	300b883a 	mov	r5,r6
 101d538:	a809883a 	mov	r4,r21
 101d53c:	101da1c0 	call	101da1c <_malloc_r>
 101d540:	102f883a 	mov	r23,r2
 101d544:	10002926 	beq	r2,zero,101d5ec <__sfvwrite_r+0x4ac>
 101d548:	81400417 	ldw	r5,16(r16)
 101d54c:	b00d883a 	mov	r6,r22
 101d550:	1009883a 	mov	r4,r2
 101d554:	10158f40 	call	10158f4 <memcpy>
 101d558:	8080030b 	ldhu	r2,12(r16)
 101d55c:	00fedfc4 	movi	r3,-1153
 101d560:	10c4703a 	and	r2,r2,r3
 101d564:	10802014 	ori	r2,r2,128
 101d568:	8080030d 	sth	r2,12(r16)
 101d56c:	bd89883a 	add	r4,r23,r22
 101d570:	9d8fc83a 	sub	r7,r19,r22
 101d574:	85c00415 	stw	r23,16(r16)
 101d578:	84c00515 	stw	r19,20(r16)
 101d57c:	81000015 	stw	r4,0(r16)
 101d580:	9027883a 	mov	r19,r18
 101d584:	81c00215 	stw	r7,8(r16)
 101d588:	902f883a 	mov	r23,r18
 101d58c:	003f3b06 	br	101d27c <__alt_data_end+0xff01d27c>
 101d590:	800b883a 	mov	r5,r16
 101d594:	a809883a 	mov	r4,r21
 101d598:	101c8e00 	call	101c8e0 <_fflush_r>
 101d59c:	103fb926 	beq	r2,zero,101d484 <__alt_data_end+0xff01d484>
 101d5a0:	003f6506 	br	101d338 <__alt_data_end+0xff01d338>
 101d5a4:	a809883a 	mov	r4,r21
 101d5a8:	101f4640 	call	101f464 <_realloc_r>
 101d5ac:	102f883a 	mov	r23,r2
 101d5b0:	103fee1e 	bne	r2,zero,101d56c <__alt_data_end+0xff01d56c>
 101d5b4:	81400417 	ldw	r5,16(r16)
 101d5b8:	a809883a 	mov	r4,r21
 101d5bc:	101ce300 	call	101ce30 <_free_r>
 101d5c0:	8080030b 	ldhu	r2,12(r16)
 101d5c4:	00ffdfc4 	movi	r3,-129
 101d5c8:	1884703a 	and	r2,r3,r2
 101d5cc:	00c00304 	movi	r3,12
 101d5d0:	a8c00015 	stw	r3,0(r21)
 101d5d4:	003f5906 	br	101d33c <__alt_data_end+0xff01d33c>
 101d5d8:	94c00044 	addi	r19,r18,1
 101d5dc:	02000044 	movi	r8,1
 101d5e0:	003f6006 	br	101d364 <__alt_data_end+0xff01d364>
 101d5e4:	00bfffc4 	movi	r2,-1
 101d5e8:	003f0306 	br	101d1f8 <__alt_data_end+0xff01d1f8>
 101d5ec:	00800304 	movi	r2,12
 101d5f0:	a8800015 	stw	r2,0(r21)
 101d5f4:	8080030b 	ldhu	r2,12(r16)
 101d5f8:	003f5006 	br	101d33c <__alt_data_end+0xff01d33c>

0101d5fc <_fwalk>:
 101d5fc:	defff704 	addi	sp,sp,-36
 101d600:	dd000415 	stw	r20,16(sp)
 101d604:	dfc00815 	stw	ra,32(sp)
 101d608:	ddc00715 	stw	r23,28(sp)
 101d60c:	dd800615 	stw	r22,24(sp)
 101d610:	dd400515 	stw	r21,20(sp)
 101d614:	dcc00315 	stw	r19,12(sp)
 101d618:	dc800215 	stw	r18,8(sp)
 101d61c:	dc400115 	stw	r17,4(sp)
 101d620:	dc000015 	stw	r16,0(sp)
 101d624:	2500b804 	addi	r20,r4,736
 101d628:	a0002326 	beq	r20,zero,101d6b8 <_fwalk+0xbc>
 101d62c:	282b883a 	mov	r21,r5
 101d630:	002f883a 	mov	r23,zero
 101d634:	05800044 	movi	r22,1
 101d638:	04ffffc4 	movi	r19,-1
 101d63c:	a4400117 	ldw	r17,4(r20)
 101d640:	a4800217 	ldw	r18,8(r20)
 101d644:	8c7fffc4 	addi	r17,r17,-1
 101d648:	88000d16 	blt	r17,zero,101d680 <_fwalk+0x84>
 101d64c:	94000304 	addi	r16,r18,12
 101d650:	94800384 	addi	r18,r18,14
 101d654:	8080000b 	ldhu	r2,0(r16)
 101d658:	8c7fffc4 	addi	r17,r17,-1
 101d65c:	813ffd04 	addi	r4,r16,-12
 101d660:	b080042e 	bgeu	r22,r2,101d674 <_fwalk+0x78>
 101d664:	9080000f 	ldh	r2,0(r18)
 101d668:	14c00226 	beq	r2,r19,101d674 <_fwalk+0x78>
 101d66c:	a83ee83a 	callr	r21
 101d670:	b8aeb03a 	or	r23,r23,r2
 101d674:	84001a04 	addi	r16,r16,104
 101d678:	94801a04 	addi	r18,r18,104
 101d67c:	8cfff51e 	bne	r17,r19,101d654 <__alt_data_end+0xff01d654>
 101d680:	a5000017 	ldw	r20,0(r20)
 101d684:	a03fed1e 	bne	r20,zero,101d63c <__alt_data_end+0xff01d63c>
 101d688:	b805883a 	mov	r2,r23
 101d68c:	dfc00817 	ldw	ra,32(sp)
 101d690:	ddc00717 	ldw	r23,28(sp)
 101d694:	dd800617 	ldw	r22,24(sp)
 101d698:	dd400517 	ldw	r21,20(sp)
 101d69c:	dd000417 	ldw	r20,16(sp)
 101d6a0:	dcc00317 	ldw	r19,12(sp)
 101d6a4:	dc800217 	ldw	r18,8(sp)
 101d6a8:	dc400117 	ldw	r17,4(sp)
 101d6ac:	dc000017 	ldw	r16,0(sp)
 101d6b0:	dec00904 	addi	sp,sp,36
 101d6b4:	f800283a 	ret
 101d6b8:	002f883a 	mov	r23,zero
 101d6bc:	003ff206 	br	101d688 <__alt_data_end+0xff01d688>

0101d6c0 <_fwalk_reent>:
 101d6c0:	defff704 	addi	sp,sp,-36
 101d6c4:	dd000415 	stw	r20,16(sp)
 101d6c8:	dfc00815 	stw	ra,32(sp)
 101d6cc:	ddc00715 	stw	r23,28(sp)
 101d6d0:	dd800615 	stw	r22,24(sp)
 101d6d4:	dd400515 	stw	r21,20(sp)
 101d6d8:	dcc00315 	stw	r19,12(sp)
 101d6dc:	dc800215 	stw	r18,8(sp)
 101d6e0:	dc400115 	stw	r17,4(sp)
 101d6e4:	dc000015 	stw	r16,0(sp)
 101d6e8:	2500b804 	addi	r20,r4,736
 101d6ec:	a0002326 	beq	r20,zero,101d77c <_fwalk_reent+0xbc>
 101d6f0:	282b883a 	mov	r21,r5
 101d6f4:	2027883a 	mov	r19,r4
 101d6f8:	002f883a 	mov	r23,zero
 101d6fc:	05800044 	movi	r22,1
 101d700:	04bfffc4 	movi	r18,-1
 101d704:	a4400117 	ldw	r17,4(r20)
 101d708:	a4000217 	ldw	r16,8(r20)
 101d70c:	8c7fffc4 	addi	r17,r17,-1
 101d710:	88000c16 	blt	r17,zero,101d744 <_fwalk_reent+0x84>
 101d714:	84000304 	addi	r16,r16,12
 101d718:	8080000b 	ldhu	r2,0(r16)
 101d71c:	8c7fffc4 	addi	r17,r17,-1
 101d720:	817ffd04 	addi	r5,r16,-12
 101d724:	b080052e 	bgeu	r22,r2,101d73c <_fwalk_reent+0x7c>
 101d728:	8080008f 	ldh	r2,2(r16)
 101d72c:	9809883a 	mov	r4,r19
 101d730:	14800226 	beq	r2,r18,101d73c <_fwalk_reent+0x7c>
 101d734:	a83ee83a 	callr	r21
 101d738:	b8aeb03a 	or	r23,r23,r2
 101d73c:	84001a04 	addi	r16,r16,104
 101d740:	8cbff51e 	bne	r17,r18,101d718 <__alt_data_end+0xff01d718>
 101d744:	a5000017 	ldw	r20,0(r20)
 101d748:	a03fee1e 	bne	r20,zero,101d704 <__alt_data_end+0xff01d704>
 101d74c:	b805883a 	mov	r2,r23
 101d750:	dfc00817 	ldw	ra,32(sp)
 101d754:	ddc00717 	ldw	r23,28(sp)
 101d758:	dd800617 	ldw	r22,24(sp)
 101d75c:	dd400517 	ldw	r21,20(sp)
 101d760:	dd000417 	ldw	r20,16(sp)
 101d764:	dcc00317 	ldw	r19,12(sp)
 101d768:	dc800217 	ldw	r18,8(sp)
 101d76c:	dc400117 	ldw	r17,4(sp)
 101d770:	dc000017 	ldw	r16,0(sp)
 101d774:	dec00904 	addi	sp,sp,36
 101d778:	f800283a 	ret
 101d77c:	002f883a 	mov	r23,zero
 101d780:	003ff206 	br	101d74c <__alt_data_end+0xff01d74c>

0101d784 <_setlocale_r>:
 101d784:	30001b26 	beq	r6,zero,101d7f4 <_setlocale_r+0x70>
 101d788:	014040f4 	movhi	r5,259
 101d78c:	defffe04 	addi	sp,sp,-8
 101d790:	296aa104 	addi	r5,r5,-21884
 101d794:	3009883a 	mov	r4,r6
 101d798:	dc000015 	stw	r16,0(sp)
 101d79c:	dfc00115 	stw	ra,4(sp)
 101d7a0:	3021883a 	mov	r16,r6
 101d7a4:	1015e600 	call	1015e60 <strcmp>
 101d7a8:	1000061e 	bne	r2,zero,101d7c4 <_setlocale_r+0x40>
 101d7ac:	008040f4 	movhi	r2,259
 101d7b0:	10a8ba04 	addi	r2,r2,-23832
 101d7b4:	dfc00117 	ldw	ra,4(sp)
 101d7b8:	dc000017 	ldw	r16,0(sp)
 101d7bc:	dec00204 	addi	sp,sp,8
 101d7c0:	f800283a 	ret
 101d7c4:	014040f4 	movhi	r5,259
 101d7c8:	2968ba04 	addi	r5,r5,-23832
 101d7cc:	8009883a 	mov	r4,r16
 101d7d0:	1015e600 	call	1015e60 <strcmp>
 101d7d4:	103ff526 	beq	r2,zero,101d7ac <__alt_data_end+0xff01d7ac>
 101d7d8:	014040f4 	movhi	r5,259
 101d7dc:	2968ad04 	addi	r5,r5,-23884
 101d7e0:	8009883a 	mov	r4,r16
 101d7e4:	1015e600 	call	1015e60 <strcmp>
 101d7e8:	103ff026 	beq	r2,zero,101d7ac <__alt_data_end+0xff01d7ac>
 101d7ec:	0005883a 	mov	r2,zero
 101d7f0:	003ff006 	br	101d7b4 <__alt_data_end+0xff01d7b4>
 101d7f4:	008040f4 	movhi	r2,259
 101d7f8:	10a8ba04 	addi	r2,r2,-23832
 101d7fc:	f800283a 	ret

0101d800 <__locale_charset>:
 101d800:	008040f4 	movhi	r2,259
 101d804:	10acb404 	addi	r2,r2,-19760
 101d808:	f800283a 	ret

0101d80c <__locale_mb_cur_max>:
 101d80c:	008040f4 	movhi	r2,259
 101d810:	10b25e04 	addi	r2,r2,-13960
 101d814:	10800017 	ldw	r2,0(r2)
 101d818:	f800283a 	ret

0101d81c <__locale_msgcharset>:
 101d81c:	008040f4 	movhi	r2,259
 101d820:	10acac04 	addi	r2,r2,-19792
 101d824:	f800283a 	ret

0101d828 <__locale_cjk_lang>:
 101d828:	0005883a 	mov	r2,zero
 101d82c:	f800283a 	ret

0101d830 <_localeconv_r>:
 101d830:	008040f4 	movhi	r2,259
 101d834:	10acbc04 	addi	r2,r2,-19728
 101d838:	f800283a 	ret

0101d83c <setlocale>:
 101d83c:	008040f4 	movhi	r2,259
 101d840:	10b25d04 	addi	r2,r2,-13964
 101d844:	280d883a 	mov	r6,r5
 101d848:	200b883a 	mov	r5,r4
 101d84c:	11000017 	ldw	r4,0(r2)
 101d850:	101d7841 	jmpi	101d784 <_setlocale_r>

0101d854 <localeconv>:
 101d854:	008040f4 	movhi	r2,259
 101d858:	10acbc04 	addi	r2,r2,-19728
 101d85c:	f800283a 	ret

0101d860 <__smakebuf_r>:
 101d860:	2880030b 	ldhu	r2,12(r5)
 101d864:	10c0008c 	andi	r3,r2,2
 101d868:	1800411e 	bne	r3,zero,101d970 <__smakebuf_r+0x110>
 101d86c:	deffec04 	addi	sp,sp,-80
 101d870:	dc000f15 	stw	r16,60(sp)
 101d874:	2821883a 	mov	r16,r5
 101d878:	2940038f 	ldh	r5,14(r5)
 101d87c:	dc401015 	stw	r17,64(sp)
 101d880:	dfc01315 	stw	ra,76(sp)
 101d884:	dcc01215 	stw	r19,72(sp)
 101d888:	dc801115 	stw	r18,68(sp)
 101d88c:	2023883a 	mov	r17,r4
 101d890:	28001c16 	blt	r5,zero,101d904 <__smakebuf_r+0xa4>
 101d894:	d80d883a 	mov	r6,sp
 101d898:	1022da80 	call	1022da8 <_fstat_r>
 101d89c:	10001816 	blt	r2,zero,101d900 <__smakebuf_r+0xa0>
 101d8a0:	d8800117 	ldw	r2,4(sp)
 101d8a4:	00e00014 	movui	r3,32768
 101d8a8:	10bc000c 	andi	r2,r2,61440
 101d8ac:	14c80020 	cmpeqi	r19,r2,8192
 101d8b0:	10c03726 	beq	r2,r3,101d990 <__smakebuf_r+0x130>
 101d8b4:	80c0030b 	ldhu	r3,12(r16)
 101d8b8:	18c20014 	ori	r3,r3,2048
 101d8bc:	80c0030d 	sth	r3,12(r16)
 101d8c0:	00c80004 	movi	r3,8192
 101d8c4:	10c0521e 	bne	r2,r3,101da10 <__smakebuf_r+0x1b0>
 101d8c8:	8140038f 	ldh	r5,14(r16)
 101d8cc:	8809883a 	mov	r4,r17
 101d8d0:	1022e040 	call	1022e04 <_isatty_r>
 101d8d4:	10004c26 	beq	r2,zero,101da08 <__smakebuf_r+0x1a8>
 101d8d8:	8080030b 	ldhu	r2,12(r16)
 101d8dc:	80c010c4 	addi	r3,r16,67
 101d8e0:	80c00015 	stw	r3,0(r16)
 101d8e4:	10800054 	ori	r2,r2,1
 101d8e8:	8080030d 	sth	r2,12(r16)
 101d8ec:	00800044 	movi	r2,1
 101d8f0:	80c00415 	stw	r3,16(r16)
 101d8f4:	80800515 	stw	r2,20(r16)
 101d8f8:	04810004 	movi	r18,1024
 101d8fc:	00000706 	br	101d91c <__smakebuf_r+0xbc>
 101d900:	8080030b 	ldhu	r2,12(r16)
 101d904:	10c0200c 	andi	r3,r2,128
 101d908:	18001f1e 	bne	r3,zero,101d988 <__smakebuf_r+0x128>
 101d90c:	04810004 	movi	r18,1024
 101d910:	10820014 	ori	r2,r2,2048
 101d914:	8080030d 	sth	r2,12(r16)
 101d918:	0027883a 	mov	r19,zero
 101d91c:	900b883a 	mov	r5,r18
 101d920:	8809883a 	mov	r4,r17
 101d924:	101da1c0 	call	101da1c <_malloc_r>
 101d928:	10002c26 	beq	r2,zero,101d9dc <__smakebuf_r+0x17c>
 101d92c:	80c0030b 	ldhu	r3,12(r16)
 101d930:	010040b4 	movhi	r4,258
 101d934:	21325d04 	addi	r4,r4,-13964
 101d938:	89000f15 	stw	r4,60(r17)
 101d93c:	18c02014 	ori	r3,r3,128
 101d940:	80c0030d 	sth	r3,12(r16)
 101d944:	80800015 	stw	r2,0(r16)
 101d948:	80800415 	stw	r2,16(r16)
 101d94c:	84800515 	stw	r18,20(r16)
 101d950:	98001a1e 	bne	r19,zero,101d9bc <__smakebuf_r+0x15c>
 101d954:	dfc01317 	ldw	ra,76(sp)
 101d958:	dcc01217 	ldw	r19,72(sp)
 101d95c:	dc801117 	ldw	r18,68(sp)
 101d960:	dc401017 	ldw	r17,64(sp)
 101d964:	dc000f17 	ldw	r16,60(sp)
 101d968:	dec01404 	addi	sp,sp,80
 101d96c:	f800283a 	ret
 101d970:	288010c4 	addi	r2,r5,67
 101d974:	28800015 	stw	r2,0(r5)
 101d978:	28800415 	stw	r2,16(r5)
 101d97c:	00800044 	movi	r2,1
 101d980:	28800515 	stw	r2,20(r5)
 101d984:	f800283a 	ret
 101d988:	04801004 	movi	r18,64
 101d98c:	003fe006 	br	101d910 <__alt_data_end+0xff01d910>
 101d990:	81000a17 	ldw	r4,40(r16)
 101d994:	00c040b4 	movhi	r3,258
 101d998:	18ff9b04 	addi	r3,r3,-404
 101d99c:	20ffc51e 	bne	r4,r3,101d8b4 <__alt_data_end+0xff01d8b4>
 101d9a0:	8080030b 	ldhu	r2,12(r16)
 101d9a4:	04810004 	movi	r18,1024
 101d9a8:	84801315 	stw	r18,76(r16)
 101d9ac:	1484b03a 	or	r2,r2,r18
 101d9b0:	8080030d 	sth	r2,12(r16)
 101d9b4:	0027883a 	mov	r19,zero
 101d9b8:	003fd806 	br	101d91c <__alt_data_end+0xff01d91c>
 101d9bc:	8140038f 	ldh	r5,14(r16)
 101d9c0:	8809883a 	mov	r4,r17
 101d9c4:	1022e040 	call	1022e04 <_isatty_r>
 101d9c8:	103fe226 	beq	r2,zero,101d954 <__alt_data_end+0xff01d954>
 101d9cc:	8080030b 	ldhu	r2,12(r16)
 101d9d0:	10800054 	ori	r2,r2,1
 101d9d4:	8080030d 	sth	r2,12(r16)
 101d9d8:	003fde06 	br	101d954 <__alt_data_end+0xff01d954>
 101d9dc:	8080030b 	ldhu	r2,12(r16)
 101d9e0:	10c0800c 	andi	r3,r2,512
 101d9e4:	183fdb1e 	bne	r3,zero,101d954 <__alt_data_end+0xff01d954>
 101d9e8:	10800094 	ori	r2,r2,2
 101d9ec:	80c010c4 	addi	r3,r16,67
 101d9f0:	8080030d 	sth	r2,12(r16)
 101d9f4:	00800044 	movi	r2,1
 101d9f8:	80c00015 	stw	r3,0(r16)
 101d9fc:	80c00415 	stw	r3,16(r16)
 101da00:	80800515 	stw	r2,20(r16)
 101da04:	003fd306 	br	101d954 <__alt_data_end+0xff01d954>
 101da08:	04810004 	movi	r18,1024
 101da0c:	003fc306 	br	101d91c <__alt_data_end+0xff01d91c>
 101da10:	0027883a 	mov	r19,zero
 101da14:	04810004 	movi	r18,1024
 101da18:	003fc006 	br	101d91c <__alt_data_end+0xff01d91c>

0101da1c <_malloc_r>:
 101da1c:	defff504 	addi	sp,sp,-44
 101da20:	dc800315 	stw	r18,12(sp)
 101da24:	dfc00a15 	stw	ra,40(sp)
 101da28:	df000915 	stw	fp,36(sp)
 101da2c:	ddc00815 	stw	r23,32(sp)
 101da30:	dd800715 	stw	r22,28(sp)
 101da34:	dd400615 	stw	r21,24(sp)
 101da38:	dd000515 	stw	r20,20(sp)
 101da3c:	dcc00415 	stw	r19,16(sp)
 101da40:	dc400215 	stw	r17,8(sp)
 101da44:	dc000115 	stw	r16,4(sp)
 101da48:	288002c4 	addi	r2,r5,11
 101da4c:	00c00584 	movi	r3,22
 101da50:	2025883a 	mov	r18,r4
 101da54:	18807f2e 	bgeu	r3,r2,101dc54 <_malloc_r+0x238>
 101da58:	047ffe04 	movi	r17,-8
 101da5c:	1462703a 	and	r17,r2,r17
 101da60:	8800a316 	blt	r17,zero,101dcf0 <_malloc_r+0x2d4>
 101da64:	8940a236 	bltu	r17,r5,101dcf0 <_malloc_r+0x2d4>
 101da68:	1026ed00 	call	1026ed0 <__malloc_lock>
 101da6c:	00807dc4 	movi	r2,503
 101da70:	1441e92e 	bgeu	r2,r17,101e218 <_malloc_r+0x7fc>
 101da74:	8804d27a 	srli	r2,r17,9
 101da78:	1000a126 	beq	r2,zero,101dd00 <_malloc_r+0x2e4>
 101da7c:	00c00104 	movi	r3,4
 101da80:	18811e36 	bltu	r3,r2,101defc <_malloc_r+0x4e0>
 101da84:	8804d1ba 	srli	r2,r17,6
 101da88:	12000e44 	addi	r8,r2,57
 101da8c:	11c00e04 	addi	r7,r2,56
 101da90:	4209883a 	add	r4,r8,r8
 101da94:	04c040f4 	movhi	r19,259
 101da98:	2109883a 	add	r4,r4,r4
 101da9c:	9cecca04 	addi	r19,r19,-19672
 101daa0:	2109883a 	add	r4,r4,r4
 101daa4:	9909883a 	add	r4,r19,r4
 101daa8:	24000117 	ldw	r16,4(r4)
 101daac:	213ffe04 	addi	r4,r4,-8
 101dab0:	24009726 	beq	r4,r16,101dd10 <_malloc_r+0x2f4>
 101dab4:	80800117 	ldw	r2,4(r16)
 101dab8:	01bfff04 	movi	r6,-4
 101dabc:	014003c4 	movi	r5,15
 101dac0:	1184703a 	and	r2,r2,r6
 101dac4:	1447c83a 	sub	r3,r2,r17
 101dac8:	28c00716 	blt	r5,r3,101dae8 <_malloc_r+0xcc>
 101dacc:	1800920e 	bge	r3,zero,101dd18 <_malloc_r+0x2fc>
 101dad0:	84000317 	ldw	r16,12(r16)
 101dad4:	24008e26 	beq	r4,r16,101dd10 <_malloc_r+0x2f4>
 101dad8:	80800117 	ldw	r2,4(r16)
 101dadc:	1184703a 	and	r2,r2,r6
 101dae0:	1447c83a 	sub	r3,r2,r17
 101dae4:	28fff90e 	bge	r5,r3,101dacc <__alt_data_end+0xff01dacc>
 101dae8:	3809883a 	mov	r4,r7
 101daec:	018040f4 	movhi	r6,259
 101daf0:	9c000417 	ldw	r16,16(r19)
 101daf4:	31acca04 	addi	r6,r6,-19672
 101daf8:	32000204 	addi	r8,r6,8
 101dafc:	82013426 	beq	r16,r8,101dfd0 <_malloc_r+0x5b4>
 101db00:	80c00117 	ldw	r3,4(r16)
 101db04:	00bfff04 	movi	r2,-4
 101db08:	188e703a 	and	r7,r3,r2
 101db0c:	3c45c83a 	sub	r2,r7,r17
 101db10:	00c003c4 	movi	r3,15
 101db14:	18811f16 	blt	r3,r2,101df94 <_malloc_r+0x578>
 101db18:	32000515 	stw	r8,20(r6)
 101db1c:	32000415 	stw	r8,16(r6)
 101db20:	10007f0e 	bge	r2,zero,101dd20 <_malloc_r+0x304>
 101db24:	00807fc4 	movi	r2,511
 101db28:	11c0fd36 	bltu	r2,r7,101df20 <_malloc_r+0x504>
 101db2c:	3806d0fa 	srli	r3,r7,3
 101db30:	01c00044 	movi	r7,1
 101db34:	30800117 	ldw	r2,4(r6)
 101db38:	19400044 	addi	r5,r3,1
 101db3c:	294b883a 	add	r5,r5,r5
 101db40:	1807d0ba 	srai	r3,r3,2
 101db44:	294b883a 	add	r5,r5,r5
 101db48:	294b883a 	add	r5,r5,r5
 101db4c:	298b883a 	add	r5,r5,r6
 101db50:	38c6983a 	sll	r3,r7,r3
 101db54:	29c00017 	ldw	r7,0(r5)
 101db58:	2a7ffe04 	addi	r9,r5,-8
 101db5c:	1886b03a 	or	r3,r3,r2
 101db60:	82400315 	stw	r9,12(r16)
 101db64:	81c00215 	stw	r7,8(r16)
 101db68:	30c00115 	stw	r3,4(r6)
 101db6c:	2c000015 	stw	r16,0(r5)
 101db70:	3c000315 	stw	r16,12(r7)
 101db74:	2005d0ba 	srai	r2,r4,2
 101db78:	01400044 	movi	r5,1
 101db7c:	288a983a 	sll	r5,r5,r2
 101db80:	19406f36 	bltu	r3,r5,101dd40 <_malloc_r+0x324>
 101db84:	28c4703a 	and	r2,r5,r3
 101db88:	10000a1e 	bne	r2,zero,101dbb4 <_malloc_r+0x198>
 101db8c:	00bfff04 	movi	r2,-4
 101db90:	294b883a 	add	r5,r5,r5
 101db94:	2088703a 	and	r4,r4,r2
 101db98:	28c4703a 	and	r2,r5,r3
 101db9c:	21000104 	addi	r4,r4,4
 101dba0:	1000041e 	bne	r2,zero,101dbb4 <_malloc_r+0x198>
 101dba4:	294b883a 	add	r5,r5,r5
 101dba8:	28c4703a 	and	r2,r5,r3
 101dbac:	21000104 	addi	r4,r4,4
 101dbb0:	103ffc26 	beq	r2,zero,101dba4 <__alt_data_end+0xff01dba4>
 101dbb4:	02bfff04 	movi	r10,-4
 101dbb8:	024003c4 	movi	r9,15
 101dbbc:	21800044 	addi	r6,r4,1
 101dbc0:	318d883a 	add	r6,r6,r6
 101dbc4:	318d883a 	add	r6,r6,r6
 101dbc8:	318d883a 	add	r6,r6,r6
 101dbcc:	998d883a 	add	r6,r19,r6
 101dbd0:	333ffe04 	addi	r12,r6,-8
 101dbd4:	2017883a 	mov	r11,r4
 101dbd8:	31800104 	addi	r6,r6,4
 101dbdc:	34000017 	ldw	r16,0(r6)
 101dbe0:	31fffd04 	addi	r7,r6,-12
 101dbe4:	81c0041e 	bne	r16,r7,101dbf8 <_malloc_r+0x1dc>
 101dbe8:	0000fb06 	br	101dfd8 <_malloc_r+0x5bc>
 101dbec:	1801030e 	bge	r3,zero,101dffc <_malloc_r+0x5e0>
 101dbf0:	84000317 	ldw	r16,12(r16)
 101dbf4:	81c0f826 	beq	r16,r7,101dfd8 <_malloc_r+0x5bc>
 101dbf8:	80800117 	ldw	r2,4(r16)
 101dbfc:	1284703a 	and	r2,r2,r10
 101dc00:	1447c83a 	sub	r3,r2,r17
 101dc04:	48fff90e 	bge	r9,r3,101dbec <__alt_data_end+0xff01dbec>
 101dc08:	80800317 	ldw	r2,12(r16)
 101dc0c:	81000217 	ldw	r4,8(r16)
 101dc10:	89400054 	ori	r5,r17,1
 101dc14:	81400115 	stw	r5,4(r16)
 101dc18:	20800315 	stw	r2,12(r4)
 101dc1c:	11000215 	stw	r4,8(r2)
 101dc20:	8463883a 	add	r17,r16,r17
 101dc24:	9c400515 	stw	r17,20(r19)
 101dc28:	9c400415 	stw	r17,16(r19)
 101dc2c:	18800054 	ori	r2,r3,1
 101dc30:	88800115 	stw	r2,4(r17)
 101dc34:	8a000315 	stw	r8,12(r17)
 101dc38:	8a000215 	stw	r8,8(r17)
 101dc3c:	88e3883a 	add	r17,r17,r3
 101dc40:	88c00015 	stw	r3,0(r17)
 101dc44:	9009883a 	mov	r4,r18
 101dc48:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101dc4c:	80800204 	addi	r2,r16,8
 101dc50:	00001b06 	br	101dcc0 <_malloc_r+0x2a4>
 101dc54:	04400404 	movi	r17,16
 101dc58:	89402536 	bltu	r17,r5,101dcf0 <_malloc_r+0x2d4>
 101dc5c:	1026ed00 	call	1026ed0 <__malloc_lock>
 101dc60:	00800184 	movi	r2,6
 101dc64:	01000084 	movi	r4,2
 101dc68:	04c040f4 	movhi	r19,259
 101dc6c:	1085883a 	add	r2,r2,r2
 101dc70:	9cecca04 	addi	r19,r19,-19672
 101dc74:	1085883a 	add	r2,r2,r2
 101dc78:	9885883a 	add	r2,r19,r2
 101dc7c:	14000117 	ldw	r16,4(r2)
 101dc80:	10fffe04 	addi	r3,r2,-8
 101dc84:	80c0d926 	beq	r16,r3,101dfec <_malloc_r+0x5d0>
 101dc88:	80c00117 	ldw	r3,4(r16)
 101dc8c:	81000317 	ldw	r4,12(r16)
 101dc90:	00bfff04 	movi	r2,-4
 101dc94:	1884703a 	and	r2,r3,r2
 101dc98:	81400217 	ldw	r5,8(r16)
 101dc9c:	8085883a 	add	r2,r16,r2
 101dca0:	10c00117 	ldw	r3,4(r2)
 101dca4:	29000315 	stw	r4,12(r5)
 101dca8:	21400215 	stw	r5,8(r4)
 101dcac:	18c00054 	ori	r3,r3,1
 101dcb0:	10c00115 	stw	r3,4(r2)
 101dcb4:	9009883a 	mov	r4,r18
 101dcb8:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101dcbc:	80800204 	addi	r2,r16,8
 101dcc0:	dfc00a17 	ldw	ra,40(sp)
 101dcc4:	df000917 	ldw	fp,36(sp)
 101dcc8:	ddc00817 	ldw	r23,32(sp)
 101dccc:	dd800717 	ldw	r22,28(sp)
 101dcd0:	dd400617 	ldw	r21,24(sp)
 101dcd4:	dd000517 	ldw	r20,20(sp)
 101dcd8:	dcc00417 	ldw	r19,16(sp)
 101dcdc:	dc800317 	ldw	r18,12(sp)
 101dce0:	dc400217 	ldw	r17,8(sp)
 101dce4:	dc000117 	ldw	r16,4(sp)
 101dce8:	dec00b04 	addi	sp,sp,44
 101dcec:	f800283a 	ret
 101dcf0:	00800304 	movi	r2,12
 101dcf4:	90800015 	stw	r2,0(r18)
 101dcf8:	0005883a 	mov	r2,zero
 101dcfc:	003ff006 	br	101dcc0 <__alt_data_end+0xff01dcc0>
 101dd00:	01002004 	movi	r4,128
 101dd04:	02001004 	movi	r8,64
 101dd08:	01c00fc4 	movi	r7,63
 101dd0c:	003f6106 	br	101da94 <__alt_data_end+0xff01da94>
 101dd10:	4009883a 	mov	r4,r8
 101dd14:	003f7506 	br	101daec <__alt_data_end+0xff01daec>
 101dd18:	81000317 	ldw	r4,12(r16)
 101dd1c:	003fde06 	br	101dc98 <__alt_data_end+0xff01dc98>
 101dd20:	81c5883a 	add	r2,r16,r7
 101dd24:	11400117 	ldw	r5,4(r2)
 101dd28:	9009883a 	mov	r4,r18
 101dd2c:	29400054 	ori	r5,r5,1
 101dd30:	11400115 	stw	r5,4(r2)
 101dd34:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101dd38:	80800204 	addi	r2,r16,8
 101dd3c:	003fe006 	br	101dcc0 <__alt_data_end+0xff01dcc0>
 101dd40:	9c000217 	ldw	r16,8(r19)
 101dd44:	00bfff04 	movi	r2,-4
 101dd48:	85800117 	ldw	r22,4(r16)
 101dd4c:	b0ac703a 	and	r22,r22,r2
 101dd50:	b4400336 	bltu	r22,r17,101dd60 <_malloc_r+0x344>
 101dd54:	b445c83a 	sub	r2,r22,r17
 101dd58:	00c003c4 	movi	r3,15
 101dd5c:	18805d16 	blt	r3,r2,101ded4 <_malloc_r+0x4b8>
 101dd60:	05c040f4 	movhi	r23,259
 101dd64:	008040f4 	movhi	r2,259
 101dd68:	10b9ac04 	addi	r2,r2,-6480
 101dd6c:	bdf25f04 	addi	r23,r23,-13956
 101dd70:	15400017 	ldw	r21,0(r2)
 101dd74:	b8c00017 	ldw	r3,0(r23)
 101dd78:	00bfffc4 	movi	r2,-1
 101dd7c:	858d883a 	add	r6,r16,r22
 101dd80:	8d6b883a 	add	r21,r17,r21
 101dd84:	1880ea26 	beq	r3,r2,101e130 <_malloc_r+0x714>
 101dd88:	ad4403c4 	addi	r21,r21,4111
 101dd8c:	00bc0004 	movi	r2,-4096
 101dd90:	a8aa703a 	and	r21,r21,r2
 101dd94:	a80b883a 	mov	r5,r21
 101dd98:	9009883a 	mov	r4,r18
 101dd9c:	d9800015 	stw	r6,0(sp)
 101dda0:	101fa3c0 	call	101fa3c <_sbrk_r>
 101dda4:	1029883a 	mov	r20,r2
 101dda8:	00bfffc4 	movi	r2,-1
 101ddac:	d9800017 	ldw	r6,0(sp)
 101ddb0:	a080e826 	beq	r20,r2,101e154 <_malloc_r+0x738>
 101ddb4:	a180a636 	bltu	r20,r6,101e050 <_malloc_r+0x634>
 101ddb8:	070060f4 	movhi	fp,387
 101ddbc:	e73ae704 	addi	fp,fp,-5220
 101ddc0:	e0800017 	ldw	r2,0(fp)
 101ddc4:	a887883a 	add	r3,r21,r2
 101ddc8:	e0c00015 	stw	r3,0(fp)
 101ddcc:	3500e626 	beq	r6,r20,101e168 <_malloc_r+0x74c>
 101ddd0:	b9000017 	ldw	r4,0(r23)
 101ddd4:	00bfffc4 	movi	r2,-1
 101ddd8:	2080ee26 	beq	r4,r2,101e194 <_malloc_r+0x778>
 101dddc:	a185c83a 	sub	r2,r20,r6
 101dde0:	10c5883a 	add	r2,r2,r3
 101dde4:	e0800015 	stw	r2,0(fp)
 101dde8:	a0c001cc 	andi	r3,r20,7
 101ddec:	1800bc26 	beq	r3,zero,101e0e0 <_malloc_r+0x6c4>
 101ddf0:	a0e9c83a 	sub	r20,r20,r3
 101ddf4:	00840204 	movi	r2,4104
 101ddf8:	a5000204 	addi	r20,r20,8
 101ddfc:	10c7c83a 	sub	r3,r2,r3
 101de00:	a545883a 	add	r2,r20,r21
 101de04:	1083ffcc 	andi	r2,r2,4095
 101de08:	18abc83a 	sub	r21,r3,r2
 101de0c:	a80b883a 	mov	r5,r21
 101de10:	9009883a 	mov	r4,r18
 101de14:	101fa3c0 	call	101fa3c <_sbrk_r>
 101de18:	00ffffc4 	movi	r3,-1
 101de1c:	10c0e126 	beq	r2,r3,101e1a4 <_malloc_r+0x788>
 101de20:	1505c83a 	sub	r2,r2,r20
 101de24:	1545883a 	add	r2,r2,r21
 101de28:	10800054 	ori	r2,r2,1
 101de2c:	e0c00017 	ldw	r3,0(fp)
 101de30:	9d000215 	stw	r20,8(r19)
 101de34:	a0800115 	stw	r2,4(r20)
 101de38:	a8c7883a 	add	r3,r21,r3
 101de3c:	e0c00015 	stw	r3,0(fp)
 101de40:	84c00e26 	beq	r16,r19,101de7c <_malloc_r+0x460>
 101de44:	018003c4 	movi	r6,15
 101de48:	3580a72e 	bgeu	r6,r22,101e0e8 <_malloc_r+0x6cc>
 101de4c:	81400117 	ldw	r5,4(r16)
 101de50:	013ffe04 	movi	r4,-8
 101de54:	b0bffd04 	addi	r2,r22,-12
 101de58:	1104703a 	and	r2,r2,r4
 101de5c:	2900004c 	andi	r4,r5,1
 101de60:	2088b03a 	or	r4,r4,r2
 101de64:	81000115 	stw	r4,4(r16)
 101de68:	01400144 	movi	r5,5
 101de6c:	8089883a 	add	r4,r16,r2
 101de70:	21400115 	stw	r5,4(r4)
 101de74:	21400215 	stw	r5,8(r4)
 101de78:	3080cd36 	bltu	r6,r2,101e1b0 <_malloc_r+0x794>
 101de7c:	008040f4 	movhi	r2,259
 101de80:	10b9ab04 	addi	r2,r2,-6484
 101de84:	11000017 	ldw	r4,0(r2)
 101de88:	20c0012e 	bgeu	r4,r3,101de90 <_malloc_r+0x474>
 101de8c:	10c00015 	stw	r3,0(r2)
 101de90:	008040f4 	movhi	r2,259
 101de94:	10b9aa04 	addi	r2,r2,-6488
 101de98:	11000017 	ldw	r4,0(r2)
 101de9c:	9c000217 	ldw	r16,8(r19)
 101dea0:	20c0012e 	bgeu	r4,r3,101dea8 <_malloc_r+0x48c>
 101dea4:	10c00015 	stw	r3,0(r2)
 101dea8:	80c00117 	ldw	r3,4(r16)
 101deac:	00bfff04 	movi	r2,-4
 101deb0:	1886703a 	and	r3,r3,r2
 101deb4:	1c45c83a 	sub	r2,r3,r17
 101deb8:	1c400236 	bltu	r3,r17,101dec4 <_malloc_r+0x4a8>
 101debc:	00c003c4 	movi	r3,15
 101dec0:	18800416 	blt	r3,r2,101ded4 <_malloc_r+0x4b8>
 101dec4:	9009883a 	mov	r4,r18
 101dec8:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101decc:	0005883a 	mov	r2,zero
 101ded0:	003f7b06 	br	101dcc0 <__alt_data_end+0xff01dcc0>
 101ded4:	88c00054 	ori	r3,r17,1
 101ded8:	80c00115 	stw	r3,4(r16)
 101dedc:	8463883a 	add	r17,r16,r17
 101dee0:	10800054 	ori	r2,r2,1
 101dee4:	9c400215 	stw	r17,8(r19)
 101dee8:	88800115 	stw	r2,4(r17)
 101deec:	9009883a 	mov	r4,r18
 101def0:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101def4:	80800204 	addi	r2,r16,8
 101def8:	003f7106 	br	101dcc0 <__alt_data_end+0xff01dcc0>
 101defc:	00c00504 	movi	r3,20
 101df00:	18804a2e 	bgeu	r3,r2,101e02c <_malloc_r+0x610>
 101df04:	00c01504 	movi	r3,84
 101df08:	18806e36 	bltu	r3,r2,101e0c4 <_malloc_r+0x6a8>
 101df0c:	8804d33a 	srli	r2,r17,12
 101df10:	12001bc4 	addi	r8,r2,111
 101df14:	11c01b84 	addi	r7,r2,110
 101df18:	4209883a 	add	r4,r8,r8
 101df1c:	003edd06 	br	101da94 <__alt_data_end+0xff01da94>
 101df20:	3804d27a 	srli	r2,r7,9
 101df24:	00c00104 	movi	r3,4
 101df28:	1880442e 	bgeu	r3,r2,101e03c <_malloc_r+0x620>
 101df2c:	00c00504 	movi	r3,20
 101df30:	18808136 	bltu	r3,r2,101e138 <_malloc_r+0x71c>
 101df34:	11401704 	addi	r5,r2,92
 101df38:	10c016c4 	addi	r3,r2,91
 101df3c:	294b883a 	add	r5,r5,r5
 101df40:	294b883a 	add	r5,r5,r5
 101df44:	294b883a 	add	r5,r5,r5
 101df48:	994b883a 	add	r5,r19,r5
 101df4c:	28800017 	ldw	r2,0(r5)
 101df50:	018040f4 	movhi	r6,259
 101df54:	297ffe04 	addi	r5,r5,-8
 101df58:	31acca04 	addi	r6,r6,-19672
 101df5c:	28806526 	beq	r5,r2,101e0f4 <_malloc_r+0x6d8>
 101df60:	01bfff04 	movi	r6,-4
 101df64:	10c00117 	ldw	r3,4(r2)
 101df68:	1986703a 	and	r3,r3,r6
 101df6c:	38c0022e 	bgeu	r7,r3,101df78 <_malloc_r+0x55c>
 101df70:	10800217 	ldw	r2,8(r2)
 101df74:	28bffb1e 	bne	r5,r2,101df64 <__alt_data_end+0xff01df64>
 101df78:	11400317 	ldw	r5,12(r2)
 101df7c:	98c00117 	ldw	r3,4(r19)
 101df80:	81400315 	stw	r5,12(r16)
 101df84:	80800215 	stw	r2,8(r16)
 101df88:	2c000215 	stw	r16,8(r5)
 101df8c:	14000315 	stw	r16,12(r2)
 101df90:	003ef806 	br	101db74 <__alt_data_end+0xff01db74>
 101df94:	88c00054 	ori	r3,r17,1
 101df98:	80c00115 	stw	r3,4(r16)
 101df9c:	8463883a 	add	r17,r16,r17
 101dfa0:	34400515 	stw	r17,20(r6)
 101dfa4:	34400415 	stw	r17,16(r6)
 101dfa8:	10c00054 	ori	r3,r2,1
 101dfac:	8a000315 	stw	r8,12(r17)
 101dfb0:	8a000215 	stw	r8,8(r17)
 101dfb4:	88c00115 	stw	r3,4(r17)
 101dfb8:	88a3883a 	add	r17,r17,r2
 101dfbc:	88800015 	stw	r2,0(r17)
 101dfc0:	9009883a 	mov	r4,r18
 101dfc4:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101dfc8:	80800204 	addi	r2,r16,8
 101dfcc:	003f3c06 	br	101dcc0 <__alt_data_end+0xff01dcc0>
 101dfd0:	30c00117 	ldw	r3,4(r6)
 101dfd4:	003ee706 	br	101db74 <__alt_data_end+0xff01db74>
 101dfd8:	5ac00044 	addi	r11,r11,1
 101dfdc:	588000cc 	andi	r2,r11,3
 101dfe0:	31800204 	addi	r6,r6,8
 101dfe4:	103efd1e 	bne	r2,zero,101dbdc <__alt_data_end+0xff01dbdc>
 101dfe8:	00002406 	br	101e07c <_malloc_r+0x660>
 101dfec:	14000317 	ldw	r16,12(r2)
 101dff0:	143f251e 	bne	r2,r16,101dc88 <__alt_data_end+0xff01dc88>
 101dff4:	21000084 	addi	r4,r4,2
 101dff8:	003ebc06 	br	101daec <__alt_data_end+0xff01daec>
 101dffc:	8085883a 	add	r2,r16,r2
 101e000:	10c00117 	ldw	r3,4(r2)
 101e004:	81000317 	ldw	r4,12(r16)
 101e008:	81400217 	ldw	r5,8(r16)
 101e00c:	18c00054 	ori	r3,r3,1
 101e010:	10c00115 	stw	r3,4(r2)
 101e014:	29000315 	stw	r4,12(r5)
 101e018:	21400215 	stw	r5,8(r4)
 101e01c:	9009883a 	mov	r4,r18
 101e020:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101e024:	80800204 	addi	r2,r16,8
 101e028:	003f2506 	br	101dcc0 <__alt_data_end+0xff01dcc0>
 101e02c:	12001704 	addi	r8,r2,92
 101e030:	11c016c4 	addi	r7,r2,91
 101e034:	4209883a 	add	r4,r8,r8
 101e038:	003e9606 	br	101da94 <__alt_data_end+0xff01da94>
 101e03c:	3804d1ba 	srli	r2,r7,6
 101e040:	11400e44 	addi	r5,r2,57
 101e044:	10c00e04 	addi	r3,r2,56
 101e048:	294b883a 	add	r5,r5,r5
 101e04c:	003fbc06 	br	101df40 <__alt_data_end+0xff01df40>
 101e050:	84ff5926 	beq	r16,r19,101ddb8 <__alt_data_end+0xff01ddb8>
 101e054:	008040f4 	movhi	r2,259
 101e058:	10acca04 	addi	r2,r2,-19672
 101e05c:	14000217 	ldw	r16,8(r2)
 101e060:	00bfff04 	movi	r2,-4
 101e064:	80c00117 	ldw	r3,4(r16)
 101e068:	1886703a 	and	r3,r3,r2
 101e06c:	003f9106 	br	101deb4 <__alt_data_end+0xff01deb4>
 101e070:	60800217 	ldw	r2,8(r12)
 101e074:	213fffc4 	addi	r4,r4,-1
 101e078:	1300651e 	bne	r2,r12,101e210 <_malloc_r+0x7f4>
 101e07c:	208000cc 	andi	r2,r4,3
 101e080:	633ffe04 	addi	r12,r12,-8
 101e084:	103ffa1e 	bne	r2,zero,101e070 <__alt_data_end+0xff01e070>
 101e088:	98800117 	ldw	r2,4(r19)
 101e08c:	0146303a 	nor	r3,zero,r5
 101e090:	1884703a 	and	r2,r3,r2
 101e094:	98800115 	stw	r2,4(r19)
 101e098:	294b883a 	add	r5,r5,r5
 101e09c:	117f2836 	bltu	r2,r5,101dd40 <__alt_data_end+0xff01dd40>
 101e0a0:	283f2726 	beq	r5,zero,101dd40 <__alt_data_end+0xff01dd40>
 101e0a4:	2886703a 	and	r3,r5,r2
 101e0a8:	5809883a 	mov	r4,r11
 101e0ac:	183ec31e 	bne	r3,zero,101dbbc <__alt_data_end+0xff01dbbc>
 101e0b0:	294b883a 	add	r5,r5,r5
 101e0b4:	2886703a 	and	r3,r5,r2
 101e0b8:	21000104 	addi	r4,r4,4
 101e0bc:	183ffc26 	beq	r3,zero,101e0b0 <__alt_data_end+0xff01e0b0>
 101e0c0:	003ebe06 	br	101dbbc <__alt_data_end+0xff01dbbc>
 101e0c4:	00c05504 	movi	r3,340
 101e0c8:	18801236 	bltu	r3,r2,101e114 <_malloc_r+0x6f8>
 101e0cc:	8804d3fa 	srli	r2,r17,15
 101e0d0:	12001e04 	addi	r8,r2,120
 101e0d4:	11c01dc4 	addi	r7,r2,119
 101e0d8:	4209883a 	add	r4,r8,r8
 101e0dc:	003e6d06 	br	101da94 <__alt_data_end+0xff01da94>
 101e0e0:	00c40004 	movi	r3,4096
 101e0e4:	003f4606 	br	101de00 <__alt_data_end+0xff01de00>
 101e0e8:	00800044 	movi	r2,1
 101e0ec:	a0800115 	stw	r2,4(r20)
 101e0f0:	003f7406 	br	101dec4 <__alt_data_end+0xff01dec4>
 101e0f4:	1805d0ba 	srai	r2,r3,2
 101e0f8:	01c00044 	movi	r7,1
 101e0fc:	30c00117 	ldw	r3,4(r6)
 101e100:	388e983a 	sll	r7,r7,r2
 101e104:	2805883a 	mov	r2,r5
 101e108:	38c6b03a 	or	r3,r7,r3
 101e10c:	30c00115 	stw	r3,4(r6)
 101e110:	003f9b06 	br	101df80 <__alt_data_end+0xff01df80>
 101e114:	00c15504 	movi	r3,1364
 101e118:	18801a36 	bltu	r3,r2,101e184 <_malloc_r+0x768>
 101e11c:	8804d4ba 	srli	r2,r17,18
 101e120:	12001f44 	addi	r8,r2,125
 101e124:	11c01f04 	addi	r7,r2,124
 101e128:	4209883a 	add	r4,r8,r8
 101e12c:	003e5906 	br	101da94 <__alt_data_end+0xff01da94>
 101e130:	ad400404 	addi	r21,r21,16
 101e134:	003f1706 	br	101dd94 <__alt_data_end+0xff01dd94>
 101e138:	00c01504 	movi	r3,84
 101e13c:	18802336 	bltu	r3,r2,101e1cc <_malloc_r+0x7b0>
 101e140:	3804d33a 	srli	r2,r7,12
 101e144:	11401bc4 	addi	r5,r2,111
 101e148:	10c01b84 	addi	r3,r2,110
 101e14c:	294b883a 	add	r5,r5,r5
 101e150:	003f7b06 	br	101df40 <__alt_data_end+0xff01df40>
 101e154:	9c000217 	ldw	r16,8(r19)
 101e158:	00bfff04 	movi	r2,-4
 101e15c:	80c00117 	ldw	r3,4(r16)
 101e160:	1886703a 	and	r3,r3,r2
 101e164:	003f5306 	br	101deb4 <__alt_data_end+0xff01deb4>
 101e168:	3083ffcc 	andi	r2,r6,4095
 101e16c:	103f181e 	bne	r2,zero,101ddd0 <__alt_data_end+0xff01ddd0>
 101e170:	99000217 	ldw	r4,8(r19)
 101e174:	b545883a 	add	r2,r22,r21
 101e178:	10800054 	ori	r2,r2,1
 101e17c:	20800115 	stw	r2,4(r4)
 101e180:	003f3e06 	br	101de7c <__alt_data_end+0xff01de7c>
 101e184:	01003f84 	movi	r4,254
 101e188:	02001fc4 	movi	r8,127
 101e18c:	01c01f84 	movi	r7,126
 101e190:	003e4006 	br	101da94 <__alt_data_end+0xff01da94>
 101e194:	008040f4 	movhi	r2,259
 101e198:	10b25f04 	addi	r2,r2,-13956
 101e19c:	15000015 	stw	r20,0(r2)
 101e1a0:	003f1106 	br	101dde8 <__alt_data_end+0xff01dde8>
 101e1a4:	00800044 	movi	r2,1
 101e1a8:	002b883a 	mov	r21,zero
 101e1ac:	003f1f06 	br	101de2c <__alt_data_end+0xff01de2c>
 101e1b0:	81400204 	addi	r5,r16,8
 101e1b4:	9009883a 	mov	r4,r18
 101e1b8:	101ce300 	call	101ce30 <_free_r>
 101e1bc:	008060f4 	movhi	r2,387
 101e1c0:	10bae704 	addi	r2,r2,-5220
 101e1c4:	10c00017 	ldw	r3,0(r2)
 101e1c8:	003f2c06 	br	101de7c <__alt_data_end+0xff01de7c>
 101e1cc:	00c05504 	movi	r3,340
 101e1d0:	18800536 	bltu	r3,r2,101e1e8 <_malloc_r+0x7cc>
 101e1d4:	3804d3fa 	srli	r2,r7,15
 101e1d8:	11401e04 	addi	r5,r2,120
 101e1dc:	10c01dc4 	addi	r3,r2,119
 101e1e0:	294b883a 	add	r5,r5,r5
 101e1e4:	003f5606 	br	101df40 <__alt_data_end+0xff01df40>
 101e1e8:	00c15504 	movi	r3,1364
 101e1ec:	18800536 	bltu	r3,r2,101e204 <_malloc_r+0x7e8>
 101e1f0:	3804d4ba 	srli	r2,r7,18
 101e1f4:	11401f44 	addi	r5,r2,125
 101e1f8:	10c01f04 	addi	r3,r2,124
 101e1fc:	294b883a 	add	r5,r5,r5
 101e200:	003f4f06 	br	101df40 <__alt_data_end+0xff01df40>
 101e204:	01403f84 	movi	r5,254
 101e208:	00c01f84 	movi	r3,126
 101e20c:	003f4c06 	br	101df40 <__alt_data_end+0xff01df40>
 101e210:	98800117 	ldw	r2,4(r19)
 101e214:	003fa006 	br	101e098 <__alt_data_end+0xff01e098>
 101e218:	8808d0fa 	srli	r4,r17,3
 101e21c:	20800044 	addi	r2,r4,1
 101e220:	1085883a 	add	r2,r2,r2
 101e224:	003e9006 	br	101dc68 <__alt_data_end+0xff01dc68>

0101e228 <memchr>:
 101e228:	208000cc 	andi	r2,r4,3
 101e22c:	280f883a 	mov	r7,r5
 101e230:	10003426 	beq	r2,zero,101e304 <memchr+0xdc>
 101e234:	30bfffc4 	addi	r2,r6,-1
 101e238:	30001a26 	beq	r6,zero,101e2a4 <memchr+0x7c>
 101e23c:	20c00003 	ldbu	r3,0(r4)
 101e240:	29803fcc 	andi	r6,r5,255
 101e244:	30c0051e 	bne	r6,r3,101e25c <memchr+0x34>
 101e248:	00001806 	br	101e2ac <memchr+0x84>
 101e24c:	10001526 	beq	r2,zero,101e2a4 <memchr+0x7c>
 101e250:	20c00003 	ldbu	r3,0(r4)
 101e254:	10bfffc4 	addi	r2,r2,-1
 101e258:	30c01426 	beq	r6,r3,101e2ac <memchr+0x84>
 101e25c:	21000044 	addi	r4,r4,1
 101e260:	20c000cc 	andi	r3,r4,3
 101e264:	183ff91e 	bne	r3,zero,101e24c <__alt_data_end+0xff01e24c>
 101e268:	020000c4 	movi	r8,3
 101e26c:	40801136 	bltu	r8,r2,101e2b4 <memchr+0x8c>
 101e270:	10000c26 	beq	r2,zero,101e2a4 <memchr+0x7c>
 101e274:	20c00003 	ldbu	r3,0(r4)
 101e278:	29403fcc 	andi	r5,r5,255
 101e27c:	28c00b26 	beq	r5,r3,101e2ac <memchr+0x84>
 101e280:	20c00044 	addi	r3,r4,1
 101e284:	39803fcc 	andi	r6,r7,255
 101e288:	2089883a 	add	r4,r4,r2
 101e28c:	00000306 	br	101e29c <memchr+0x74>
 101e290:	18c00044 	addi	r3,r3,1
 101e294:	197fffc3 	ldbu	r5,-1(r3)
 101e298:	31400526 	beq	r6,r5,101e2b0 <memchr+0x88>
 101e29c:	1805883a 	mov	r2,r3
 101e2a0:	20fffb1e 	bne	r4,r3,101e290 <__alt_data_end+0xff01e290>
 101e2a4:	0005883a 	mov	r2,zero
 101e2a8:	f800283a 	ret
 101e2ac:	2005883a 	mov	r2,r4
 101e2b0:	f800283a 	ret
 101e2b4:	28c03fcc 	andi	r3,r5,255
 101e2b8:	1812923a 	slli	r9,r3,8
 101e2bc:	02ffbff4 	movhi	r11,65279
 101e2c0:	02a02074 	movhi	r10,32897
 101e2c4:	48d2b03a 	or	r9,r9,r3
 101e2c8:	4806943a 	slli	r3,r9,16
 101e2cc:	5affbfc4 	addi	r11,r11,-257
 101e2d0:	52a02004 	addi	r10,r10,-32640
 101e2d4:	48d2b03a 	or	r9,r9,r3
 101e2d8:	20c00017 	ldw	r3,0(r4)
 101e2dc:	48c6f03a 	xor	r3,r9,r3
 101e2e0:	1acd883a 	add	r6,r3,r11
 101e2e4:	00c6303a 	nor	r3,zero,r3
 101e2e8:	30c6703a 	and	r3,r6,r3
 101e2ec:	1a86703a 	and	r3,r3,r10
 101e2f0:	183fe01e 	bne	r3,zero,101e274 <__alt_data_end+0xff01e274>
 101e2f4:	10bfff04 	addi	r2,r2,-4
 101e2f8:	21000104 	addi	r4,r4,4
 101e2fc:	40bff636 	bltu	r8,r2,101e2d8 <__alt_data_end+0xff01e2d8>
 101e300:	003fdb06 	br	101e270 <__alt_data_end+0xff01e270>
 101e304:	3005883a 	mov	r2,r6
 101e308:	003fd706 	br	101e268 <__alt_data_end+0xff01e268>

0101e30c <memmove>:
 101e30c:	2005883a 	mov	r2,r4
 101e310:	29000b2e 	bgeu	r5,r4,101e340 <memmove+0x34>
 101e314:	298f883a 	add	r7,r5,r6
 101e318:	21c0092e 	bgeu	r4,r7,101e340 <memmove+0x34>
 101e31c:	2187883a 	add	r3,r4,r6
 101e320:	198bc83a 	sub	r5,r3,r6
 101e324:	30004826 	beq	r6,zero,101e448 <memmove+0x13c>
 101e328:	39ffffc4 	addi	r7,r7,-1
 101e32c:	39000003 	ldbu	r4,0(r7)
 101e330:	18ffffc4 	addi	r3,r3,-1
 101e334:	19000005 	stb	r4,0(r3)
 101e338:	28fffb1e 	bne	r5,r3,101e328 <__alt_data_end+0xff01e328>
 101e33c:	f800283a 	ret
 101e340:	00c003c4 	movi	r3,15
 101e344:	1980412e 	bgeu	r3,r6,101e44c <memmove+0x140>
 101e348:	2886b03a 	or	r3,r5,r2
 101e34c:	18c000cc 	andi	r3,r3,3
 101e350:	1800401e 	bne	r3,zero,101e454 <memmove+0x148>
 101e354:	33fffc04 	addi	r15,r6,-16
 101e358:	781ed13a 	srli	r15,r15,4
 101e35c:	28c00104 	addi	r3,r5,4
 101e360:	13400104 	addi	r13,r2,4
 101e364:	781c913a 	slli	r14,r15,4
 101e368:	2b000204 	addi	r12,r5,8
 101e36c:	12c00204 	addi	r11,r2,8
 101e370:	73800504 	addi	r14,r14,20
 101e374:	2a800304 	addi	r10,r5,12
 101e378:	12400304 	addi	r9,r2,12
 101e37c:	2b9d883a 	add	r14,r5,r14
 101e380:	2811883a 	mov	r8,r5
 101e384:	100f883a 	mov	r7,r2
 101e388:	41000017 	ldw	r4,0(r8)
 101e38c:	39c00404 	addi	r7,r7,16
 101e390:	18c00404 	addi	r3,r3,16
 101e394:	393ffc15 	stw	r4,-16(r7)
 101e398:	193ffc17 	ldw	r4,-16(r3)
 101e39c:	6b400404 	addi	r13,r13,16
 101e3a0:	5ac00404 	addi	r11,r11,16
 101e3a4:	693ffc15 	stw	r4,-16(r13)
 101e3a8:	61000017 	ldw	r4,0(r12)
 101e3ac:	4a400404 	addi	r9,r9,16
 101e3b0:	42000404 	addi	r8,r8,16
 101e3b4:	593ffc15 	stw	r4,-16(r11)
 101e3b8:	51000017 	ldw	r4,0(r10)
 101e3bc:	63000404 	addi	r12,r12,16
 101e3c0:	52800404 	addi	r10,r10,16
 101e3c4:	493ffc15 	stw	r4,-16(r9)
 101e3c8:	1bbfef1e 	bne	r3,r14,101e388 <__alt_data_end+0xff01e388>
 101e3cc:	79000044 	addi	r4,r15,1
 101e3d0:	2008913a 	slli	r4,r4,4
 101e3d4:	328003cc 	andi	r10,r6,15
 101e3d8:	02c000c4 	movi	r11,3
 101e3dc:	1107883a 	add	r3,r2,r4
 101e3e0:	290b883a 	add	r5,r5,r4
 101e3e4:	5a801e2e 	bgeu	r11,r10,101e460 <memmove+0x154>
 101e3e8:	1813883a 	mov	r9,r3
 101e3ec:	2811883a 	mov	r8,r5
 101e3f0:	500f883a 	mov	r7,r10
 101e3f4:	41000017 	ldw	r4,0(r8)
 101e3f8:	4a400104 	addi	r9,r9,4
 101e3fc:	39ffff04 	addi	r7,r7,-4
 101e400:	493fff15 	stw	r4,-4(r9)
 101e404:	42000104 	addi	r8,r8,4
 101e408:	59fffa36 	bltu	r11,r7,101e3f4 <__alt_data_end+0xff01e3f4>
 101e40c:	513fff04 	addi	r4,r10,-4
 101e410:	2008d0ba 	srli	r4,r4,2
 101e414:	318000cc 	andi	r6,r6,3
 101e418:	21000044 	addi	r4,r4,1
 101e41c:	2109883a 	add	r4,r4,r4
 101e420:	2109883a 	add	r4,r4,r4
 101e424:	1907883a 	add	r3,r3,r4
 101e428:	290b883a 	add	r5,r5,r4
 101e42c:	30000b26 	beq	r6,zero,101e45c <memmove+0x150>
 101e430:	198d883a 	add	r6,r3,r6
 101e434:	29c00003 	ldbu	r7,0(r5)
 101e438:	18c00044 	addi	r3,r3,1
 101e43c:	29400044 	addi	r5,r5,1
 101e440:	19ffffc5 	stb	r7,-1(r3)
 101e444:	19bffb1e 	bne	r3,r6,101e434 <__alt_data_end+0xff01e434>
 101e448:	f800283a 	ret
 101e44c:	1007883a 	mov	r3,r2
 101e450:	003ff606 	br	101e42c <__alt_data_end+0xff01e42c>
 101e454:	1007883a 	mov	r3,r2
 101e458:	003ff506 	br	101e430 <__alt_data_end+0xff01e430>
 101e45c:	f800283a 	ret
 101e460:	500d883a 	mov	r6,r10
 101e464:	003ff106 	br	101e42c <__alt_data_end+0xff01e42c>

0101e468 <_Balloc>:
 101e468:	20801317 	ldw	r2,76(r4)
 101e46c:	defffc04 	addi	sp,sp,-16
 101e470:	dc400115 	stw	r17,4(sp)
 101e474:	dc000015 	stw	r16,0(sp)
 101e478:	dfc00315 	stw	ra,12(sp)
 101e47c:	dc800215 	stw	r18,8(sp)
 101e480:	2023883a 	mov	r17,r4
 101e484:	2821883a 	mov	r16,r5
 101e488:	10000f26 	beq	r2,zero,101e4c8 <_Balloc+0x60>
 101e48c:	8407883a 	add	r3,r16,r16
 101e490:	18c7883a 	add	r3,r3,r3
 101e494:	10c7883a 	add	r3,r2,r3
 101e498:	18800017 	ldw	r2,0(r3)
 101e49c:	10001126 	beq	r2,zero,101e4e4 <_Balloc+0x7c>
 101e4a0:	11000017 	ldw	r4,0(r2)
 101e4a4:	19000015 	stw	r4,0(r3)
 101e4a8:	10000415 	stw	zero,16(r2)
 101e4ac:	10000315 	stw	zero,12(r2)
 101e4b0:	dfc00317 	ldw	ra,12(sp)
 101e4b4:	dc800217 	ldw	r18,8(sp)
 101e4b8:	dc400117 	ldw	r17,4(sp)
 101e4bc:	dc000017 	ldw	r16,0(sp)
 101e4c0:	dec00404 	addi	sp,sp,16
 101e4c4:	f800283a 	ret
 101e4c8:	01800844 	movi	r6,33
 101e4cc:	01400104 	movi	r5,4
 101e4d0:	10229d80 	call	10229d8 <_calloc_r>
 101e4d4:	88801315 	stw	r2,76(r17)
 101e4d8:	103fec1e 	bne	r2,zero,101e48c <__alt_data_end+0xff01e48c>
 101e4dc:	0005883a 	mov	r2,zero
 101e4e0:	003ff306 	br	101e4b0 <__alt_data_end+0xff01e4b0>
 101e4e4:	01400044 	movi	r5,1
 101e4e8:	2c24983a 	sll	r18,r5,r16
 101e4ec:	8809883a 	mov	r4,r17
 101e4f0:	91800144 	addi	r6,r18,5
 101e4f4:	318d883a 	add	r6,r6,r6
 101e4f8:	318d883a 	add	r6,r6,r6
 101e4fc:	10229d80 	call	10229d8 <_calloc_r>
 101e500:	103ff626 	beq	r2,zero,101e4dc <__alt_data_end+0xff01e4dc>
 101e504:	14000115 	stw	r16,4(r2)
 101e508:	14800215 	stw	r18,8(r2)
 101e50c:	003fe606 	br	101e4a8 <__alt_data_end+0xff01e4a8>

0101e510 <_Bfree>:
 101e510:	28000826 	beq	r5,zero,101e534 <_Bfree+0x24>
 101e514:	28c00117 	ldw	r3,4(r5)
 101e518:	20801317 	ldw	r2,76(r4)
 101e51c:	18c7883a 	add	r3,r3,r3
 101e520:	18c7883a 	add	r3,r3,r3
 101e524:	10c5883a 	add	r2,r2,r3
 101e528:	10c00017 	ldw	r3,0(r2)
 101e52c:	28c00015 	stw	r3,0(r5)
 101e530:	11400015 	stw	r5,0(r2)
 101e534:	f800283a 	ret

0101e538 <__multadd>:
 101e538:	defffa04 	addi	sp,sp,-24
 101e53c:	dc800315 	stw	r18,12(sp)
 101e540:	dc400215 	stw	r17,8(sp)
 101e544:	dc000115 	stw	r16,4(sp)
 101e548:	2823883a 	mov	r17,r5
 101e54c:	2c000417 	ldw	r16,16(r5)
 101e550:	dfc00515 	stw	ra,20(sp)
 101e554:	dcc00415 	stw	r19,16(sp)
 101e558:	2025883a 	mov	r18,r4
 101e55c:	29400504 	addi	r5,r5,20
 101e560:	0011883a 	mov	r8,zero
 101e564:	28c00017 	ldw	r3,0(r5)
 101e568:	29400104 	addi	r5,r5,4
 101e56c:	42000044 	addi	r8,r8,1
 101e570:	18bfffcc 	andi	r2,r3,65535
 101e574:	1185383a 	mul	r2,r2,r6
 101e578:	1806d43a 	srli	r3,r3,16
 101e57c:	11cf883a 	add	r7,r2,r7
 101e580:	3808d43a 	srli	r4,r7,16
 101e584:	1987383a 	mul	r3,r3,r6
 101e588:	38bfffcc 	andi	r2,r7,65535
 101e58c:	1907883a 	add	r3,r3,r4
 101e590:	1808943a 	slli	r4,r3,16
 101e594:	180ed43a 	srli	r7,r3,16
 101e598:	2085883a 	add	r2,r4,r2
 101e59c:	28bfff15 	stw	r2,-4(r5)
 101e5a0:	443ff016 	blt	r8,r16,101e564 <__alt_data_end+0xff01e564>
 101e5a4:	38000926 	beq	r7,zero,101e5cc <__multadd+0x94>
 101e5a8:	88800217 	ldw	r2,8(r17)
 101e5ac:	80800f0e 	bge	r16,r2,101e5ec <__multadd+0xb4>
 101e5b0:	80800144 	addi	r2,r16,5
 101e5b4:	1085883a 	add	r2,r2,r2
 101e5b8:	1085883a 	add	r2,r2,r2
 101e5bc:	8885883a 	add	r2,r17,r2
 101e5c0:	11c00015 	stw	r7,0(r2)
 101e5c4:	84000044 	addi	r16,r16,1
 101e5c8:	8c000415 	stw	r16,16(r17)
 101e5cc:	8805883a 	mov	r2,r17
 101e5d0:	dfc00517 	ldw	ra,20(sp)
 101e5d4:	dcc00417 	ldw	r19,16(sp)
 101e5d8:	dc800317 	ldw	r18,12(sp)
 101e5dc:	dc400217 	ldw	r17,8(sp)
 101e5e0:	dc000117 	ldw	r16,4(sp)
 101e5e4:	dec00604 	addi	sp,sp,24
 101e5e8:	f800283a 	ret
 101e5ec:	89400117 	ldw	r5,4(r17)
 101e5f0:	9009883a 	mov	r4,r18
 101e5f4:	d9c00015 	stw	r7,0(sp)
 101e5f8:	29400044 	addi	r5,r5,1
 101e5fc:	101e4680 	call	101e468 <_Balloc>
 101e600:	89800417 	ldw	r6,16(r17)
 101e604:	89400304 	addi	r5,r17,12
 101e608:	11000304 	addi	r4,r2,12
 101e60c:	31800084 	addi	r6,r6,2
 101e610:	318d883a 	add	r6,r6,r6
 101e614:	318d883a 	add	r6,r6,r6
 101e618:	1027883a 	mov	r19,r2
 101e61c:	10158f40 	call	10158f4 <memcpy>
 101e620:	d9c00017 	ldw	r7,0(sp)
 101e624:	88000a26 	beq	r17,zero,101e650 <__multadd+0x118>
 101e628:	88c00117 	ldw	r3,4(r17)
 101e62c:	90801317 	ldw	r2,76(r18)
 101e630:	18c7883a 	add	r3,r3,r3
 101e634:	18c7883a 	add	r3,r3,r3
 101e638:	10c5883a 	add	r2,r2,r3
 101e63c:	10c00017 	ldw	r3,0(r2)
 101e640:	88c00015 	stw	r3,0(r17)
 101e644:	14400015 	stw	r17,0(r2)
 101e648:	9823883a 	mov	r17,r19
 101e64c:	003fd806 	br	101e5b0 <__alt_data_end+0xff01e5b0>
 101e650:	9823883a 	mov	r17,r19
 101e654:	003fd606 	br	101e5b0 <__alt_data_end+0xff01e5b0>

0101e658 <__s2b>:
 101e658:	defff904 	addi	sp,sp,-28
 101e65c:	dc400115 	stw	r17,4(sp)
 101e660:	dc000015 	stw	r16,0(sp)
 101e664:	2023883a 	mov	r17,r4
 101e668:	2821883a 	mov	r16,r5
 101e66c:	39000204 	addi	r4,r7,8
 101e670:	01400244 	movi	r5,9
 101e674:	dcc00315 	stw	r19,12(sp)
 101e678:	dc800215 	stw	r18,8(sp)
 101e67c:	dfc00615 	stw	ra,24(sp)
 101e680:	dd400515 	stw	r21,20(sp)
 101e684:	dd000415 	stw	r20,16(sp)
 101e688:	3825883a 	mov	r18,r7
 101e68c:	3027883a 	mov	r19,r6
 101e690:	1023d080 	call	1023d08 <__divsi3>
 101e694:	00c00044 	movi	r3,1
 101e698:	000b883a 	mov	r5,zero
 101e69c:	1880030e 	bge	r3,r2,101e6ac <__s2b+0x54>
 101e6a0:	18c7883a 	add	r3,r3,r3
 101e6a4:	29400044 	addi	r5,r5,1
 101e6a8:	18bffd16 	blt	r3,r2,101e6a0 <__alt_data_end+0xff01e6a0>
 101e6ac:	8809883a 	mov	r4,r17
 101e6b0:	101e4680 	call	101e468 <_Balloc>
 101e6b4:	d8c00717 	ldw	r3,28(sp)
 101e6b8:	10c00515 	stw	r3,20(r2)
 101e6bc:	00c00044 	movi	r3,1
 101e6c0:	10c00415 	stw	r3,16(r2)
 101e6c4:	00c00244 	movi	r3,9
 101e6c8:	1cc0210e 	bge	r3,r19,101e750 <__s2b+0xf8>
 101e6cc:	80eb883a 	add	r21,r16,r3
 101e6d0:	a829883a 	mov	r20,r21
 101e6d4:	84e1883a 	add	r16,r16,r19
 101e6d8:	a1c00007 	ldb	r7,0(r20)
 101e6dc:	01800284 	movi	r6,10
 101e6e0:	a5000044 	addi	r20,r20,1
 101e6e4:	100b883a 	mov	r5,r2
 101e6e8:	39fff404 	addi	r7,r7,-48
 101e6ec:	8809883a 	mov	r4,r17
 101e6f0:	101e5380 	call	101e538 <__multadd>
 101e6f4:	a43ff81e 	bne	r20,r16,101e6d8 <__alt_data_end+0xff01e6d8>
 101e6f8:	ace1883a 	add	r16,r21,r19
 101e6fc:	843ffe04 	addi	r16,r16,-8
 101e700:	9c800a0e 	bge	r19,r18,101e72c <__s2b+0xd4>
 101e704:	94e5c83a 	sub	r18,r18,r19
 101e708:	84a5883a 	add	r18,r16,r18
 101e70c:	81c00007 	ldb	r7,0(r16)
 101e710:	01800284 	movi	r6,10
 101e714:	84000044 	addi	r16,r16,1
 101e718:	100b883a 	mov	r5,r2
 101e71c:	39fff404 	addi	r7,r7,-48
 101e720:	8809883a 	mov	r4,r17
 101e724:	101e5380 	call	101e538 <__multadd>
 101e728:	84bff81e 	bne	r16,r18,101e70c <__alt_data_end+0xff01e70c>
 101e72c:	dfc00617 	ldw	ra,24(sp)
 101e730:	dd400517 	ldw	r21,20(sp)
 101e734:	dd000417 	ldw	r20,16(sp)
 101e738:	dcc00317 	ldw	r19,12(sp)
 101e73c:	dc800217 	ldw	r18,8(sp)
 101e740:	dc400117 	ldw	r17,4(sp)
 101e744:	dc000017 	ldw	r16,0(sp)
 101e748:	dec00704 	addi	sp,sp,28
 101e74c:	f800283a 	ret
 101e750:	84000284 	addi	r16,r16,10
 101e754:	1827883a 	mov	r19,r3
 101e758:	003fe906 	br	101e700 <__alt_data_end+0xff01e700>

0101e75c <__hi0bits>:
 101e75c:	20bfffec 	andhi	r2,r4,65535
 101e760:	1000141e 	bne	r2,zero,101e7b4 <__hi0bits+0x58>
 101e764:	2008943a 	slli	r4,r4,16
 101e768:	00800404 	movi	r2,16
 101e76c:	20ffc02c 	andhi	r3,r4,65280
 101e770:	1800021e 	bne	r3,zero,101e77c <__hi0bits+0x20>
 101e774:	2008923a 	slli	r4,r4,8
 101e778:	10800204 	addi	r2,r2,8
 101e77c:	20fc002c 	andhi	r3,r4,61440
 101e780:	1800021e 	bne	r3,zero,101e78c <__hi0bits+0x30>
 101e784:	2008913a 	slli	r4,r4,4
 101e788:	10800104 	addi	r2,r2,4
 101e78c:	20f0002c 	andhi	r3,r4,49152
 101e790:	1800031e 	bne	r3,zero,101e7a0 <__hi0bits+0x44>
 101e794:	2109883a 	add	r4,r4,r4
 101e798:	10800084 	addi	r2,r2,2
 101e79c:	2109883a 	add	r4,r4,r4
 101e7a0:	20000316 	blt	r4,zero,101e7b0 <__hi0bits+0x54>
 101e7a4:	2110002c 	andhi	r4,r4,16384
 101e7a8:	2000041e 	bne	r4,zero,101e7bc <__hi0bits+0x60>
 101e7ac:	00800804 	movi	r2,32
 101e7b0:	f800283a 	ret
 101e7b4:	0005883a 	mov	r2,zero
 101e7b8:	003fec06 	br	101e76c <__alt_data_end+0xff01e76c>
 101e7bc:	10800044 	addi	r2,r2,1
 101e7c0:	f800283a 	ret

0101e7c4 <__lo0bits>:
 101e7c4:	20c00017 	ldw	r3,0(r4)
 101e7c8:	188001cc 	andi	r2,r3,7
 101e7cc:	10000826 	beq	r2,zero,101e7f0 <__lo0bits+0x2c>
 101e7d0:	1880004c 	andi	r2,r3,1
 101e7d4:	1000211e 	bne	r2,zero,101e85c <__lo0bits+0x98>
 101e7d8:	1880008c 	andi	r2,r3,2
 101e7dc:	1000211e 	bne	r2,zero,101e864 <__lo0bits+0xa0>
 101e7e0:	1806d0ba 	srli	r3,r3,2
 101e7e4:	00800084 	movi	r2,2
 101e7e8:	20c00015 	stw	r3,0(r4)
 101e7ec:	f800283a 	ret
 101e7f0:	18bfffcc 	andi	r2,r3,65535
 101e7f4:	10001326 	beq	r2,zero,101e844 <__lo0bits+0x80>
 101e7f8:	0005883a 	mov	r2,zero
 101e7fc:	19403fcc 	andi	r5,r3,255
 101e800:	2800021e 	bne	r5,zero,101e80c <__lo0bits+0x48>
 101e804:	1806d23a 	srli	r3,r3,8
 101e808:	10800204 	addi	r2,r2,8
 101e80c:	194003cc 	andi	r5,r3,15
 101e810:	2800021e 	bne	r5,zero,101e81c <__lo0bits+0x58>
 101e814:	1806d13a 	srli	r3,r3,4
 101e818:	10800104 	addi	r2,r2,4
 101e81c:	194000cc 	andi	r5,r3,3
 101e820:	2800021e 	bne	r5,zero,101e82c <__lo0bits+0x68>
 101e824:	1806d0ba 	srli	r3,r3,2
 101e828:	10800084 	addi	r2,r2,2
 101e82c:	1940004c 	andi	r5,r3,1
 101e830:	2800081e 	bne	r5,zero,101e854 <__lo0bits+0x90>
 101e834:	1806d07a 	srli	r3,r3,1
 101e838:	1800051e 	bne	r3,zero,101e850 <__lo0bits+0x8c>
 101e83c:	00800804 	movi	r2,32
 101e840:	f800283a 	ret
 101e844:	1806d43a 	srli	r3,r3,16
 101e848:	00800404 	movi	r2,16
 101e84c:	003feb06 	br	101e7fc <__alt_data_end+0xff01e7fc>
 101e850:	10800044 	addi	r2,r2,1
 101e854:	20c00015 	stw	r3,0(r4)
 101e858:	f800283a 	ret
 101e85c:	0005883a 	mov	r2,zero
 101e860:	f800283a 	ret
 101e864:	1806d07a 	srli	r3,r3,1
 101e868:	00800044 	movi	r2,1
 101e86c:	20c00015 	stw	r3,0(r4)
 101e870:	f800283a 	ret

0101e874 <__i2b>:
 101e874:	defffd04 	addi	sp,sp,-12
 101e878:	dc000015 	stw	r16,0(sp)
 101e87c:	04000044 	movi	r16,1
 101e880:	dc400115 	stw	r17,4(sp)
 101e884:	2823883a 	mov	r17,r5
 101e888:	800b883a 	mov	r5,r16
 101e88c:	dfc00215 	stw	ra,8(sp)
 101e890:	101e4680 	call	101e468 <_Balloc>
 101e894:	14400515 	stw	r17,20(r2)
 101e898:	14000415 	stw	r16,16(r2)
 101e89c:	dfc00217 	ldw	ra,8(sp)
 101e8a0:	dc400117 	ldw	r17,4(sp)
 101e8a4:	dc000017 	ldw	r16,0(sp)
 101e8a8:	dec00304 	addi	sp,sp,12
 101e8ac:	f800283a 	ret

0101e8b0 <__multiply>:
 101e8b0:	defffa04 	addi	sp,sp,-24
 101e8b4:	dcc00315 	stw	r19,12(sp)
 101e8b8:	dc800215 	stw	r18,8(sp)
 101e8bc:	34c00417 	ldw	r19,16(r6)
 101e8c0:	2c800417 	ldw	r18,16(r5)
 101e8c4:	dd000415 	stw	r20,16(sp)
 101e8c8:	dc400115 	stw	r17,4(sp)
 101e8cc:	dfc00515 	stw	ra,20(sp)
 101e8d0:	dc000015 	stw	r16,0(sp)
 101e8d4:	2829883a 	mov	r20,r5
 101e8d8:	3023883a 	mov	r17,r6
 101e8dc:	94c0050e 	bge	r18,r19,101e8f4 <__multiply+0x44>
 101e8e0:	9007883a 	mov	r3,r18
 101e8e4:	3029883a 	mov	r20,r6
 101e8e8:	9825883a 	mov	r18,r19
 101e8ec:	2823883a 	mov	r17,r5
 101e8f0:	1827883a 	mov	r19,r3
 101e8f4:	a0800217 	ldw	r2,8(r20)
 101e8f8:	94e1883a 	add	r16,r18,r19
 101e8fc:	a1400117 	ldw	r5,4(r20)
 101e900:	1400010e 	bge	r2,r16,101e908 <__multiply+0x58>
 101e904:	29400044 	addi	r5,r5,1
 101e908:	101e4680 	call	101e468 <_Balloc>
 101e90c:	8415883a 	add	r10,r16,r16
 101e910:	12c00504 	addi	r11,r2,20
 101e914:	5295883a 	add	r10,r10,r10
 101e918:	5a95883a 	add	r10,r11,r10
 101e91c:	5807883a 	mov	r3,r11
 101e920:	5a80032e 	bgeu	r11,r10,101e930 <__multiply+0x80>
 101e924:	18000015 	stw	zero,0(r3)
 101e928:	18c00104 	addi	r3,r3,4
 101e92c:	1abffd36 	bltu	r3,r10,101e924 <__alt_data_end+0xff01e924>
 101e930:	9ce7883a 	add	r19,r19,r19
 101e934:	94a5883a 	add	r18,r18,r18
 101e938:	89800504 	addi	r6,r17,20
 101e93c:	9ce7883a 	add	r19,r19,r19
 101e940:	a3400504 	addi	r13,r20,20
 101e944:	94a5883a 	add	r18,r18,r18
 101e948:	34d9883a 	add	r12,r6,r19
 101e94c:	6c93883a 	add	r9,r13,r18
 101e950:	3300422e 	bgeu	r6,r12,101ea5c <__multiply+0x1ac>
 101e954:	37c00017 	ldw	ra,0(r6)
 101e958:	fbffffcc 	andi	r15,ra,65535
 101e95c:	78001b26 	beq	r15,zero,101e9cc <__multiply+0x11c>
 101e960:	5811883a 	mov	r8,r11
 101e964:	681d883a 	mov	r14,r13
 101e968:	000f883a 	mov	r7,zero
 101e96c:	71000017 	ldw	r4,0(r14)
 101e970:	40c00017 	ldw	r3,0(r8)
 101e974:	73800104 	addi	r14,r14,4
 101e978:	217fffcc 	andi	r5,r4,65535
 101e97c:	2bcb383a 	mul	r5,r5,r15
 101e980:	2008d43a 	srli	r4,r4,16
 101e984:	1c7fffcc 	andi	r17,r3,65535
 101e988:	2c4b883a 	add	r5,r5,r17
 101e98c:	29cb883a 	add	r5,r5,r7
 101e990:	23c9383a 	mul	r4,r4,r15
 101e994:	1806d43a 	srli	r3,r3,16
 101e998:	280ed43a 	srli	r7,r5,16
 101e99c:	297fffcc 	andi	r5,r5,65535
 101e9a0:	20c7883a 	add	r3,r4,r3
 101e9a4:	19c7883a 	add	r3,r3,r7
 101e9a8:	1808943a 	slli	r4,r3,16
 101e9ac:	4023883a 	mov	r17,r8
 101e9b0:	180ed43a 	srli	r7,r3,16
 101e9b4:	214ab03a 	or	r5,r4,r5
 101e9b8:	41400015 	stw	r5,0(r8)
 101e9bc:	42000104 	addi	r8,r8,4
 101e9c0:	727fea36 	bltu	r14,r9,101e96c <__alt_data_end+0xff01e96c>
 101e9c4:	89c00115 	stw	r7,4(r17)
 101e9c8:	37c00017 	ldw	ra,0(r6)
 101e9cc:	f83ed43a 	srli	ra,ra,16
 101e9d0:	f8001f26 	beq	ra,zero,101ea50 <__multiply+0x1a0>
 101e9d4:	58c00017 	ldw	r3,0(r11)
 101e9d8:	681d883a 	mov	r14,r13
 101e9dc:	581f883a 	mov	r15,r11
 101e9e0:	1811883a 	mov	r8,r3
 101e9e4:	5825883a 	mov	r18,r11
 101e9e8:	000f883a 	mov	r7,zero
 101e9ec:	00000106 	br	101e9f4 <__multiply+0x144>
 101e9f0:	8825883a 	mov	r18,r17
 101e9f4:	7140000b 	ldhu	r5,0(r14)
 101e9f8:	4010d43a 	srli	r8,r8,16
 101e9fc:	193fffcc 	andi	r4,r3,65535
 101ea00:	2fcb383a 	mul	r5,r5,ra
 101ea04:	7bc00104 	addi	r15,r15,4
 101ea08:	73800104 	addi	r14,r14,4
 101ea0c:	2a0b883a 	add	r5,r5,r8
 101ea10:	29cb883a 	add	r5,r5,r7
 101ea14:	2806943a 	slli	r3,r5,16
 101ea18:	94400104 	addi	r17,r18,4
 101ea1c:	280ad43a 	srli	r5,r5,16
 101ea20:	1908b03a 	or	r4,r3,r4
 101ea24:	793fff15 	stw	r4,-4(r15)
 101ea28:	70ffff17 	ldw	r3,-4(r14)
 101ea2c:	8a000017 	ldw	r8,0(r17)
 101ea30:	1806d43a 	srli	r3,r3,16
 101ea34:	413fffcc 	andi	r4,r8,65535
 101ea38:	1fc7383a 	mul	r3,r3,ra
 101ea3c:	1907883a 	add	r3,r3,r4
 101ea40:	1947883a 	add	r3,r3,r5
 101ea44:	180ed43a 	srli	r7,r3,16
 101ea48:	727fe936 	bltu	r14,r9,101e9f0 <__alt_data_end+0xff01e9f0>
 101ea4c:	90c00115 	stw	r3,4(r18)
 101ea50:	31800104 	addi	r6,r6,4
 101ea54:	5ac00104 	addi	r11,r11,4
 101ea58:	333fbe36 	bltu	r6,r12,101e954 <__alt_data_end+0xff01e954>
 101ea5c:	0400090e 	bge	zero,r16,101ea84 <__multiply+0x1d4>
 101ea60:	50ffff17 	ldw	r3,-4(r10)
 101ea64:	52bfff04 	addi	r10,r10,-4
 101ea68:	18000326 	beq	r3,zero,101ea78 <__multiply+0x1c8>
 101ea6c:	00000506 	br	101ea84 <__multiply+0x1d4>
 101ea70:	50c00017 	ldw	r3,0(r10)
 101ea74:	1800031e 	bne	r3,zero,101ea84 <__multiply+0x1d4>
 101ea78:	843fffc4 	addi	r16,r16,-1
 101ea7c:	52bfff04 	addi	r10,r10,-4
 101ea80:	803ffb1e 	bne	r16,zero,101ea70 <__alt_data_end+0xff01ea70>
 101ea84:	14000415 	stw	r16,16(r2)
 101ea88:	dfc00517 	ldw	ra,20(sp)
 101ea8c:	dd000417 	ldw	r20,16(sp)
 101ea90:	dcc00317 	ldw	r19,12(sp)
 101ea94:	dc800217 	ldw	r18,8(sp)
 101ea98:	dc400117 	ldw	r17,4(sp)
 101ea9c:	dc000017 	ldw	r16,0(sp)
 101eaa0:	dec00604 	addi	sp,sp,24
 101eaa4:	f800283a 	ret

0101eaa8 <__pow5mult>:
 101eaa8:	defffa04 	addi	sp,sp,-24
 101eaac:	dcc00315 	stw	r19,12(sp)
 101eab0:	dc000015 	stw	r16,0(sp)
 101eab4:	dfc00515 	stw	ra,20(sp)
 101eab8:	dd000415 	stw	r20,16(sp)
 101eabc:	dc800215 	stw	r18,8(sp)
 101eac0:	dc400115 	stw	r17,4(sp)
 101eac4:	308000cc 	andi	r2,r6,3
 101eac8:	3021883a 	mov	r16,r6
 101eacc:	2027883a 	mov	r19,r4
 101ead0:	10002f1e 	bne	r2,zero,101eb90 <__pow5mult+0xe8>
 101ead4:	2825883a 	mov	r18,r5
 101ead8:	8021d0ba 	srai	r16,r16,2
 101eadc:	80001a26 	beq	r16,zero,101eb48 <__pow5mult+0xa0>
 101eae0:	9c401217 	ldw	r17,72(r19)
 101eae4:	8800061e 	bne	r17,zero,101eb00 <__pow5mult+0x58>
 101eae8:	00003406 	br	101ebbc <__pow5mult+0x114>
 101eaec:	8021d07a 	srai	r16,r16,1
 101eaf0:	80001526 	beq	r16,zero,101eb48 <__pow5mult+0xa0>
 101eaf4:	88800017 	ldw	r2,0(r17)
 101eaf8:	10001c26 	beq	r2,zero,101eb6c <__pow5mult+0xc4>
 101eafc:	1023883a 	mov	r17,r2
 101eb00:	8080004c 	andi	r2,r16,1
 101eb04:	103ff926 	beq	r2,zero,101eaec <__alt_data_end+0xff01eaec>
 101eb08:	880d883a 	mov	r6,r17
 101eb0c:	900b883a 	mov	r5,r18
 101eb10:	9809883a 	mov	r4,r19
 101eb14:	101e8b00 	call	101e8b0 <__multiply>
 101eb18:	90001b26 	beq	r18,zero,101eb88 <__pow5mult+0xe0>
 101eb1c:	91000117 	ldw	r4,4(r18)
 101eb20:	98c01317 	ldw	r3,76(r19)
 101eb24:	8021d07a 	srai	r16,r16,1
 101eb28:	2109883a 	add	r4,r4,r4
 101eb2c:	2109883a 	add	r4,r4,r4
 101eb30:	1907883a 	add	r3,r3,r4
 101eb34:	19000017 	ldw	r4,0(r3)
 101eb38:	91000015 	stw	r4,0(r18)
 101eb3c:	1c800015 	stw	r18,0(r3)
 101eb40:	1025883a 	mov	r18,r2
 101eb44:	803feb1e 	bne	r16,zero,101eaf4 <__alt_data_end+0xff01eaf4>
 101eb48:	9005883a 	mov	r2,r18
 101eb4c:	dfc00517 	ldw	ra,20(sp)
 101eb50:	dd000417 	ldw	r20,16(sp)
 101eb54:	dcc00317 	ldw	r19,12(sp)
 101eb58:	dc800217 	ldw	r18,8(sp)
 101eb5c:	dc400117 	ldw	r17,4(sp)
 101eb60:	dc000017 	ldw	r16,0(sp)
 101eb64:	dec00604 	addi	sp,sp,24
 101eb68:	f800283a 	ret
 101eb6c:	880d883a 	mov	r6,r17
 101eb70:	880b883a 	mov	r5,r17
 101eb74:	9809883a 	mov	r4,r19
 101eb78:	101e8b00 	call	101e8b0 <__multiply>
 101eb7c:	88800015 	stw	r2,0(r17)
 101eb80:	10000015 	stw	zero,0(r2)
 101eb84:	003fdd06 	br	101eafc <__alt_data_end+0xff01eafc>
 101eb88:	1025883a 	mov	r18,r2
 101eb8c:	003fd706 	br	101eaec <__alt_data_end+0xff01eaec>
 101eb90:	10bfffc4 	addi	r2,r2,-1
 101eb94:	1085883a 	add	r2,r2,r2
 101eb98:	00c040f4 	movhi	r3,259
 101eb9c:	18eaa404 	addi	r3,r3,-21872
 101eba0:	1085883a 	add	r2,r2,r2
 101eba4:	1885883a 	add	r2,r3,r2
 101eba8:	11800017 	ldw	r6,0(r2)
 101ebac:	000f883a 	mov	r7,zero
 101ebb0:	101e5380 	call	101e538 <__multadd>
 101ebb4:	1025883a 	mov	r18,r2
 101ebb8:	003fc706 	br	101ead8 <__alt_data_end+0xff01ead8>
 101ebbc:	05000044 	movi	r20,1
 101ebc0:	a00b883a 	mov	r5,r20
 101ebc4:	9809883a 	mov	r4,r19
 101ebc8:	101e4680 	call	101e468 <_Balloc>
 101ebcc:	1023883a 	mov	r17,r2
 101ebd0:	00809c44 	movi	r2,625
 101ebd4:	88800515 	stw	r2,20(r17)
 101ebd8:	8d000415 	stw	r20,16(r17)
 101ebdc:	9c401215 	stw	r17,72(r19)
 101ebe0:	88000015 	stw	zero,0(r17)
 101ebe4:	003fc606 	br	101eb00 <__alt_data_end+0xff01eb00>

0101ebe8 <__lshift>:
 101ebe8:	defff904 	addi	sp,sp,-28
 101ebec:	dd400515 	stw	r21,20(sp)
 101ebf0:	dcc00315 	stw	r19,12(sp)
 101ebf4:	302bd17a 	srai	r21,r6,5
 101ebf8:	2cc00417 	ldw	r19,16(r5)
 101ebfc:	28800217 	ldw	r2,8(r5)
 101ec00:	dd000415 	stw	r20,16(sp)
 101ec04:	ace7883a 	add	r19,r21,r19
 101ec08:	dc800215 	stw	r18,8(sp)
 101ec0c:	dc400115 	stw	r17,4(sp)
 101ec10:	dc000015 	stw	r16,0(sp)
 101ec14:	dfc00615 	stw	ra,24(sp)
 101ec18:	9c000044 	addi	r16,r19,1
 101ec1c:	2823883a 	mov	r17,r5
 101ec20:	3029883a 	mov	r20,r6
 101ec24:	2025883a 	mov	r18,r4
 101ec28:	29400117 	ldw	r5,4(r5)
 101ec2c:	1400030e 	bge	r2,r16,101ec3c <__lshift+0x54>
 101ec30:	1085883a 	add	r2,r2,r2
 101ec34:	29400044 	addi	r5,r5,1
 101ec38:	143ffd16 	blt	r2,r16,101ec30 <__alt_data_end+0xff01ec30>
 101ec3c:	9009883a 	mov	r4,r18
 101ec40:	101e4680 	call	101e468 <_Balloc>
 101ec44:	10c00504 	addi	r3,r2,20
 101ec48:	0540070e 	bge	zero,r21,101ec68 <__lshift+0x80>
 101ec4c:	ad6b883a 	add	r21,r21,r21
 101ec50:	ad6b883a 	add	r21,r21,r21
 101ec54:	1809883a 	mov	r4,r3
 101ec58:	1d47883a 	add	r3,r3,r21
 101ec5c:	20000015 	stw	zero,0(r4)
 101ec60:	21000104 	addi	r4,r4,4
 101ec64:	193ffd1e 	bne	r3,r4,101ec5c <__alt_data_end+0xff01ec5c>
 101ec68:	8a000417 	ldw	r8,16(r17)
 101ec6c:	89000504 	addi	r4,r17,20
 101ec70:	a18007cc 	andi	r6,r20,31
 101ec74:	4211883a 	add	r8,r8,r8
 101ec78:	4211883a 	add	r8,r8,r8
 101ec7c:	2211883a 	add	r8,r4,r8
 101ec80:	30002326 	beq	r6,zero,101ed10 <__lshift+0x128>
 101ec84:	02400804 	movi	r9,32
 101ec88:	4993c83a 	sub	r9,r9,r6
 101ec8c:	000b883a 	mov	r5,zero
 101ec90:	21c00017 	ldw	r7,0(r4)
 101ec94:	1815883a 	mov	r10,r3
 101ec98:	18c00104 	addi	r3,r3,4
 101ec9c:	398e983a 	sll	r7,r7,r6
 101eca0:	21000104 	addi	r4,r4,4
 101eca4:	394ab03a 	or	r5,r7,r5
 101eca8:	197fff15 	stw	r5,-4(r3)
 101ecac:	217fff17 	ldw	r5,-4(r4)
 101ecb0:	2a4ad83a 	srl	r5,r5,r9
 101ecb4:	223ff636 	bltu	r4,r8,101ec90 <__alt_data_end+0xff01ec90>
 101ecb8:	51400115 	stw	r5,4(r10)
 101ecbc:	28001a1e 	bne	r5,zero,101ed28 <__lshift+0x140>
 101ecc0:	843fffc4 	addi	r16,r16,-1
 101ecc4:	14000415 	stw	r16,16(r2)
 101ecc8:	88000826 	beq	r17,zero,101ecec <__lshift+0x104>
 101eccc:	89000117 	ldw	r4,4(r17)
 101ecd0:	90c01317 	ldw	r3,76(r18)
 101ecd4:	2109883a 	add	r4,r4,r4
 101ecd8:	2109883a 	add	r4,r4,r4
 101ecdc:	1907883a 	add	r3,r3,r4
 101ece0:	19000017 	ldw	r4,0(r3)
 101ece4:	89000015 	stw	r4,0(r17)
 101ece8:	1c400015 	stw	r17,0(r3)
 101ecec:	dfc00617 	ldw	ra,24(sp)
 101ecf0:	dd400517 	ldw	r21,20(sp)
 101ecf4:	dd000417 	ldw	r20,16(sp)
 101ecf8:	dcc00317 	ldw	r19,12(sp)
 101ecfc:	dc800217 	ldw	r18,8(sp)
 101ed00:	dc400117 	ldw	r17,4(sp)
 101ed04:	dc000017 	ldw	r16,0(sp)
 101ed08:	dec00704 	addi	sp,sp,28
 101ed0c:	f800283a 	ret
 101ed10:	21400017 	ldw	r5,0(r4)
 101ed14:	18c00104 	addi	r3,r3,4
 101ed18:	21000104 	addi	r4,r4,4
 101ed1c:	197fff15 	stw	r5,-4(r3)
 101ed20:	223ffb36 	bltu	r4,r8,101ed10 <__alt_data_end+0xff01ed10>
 101ed24:	003fe606 	br	101ecc0 <__alt_data_end+0xff01ecc0>
 101ed28:	9c000084 	addi	r16,r19,2
 101ed2c:	003fe406 	br	101ecc0 <__alt_data_end+0xff01ecc0>

0101ed30 <__mcmp>:
 101ed30:	20800417 	ldw	r2,16(r4)
 101ed34:	28c00417 	ldw	r3,16(r5)
 101ed38:	10c5c83a 	sub	r2,r2,r3
 101ed3c:	1000111e 	bne	r2,zero,101ed84 <__mcmp+0x54>
 101ed40:	18c7883a 	add	r3,r3,r3
 101ed44:	18c7883a 	add	r3,r3,r3
 101ed48:	21000504 	addi	r4,r4,20
 101ed4c:	29400504 	addi	r5,r5,20
 101ed50:	20c5883a 	add	r2,r4,r3
 101ed54:	28cb883a 	add	r5,r5,r3
 101ed58:	00000106 	br	101ed60 <__mcmp+0x30>
 101ed5c:	20800a2e 	bgeu	r4,r2,101ed88 <__mcmp+0x58>
 101ed60:	10bfff04 	addi	r2,r2,-4
 101ed64:	297fff04 	addi	r5,r5,-4
 101ed68:	11800017 	ldw	r6,0(r2)
 101ed6c:	28c00017 	ldw	r3,0(r5)
 101ed70:	30fffa26 	beq	r6,r3,101ed5c <__alt_data_end+0xff01ed5c>
 101ed74:	30c00236 	bltu	r6,r3,101ed80 <__mcmp+0x50>
 101ed78:	00800044 	movi	r2,1
 101ed7c:	f800283a 	ret
 101ed80:	00bfffc4 	movi	r2,-1
 101ed84:	f800283a 	ret
 101ed88:	0005883a 	mov	r2,zero
 101ed8c:	f800283a 	ret

0101ed90 <__mdiff>:
 101ed90:	28c00417 	ldw	r3,16(r5)
 101ed94:	30800417 	ldw	r2,16(r6)
 101ed98:	defffa04 	addi	sp,sp,-24
 101ed9c:	dcc00315 	stw	r19,12(sp)
 101eda0:	dc800215 	stw	r18,8(sp)
 101eda4:	dfc00515 	stw	ra,20(sp)
 101eda8:	dd000415 	stw	r20,16(sp)
 101edac:	dc400115 	stw	r17,4(sp)
 101edb0:	dc000015 	stw	r16,0(sp)
 101edb4:	1887c83a 	sub	r3,r3,r2
 101edb8:	2825883a 	mov	r18,r5
 101edbc:	3027883a 	mov	r19,r6
 101edc0:	1800141e 	bne	r3,zero,101ee14 <__mdiff+0x84>
 101edc4:	1085883a 	add	r2,r2,r2
 101edc8:	1085883a 	add	r2,r2,r2
 101edcc:	2a000504 	addi	r8,r5,20
 101edd0:	34000504 	addi	r16,r6,20
 101edd4:	4087883a 	add	r3,r8,r2
 101edd8:	8085883a 	add	r2,r16,r2
 101eddc:	00000106 	br	101ede4 <__mdiff+0x54>
 101ede0:	40c0592e 	bgeu	r8,r3,101ef48 <__mdiff+0x1b8>
 101ede4:	18ffff04 	addi	r3,r3,-4
 101ede8:	10bfff04 	addi	r2,r2,-4
 101edec:	19c00017 	ldw	r7,0(r3)
 101edf0:	11400017 	ldw	r5,0(r2)
 101edf4:	397ffa26 	beq	r7,r5,101ede0 <__alt_data_end+0xff01ede0>
 101edf8:	3940592e 	bgeu	r7,r5,101ef60 <__mdiff+0x1d0>
 101edfc:	9005883a 	mov	r2,r18
 101ee00:	4023883a 	mov	r17,r8
 101ee04:	9825883a 	mov	r18,r19
 101ee08:	05000044 	movi	r20,1
 101ee0c:	1027883a 	mov	r19,r2
 101ee10:	00000406 	br	101ee24 <__mdiff+0x94>
 101ee14:	18005616 	blt	r3,zero,101ef70 <__mdiff+0x1e0>
 101ee18:	34400504 	addi	r17,r6,20
 101ee1c:	2c000504 	addi	r16,r5,20
 101ee20:	0029883a 	mov	r20,zero
 101ee24:	91400117 	ldw	r5,4(r18)
 101ee28:	101e4680 	call	101e468 <_Balloc>
 101ee2c:	92400417 	ldw	r9,16(r18)
 101ee30:	9b000417 	ldw	r12,16(r19)
 101ee34:	12c00504 	addi	r11,r2,20
 101ee38:	4a51883a 	add	r8,r9,r9
 101ee3c:	6319883a 	add	r12,r12,r12
 101ee40:	4211883a 	add	r8,r8,r8
 101ee44:	6319883a 	add	r12,r12,r12
 101ee48:	15000315 	stw	r20,12(r2)
 101ee4c:	8211883a 	add	r8,r16,r8
 101ee50:	8b19883a 	add	r12,r17,r12
 101ee54:	0007883a 	mov	r3,zero
 101ee58:	81400017 	ldw	r5,0(r16)
 101ee5c:	89c00017 	ldw	r7,0(r17)
 101ee60:	59800104 	addi	r6,r11,4
 101ee64:	293fffcc 	andi	r4,r5,65535
 101ee68:	20c7883a 	add	r3,r4,r3
 101ee6c:	393fffcc 	andi	r4,r7,65535
 101ee70:	1909c83a 	sub	r4,r3,r4
 101ee74:	280ad43a 	srli	r5,r5,16
 101ee78:	380ed43a 	srli	r7,r7,16
 101ee7c:	2007d43a 	srai	r3,r4,16
 101ee80:	213fffcc 	andi	r4,r4,65535
 101ee84:	29cbc83a 	sub	r5,r5,r7
 101ee88:	28c7883a 	add	r3,r5,r3
 101ee8c:	180a943a 	slli	r5,r3,16
 101ee90:	8c400104 	addi	r17,r17,4
 101ee94:	84000104 	addi	r16,r16,4
 101ee98:	2908b03a 	or	r4,r5,r4
 101ee9c:	59000015 	stw	r4,0(r11)
 101eea0:	1807d43a 	srai	r3,r3,16
 101eea4:	3015883a 	mov	r10,r6
 101eea8:	3017883a 	mov	r11,r6
 101eeac:	8b3fea36 	bltu	r17,r12,101ee58 <__alt_data_end+0xff01ee58>
 101eeb0:	8200162e 	bgeu	r16,r8,101ef0c <__mdiff+0x17c>
 101eeb4:	8017883a 	mov	r11,r16
 101eeb8:	59400017 	ldw	r5,0(r11)
 101eebc:	31800104 	addi	r6,r6,4
 101eec0:	5ac00104 	addi	r11,r11,4
 101eec4:	293fffcc 	andi	r4,r5,65535
 101eec8:	20c7883a 	add	r3,r4,r3
 101eecc:	280ed43a 	srli	r7,r5,16
 101eed0:	180bd43a 	srai	r5,r3,16
 101eed4:	193fffcc 	andi	r4,r3,65535
 101eed8:	3947883a 	add	r3,r7,r5
 101eedc:	180a943a 	slli	r5,r3,16
 101eee0:	1807d43a 	srai	r3,r3,16
 101eee4:	2908b03a 	or	r4,r5,r4
 101eee8:	313fff15 	stw	r4,-4(r6)
 101eeec:	5a3ff236 	bltu	r11,r8,101eeb8 <__alt_data_end+0xff01eeb8>
 101eef0:	0406303a 	nor	r3,zero,r16
 101eef4:	1a07883a 	add	r3,r3,r8
 101eef8:	1806d0ba 	srli	r3,r3,2
 101eefc:	18c00044 	addi	r3,r3,1
 101ef00:	18c7883a 	add	r3,r3,r3
 101ef04:	18c7883a 	add	r3,r3,r3
 101ef08:	50d5883a 	add	r10,r10,r3
 101ef0c:	50ffff04 	addi	r3,r10,-4
 101ef10:	2000041e 	bne	r4,zero,101ef24 <__mdiff+0x194>
 101ef14:	18ffff04 	addi	r3,r3,-4
 101ef18:	19000017 	ldw	r4,0(r3)
 101ef1c:	4a7fffc4 	addi	r9,r9,-1
 101ef20:	203ffc26 	beq	r4,zero,101ef14 <__alt_data_end+0xff01ef14>
 101ef24:	12400415 	stw	r9,16(r2)
 101ef28:	dfc00517 	ldw	ra,20(sp)
 101ef2c:	dd000417 	ldw	r20,16(sp)
 101ef30:	dcc00317 	ldw	r19,12(sp)
 101ef34:	dc800217 	ldw	r18,8(sp)
 101ef38:	dc400117 	ldw	r17,4(sp)
 101ef3c:	dc000017 	ldw	r16,0(sp)
 101ef40:	dec00604 	addi	sp,sp,24
 101ef44:	f800283a 	ret
 101ef48:	000b883a 	mov	r5,zero
 101ef4c:	101e4680 	call	101e468 <_Balloc>
 101ef50:	00c00044 	movi	r3,1
 101ef54:	10c00415 	stw	r3,16(r2)
 101ef58:	10000515 	stw	zero,20(r2)
 101ef5c:	003ff206 	br	101ef28 <__alt_data_end+0xff01ef28>
 101ef60:	8023883a 	mov	r17,r16
 101ef64:	0029883a 	mov	r20,zero
 101ef68:	4021883a 	mov	r16,r8
 101ef6c:	003fad06 	br	101ee24 <__alt_data_end+0xff01ee24>
 101ef70:	9005883a 	mov	r2,r18
 101ef74:	94400504 	addi	r17,r18,20
 101ef78:	9c000504 	addi	r16,r19,20
 101ef7c:	9825883a 	mov	r18,r19
 101ef80:	05000044 	movi	r20,1
 101ef84:	1027883a 	mov	r19,r2
 101ef88:	003fa606 	br	101ee24 <__alt_data_end+0xff01ee24>

0101ef8c <__ulp>:
 101ef8c:	295ffc2c 	andhi	r5,r5,32752
 101ef90:	00bf3034 	movhi	r2,64704
 101ef94:	2887883a 	add	r3,r5,r2
 101ef98:	00c0020e 	bge	zero,r3,101efa4 <__ulp+0x18>
 101ef9c:	0005883a 	mov	r2,zero
 101efa0:	f800283a 	ret
 101efa4:	00c7c83a 	sub	r3,zero,r3
 101efa8:	1807d53a 	srai	r3,r3,20
 101efac:	008004c4 	movi	r2,19
 101efb0:	10c00b0e 	bge	r2,r3,101efe0 <__ulp+0x54>
 101efb4:	18bffb04 	addi	r2,r3,-20
 101efb8:	01000784 	movi	r4,30
 101efbc:	0007883a 	mov	r3,zero
 101efc0:	20800516 	blt	r4,r2,101efd8 <__ulp+0x4c>
 101efc4:	010007c4 	movi	r4,31
 101efc8:	2089c83a 	sub	r4,r4,r2
 101efcc:	00800044 	movi	r2,1
 101efd0:	1104983a 	sll	r2,r2,r4
 101efd4:	f800283a 	ret
 101efd8:	00800044 	movi	r2,1
 101efdc:	f800283a 	ret
 101efe0:	01400234 	movhi	r5,8
 101efe4:	28c7d83a 	sra	r3,r5,r3
 101efe8:	0005883a 	mov	r2,zero
 101efec:	f800283a 	ret

0101eff0 <__b2d>:
 101eff0:	defffa04 	addi	sp,sp,-24
 101eff4:	dc000015 	stw	r16,0(sp)
 101eff8:	24000417 	ldw	r16,16(r4)
 101effc:	dc400115 	stw	r17,4(sp)
 101f000:	24400504 	addi	r17,r4,20
 101f004:	8421883a 	add	r16,r16,r16
 101f008:	8421883a 	add	r16,r16,r16
 101f00c:	8c21883a 	add	r16,r17,r16
 101f010:	dc800215 	stw	r18,8(sp)
 101f014:	84bfff17 	ldw	r18,-4(r16)
 101f018:	dd000415 	stw	r20,16(sp)
 101f01c:	dcc00315 	stw	r19,12(sp)
 101f020:	9009883a 	mov	r4,r18
 101f024:	2829883a 	mov	r20,r5
 101f028:	dfc00515 	stw	ra,20(sp)
 101f02c:	101e75c0 	call	101e75c <__hi0bits>
 101f030:	00c00804 	movi	r3,32
 101f034:	1889c83a 	sub	r4,r3,r2
 101f038:	a1000015 	stw	r4,0(r20)
 101f03c:	01000284 	movi	r4,10
 101f040:	84ffff04 	addi	r19,r16,-4
 101f044:	20801216 	blt	r4,r2,101f090 <__b2d+0xa0>
 101f048:	018002c4 	movi	r6,11
 101f04c:	308dc83a 	sub	r6,r6,r2
 101f050:	9186d83a 	srl	r3,r18,r6
 101f054:	18cffc34 	orhi	r3,r3,16368
 101f058:	8cc0212e 	bgeu	r17,r19,101f0e0 <__b2d+0xf0>
 101f05c:	813ffe17 	ldw	r4,-8(r16)
 101f060:	218cd83a 	srl	r6,r4,r6
 101f064:	10800544 	addi	r2,r2,21
 101f068:	9084983a 	sll	r2,r18,r2
 101f06c:	1184b03a 	or	r2,r2,r6
 101f070:	dfc00517 	ldw	ra,20(sp)
 101f074:	dd000417 	ldw	r20,16(sp)
 101f078:	dcc00317 	ldw	r19,12(sp)
 101f07c:	dc800217 	ldw	r18,8(sp)
 101f080:	dc400117 	ldw	r17,4(sp)
 101f084:	dc000017 	ldw	r16,0(sp)
 101f088:	dec00604 	addi	sp,sp,24
 101f08c:	f800283a 	ret
 101f090:	8cc00f2e 	bgeu	r17,r19,101f0d0 <__b2d+0xe0>
 101f094:	117ffd44 	addi	r5,r2,-11
 101f098:	80bffe17 	ldw	r2,-8(r16)
 101f09c:	28000e26 	beq	r5,zero,101f0d8 <__b2d+0xe8>
 101f0a0:	1949c83a 	sub	r4,r3,r5
 101f0a4:	9164983a 	sll	r18,r18,r5
 101f0a8:	1106d83a 	srl	r3,r2,r4
 101f0ac:	81bffe04 	addi	r6,r16,-8
 101f0b0:	948ffc34 	orhi	r18,r18,16368
 101f0b4:	90c6b03a 	or	r3,r18,r3
 101f0b8:	89800e2e 	bgeu	r17,r6,101f0f4 <__b2d+0x104>
 101f0bc:	81bffd17 	ldw	r6,-12(r16)
 101f0c0:	1144983a 	sll	r2,r2,r5
 101f0c4:	310ad83a 	srl	r5,r6,r4
 101f0c8:	2884b03a 	or	r2,r5,r2
 101f0cc:	003fe806 	br	101f070 <__alt_data_end+0xff01f070>
 101f0d0:	10bffd44 	addi	r2,r2,-11
 101f0d4:	1000041e 	bne	r2,zero,101f0e8 <__b2d+0xf8>
 101f0d8:	90cffc34 	orhi	r3,r18,16368
 101f0dc:	003fe406 	br	101f070 <__alt_data_end+0xff01f070>
 101f0e0:	000d883a 	mov	r6,zero
 101f0e4:	003fdf06 	br	101f064 <__alt_data_end+0xff01f064>
 101f0e8:	90a4983a 	sll	r18,r18,r2
 101f0ec:	0005883a 	mov	r2,zero
 101f0f0:	003ff906 	br	101f0d8 <__alt_data_end+0xff01f0d8>
 101f0f4:	1144983a 	sll	r2,r2,r5
 101f0f8:	003fdd06 	br	101f070 <__alt_data_end+0xff01f070>

0101f0fc <__d2b>:
 101f0fc:	defff804 	addi	sp,sp,-32
 101f100:	dc000215 	stw	r16,8(sp)
 101f104:	3021883a 	mov	r16,r6
 101f108:	dc400315 	stw	r17,12(sp)
 101f10c:	8022907a 	slli	r17,r16,1
 101f110:	dd000615 	stw	r20,24(sp)
 101f114:	2829883a 	mov	r20,r5
 101f118:	01400044 	movi	r5,1
 101f11c:	dcc00515 	stw	r19,20(sp)
 101f120:	dc800415 	stw	r18,16(sp)
 101f124:	dfc00715 	stw	ra,28(sp)
 101f128:	3825883a 	mov	r18,r7
 101f12c:	8822d57a 	srli	r17,r17,21
 101f130:	101e4680 	call	101e468 <_Balloc>
 101f134:	1027883a 	mov	r19,r2
 101f138:	00800434 	movhi	r2,16
 101f13c:	10bfffc4 	addi	r2,r2,-1
 101f140:	808c703a 	and	r6,r16,r2
 101f144:	88000126 	beq	r17,zero,101f14c <__d2b+0x50>
 101f148:	31800434 	orhi	r6,r6,16
 101f14c:	d9800015 	stw	r6,0(sp)
 101f150:	a0002426 	beq	r20,zero,101f1e4 <__d2b+0xe8>
 101f154:	d9000104 	addi	r4,sp,4
 101f158:	dd000115 	stw	r20,4(sp)
 101f15c:	101e7c40 	call	101e7c4 <__lo0bits>
 101f160:	d8c00017 	ldw	r3,0(sp)
 101f164:	10002f1e 	bne	r2,zero,101f224 <__d2b+0x128>
 101f168:	d9000117 	ldw	r4,4(sp)
 101f16c:	99000515 	stw	r4,20(r19)
 101f170:	1821003a 	cmpeq	r16,r3,zero
 101f174:	01000084 	movi	r4,2
 101f178:	2421c83a 	sub	r16,r4,r16
 101f17c:	98c00615 	stw	r3,24(r19)
 101f180:	9c000415 	stw	r16,16(r19)
 101f184:	88001f1e 	bne	r17,zero,101f204 <__d2b+0x108>
 101f188:	10bef384 	addi	r2,r2,-1074
 101f18c:	90800015 	stw	r2,0(r18)
 101f190:	00900034 	movhi	r2,16384
 101f194:	10bfffc4 	addi	r2,r2,-1
 101f198:	8085883a 	add	r2,r16,r2
 101f19c:	1085883a 	add	r2,r2,r2
 101f1a0:	1085883a 	add	r2,r2,r2
 101f1a4:	9885883a 	add	r2,r19,r2
 101f1a8:	11000517 	ldw	r4,20(r2)
 101f1ac:	8020917a 	slli	r16,r16,5
 101f1b0:	101e75c0 	call	101e75c <__hi0bits>
 101f1b4:	d8c00817 	ldw	r3,32(sp)
 101f1b8:	8085c83a 	sub	r2,r16,r2
 101f1bc:	18800015 	stw	r2,0(r3)
 101f1c0:	9805883a 	mov	r2,r19
 101f1c4:	dfc00717 	ldw	ra,28(sp)
 101f1c8:	dd000617 	ldw	r20,24(sp)
 101f1cc:	dcc00517 	ldw	r19,20(sp)
 101f1d0:	dc800417 	ldw	r18,16(sp)
 101f1d4:	dc400317 	ldw	r17,12(sp)
 101f1d8:	dc000217 	ldw	r16,8(sp)
 101f1dc:	dec00804 	addi	sp,sp,32
 101f1e0:	f800283a 	ret
 101f1e4:	d809883a 	mov	r4,sp
 101f1e8:	101e7c40 	call	101e7c4 <__lo0bits>
 101f1ec:	d8c00017 	ldw	r3,0(sp)
 101f1f0:	04000044 	movi	r16,1
 101f1f4:	9c000415 	stw	r16,16(r19)
 101f1f8:	98c00515 	stw	r3,20(r19)
 101f1fc:	10800804 	addi	r2,r2,32
 101f200:	883fe126 	beq	r17,zero,101f188 <__alt_data_end+0xff01f188>
 101f204:	00c00d44 	movi	r3,53
 101f208:	8c7ef344 	addi	r17,r17,-1075
 101f20c:	88a3883a 	add	r17,r17,r2
 101f210:	1885c83a 	sub	r2,r3,r2
 101f214:	d8c00817 	ldw	r3,32(sp)
 101f218:	94400015 	stw	r17,0(r18)
 101f21c:	18800015 	stw	r2,0(r3)
 101f220:	003fe706 	br	101f1c0 <__alt_data_end+0xff01f1c0>
 101f224:	01000804 	movi	r4,32
 101f228:	2089c83a 	sub	r4,r4,r2
 101f22c:	1908983a 	sll	r4,r3,r4
 101f230:	d9400117 	ldw	r5,4(sp)
 101f234:	1886d83a 	srl	r3,r3,r2
 101f238:	2148b03a 	or	r4,r4,r5
 101f23c:	99000515 	stw	r4,20(r19)
 101f240:	d8c00015 	stw	r3,0(sp)
 101f244:	003fca06 	br	101f170 <__alt_data_end+0xff01f170>

0101f248 <__ratio>:
 101f248:	defff904 	addi	sp,sp,-28
 101f24c:	dc400315 	stw	r17,12(sp)
 101f250:	2823883a 	mov	r17,r5
 101f254:	d9400104 	addi	r5,sp,4
 101f258:	dfc00615 	stw	ra,24(sp)
 101f25c:	dcc00515 	stw	r19,20(sp)
 101f260:	dc800415 	stw	r18,16(sp)
 101f264:	2027883a 	mov	r19,r4
 101f268:	dc000215 	stw	r16,8(sp)
 101f26c:	101eff00 	call	101eff0 <__b2d>
 101f270:	d80b883a 	mov	r5,sp
 101f274:	8809883a 	mov	r4,r17
 101f278:	1025883a 	mov	r18,r2
 101f27c:	1821883a 	mov	r16,r3
 101f280:	101eff00 	call	101eff0 <__b2d>
 101f284:	8a000417 	ldw	r8,16(r17)
 101f288:	99000417 	ldw	r4,16(r19)
 101f28c:	d9400117 	ldw	r5,4(sp)
 101f290:	2209c83a 	sub	r4,r4,r8
 101f294:	2010917a 	slli	r8,r4,5
 101f298:	d9000017 	ldw	r4,0(sp)
 101f29c:	2909c83a 	sub	r4,r5,r4
 101f2a0:	4109883a 	add	r4,r8,r4
 101f2a4:	01000e0e 	bge	zero,r4,101f2e0 <__ratio+0x98>
 101f2a8:	2008953a 	slli	r4,r4,20
 101f2ac:	2421883a 	add	r16,r4,r16
 101f2b0:	100d883a 	mov	r6,r2
 101f2b4:	180f883a 	mov	r7,r3
 101f2b8:	9009883a 	mov	r4,r18
 101f2bc:	800b883a 	mov	r5,r16
 101f2c0:	10247680 	call	1024768 <__divdf3>
 101f2c4:	dfc00617 	ldw	ra,24(sp)
 101f2c8:	dcc00517 	ldw	r19,20(sp)
 101f2cc:	dc800417 	ldw	r18,16(sp)
 101f2d0:	dc400317 	ldw	r17,12(sp)
 101f2d4:	dc000217 	ldw	r16,8(sp)
 101f2d8:	dec00704 	addi	sp,sp,28
 101f2dc:	f800283a 	ret
 101f2e0:	2008953a 	slli	r4,r4,20
 101f2e4:	1907c83a 	sub	r3,r3,r4
 101f2e8:	003ff106 	br	101f2b0 <__alt_data_end+0xff01f2b0>

0101f2ec <_mprec_log10>:
 101f2ec:	defffe04 	addi	sp,sp,-8
 101f2f0:	dc000015 	stw	r16,0(sp)
 101f2f4:	dfc00115 	stw	ra,4(sp)
 101f2f8:	008005c4 	movi	r2,23
 101f2fc:	2021883a 	mov	r16,r4
 101f300:	11000d0e 	bge	r2,r4,101f338 <_mprec_log10+0x4c>
 101f304:	0005883a 	mov	r2,zero
 101f308:	00cffc34 	movhi	r3,16368
 101f30c:	843fffc4 	addi	r16,r16,-1
 101f310:	000d883a 	mov	r6,zero
 101f314:	01d00934 	movhi	r7,16420
 101f318:	1009883a 	mov	r4,r2
 101f31c:	180b883a 	mov	r5,r3
 101f320:	10252a80 	call	10252a8 <__muldf3>
 101f324:	803ff91e 	bne	r16,zero,101f30c <__alt_data_end+0xff01f30c>
 101f328:	dfc00117 	ldw	ra,4(sp)
 101f32c:	dc000017 	ldw	r16,0(sp)
 101f330:	dec00204 	addi	sp,sp,8
 101f334:	f800283a 	ret
 101f338:	202090fa 	slli	r16,r4,3
 101f33c:	008040f4 	movhi	r2,259
 101f340:	10aabb04 	addi	r2,r2,-21780
 101f344:	1421883a 	add	r16,r2,r16
 101f348:	80800017 	ldw	r2,0(r16)
 101f34c:	80c00117 	ldw	r3,4(r16)
 101f350:	dfc00117 	ldw	ra,4(sp)
 101f354:	dc000017 	ldw	r16,0(sp)
 101f358:	dec00204 	addi	sp,sp,8
 101f35c:	f800283a 	ret

0101f360 <__copybits>:
 101f360:	297fffc4 	addi	r5,r5,-1
 101f364:	280fd17a 	srai	r7,r5,5
 101f368:	30c00417 	ldw	r3,16(r6)
 101f36c:	30800504 	addi	r2,r6,20
 101f370:	39c00044 	addi	r7,r7,1
 101f374:	18c7883a 	add	r3,r3,r3
 101f378:	39cf883a 	add	r7,r7,r7
 101f37c:	18c7883a 	add	r3,r3,r3
 101f380:	39cf883a 	add	r7,r7,r7
 101f384:	10c7883a 	add	r3,r2,r3
 101f388:	21cf883a 	add	r7,r4,r7
 101f38c:	10c00d2e 	bgeu	r2,r3,101f3c4 <__copybits+0x64>
 101f390:	200b883a 	mov	r5,r4
 101f394:	12000017 	ldw	r8,0(r2)
 101f398:	29400104 	addi	r5,r5,4
 101f39c:	10800104 	addi	r2,r2,4
 101f3a0:	2a3fff15 	stw	r8,-4(r5)
 101f3a4:	10fffb36 	bltu	r2,r3,101f394 <__alt_data_end+0xff01f394>
 101f3a8:	1985c83a 	sub	r2,r3,r6
 101f3ac:	10bffac4 	addi	r2,r2,-21
 101f3b0:	1004d0ba 	srli	r2,r2,2
 101f3b4:	10800044 	addi	r2,r2,1
 101f3b8:	1085883a 	add	r2,r2,r2
 101f3bc:	1085883a 	add	r2,r2,r2
 101f3c0:	2089883a 	add	r4,r4,r2
 101f3c4:	21c0032e 	bgeu	r4,r7,101f3d4 <__copybits+0x74>
 101f3c8:	20000015 	stw	zero,0(r4)
 101f3cc:	21000104 	addi	r4,r4,4
 101f3d0:	21fffd36 	bltu	r4,r7,101f3c8 <__alt_data_end+0xff01f3c8>
 101f3d4:	f800283a 	ret

0101f3d8 <__any_on>:
 101f3d8:	20c00417 	ldw	r3,16(r4)
 101f3dc:	2805d17a 	srai	r2,r5,5
 101f3e0:	21000504 	addi	r4,r4,20
 101f3e4:	18800d0e 	bge	r3,r2,101f41c <__any_on+0x44>
 101f3e8:	18c7883a 	add	r3,r3,r3
 101f3ec:	18c7883a 	add	r3,r3,r3
 101f3f0:	20c7883a 	add	r3,r4,r3
 101f3f4:	20c0192e 	bgeu	r4,r3,101f45c <__any_on+0x84>
 101f3f8:	18bfff17 	ldw	r2,-4(r3)
 101f3fc:	18ffff04 	addi	r3,r3,-4
 101f400:	1000041e 	bne	r2,zero,101f414 <__any_on+0x3c>
 101f404:	20c0142e 	bgeu	r4,r3,101f458 <__any_on+0x80>
 101f408:	18ffff04 	addi	r3,r3,-4
 101f40c:	19400017 	ldw	r5,0(r3)
 101f410:	283ffc26 	beq	r5,zero,101f404 <__alt_data_end+0xff01f404>
 101f414:	00800044 	movi	r2,1
 101f418:	f800283a 	ret
 101f41c:	10c00a0e 	bge	r2,r3,101f448 <__any_on+0x70>
 101f420:	1085883a 	add	r2,r2,r2
 101f424:	1085883a 	add	r2,r2,r2
 101f428:	294007cc 	andi	r5,r5,31
 101f42c:	2087883a 	add	r3,r4,r2
 101f430:	283ff026 	beq	r5,zero,101f3f4 <__alt_data_end+0xff01f3f4>
 101f434:	19800017 	ldw	r6,0(r3)
 101f438:	3144d83a 	srl	r2,r6,r5
 101f43c:	114a983a 	sll	r5,r2,r5
 101f440:	317ff41e 	bne	r6,r5,101f414 <__alt_data_end+0xff01f414>
 101f444:	003feb06 	br	101f3f4 <__alt_data_end+0xff01f3f4>
 101f448:	1085883a 	add	r2,r2,r2
 101f44c:	1085883a 	add	r2,r2,r2
 101f450:	2087883a 	add	r3,r4,r2
 101f454:	003fe706 	br	101f3f4 <__alt_data_end+0xff01f3f4>
 101f458:	f800283a 	ret
 101f45c:	0005883a 	mov	r2,zero
 101f460:	f800283a 	ret

0101f464 <_realloc_r>:
 101f464:	defff604 	addi	sp,sp,-40
 101f468:	dc800215 	stw	r18,8(sp)
 101f46c:	dfc00915 	stw	ra,36(sp)
 101f470:	df000815 	stw	fp,32(sp)
 101f474:	ddc00715 	stw	r23,28(sp)
 101f478:	dd800615 	stw	r22,24(sp)
 101f47c:	dd400515 	stw	r21,20(sp)
 101f480:	dd000415 	stw	r20,16(sp)
 101f484:	dcc00315 	stw	r19,12(sp)
 101f488:	dc400115 	stw	r17,4(sp)
 101f48c:	dc000015 	stw	r16,0(sp)
 101f490:	3025883a 	mov	r18,r6
 101f494:	2800b726 	beq	r5,zero,101f774 <_realloc_r+0x310>
 101f498:	282b883a 	mov	r21,r5
 101f49c:	2029883a 	mov	r20,r4
 101f4a0:	1026ed00 	call	1026ed0 <__malloc_lock>
 101f4a4:	a8bfff17 	ldw	r2,-4(r21)
 101f4a8:	043fff04 	movi	r16,-4
 101f4ac:	90c002c4 	addi	r3,r18,11
 101f4b0:	01000584 	movi	r4,22
 101f4b4:	acfffe04 	addi	r19,r21,-8
 101f4b8:	1420703a 	and	r16,r2,r16
 101f4bc:	20c0332e 	bgeu	r4,r3,101f58c <_realloc_r+0x128>
 101f4c0:	047ffe04 	movi	r17,-8
 101f4c4:	1c62703a 	and	r17,r3,r17
 101f4c8:	8807883a 	mov	r3,r17
 101f4cc:	88005816 	blt	r17,zero,101f630 <_realloc_r+0x1cc>
 101f4d0:	8c805736 	bltu	r17,r18,101f630 <_realloc_r+0x1cc>
 101f4d4:	80c0300e 	bge	r16,r3,101f598 <_realloc_r+0x134>
 101f4d8:	070040f4 	movhi	fp,259
 101f4dc:	e72cca04 	addi	fp,fp,-19672
 101f4e0:	e1c00217 	ldw	r7,8(fp)
 101f4e4:	9c09883a 	add	r4,r19,r16
 101f4e8:	22000117 	ldw	r8,4(r4)
 101f4ec:	21c06326 	beq	r4,r7,101f67c <_realloc_r+0x218>
 101f4f0:	017fff84 	movi	r5,-2
 101f4f4:	414a703a 	and	r5,r8,r5
 101f4f8:	214b883a 	add	r5,r4,r5
 101f4fc:	29800117 	ldw	r6,4(r5)
 101f500:	3180004c 	andi	r6,r6,1
 101f504:	30003f26 	beq	r6,zero,101f604 <_realloc_r+0x1a0>
 101f508:	1080004c 	andi	r2,r2,1
 101f50c:	10008326 	beq	r2,zero,101f71c <_realloc_r+0x2b8>
 101f510:	900b883a 	mov	r5,r18
 101f514:	a009883a 	mov	r4,r20
 101f518:	101da1c0 	call	101da1c <_malloc_r>
 101f51c:	1025883a 	mov	r18,r2
 101f520:	10011e26 	beq	r2,zero,101f99c <_realloc_r+0x538>
 101f524:	a93fff17 	ldw	r4,-4(r21)
 101f528:	10fffe04 	addi	r3,r2,-8
 101f52c:	00bfff84 	movi	r2,-2
 101f530:	2084703a 	and	r2,r4,r2
 101f534:	9885883a 	add	r2,r19,r2
 101f538:	1880ee26 	beq	r3,r2,101f8f4 <_realloc_r+0x490>
 101f53c:	81bfff04 	addi	r6,r16,-4
 101f540:	00800904 	movi	r2,36
 101f544:	1180b836 	bltu	r2,r6,101f828 <_realloc_r+0x3c4>
 101f548:	00c004c4 	movi	r3,19
 101f54c:	19809636 	bltu	r3,r6,101f7a8 <_realloc_r+0x344>
 101f550:	9005883a 	mov	r2,r18
 101f554:	a807883a 	mov	r3,r21
 101f558:	19000017 	ldw	r4,0(r3)
 101f55c:	11000015 	stw	r4,0(r2)
 101f560:	19000117 	ldw	r4,4(r3)
 101f564:	11000115 	stw	r4,4(r2)
 101f568:	18c00217 	ldw	r3,8(r3)
 101f56c:	10c00215 	stw	r3,8(r2)
 101f570:	a80b883a 	mov	r5,r21
 101f574:	a009883a 	mov	r4,r20
 101f578:	101ce300 	call	101ce30 <_free_r>
 101f57c:	a009883a 	mov	r4,r20
 101f580:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101f584:	9005883a 	mov	r2,r18
 101f588:	00001206 	br	101f5d4 <_realloc_r+0x170>
 101f58c:	00c00404 	movi	r3,16
 101f590:	1823883a 	mov	r17,r3
 101f594:	003fce06 	br	101f4d0 <__alt_data_end+0xff01f4d0>
 101f598:	a825883a 	mov	r18,r21
 101f59c:	8445c83a 	sub	r2,r16,r17
 101f5a0:	00c003c4 	movi	r3,15
 101f5a4:	18802636 	bltu	r3,r2,101f640 <_realloc_r+0x1dc>
 101f5a8:	99800117 	ldw	r6,4(r19)
 101f5ac:	9c07883a 	add	r3,r19,r16
 101f5b0:	3180004c 	andi	r6,r6,1
 101f5b4:	3420b03a 	or	r16,r6,r16
 101f5b8:	9c000115 	stw	r16,4(r19)
 101f5bc:	18800117 	ldw	r2,4(r3)
 101f5c0:	10800054 	ori	r2,r2,1
 101f5c4:	18800115 	stw	r2,4(r3)
 101f5c8:	a009883a 	mov	r4,r20
 101f5cc:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101f5d0:	9005883a 	mov	r2,r18
 101f5d4:	dfc00917 	ldw	ra,36(sp)
 101f5d8:	df000817 	ldw	fp,32(sp)
 101f5dc:	ddc00717 	ldw	r23,28(sp)
 101f5e0:	dd800617 	ldw	r22,24(sp)
 101f5e4:	dd400517 	ldw	r21,20(sp)
 101f5e8:	dd000417 	ldw	r20,16(sp)
 101f5ec:	dcc00317 	ldw	r19,12(sp)
 101f5f0:	dc800217 	ldw	r18,8(sp)
 101f5f4:	dc400117 	ldw	r17,4(sp)
 101f5f8:	dc000017 	ldw	r16,0(sp)
 101f5fc:	dec00a04 	addi	sp,sp,40
 101f600:	f800283a 	ret
 101f604:	017fff04 	movi	r5,-4
 101f608:	414a703a 	and	r5,r8,r5
 101f60c:	814d883a 	add	r6,r16,r5
 101f610:	30c01f16 	blt	r6,r3,101f690 <_realloc_r+0x22c>
 101f614:	20800317 	ldw	r2,12(r4)
 101f618:	20c00217 	ldw	r3,8(r4)
 101f61c:	a825883a 	mov	r18,r21
 101f620:	3021883a 	mov	r16,r6
 101f624:	18800315 	stw	r2,12(r3)
 101f628:	10c00215 	stw	r3,8(r2)
 101f62c:	003fdb06 	br	101f59c <__alt_data_end+0xff01f59c>
 101f630:	00800304 	movi	r2,12
 101f634:	a0800015 	stw	r2,0(r20)
 101f638:	0005883a 	mov	r2,zero
 101f63c:	003fe506 	br	101f5d4 <__alt_data_end+0xff01f5d4>
 101f640:	98c00117 	ldw	r3,4(r19)
 101f644:	9c4b883a 	add	r5,r19,r17
 101f648:	11000054 	ori	r4,r2,1
 101f64c:	18c0004c 	andi	r3,r3,1
 101f650:	1c62b03a 	or	r17,r3,r17
 101f654:	9c400115 	stw	r17,4(r19)
 101f658:	29000115 	stw	r4,4(r5)
 101f65c:	2885883a 	add	r2,r5,r2
 101f660:	10c00117 	ldw	r3,4(r2)
 101f664:	29400204 	addi	r5,r5,8
 101f668:	a009883a 	mov	r4,r20
 101f66c:	18c00054 	ori	r3,r3,1
 101f670:	10c00115 	stw	r3,4(r2)
 101f674:	101ce300 	call	101ce30 <_free_r>
 101f678:	003fd306 	br	101f5c8 <__alt_data_end+0xff01f5c8>
 101f67c:	017fff04 	movi	r5,-4
 101f680:	414a703a 	and	r5,r8,r5
 101f684:	89800404 	addi	r6,r17,16
 101f688:	8151883a 	add	r8,r16,r5
 101f68c:	4180590e 	bge	r8,r6,101f7f4 <_realloc_r+0x390>
 101f690:	1080004c 	andi	r2,r2,1
 101f694:	103f9e1e 	bne	r2,zero,101f510 <__alt_data_end+0xff01f510>
 101f698:	adbffe17 	ldw	r22,-8(r21)
 101f69c:	00bfff04 	movi	r2,-4
 101f6a0:	9dadc83a 	sub	r22,r19,r22
 101f6a4:	b1800117 	ldw	r6,4(r22)
 101f6a8:	3084703a 	and	r2,r6,r2
 101f6ac:	20002026 	beq	r4,zero,101f730 <_realloc_r+0x2cc>
 101f6b0:	80af883a 	add	r23,r16,r2
 101f6b4:	b96f883a 	add	r23,r23,r5
 101f6b8:	21c05f26 	beq	r4,r7,101f838 <_realloc_r+0x3d4>
 101f6bc:	b8c01c16 	blt	r23,r3,101f730 <_realloc_r+0x2cc>
 101f6c0:	20800317 	ldw	r2,12(r4)
 101f6c4:	20c00217 	ldw	r3,8(r4)
 101f6c8:	81bfff04 	addi	r6,r16,-4
 101f6cc:	01000904 	movi	r4,36
 101f6d0:	18800315 	stw	r2,12(r3)
 101f6d4:	10c00215 	stw	r3,8(r2)
 101f6d8:	b0c00217 	ldw	r3,8(r22)
 101f6dc:	b0800317 	ldw	r2,12(r22)
 101f6e0:	b4800204 	addi	r18,r22,8
 101f6e4:	18800315 	stw	r2,12(r3)
 101f6e8:	10c00215 	stw	r3,8(r2)
 101f6ec:	21801b36 	bltu	r4,r6,101f75c <_realloc_r+0x2f8>
 101f6f0:	008004c4 	movi	r2,19
 101f6f4:	1180352e 	bgeu	r2,r6,101f7cc <_realloc_r+0x368>
 101f6f8:	a8800017 	ldw	r2,0(r21)
 101f6fc:	b0800215 	stw	r2,8(r22)
 101f700:	a8800117 	ldw	r2,4(r21)
 101f704:	b0800315 	stw	r2,12(r22)
 101f708:	008006c4 	movi	r2,27
 101f70c:	11807f36 	bltu	r2,r6,101f90c <_realloc_r+0x4a8>
 101f710:	b0800404 	addi	r2,r22,16
 101f714:	ad400204 	addi	r21,r21,8
 101f718:	00002d06 	br	101f7d0 <_realloc_r+0x36c>
 101f71c:	adbffe17 	ldw	r22,-8(r21)
 101f720:	00bfff04 	movi	r2,-4
 101f724:	9dadc83a 	sub	r22,r19,r22
 101f728:	b1000117 	ldw	r4,4(r22)
 101f72c:	2084703a 	and	r2,r4,r2
 101f730:	b03f7726 	beq	r22,zero,101f510 <__alt_data_end+0xff01f510>
 101f734:	80af883a 	add	r23,r16,r2
 101f738:	b8ff7516 	blt	r23,r3,101f510 <__alt_data_end+0xff01f510>
 101f73c:	b0800317 	ldw	r2,12(r22)
 101f740:	b0c00217 	ldw	r3,8(r22)
 101f744:	81bfff04 	addi	r6,r16,-4
 101f748:	01000904 	movi	r4,36
 101f74c:	18800315 	stw	r2,12(r3)
 101f750:	10c00215 	stw	r3,8(r2)
 101f754:	b4800204 	addi	r18,r22,8
 101f758:	21bfe52e 	bgeu	r4,r6,101f6f0 <__alt_data_end+0xff01f6f0>
 101f75c:	a80b883a 	mov	r5,r21
 101f760:	9009883a 	mov	r4,r18
 101f764:	101e30c0 	call	101e30c <memmove>
 101f768:	b821883a 	mov	r16,r23
 101f76c:	b027883a 	mov	r19,r22
 101f770:	003f8a06 	br	101f59c <__alt_data_end+0xff01f59c>
 101f774:	300b883a 	mov	r5,r6
 101f778:	dfc00917 	ldw	ra,36(sp)
 101f77c:	df000817 	ldw	fp,32(sp)
 101f780:	ddc00717 	ldw	r23,28(sp)
 101f784:	dd800617 	ldw	r22,24(sp)
 101f788:	dd400517 	ldw	r21,20(sp)
 101f78c:	dd000417 	ldw	r20,16(sp)
 101f790:	dcc00317 	ldw	r19,12(sp)
 101f794:	dc800217 	ldw	r18,8(sp)
 101f798:	dc400117 	ldw	r17,4(sp)
 101f79c:	dc000017 	ldw	r16,0(sp)
 101f7a0:	dec00a04 	addi	sp,sp,40
 101f7a4:	101da1c1 	jmpi	101da1c <_malloc_r>
 101f7a8:	a8c00017 	ldw	r3,0(r21)
 101f7ac:	90c00015 	stw	r3,0(r18)
 101f7b0:	a8c00117 	ldw	r3,4(r21)
 101f7b4:	90c00115 	stw	r3,4(r18)
 101f7b8:	00c006c4 	movi	r3,27
 101f7bc:	19804536 	bltu	r3,r6,101f8d4 <_realloc_r+0x470>
 101f7c0:	90800204 	addi	r2,r18,8
 101f7c4:	a8c00204 	addi	r3,r21,8
 101f7c8:	003f6306 	br	101f558 <__alt_data_end+0xff01f558>
 101f7cc:	9005883a 	mov	r2,r18
 101f7d0:	a8c00017 	ldw	r3,0(r21)
 101f7d4:	b821883a 	mov	r16,r23
 101f7d8:	b027883a 	mov	r19,r22
 101f7dc:	10c00015 	stw	r3,0(r2)
 101f7e0:	a8c00117 	ldw	r3,4(r21)
 101f7e4:	10c00115 	stw	r3,4(r2)
 101f7e8:	a8c00217 	ldw	r3,8(r21)
 101f7ec:	10c00215 	stw	r3,8(r2)
 101f7f0:	003f6a06 	br	101f59c <__alt_data_end+0xff01f59c>
 101f7f4:	9c67883a 	add	r19,r19,r17
 101f7f8:	4445c83a 	sub	r2,r8,r17
 101f7fc:	e4c00215 	stw	r19,8(fp)
 101f800:	10800054 	ori	r2,r2,1
 101f804:	98800115 	stw	r2,4(r19)
 101f808:	a8bfff17 	ldw	r2,-4(r21)
 101f80c:	a009883a 	mov	r4,r20
 101f810:	1080004c 	andi	r2,r2,1
 101f814:	1462b03a 	or	r17,r2,r17
 101f818:	ac7fff15 	stw	r17,-4(r21)
 101f81c:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101f820:	a805883a 	mov	r2,r21
 101f824:	003f6b06 	br	101f5d4 <__alt_data_end+0xff01f5d4>
 101f828:	a80b883a 	mov	r5,r21
 101f82c:	9009883a 	mov	r4,r18
 101f830:	101e30c0 	call	101e30c <memmove>
 101f834:	003f4e06 	br	101f570 <__alt_data_end+0xff01f570>
 101f838:	89000404 	addi	r4,r17,16
 101f83c:	b93fbc16 	blt	r23,r4,101f730 <__alt_data_end+0xff01f730>
 101f840:	b0800317 	ldw	r2,12(r22)
 101f844:	b0c00217 	ldw	r3,8(r22)
 101f848:	81bfff04 	addi	r6,r16,-4
 101f84c:	01000904 	movi	r4,36
 101f850:	18800315 	stw	r2,12(r3)
 101f854:	10c00215 	stw	r3,8(r2)
 101f858:	b4800204 	addi	r18,r22,8
 101f85c:	21804336 	bltu	r4,r6,101f96c <_realloc_r+0x508>
 101f860:	008004c4 	movi	r2,19
 101f864:	11803f2e 	bgeu	r2,r6,101f964 <_realloc_r+0x500>
 101f868:	a8800017 	ldw	r2,0(r21)
 101f86c:	b0800215 	stw	r2,8(r22)
 101f870:	a8800117 	ldw	r2,4(r21)
 101f874:	b0800315 	stw	r2,12(r22)
 101f878:	008006c4 	movi	r2,27
 101f87c:	11803f36 	bltu	r2,r6,101f97c <_realloc_r+0x518>
 101f880:	b0800404 	addi	r2,r22,16
 101f884:	ad400204 	addi	r21,r21,8
 101f888:	a8c00017 	ldw	r3,0(r21)
 101f88c:	10c00015 	stw	r3,0(r2)
 101f890:	a8c00117 	ldw	r3,4(r21)
 101f894:	10c00115 	stw	r3,4(r2)
 101f898:	a8c00217 	ldw	r3,8(r21)
 101f89c:	10c00215 	stw	r3,8(r2)
 101f8a0:	b447883a 	add	r3,r22,r17
 101f8a4:	bc45c83a 	sub	r2,r23,r17
 101f8a8:	e0c00215 	stw	r3,8(fp)
 101f8ac:	10800054 	ori	r2,r2,1
 101f8b0:	18800115 	stw	r2,4(r3)
 101f8b4:	b0800117 	ldw	r2,4(r22)
 101f8b8:	a009883a 	mov	r4,r20
 101f8bc:	1080004c 	andi	r2,r2,1
 101f8c0:	1462b03a 	or	r17,r2,r17
 101f8c4:	b4400115 	stw	r17,4(r22)
 101f8c8:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101f8cc:	9005883a 	mov	r2,r18
 101f8d0:	003f4006 	br	101f5d4 <__alt_data_end+0xff01f5d4>
 101f8d4:	a8c00217 	ldw	r3,8(r21)
 101f8d8:	90c00215 	stw	r3,8(r18)
 101f8dc:	a8c00317 	ldw	r3,12(r21)
 101f8e0:	90c00315 	stw	r3,12(r18)
 101f8e4:	30801126 	beq	r6,r2,101f92c <_realloc_r+0x4c8>
 101f8e8:	90800404 	addi	r2,r18,16
 101f8ec:	a8c00404 	addi	r3,r21,16
 101f8f0:	003f1906 	br	101f558 <__alt_data_end+0xff01f558>
 101f8f4:	90ffff17 	ldw	r3,-4(r18)
 101f8f8:	00bfff04 	movi	r2,-4
 101f8fc:	a825883a 	mov	r18,r21
 101f900:	1884703a 	and	r2,r3,r2
 101f904:	80a1883a 	add	r16,r16,r2
 101f908:	003f2406 	br	101f59c <__alt_data_end+0xff01f59c>
 101f90c:	a8800217 	ldw	r2,8(r21)
 101f910:	b0800415 	stw	r2,16(r22)
 101f914:	a8800317 	ldw	r2,12(r21)
 101f918:	b0800515 	stw	r2,20(r22)
 101f91c:	31000a26 	beq	r6,r4,101f948 <_realloc_r+0x4e4>
 101f920:	b0800604 	addi	r2,r22,24
 101f924:	ad400404 	addi	r21,r21,16
 101f928:	003fa906 	br	101f7d0 <__alt_data_end+0xff01f7d0>
 101f92c:	a9000417 	ldw	r4,16(r21)
 101f930:	90800604 	addi	r2,r18,24
 101f934:	a8c00604 	addi	r3,r21,24
 101f938:	91000415 	stw	r4,16(r18)
 101f93c:	a9000517 	ldw	r4,20(r21)
 101f940:	91000515 	stw	r4,20(r18)
 101f944:	003f0406 	br	101f558 <__alt_data_end+0xff01f558>
 101f948:	a8c00417 	ldw	r3,16(r21)
 101f94c:	ad400604 	addi	r21,r21,24
 101f950:	b0800804 	addi	r2,r22,32
 101f954:	b0c00615 	stw	r3,24(r22)
 101f958:	a8ffff17 	ldw	r3,-4(r21)
 101f95c:	b0c00715 	stw	r3,28(r22)
 101f960:	003f9b06 	br	101f7d0 <__alt_data_end+0xff01f7d0>
 101f964:	9005883a 	mov	r2,r18
 101f968:	003fc706 	br	101f888 <__alt_data_end+0xff01f888>
 101f96c:	a80b883a 	mov	r5,r21
 101f970:	9009883a 	mov	r4,r18
 101f974:	101e30c0 	call	101e30c <memmove>
 101f978:	003fc906 	br	101f8a0 <__alt_data_end+0xff01f8a0>
 101f97c:	a8800217 	ldw	r2,8(r21)
 101f980:	b0800415 	stw	r2,16(r22)
 101f984:	a8800317 	ldw	r2,12(r21)
 101f988:	b0800515 	stw	r2,20(r22)
 101f98c:	31000726 	beq	r6,r4,101f9ac <_realloc_r+0x548>
 101f990:	b0800604 	addi	r2,r22,24
 101f994:	ad400404 	addi	r21,r21,16
 101f998:	003fbb06 	br	101f888 <__alt_data_end+0xff01f888>
 101f99c:	a009883a 	mov	r4,r20
 101f9a0:	1026ef40 	call	1026ef4 <__malloc_unlock>
 101f9a4:	0005883a 	mov	r2,zero
 101f9a8:	003f0a06 	br	101f5d4 <__alt_data_end+0xff01f5d4>
 101f9ac:	a8c00417 	ldw	r3,16(r21)
 101f9b0:	ad400604 	addi	r21,r21,24
 101f9b4:	b0800804 	addi	r2,r22,32
 101f9b8:	b0c00615 	stw	r3,24(r22)
 101f9bc:	a8ffff17 	ldw	r3,-4(r21)
 101f9c0:	b0c00715 	stw	r3,28(r22)
 101f9c4:	003fb006 	br	101f888 <__alt_data_end+0xff01f888>

0101f9c8 <__fpclassifyd>:
 101f9c8:	00a00034 	movhi	r2,32768
 101f9cc:	10bfffc4 	addi	r2,r2,-1
 101f9d0:	2884703a 	and	r2,r5,r2
 101f9d4:	10000726 	beq	r2,zero,101f9f4 <__fpclassifyd+0x2c>
 101f9d8:	00fffc34 	movhi	r3,65520
 101f9dc:	019ff834 	movhi	r6,32736
 101f9e0:	28c7883a 	add	r3,r5,r3
 101f9e4:	31bfffc4 	addi	r6,r6,-1
 101f9e8:	30c00536 	bltu	r6,r3,101fa00 <__fpclassifyd+0x38>
 101f9ec:	00800104 	movi	r2,4
 101f9f0:	f800283a 	ret
 101f9f4:	2000021e 	bne	r4,zero,101fa00 <__fpclassifyd+0x38>
 101f9f8:	00800084 	movi	r2,2
 101f9fc:	f800283a 	ret
 101fa00:	00dffc34 	movhi	r3,32752
 101fa04:	019ff834 	movhi	r6,32736
 101fa08:	28cb883a 	add	r5,r5,r3
 101fa0c:	31bfffc4 	addi	r6,r6,-1
 101fa10:	317ff62e 	bgeu	r6,r5,101f9ec <__alt_data_end+0xff01f9ec>
 101fa14:	01400434 	movhi	r5,16
 101fa18:	297fffc4 	addi	r5,r5,-1
 101fa1c:	28800236 	bltu	r5,r2,101fa28 <__fpclassifyd+0x60>
 101fa20:	008000c4 	movi	r2,3
 101fa24:	f800283a 	ret
 101fa28:	10c00226 	beq	r2,r3,101fa34 <__fpclassifyd+0x6c>
 101fa2c:	0005883a 	mov	r2,zero
 101fa30:	f800283a 	ret
 101fa34:	2005003a 	cmpeq	r2,r4,zero
 101fa38:	f800283a 	ret

0101fa3c <_sbrk_r>:
 101fa3c:	defffd04 	addi	sp,sp,-12
 101fa40:	dc000015 	stw	r16,0(sp)
 101fa44:	040040f4 	movhi	r16,259
 101fa48:	dc400115 	stw	r17,4(sp)
 101fa4c:	8439ad04 	addi	r16,r16,-6476
 101fa50:	2023883a 	mov	r17,r4
 101fa54:	2809883a 	mov	r4,r5
 101fa58:	dfc00215 	stw	ra,8(sp)
 101fa5c:	80000015 	stw	zero,0(r16)
 101fa60:	10270b40 	call	10270b4 <sbrk>
 101fa64:	00ffffc4 	movi	r3,-1
 101fa68:	10c00526 	beq	r2,r3,101fa80 <_sbrk_r+0x44>
 101fa6c:	dfc00217 	ldw	ra,8(sp)
 101fa70:	dc400117 	ldw	r17,4(sp)
 101fa74:	dc000017 	ldw	r16,0(sp)
 101fa78:	dec00304 	addi	sp,sp,12
 101fa7c:	f800283a 	ret
 101fa80:	80c00017 	ldw	r3,0(r16)
 101fa84:	183ff926 	beq	r3,zero,101fa6c <__alt_data_end+0xff01fa6c>
 101fa88:	88c00015 	stw	r3,0(r17)
 101fa8c:	003ff706 	br	101fa6c <__alt_data_end+0xff01fa6c>

0101fa90 <_init_signal_r>:
 101fa90:	2080b717 	ldw	r2,732(r4)
 101fa94:	10000226 	beq	r2,zero,101faa0 <_init_signal_r+0x10>
 101fa98:	0005883a 	mov	r2,zero
 101fa9c:	f800283a 	ret
 101faa0:	defffe04 	addi	sp,sp,-8
 101faa4:	01402004 	movi	r5,128
 101faa8:	dc000015 	stw	r16,0(sp)
 101faac:	dfc00115 	stw	ra,4(sp)
 101fab0:	2021883a 	mov	r16,r4
 101fab4:	101da1c0 	call	101da1c <_malloc_r>
 101fab8:	8080b715 	stw	r2,732(r16)
 101fabc:	10000d26 	beq	r2,zero,101faf4 <_init_signal_r+0x64>
 101fac0:	0007883a 	mov	r3,zero
 101fac4:	01002004 	movi	r4,128
 101fac8:	00000106 	br	101fad0 <_init_signal_r+0x40>
 101facc:	8080b717 	ldw	r2,732(r16)
 101fad0:	10c5883a 	add	r2,r2,r3
 101fad4:	10000015 	stw	zero,0(r2)
 101fad8:	18c00104 	addi	r3,r3,4
 101fadc:	193ffb1e 	bne	r3,r4,101facc <__alt_data_end+0xff01facc>
 101fae0:	0005883a 	mov	r2,zero
 101fae4:	dfc00117 	ldw	ra,4(sp)
 101fae8:	dc000017 	ldw	r16,0(sp)
 101faec:	dec00204 	addi	sp,sp,8
 101faf0:	f800283a 	ret
 101faf4:	00bfffc4 	movi	r2,-1
 101faf8:	003ffa06 	br	101fae4 <__alt_data_end+0xff01fae4>

0101fafc <_signal_r>:
 101fafc:	00c007c4 	movi	r3,31
 101fb00:	19401536 	bltu	r3,r5,101fb58 <_signal_r+0x5c>
 101fb04:	2080b717 	ldw	r2,732(r4)
 101fb08:	defffc04 	addi	sp,sp,-16
 101fb0c:	dc800215 	stw	r18,8(sp)
 101fb10:	dc400115 	stw	r17,4(sp)
 101fb14:	dc000015 	stw	r16,0(sp)
 101fb18:	dfc00315 	stw	ra,12(sp)
 101fb1c:	3023883a 	mov	r17,r6
 101fb20:	2021883a 	mov	r16,r4
 101fb24:	2825883a 	mov	r18,r5
 101fb28:	10000f26 	beq	r2,zero,101fb68 <_signal_r+0x6c>
 101fb2c:	948b883a 	add	r5,r18,r18
 101fb30:	294b883a 	add	r5,r5,r5
 101fb34:	114b883a 	add	r5,r2,r5
 101fb38:	28800017 	ldw	r2,0(r5)
 101fb3c:	2c400015 	stw	r17,0(r5)
 101fb40:	dfc00317 	ldw	ra,12(sp)
 101fb44:	dc800217 	ldw	r18,8(sp)
 101fb48:	dc400117 	ldw	r17,4(sp)
 101fb4c:	dc000017 	ldw	r16,0(sp)
 101fb50:	dec00404 	addi	sp,sp,16
 101fb54:	f800283a 	ret
 101fb58:	00c00584 	movi	r3,22
 101fb5c:	20c00015 	stw	r3,0(r4)
 101fb60:	00bfffc4 	movi	r2,-1
 101fb64:	f800283a 	ret
 101fb68:	101fa900 	call	101fa90 <_init_signal_r>
 101fb6c:	1000021e 	bne	r2,zero,101fb78 <_signal_r+0x7c>
 101fb70:	8080b717 	ldw	r2,732(r16)
 101fb74:	003fed06 	br	101fb2c <__alt_data_end+0xff01fb2c>
 101fb78:	00bfffc4 	movi	r2,-1
 101fb7c:	003ff006 	br	101fb40 <__alt_data_end+0xff01fb40>

0101fb80 <_raise_r>:
 101fb80:	008007c4 	movi	r2,31
 101fb84:	11402936 	bltu	r2,r5,101fc2c <_raise_r+0xac>
 101fb88:	20c0b717 	ldw	r3,732(r4)
 101fb8c:	defffd04 	addi	sp,sp,-12
 101fb90:	dc400115 	stw	r17,4(sp)
 101fb94:	dc000015 	stw	r16,0(sp)
 101fb98:	dfc00215 	stw	ra,8(sp)
 101fb9c:	2021883a 	mov	r16,r4
 101fba0:	2823883a 	mov	r17,r5
 101fba4:	18001726 	beq	r3,zero,101fc04 <_raise_r+0x84>
 101fba8:	2945883a 	add	r2,r5,r5
 101fbac:	1085883a 	add	r2,r2,r2
 101fbb0:	1887883a 	add	r3,r3,r2
 101fbb4:	19800017 	ldw	r6,0(r3)
 101fbb8:	30001226 	beq	r6,zero,101fc04 <_raise_r+0x84>
 101fbbc:	00800044 	movi	r2,1
 101fbc0:	30800e26 	beq	r6,r2,101fbfc <_raise_r+0x7c>
 101fbc4:	013fffc4 	movi	r4,-1
 101fbc8:	31000926 	beq	r6,r4,101fbf0 <_raise_r+0x70>
 101fbcc:	18000015 	stw	zero,0(r3)
 101fbd0:	2809883a 	mov	r4,r5
 101fbd4:	303ee83a 	callr	r6
 101fbd8:	0005883a 	mov	r2,zero
 101fbdc:	dfc00217 	ldw	ra,8(sp)
 101fbe0:	dc400117 	ldw	r17,4(sp)
 101fbe4:	dc000017 	ldw	r16,0(sp)
 101fbe8:	dec00304 	addi	sp,sp,12
 101fbec:	f800283a 	ret
 101fbf0:	00c00584 	movi	r3,22
 101fbf4:	80c00015 	stw	r3,0(r16)
 101fbf8:	003ff806 	br	101fbdc <__alt_data_end+0xff01fbdc>
 101fbfc:	0005883a 	mov	r2,zero
 101fc00:	003ff606 	br	101fbdc <__alt_data_end+0xff01fbdc>
 101fc04:	8009883a 	mov	r4,r16
 101fc08:	101fd900 	call	101fd90 <_getpid_r>
 101fc0c:	880d883a 	mov	r6,r17
 101fc10:	100b883a 	mov	r5,r2
 101fc14:	8009883a 	mov	r4,r16
 101fc18:	dfc00217 	ldw	ra,8(sp)
 101fc1c:	dc400117 	ldw	r17,4(sp)
 101fc20:	dc000017 	ldw	r16,0(sp)
 101fc24:	dec00304 	addi	sp,sp,12
 101fc28:	101fd341 	jmpi	101fd34 <_kill_r>
 101fc2c:	00800584 	movi	r2,22
 101fc30:	20800015 	stw	r2,0(r4)
 101fc34:	00bfffc4 	movi	r2,-1
 101fc38:	f800283a 	ret

0101fc3c <__sigtramp_r>:
 101fc3c:	008007c4 	movi	r2,31
 101fc40:	11402436 	bltu	r2,r5,101fcd4 <__sigtramp_r+0x98>
 101fc44:	20c0b717 	ldw	r3,732(r4)
 101fc48:	defffd04 	addi	sp,sp,-12
 101fc4c:	dc400115 	stw	r17,4(sp)
 101fc50:	dc000015 	stw	r16,0(sp)
 101fc54:	dfc00215 	stw	ra,8(sp)
 101fc58:	2021883a 	mov	r16,r4
 101fc5c:	2823883a 	mov	r17,r5
 101fc60:	18001826 	beq	r3,zero,101fcc4 <__sigtramp_r+0x88>
 101fc64:	8c45883a 	add	r2,r17,r17
 101fc68:	1085883a 	add	r2,r2,r2
 101fc6c:	1885883a 	add	r2,r3,r2
 101fc70:	10c00017 	ldw	r3,0(r2)
 101fc74:	18001126 	beq	r3,zero,101fcbc <__sigtramp_r+0x80>
 101fc78:	013fffc4 	movi	r4,-1
 101fc7c:	19000d26 	beq	r3,r4,101fcb4 <__sigtramp_r+0x78>
 101fc80:	01000044 	movi	r4,1
 101fc84:	19000926 	beq	r3,r4,101fcac <__sigtramp_r+0x70>
 101fc88:	10000015 	stw	zero,0(r2)
 101fc8c:	8809883a 	mov	r4,r17
 101fc90:	183ee83a 	callr	r3
 101fc94:	0005883a 	mov	r2,zero
 101fc98:	dfc00217 	ldw	ra,8(sp)
 101fc9c:	dc400117 	ldw	r17,4(sp)
 101fca0:	dc000017 	ldw	r16,0(sp)
 101fca4:	dec00304 	addi	sp,sp,12
 101fca8:	f800283a 	ret
 101fcac:	008000c4 	movi	r2,3
 101fcb0:	003ff906 	br	101fc98 <__alt_data_end+0xff01fc98>
 101fcb4:	00800084 	movi	r2,2
 101fcb8:	003ff706 	br	101fc98 <__alt_data_end+0xff01fc98>
 101fcbc:	00800044 	movi	r2,1
 101fcc0:	003ff506 	br	101fc98 <__alt_data_end+0xff01fc98>
 101fcc4:	101fa900 	call	101fa90 <_init_signal_r>
 101fcc8:	1000041e 	bne	r2,zero,101fcdc <__sigtramp_r+0xa0>
 101fccc:	80c0b717 	ldw	r3,732(r16)
 101fcd0:	003fe406 	br	101fc64 <__alt_data_end+0xff01fc64>
 101fcd4:	00bfffc4 	movi	r2,-1
 101fcd8:	f800283a 	ret
 101fcdc:	00bfffc4 	movi	r2,-1
 101fce0:	003fed06 	br	101fc98 <__alt_data_end+0xff01fc98>

0101fce4 <raise>:
 101fce4:	008040f4 	movhi	r2,259
 101fce8:	10b25d04 	addi	r2,r2,-13964
 101fcec:	200b883a 	mov	r5,r4
 101fcf0:	11000017 	ldw	r4,0(r2)
 101fcf4:	101fb801 	jmpi	101fb80 <_raise_r>

0101fcf8 <signal>:
 101fcf8:	008040f4 	movhi	r2,259
 101fcfc:	10b25d04 	addi	r2,r2,-13964
 101fd00:	280d883a 	mov	r6,r5
 101fd04:	200b883a 	mov	r5,r4
 101fd08:	11000017 	ldw	r4,0(r2)
 101fd0c:	101fafc1 	jmpi	101fafc <_signal_r>

0101fd10 <_init_signal>:
 101fd10:	008040f4 	movhi	r2,259
 101fd14:	10b25d04 	addi	r2,r2,-13964
 101fd18:	11000017 	ldw	r4,0(r2)
 101fd1c:	101fa901 	jmpi	101fa90 <_init_signal_r>

0101fd20 <__sigtramp>:
 101fd20:	008040f4 	movhi	r2,259
 101fd24:	10b25d04 	addi	r2,r2,-13964
 101fd28:	200b883a 	mov	r5,r4
 101fd2c:	11000017 	ldw	r4,0(r2)
 101fd30:	101fc3c1 	jmpi	101fc3c <__sigtramp_r>

0101fd34 <_kill_r>:
 101fd34:	defffd04 	addi	sp,sp,-12
 101fd38:	2805883a 	mov	r2,r5
 101fd3c:	dc000015 	stw	r16,0(sp)
 101fd40:	040040f4 	movhi	r16,259
 101fd44:	dc400115 	stw	r17,4(sp)
 101fd48:	8439ad04 	addi	r16,r16,-6476
 101fd4c:	2023883a 	mov	r17,r4
 101fd50:	300b883a 	mov	r5,r6
 101fd54:	1009883a 	mov	r4,r2
 101fd58:	dfc00215 	stw	ra,8(sp)
 101fd5c:	80000015 	stw	zero,0(r16)
 101fd60:	1026b280 	call	1026b28 <kill>
 101fd64:	00ffffc4 	movi	r3,-1
 101fd68:	10c00526 	beq	r2,r3,101fd80 <_kill_r+0x4c>
 101fd6c:	dfc00217 	ldw	ra,8(sp)
 101fd70:	dc400117 	ldw	r17,4(sp)
 101fd74:	dc000017 	ldw	r16,0(sp)
 101fd78:	dec00304 	addi	sp,sp,12
 101fd7c:	f800283a 	ret
 101fd80:	80c00017 	ldw	r3,0(r16)
 101fd84:	183ff926 	beq	r3,zero,101fd6c <__alt_data_end+0xff01fd6c>
 101fd88:	88c00015 	stw	r3,0(r17)
 101fd8c:	003ff706 	br	101fd6c <__alt_data_end+0xff01fd6c>

0101fd90 <_getpid_r>:
 101fd90:	102683c1 	jmpi	102683c <getpid>

0101fd94 <__sread>:
 101fd94:	defffe04 	addi	sp,sp,-8
 101fd98:	dc000015 	stw	r16,0(sp)
 101fd9c:	2821883a 	mov	r16,r5
 101fda0:	2940038f 	ldh	r5,14(r5)
 101fda4:	dfc00115 	stw	ra,4(sp)
 101fda8:	1022eb80 	call	1022eb8 <_read_r>
 101fdac:	10000716 	blt	r2,zero,101fdcc <__sread+0x38>
 101fdb0:	80c01417 	ldw	r3,80(r16)
 101fdb4:	1887883a 	add	r3,r3,r2
 101fdb8:	80c01415 	stw	r3,80(r16)
 101fdbc:	dfc00117 	ldw	ra,4(sp)
 101fdc0:	dc000017 	ldw	r16,0(sp)
 101fdc4:	dec00204 	addi	sp,sp,8
 101fdc8:	f800283a 	ret
 101fdcc:	80c0030b 	ldhu	r3,12(r16)
 101fdd0:	18fbffcc 	andi	r3,r3,61439
 101fdd4:	80c0030d 	sth	r3,12(r16)
 101fdd8:	dfc00117 	ldw	ra,4(sp)
 101fddc:	dc000017 	ldw	r16,0(sp)
 101fde0:	dec00204 	addi	sp,sp,8
 101fde4:	f800283a 	ret

0101fde8 <__seofread>:
 101fde8:	0005883a 	mov	r2,zero
 101fdec:	f800283a 	ret

0101fdf0 <__swrite>:
 101fdf0:	2880030b 	ldhu	r2,12(r5)
 101fdf4:	defffb04 	addi	sp,sp,-20
 101fdf8:	dcc00315 	stw	r19,12(sp)
 101fdfc:	dc800215 	stw	r18,8(sp)
 101fe00:	dc400115 	stw	r17,4(sp)
 101fe04:	dc000015 	stw	r16,0(sp)
 101fe08:	dfc00415 	stw	ra,16(sp)
 101fe0c:	10c0400c 	andi	r3,r2,256
 101fe10:	2821883a 	mov	r16,r5
 101fe14:	2023883a 	mov	r17,r4
 101fe18:	3025883a 	mov	r18,r6
 101fe1c:	3827883a 	mov	r19,r7
 101fe20:	18000526 	beq	r3,zero,101fe38 <__swrite+0x48>
 101fe24:	2940038f 	ldh	r5,14(r5)
 101fe28:	01c00084 	movi	r7,2
 101fe2c:	000d883a 	mov	r6,zero
 101fe30:	1022e580 	call	1022e58 <_lseek_r>
 101fe34:	8080030b 	ldhu	r2,12(r16)
 101fe38:	8140038f 	ldh	r5,14(r16)
 101fe3c:	10bbffcc 	andi	r2,r2,61439
 101fe40:	980f883a 	mov	r7,r19
 101fe44:	900d883a 	mov	r6,r18
 101fe48:	8809883a 	mov	r4,r17
 101fe4c:	8080030d 	sth	r2,12(r16)
 101fe50:	dfc00417 	ldw	ra,16(sp)
 101fe54:	dcc00317 	ldw	r19,12(sp)
 101fe58:	dc800217 	ldw	r18,8(sp)
 101fe5c:	dc400117 	ldw	r17,4(sp)
 101fe60:	dc000017 	ldw	r16,0(sp)
 101fe64:	dec00504 	addi	sp,sp,20
 101fe68:	10229241 	jmpi	1022924 <_write_r>

0101fe6c <__sseek>:
 101fe6c:	defffe04 	addi	sp,sp,-8
 101fe70:	dc000015 	stw	r16,0(sp)
 101fe74:	2821883a 	mov	r16,r5
 101fe78:	2940038f 	ldh	r5,14(r5)
 101fe7c:	dfc00115 	stw	ra,4(sp)
 101fe80:	1022e580 	call	1022e58 <_lseek_r>
 101fe84:	00ffffc4 	movi	r3,-1
 101fe88:	10c00826 	beq	r2,r3,101feac <__sseek+0x40>
 101fe8c:	80c0030b 	ldhu	r3,12(r16)
 101fe90:	80801415 	stw	r2,80(r16)
 101fe94:	18c40014 	ori	r3,r3,4096
 101fe98:	80c0030d 	sth	r3,12(r16)
 101fe9c:	dfc00117 	ldw	ra,4(sp)
 101fea0:	dc000017 	ldw	r16,0(sp)
 101fea4:	dec00204 	addi	sp,sp,8
 101fea8:	f800283a 	ret
 101feac:	80c0030b 	ldhu	r3,12(r16)
 101feb0:	18fbffcc 	andi	r3,r3,61439
 101feb4:	80c0030d 	sth	r3,12(r16)
 101feb8:	dfc00117 	ldw	ra,4(sp)
 101febc:	dc000017 	ldw	r16,0(sp)
 101fec0:	dec00204 	addi	sp,sp,8
 101fec4:	f800283a 	ret

0101fec8 <__sclose>:
 101fec8:	2940038f 	ldh	r5,14(r5)
 101fecc:	10229841 	jmpi	1022984 <_close_r>

0101fed0 <__ssprint_r>:
 101fed0:	30800217 	ldw	r2,8(r6)
 101fed4:	defff604 	addi	sp,sp,-40
 101fed8:	dc800215 	stw	r18,8(sp)
 101fedc:	dfc00915 	stw	ra,36(sp)
 101fee0:	df000815 	stw	fp,32(sp)
 101fee4:	ddc00715 	stw	r23,28(sp)
 101fee8:	dd800615 	stw	r22,24(sp)
 101feec:	dd400515 	stw	r21,20(sp)
 101fef0:	dd000415 	stw	r20,16(sp)
 101fef4:	dcc00315 	stw	r19,12(sp)
 101fef8:	dc400115 	stw	r17,4(sp)
 101fefc:	dc000015 	stw	r16,0(sp)
 101ff00:	3025883a 	mov	r18,r6
 101ff04:	10005826 	beq	r2,zero,1020068 <__ssprint_r+0x198>
 101ff08:	2027883a 	mov	r19,r4
 101ff0c:	35c00017 	ldw	r23,0(r6)
 101ff10:	29000017 	ldw	r4,0(r5)
 101ff14:	28800217 	ldw	r2,8(r5)
 101ff18:	2823883a 	mov	r17,r5
 101ff1c:	0039883a 	mov	fp,zero
 101ff20:	0021883a 	mov	r16,zero
 101ff24:	80003926 	beq	r16,zero,102000c <__ssprint_r+0x13c>
 101ff28:	102b883a 	mov	r21,r2
 101ff2c:	102d883a 	mov	r22,r2
 101ff30:	80803a36 	bltu	r16,r2,102001c <__ssprint_r+0x14c>
 101ff34:	88c0030b 	ldhu	r3,12(r17)
 101ff38:	1881200c 	andi	r2,r3,1152
 101ff3c:	10002626 	beq	r2,zero,101ffd8 <__ssprint_r+0x108>
 101ff40:	88800517 	ldw	r2,20(r17)
 101ff44:	89400417 	ldw	r5,16(r17)
 101ff48:	81800044 	addi	r6,r16,1
 101ff4c:	108f883a 	add	r7,r2,r2
 101ff50:	3885883a 	add	r2,r7,r2
 101ff54:	100ed7fa 	srli	r7,r2,31
 101ff58:	216dc83a 	sub	r22,r4,r5
 101ff5c:	3589883a 	add	r4,r6,r22
 101ff60:	3885883a 	add	r2,r7,r2
 101ff64:	102bd07a 	srai	r21,r2,1
 101ff68:	a80d883a 	mov	r6,r21
 101ff6c:	a900022e 	bgeu	r21,r4,101ff78 <__ssprint_r+0xa8>
 101ff70:	202b883a 	mov	r21,r4
 101ff74:	200d883a 	mov	r6,r4
 101ff78:	18c1000c 	andi	r3,r3,1024
 101ff7c:	18002a26 	beq	r3,zero,1020028 <__ssprint_r+0x158>
 101ff80:	300b883a 	mov	r5,r6
 101ff84:	9809883a 	mov	r4,r19
 101ff88:	101da1c0 	call	101da1c <_malloc_r>
 101ff8c:	1029883a 	mov	r20,r2
 101ff90:	10002c26 	beq	r2,zero,1020044 <__ssprint_r+0x174>
 101ff94:	89400417 	ldw	r5,16(r17)
 101ff98:	b00d883a 	mov	r6,r22
 101ff9c:	1009883a 	mov	r4,r2
 101ffa0:	10158f40 	call	10158f4 <memcpy>
 101ffa4:	8880030b 	ldhu	r2,12(r17)
 101ffa8:	00fedfc4 	movi	r3,-1153
 101ffac:	10c4703a 	and	r2,r2,r3
 101ffb0:	10802014 	ori	r2,r2,128
 101ffb4:	8880030d 	sth	r2,12(r17)
 101ffb8:	a589883a 	add	r4,r20,r22
 101ffbc:	adadc83a 	sub	r22,r21,r22
 101ffc0:	8d400515 	stw	r21,20(r17)
 101ffc4:	8d800215 	stw	r22,8(r17)
 101ffc8:	8d000415 	stw	r20,16(r17)
 101ffcc:	89000015 	stw	r4,0(r17)
 101ffd0:	802b883a 	mov	r21,r16
 101ffd4:	802d883a 	mov	r22,r16
 101ffd8:	b00d883a 	mov	r6,r22
 101ffdc:	e00b883a 	mov	r5,fp
 101ffe0:	101e30c0 	call	101e30c <memmove>
 101ffe4:	88800217 	ldw	r2,8(r17)
 101ffe8:	89000017 	ldw	r4,0(r17)
 101ffec:	90c00217 	ldw	r3,8(r18)
 101fff0:	1545c83a 	sub	r2,r2,r21
 101fff4:	2589883a 	add	r4,r4,r22
 101fff8:	88800215 	stw	r2,8(r17)
 101fffc:	89000015 	stw	r4,0(r17)
 1020000:	1c21c83a 	sub	r16,r3,r16
 1020004:	94000215 	stw	r16,8(r18)
 1020008:	80001726 	beq	r16,zero,1020068 <__ssprint_r+0x198>
 102000c:	bf000017 	ldw	fp,0(r23)
 1020010:	bc000117 	ldw	r16,4(r23)
 1020014:	bdc00204 	addi	r23,r23,8
 1020018:	003fc206 	br	101ff24 <__alt_data_end+0xff01ff24>
 102001c:	802b883a 	mov	r21,r16
 1020020:	802d883a 	mov	r22,r16
 1020024:	003fec06 	br	101ffd8 <__alt_data_end+0xff01ffd8>
 1020028:	9809883a 	mov	r4,r19
 102002c:	101f4640 	call	101f464 <_realloc_r>
 1020030:	1029883a 	mov	r20,r2
 1020034:	103fe01e 	bne	r2,zero,101ffb8 <__alt_data_end+0xff01ffb8>
 1020038:	89400417 	ldw	r5,16(r17)
 102003c:	9809883a 	mov	r4,r19
 1020040:	101ce300 	call	101ce30 <_free_r>
 1020044:	88c0030b 	ldhu	r3,12(r17)
 1020048:	00800304 	movi	r2,12
 102004c:	98800015 	stw	r2,0(r19)
 1020050:	18c01014 	ori	r3,r3,64
 1020054:	88c0030d 	sth	r3,12(r17)
 1020058:	00bfffc4 	movi	r2,-1
 102005c:	90000215 	stw	zero,8(r18)
 1020060:	90000115 	stw	zero,4(r18)
 1020064:	00000206 	br	1020070 <__ssprint_r+0x1a0>
 1020068:	90000115 	stw	zero,4(r18)
 102006c:	0005883a 	mov	r2,zero
 1020070:	dfc00917 	ldw	ra,36(sp)
 1020074:	df000817 	ldw	fp,32(sp)
 1020078:	ddc00717 	ldw	r23,28(sp)
 102007c:	dd800617 	ldw	r22,24(sp)
 1020080:	dd400517 	ldw	r21,20(sp)
 1020084:	dd000417 	ldw	r20,16(sp)
 1020088:	dcc00317 	ldw	r19,12(sp)
 102008c:	dc800217 	ldw	r18,8(sp)
 1020090:	dc400117 	ldw	r17,4(sp)
 1020094:	dc000017 	ldw	r16,0(sp)
 1020098:	dec00a04 	addi	sp,sp,40
 102009c:	f800283a 	ret

010200a0 <___svfiprintf_internal_r>:
 10200a0:	2880030b 	ldhu	r2,12(r5)
 10200a4:	deffc804 	addi	sp,sp,-224
 10200a8:	dcc03115 	stw	r19,196(sp)
 10200ac:	dfc03715 	stw	ra,220(sp)
 10200b0:	df003615 	stw	fp,216(sp)
 10200b4:	ddc03515 	stw	r23,212(sp)
 10200b8:	dd803415 	stw	r22,208(sp)
 10200bc:	dd403315 	stw	r21,204(sp)
 10200c0:	dd003215 	stw	r20,200(sp)
 10200c4:	dc803015 	stw	r18,192(sp)
 10200c8:	dc402f15 	stw	r17,188(sp)
 10200cc:	dc002e15 	stw	r16,184(sp)
 10200d0:	d9402715 	stw	r5,156(sp)
 10200d4:	d9002a15 	stw	r4,168(sp)
 10200d8:	1080200c 	andi	r2,r2,128
 10200dc:	d9c02315 	stw	r7,140(sp)
 10200e0:	3027883a 	mov	r19,r6
 10200e4:	10000226 	beq	r2,zero,10200f0 <___svfiprintf_internal_r+0x50>
 10200e8:	28800417 	ldw	r2,16(r5)
 10200ec:	10041d26 	beq	r2,zero,1021164 <___svfiprintf_internal_r+0x10c4>
 10200f0:	dac01a04 	addi	r11,sp,104
 10200f4:	dac01e15 	stw	r11,120(sp)
 10200f8:	d8801e17 	ldw	r2,120(sp)
 10200fc:	dac019c4 	addi	r11,sp,103
 1020100:	dd402a17 	ldw	r21,168(sp)
 1020104:	ddc02717 	ldw	r23,156(sp)
 1020108:	058040f4 	movhi	r22,259
 102010c:	050040f4 	movhi	r20,259
 1020110:	dac01f15 	stw	r11,124(sp)
 1020114:	12d7c83a 	sub	r11,r2,r11
 1020118:	b5aaf104 	addi	r22,r22,-21564
 102011c:	a52aed04 	addi	r20,r20,-21580
 1020120:	dec01a15 	stw	sp,104(sp)
 1020124:	d8001c15 	stw	zero,112(sp)
 1020128:	d8001b15 	stw	zero,108(sp)
 102012c:	d811883a 	mov	r8,sp
 1020130:	d8002915 	stw	zero,164(sp)
 1020134:	d8002515 	stw	zero,148(sp)
 1020138:	dac02b15 	stw	r11,172(sp)
 102013c:	98800007 	ldb	r2,0(r19)
 1020140:	1002dd26 	beq	r2,zero,1020cb8 <___svfiprintf_internal_r+0xc18>
 1020144:	00c00944 	movi	r3,37
 1020148:	9823883a 	mov	r17,r19
 102014c:	10c0021e 	bne	r2,r3,1020158 <___svfiprintf_internal_r+0xb8>
 1020150:	00001406 	br	10201a4 <___svfiprintf_internal_r+0x104>
 1020154:	10c00326 	beq	r2,r3,1020164 <___svfiprintf_internal_r+0xc4>
 1020158:	8c400044 	addi	r17,r17,1
 102015c:	88800007 	ldb	r2,0(r17)
 1020160:	103ffc1e 	bne	r2,zero,1020154 <__alt_data_end+0xff020154>
 1020164:	8ce1c83a 	sub	r16,r17,r19
 1020168:	80000e26 	beq	r16,zero,10201a4 <___svfiprintf_internal_r+0x104>
 102016c:	d8c01c17 	ldw	r3,112(sp)
 1020170:	d8801b17 	ldw	r2,108(sp)
 1020174:	44c00015 	stw	r19,0(r8)
 1020178:	1c07883a 	add	r3,r3,r16
 102017c:	10800044 	addi	r2,r2,1
 1020180:	d8c01c15 	stw	r3,112(sp)
 1020184:	44000115 	stw	r16,4(r8)
 1020188:	d8801b15 	stw	r2,108(sp)
 102018c:	00c001c4 	movi	r3,7
 1020190:	18831e16 	blt	r3,r2,1020e0c <___svfiprintf_internal_r+0xd6c>
 1020194:	42000204 	addi	r8,r8,8
 1020198:	dac02517 	ldw	r11,148(sp)
 102019c:	5c17883a 	add	r11,r11,r16
 10201a0:	dac02515 	stw	r11,148(sp)
 10201a4:	88800007 	ldb	r2,0(r17)
 10201a8:	1002c526 	beq	r2,zero,1020cc0 <___svfiprintf_internal_r+0xc20>
 10201ac:	88c00047 	ldb	r3,1(r17)
 10201b0:	8cc00044 	addi	r19,r17,1
 10201b4:	d8001d85 	stb	zero,118(sp)
 10201b8:	0009883a 	mov	r4,zero
 10201bc:	000f883a 	mov	r7,zero
 10201c0:	043fffc4 	movi	r16,-1
 10201c4:	d8002415 	stw	zero,144(sp)
 10201c8:	0025883a 	mov	r18,zero
 10201cc:	01401604 	movi	r5,88
 10201d0:	01800244 	movi	r6,9
 10201d4:	02800a84 	movi	r10,42
 10201d8:	02401b04 	movi	r9,108
 10201dc:	9cc00044 	addi	r19,r19,1
 10201e0:	18bff804 	addi	r2,r3,-32
 10201e4:	2881dd36 	bltu	r5,r2,102095c <___svfiprintf_internal_r+0x8bc>
 10201e8:	100490ba 	slli	r2,r2,2
 10201ec:	02c040b4 	movhi	r11,258
 10201f0:	5ac08004 	addi	r11,r11,512
 10201f4:	12c5883a 	add	r2,r2,r11
 10201f8:	10800017 	ldw	r2,0(r2)
 10201fc:	1000683a 	jmp	r2
 1020200:	010203fc 	xorhi	r4,zero,2063
 1020204:	0102095c 	xori	r4,zero,2085
 1020208:	0102095c 	xori	r4,zero,2085
 102020c:	010203f0 	cmpltui	r4,zero,2063
 1020210:	0102095c 	xori	r4,zero,2085
 1020214:	0102095c 	xori	r4,zero,2085
 1020218:	0102095c 	xori	r4,zero,2085
 102021c:	0102095c 	xori	r4,zero,2085
 1020220:	0102095c 	xori	r4,zero,2085
 1020224:	0102095c 	xori	r4,zero,2085
 1020228:	01020364 	muli	r4,zero,2061
 102022c:	01020540 	call	102054 <__reset-0xefdfac>
 1020230:	0102095c 	xori	r4,zero,2085
 1020234:	01020390 	cmplti	r4,zero,2062
 1020238:	01020990 	cmplti	r4,zero,2086
 102023c:	0102095c 	xori	r4,zero,2085
 1020240:	01020984 	movi	r4,2086
 1020244:	01020924 	muli	r4,zero,2084
 1020248:	01020924 	muli	r4,zero,2084
 102024c:	01020924 	muli	r4,zero,2084
 1020250:	01020924 	muli	r4,zero,2084
 1020254:	01020924 	muli	r4,zero,2084
 1020258:	01020924 	muli	r4,zero,2084
 102025c:	01020924 	muli	r4,zero,2084
 1020260:	01020924 	muli	r4,zero,2084
 1020264:	01020924 	muli	r4,zero,2084
 1020268:	0102095c 	xori	r4,zero,2085
 102026c:	0102095c 	xori	r4,zero,2085
 1020270:	0102095c 	xori	r4,zero,2085
 1020274:	0102095c 	xori	r4,zero,2085
 1020278:	0102095c 	xori	r4,zero,2085
 102027c:	0102095c 	xori	r4,zero,2085
 1020280:	0102095c 	xori	r4,zero,2085
 1020284:	0102095c 	xori	r4,zero,2085
 1020288:	0102095c 	xori	r4,zero,2085
 102028c:	0102095c 	xori	r4,zero,2085
 1020290:	010208c0 	call	10208c <__reset-0xefdf74>
 1020294:	0102095c 	xori	r4,zero,2085
 1020298:	0102095c 	xori	r4,zero,2085
 102029c:	0102095c 	xori	r4,zero,2085
 10202a0:	0102095c 	xori	r4,zero,2085
 10202a4:	0102095c 	xori	r4,zero,2085
 10202a8:	0102095c 	xori	r4,zero,2085
 10202ac:	0102095c 	xori	r4,zero,2085
 10202b0:	0102095c 	xori	r4,zero,2085
 10202b4:	0102095c 	xori	r4,zero,2085
 10202b8:	0102095c 	xori	r4,zero,2085
 10202bc:	01020a38 	rdprs	r4,zero,2088
 10202c0:	0102095c 	xori	r4,zero,2085
 10202c4:	0102095c 	xori	r4,zero,2085
 10202c8:	0102095c 	xori	r4,zero,2085
 10202cc:	0102095c 	xori	r4,zero,2085
 10202d0:	0102095c 	xori	r4,zero,2085
 10202d4:	010209d0 	cmplti	r4,zero,2087
 10202d8:	0102095c 	xori	r4,zero,2085
 10202dc:	0102095c 	xori	r4,zero,2085
 10202e0:	01020704 	movi	r4,2076
 10202e4:	0102095c 	xori	r4,zero,2085
 10202e8:	0102095c 	xori	r4,zero,2085
 10202ec:	0102095c 	xori	r4,zero,2085
 10202f0:	0102095c 	xori	r4,zero,2085
 10202f4:	0102095c 	xori	r4,zero,2085
 10202f8:	0102095c 	xori	r4,zero,2085
 10202fc:	0102095c 	xori	r4,zero,2085
 1020300:	0102095c 	xori	r4,zero,2085
 1020304:	0102095c 	xori	r4,zero,2085
 1020308:	0102095c 	xori	r4,zero,2085
 102030c:	010205f4 	movhi	r4,2071
 1020310:	010207a0 	cmpeqi	r4,zero,2078
 1020314:	0102095c 	xori	r4,zero,2085
 1020318:	0102095c 	xori	r4,zero,2085
 102031c:	0102095c 	xori	r4,zero,2085
 1020320:	01020794 	movui	r4,2078
 1020324:	010207a0 	cmpeqi	r4,zero,2078
 1020328:	0102095c 	xori	r4,zero,2085
 102032c:	0102095c 	xori	r4,zero,2085
 1020330:	01020784 	movi	r4,2078
 1020334:	0102095c 	xori	r4,zero,2085
 1020338:	01020748 	cmpgei	r4,zero,2077
 102033c:	01020550 	cmplti	r4,zero,2069
 1020340:	0102039c 	xori	r4,zero,2062
 1020344:	010208b4 	movhi	r4,2082
 1020348:	0102095c 	xori	r4,zero,2085
 102034c:	01020868 	cmpgeui	r4,zero,2081
 1020350:	0102095c 	xori	r4,zero,2085
 1020354:	010204c0 	call	10204c <__reset-0xefdfb4>
 1020358:	0102095c 	xori	r4,zero,2085
 102035c:	0102095c 	xori	r4,zero,2085
 1020360:	0102041c 	xori	r4,zero,2064
 1020364:	dac02317 	ldw	r11,140(sp)
 1020368:	5ac00017 	ldw	r11,0(r11)
 102036c:	dac02415 	stw	r11,144(sp)
 1020370:	dac02317 	ldw	r11,140(sp)
 1020374:	58800104 	addi	r2,r11,4
 1020378:	dac02417 	ldw	r11,144(sp)
 102037c:	5802e90e 	bge	r11,zero,1020f24 <___svfiprintf_internal_r+0xe84>
 1020380:	dac02417 	ldw	r11,144(sp)
 1020384:	d8802315 	stw	r2,140(sp)
 1020388:	02d7c83a 	sub	r11,zero,r11
 102038c:	dac02415 	stw	r11,144(sp)
 1020390:	94800114 	ori	r18,r18,4
 1020394:	98c00007 	ldb	r3,0(r19)
 1020398:	003f9006 	br	10201dc <__alt_data_end+0xff0201dc>
 102039c:	00800c04 	movi	r2,48
 10203a0:	dac02317 	ldw	r11,140(sp)
 10203a4:	d8801d05 	stb	r2,116(sp)
 10203a8:	00801e04 	movi	r2,120
 10203ac:	d8801d45 	stb	r2,117(sp)
 10203b0:	d8001d85 	stb	zero,118(sp)
 10203b4:	58c00104 	addi	r3,r11,4
 10203b8:	5f000017 	ldw	fp,0(r11)
 10203bc:	0013883a 	mov	r9,zero
 10203c0:	90800094 	ori	r2,r18,2
 10203c4:	80032b16 	blt	r16,zero,1021074 <___svfiprintf_internal_r+0xfd4>
 10203c8:	00bfdfc4 	movi	r2,-129
 10203cc:	90a4703a 	and	r18,r18,r2
 10203d0:	d8c02315 	stw	r3,140(sp)
 10203d4:	94800094 	ori	r18,r18,2
 10203d8:	e002dc26 	beq	fp,zero,1020f4c <___svfiprintf_internal_r+0xeac>
 10203dc:	010040f4 	movhi	r4,259
 10203e0:	212a8504 	addi	r4,r4,-21996
 10203e4:	0015883a 	mov	r10,zero
 10203e8:	d9002915 	stw	r4,164(sp)
 10203ec:	00002306 	br	102047c <___svfiprintf_internal_r+0x3dc>
 10203f0:	94800054 	ori	r18,r18,1
 10203f4:	98c00007 	ldb	r3,0(r19)
 10203f8:	003f7806 	br	10201dc <__alt_data_end+0xff0201dc>
 10203fc:	38803fcc 	andi	r2,r7,255
 1020400:	1080201c 	xori	r2,r2,128
 1020404:	10bfe004 	addi	r2,r2,-128
 1020408:	1002f31e 	bne	r2,zero,1020fd8 <___svfiprintf_internal_r+0xf38>
 102040c:	01000044 	movi	r4,1
 1020410:	01c00804 	movi	r7,32
 1020414:	98c00007 	ldb	r3,0(r19)
 1020418:	003f7006 	br	10201dc <__alt_data_end+0xff0201dc>
 102041c:	21003fcc 	andi	r4,r4,255
 1020420:	2003aa1e 	bne	r4,zero,10212cc <___svfiprintf_internal_r+0x122c>
 1020424:	008040f4 	movhi	r2,259
 1020428:	10aa8504 	addi	r2,r2,-21996
 102042c:	d8802915 	stw	r2,164(sp)
 1020430:	9080080c 	andi	r2,r18,32
 1020434:	1000ba26 	beq	r2,zero,1020720 <___svfiprintf_internal_r+0x680>
 1020438:	dac02317 	ldw	r11,140(sp)
 102043c:	5f000017 	ldw	fp,0(r11)
 1020440:	5a400117 	ldw	r9,4(r11)
 1020444:	5ac00204 	addi	r11,r11,8
 1020448:	dac02315 	stw	r11,140(sp)
 102044c:	9080004c 	andi	r2,r18,1
 1020450:	10029026 	beq	r2,zero,1020e94 <___svfiprintf_internal_r+0xdf4>
 1020454:	e244b03a 	or	r2,fp,r9
 1020458:	1002d41e 	bne	r2,zero,1020fac <___svfiprintf_internal_r+0xf0c>
 102045c:	d8001d85 	stb	zero,118(sp)
 1020460:	80030b16 	blt	r16,zero,1021090 <___svfiprintf_internal_r+0xff0>
 1020464:	00bfdfc4 	movi	r2,-129
 1020468:	90a4703a 	and	r18,r18,r2
 102046c:	0015883a 	mov	r10,zero
 1020470:	80002426 	beq	r16,zero,1020504 <___svfiprintf_internal_r+0x464>
 1020474:	0039883a 	mov	fp,zero
 1020478:	0013883a 	mov	r9,zero
 102047c:	d9002917 	ldw	r4,164(sp)
 1020480:	dc401a04 	addi	r17,sp,104
 1020484:	e08003cc 	andi	r2,fp,15
 1020488:	4806973a 	slli	r3,r9,28
 102048c:	2085883a 	add	r2,r4,r2
 1020490:	e038d13a 	srli	fp,fp,4
 1020494:	10800003 	ldbu	r2,0(r2)
 1020498:	4812d13a 	srli	r9,r9,4
 102049c:	8c7fffc4 	addi	r17,r17,-1
 10204a0:	1f38b03a 	or	fp,r3,fp
 10204a4:	88800005 	stb	r2,0(r17)
 10204a8:	e244b03a 	or	r2,fp,r9
 10204ac:	103ff51e 	bne	r2,zero,1020484 <__alt_data_end+0xff020484>
 10204b0:	dac01e17 	ldw	r11,120(sp)
 10204b4:	5c57c83a 	sub	r11,r11,r17
 10204b8:	dac02115 	stw	r11,132(sp)
 10204bc:	00001406 	br	1020510 <___svfiprintf_internal_r+0x470>
 10204c0:	21003fcc 	andi	r4,r4,255
 10204c4:	2003741e 	bne	r4,zero,1021298 <___svfiprintf_internal_r+0x11f8>
 10204c8:	9080080c 	andi	r2,r18,32
 10204cc:	10014526 	beq	r2,zero,10209e4 <___svfiprintf_internal_r+0x944>
 10204d0:	dac02317 	ldw	r11,140(sp)
 10204d4:	d8001d85 	stb	zero,118(sp)
 10204d8:	58c00204 	addi	r3,r11,8
 10204dc:	5f000017 	ldw	fp,0(r11)
 10204e0:	5a400117 	ldw	r9,4(r11)
 10204e4:	8002d916 	blt	r16,zero,102104c <___svfiprintf_internal_r+0xfac>
 10204e8:	013fdfc4 	movi	r4,-129
 10204ec:	e244b03a 	or	r2,fp,r9
 10204f0:	d8c02315 	stw	r3,140(sp)
 10204f4:	9124703a 	and	r18,r18,r4
 10204f8:	0015883a 	mov	r10,zero
 10204fc:	1000b91e 	bne	r2,zero,10207e4 <___svfiprintf_internal_r+0x744>
 1020500:	8002e61e 	bne	r16,zero,102109c <___svfiprintf_internal_r+0xffc>
 1020504:	0021883a 	mov	r16,zero
 1020508:	d8002115 	stw	zero,132(sp)
 102050c:	dc401a04 	addi	r17,sp,104
 1020510:	d8c02117 	ldw	r3,132(sp)
 1020514:	dc002015 	stw	r16,128(sp)
 1020518:	80c0010e 	bge	r16,r3,1020520 <___svfiprintf_internal_r+0x480>
 102051c:	d8c02015 	stw	r3,128(sp)
 1020520:	52803fcc 	andi	r10,r10,255
 1020524:	5280201c 	xori	r10,r10,128
 1020528:	52bfe004 	addi	r10,r10,-128
 102052c:	50003c26 	beq	r10,zero,1020620 <___svfiprintf_internal_r+0x580>
 1020530:	dac02017 	ldw	r11,128(sp)
 1020534:	5ac00044 	addi	r11,r11,1
 1020538:	dac02015 	stw	r11,128(sp)
 102053c:	00003806 	br	1020620 <___svfiprintf_internal_r+0x580>
 1020540:	01000044 	movi	r4,1
 1020544:	01c00ac4 	movi	r7,43
 1020548:	98c00007 	ldb	r3,0(r19)
 102054c:	003f2306 	br	10201dc <__alt_data_end+0xff0201dc>
 1020550:	21003fcc 	andi	r4,r4,255
 1020554:	2003481e 	bne	r4,zero,1021278 <___svfiprintf_internal_r+0x11d8>
 1020558:	9080080c 	andi	r2,r18,32
 102055c:	10013b26 	beq	r2,zero,1020a4c <___svfiprintf_internal_r+0x9ac>
 1020560:	dac02317 	ldw	r11,140(sp)
 1020564:	d8001d85 	stb	zero,118(sp)
 1020568:	58800204 	addi	r2,r11,8
 102056c:	5f000017 	ldw	fp,0(r11)
 1020570:	5a400117 	ldw	r9,4(r11)
 1020574:	8002a816 	blt	r16,zero,1021018 <___svfiprintf_internal_r+0xf78>
 1020578:	013fdfc4 	movi	r4,-129
 102057c:	e246b03a 	or	r3,fp,r9
 1020580:	d8802315 	stw	r2,140(sp)
 1020584:	9124703a 	and	r18,r18,r4
 1020588:	18013c26 	beq	r3,zero,1020a7c <___svfiprintf_internal_r+0x9dc>
 102058c:	0015883a 	mov	r10,zero
 1020590:	dc401a04 	addi	r17,sp,104
 1020594:	e006d0fa 	srli	r3,fp,3
 1020598:	4808977a 	slli	r4,r9,29
 102059c:	4812d0fa 	srli	r9,r9,3
 10205a0:	e70001cc 	andi	fp,fp,7
 10205a4:	e0800c04 	addi	r2,fp,48
 10205a8:	8c7fffc4 	addi	r17,r17,-1
 10205ac:	20f8b03a 	or	fp,r4,r3
 10205b0:	88800005 	stb	r2,0(r17)
 10205b4:	e246b03a 	or	r3,fp,r9
 10205b8:	183ff61e 	bne	r3,zero,1020594 <__alt_data_end+0xff020594>
 10205bc:	90c0004c 	andi	r3,r18,1
 10205c0:	1800a526 	beq	r3,zero,1020858 <___svfiprintf_internal_r+0x7b8>
 10205c4:	10803fcc 	andi	r2,r2,255
 10205c8:	1080201c 	xori	r2,r2,128
 10205cc:	10bfe004 	addi	r2,r2,-128
 10205d0:	00c00c04 	movi	r3,48
 10205d4:	10ffb626 	beq	r2,r3,10204b0 <__alt_data_end+0xff0204b0>
 10205d8:	88ffffc5 	stb	r3,-1(r17)
 10205dc:	d8c01e17 	ldw	r3,120(sp)
 10205e0:	88bfffc4 	addi	r2,r17,-1
 10205e4:	1023883a 	mov	r17,r2
 10205e8:	1887c83a 	sub	r3,r3,r2
 10205ec:	d8c02115 	stw	r3,132(sp)
 10205f0:	003fc706 	br	1020510 <__alt_data_end+0xff020510>
 10205f4:	dac02317 	ldw	r11,140(sp)
 10205f8:	00c00044 	movi	r3,1
 10205fc:	d8c02015 	stw	r3,128(sp)
 1020600:	58800017 	ldw	r2,0(r11)
 1020604:	5ac00104 	addi	r11,r11,4
 1020608:	d8001d85 	stb	zero,118(sp)
 102060c:	d8801005 	stb	r2,64(sp)
 1020610:	dac02315 	stw	r11,140(sp)
 1020614:	d8c02115 	stw	r3,132(sp)
 1020618:	dc401004 	addi	r17,sp,64
 102061c:	0021883a 	mov	r16,zero
 1020620:	90c0008c 	andi	r3,r18,2
 1020624:	d8c02215 	stw	r3,136(sp)
 1020628:	18000326 	beq	r3,zero,1020638 <___svfiprintf_internal_r+0x598>
 102062c:	dac02017 	ldw	r11,128(sp)
 1020630:	5ac00084 	addi	r11,r11,2
 1020634:	dac02015 	stw	r11,128(sp)
 1020638:	90c0210c 	andi	r3,r18,132
 102063c:	d8c02615 	stw	r3,152(sp)
 1020640:	1801131e 	bne	r3,zero,1020a90 <___svfiprintf_internal_r+0x9f0>
 1020644:	dac02417 	ldw	r11,144(sp)
 1020648:	d8c02017 	ldw	r3,128(sp)
 102064c:	58f9c83a 	sub	fp,r11,r3
 1020650:	07010f0e 	bge	zero,fp,1020a90 <___svfiprintf_internal_r+0x9f0>
 1020654:	02400404 	movi	r9,16
 1020658:	d8c01c17 	ldw	r3,112(sp)
 102065c:	d8801b17 	ldw	r2,108(sp)
 1020660:	4f02d60e 	bge	r9,fp,10211bc <___svfiprintf_internal_r+0x111c>
 1020664:	014040f4 	movhi	r5,259
 1020668:	296af104 	addi	r5,r5,-21564
 102066c:	d9402815 	stw	r5,160(sp)
 1020670:	028001c4 	movi	r10,7
 1020674:	00000306 	br	1020684 <___svfiprintf_internal_r+0x5e4>
 1020678:	e73ffc04 	addi	fp,fp,-16
 102067c:	42000204 	addi	r8,r8,8
 1020680:	4f00150e 	bge	r9,fp,10206d8 <___svfiprintf_internal_r+0x638>
 1020684:	18c00404 	addi	r3,r3,16
 1020688:	10800044 	addi	r2,r2,1
 102068c:	45800015 	stw	r22,0(r8)
 1020690:	42400115 	stw	r9,4(r8)
 1020694:	d8c01c15 	stw	r3,112(sp)
 1020698:	d8801b15 	stw	r2,108(sp)
 102069c:	50bff60e 	bge	r10,r2,1020678 <__alt_data_end+0xff020678>
 10206a0:	d9801a04 	addi	r6,sp,104
 10206a4:	b80b883a 	mov	r5,r23
 10206a8:	a809883a 	mov	r4,r21
 10206ac:	da402c15 	stw	r9,176(sp)
 10206b0:	da802d15 	stw	r10,180(sp)
 10206b4:	101fed00 	call	101fed0 <__ssprint_r>
 10206b8:	da402c17 	ldw	r9,176(sp)
 10206bc:	da802d17 	ldw	r10,180(sp)
 10206c0:	1001851e 	bne	r2,zero,1020cd8 <___svfiprintf_internal_r+0xc38>
 10206c4:	e73ffc04 	addi	fp,fp,-16
 10206c8:	d8c01c17 	ldw	r3,112(sp)
 10206cc:	d8801b17 	ldw	r2,108(sp)
 10206d0:	d811883a 	mov	r8,sp
 10206d4:	4f3feb16 	blt	r9,fp,1020684 <__alt_data_end+0xff020684>
 10206d8:	dac02817 	ldw	r11,160(sp)
 10206dc:	e0c7883a 	add	r3,fp,r3
 10206e0:	10800044 	addi	r2,r2,1
 10206e4:	42c00015 	stw	r11,0(r8)
 10206e8:	47000115 	stw	fp,4(r8)
 10206ec:	d8c01c15 	stw	r3,112(sp)
 10206f0:	d8801b15 	stw	r2,108(sp)
 10206f4:	010001c4 	movi	r4,7
 10206f8:	2081ee16 	blt	r4,r2,1020eb4 <___svfiprintf_internal_r+0xe14>
 10206fc:	42000204 	addi	r8,r8,8
 1020700:	0000e506 	br	1020a98 <___svfiprintf_internal_r+0x9f8>
 1020704:	21003fcc 	andi	r4,r4,255
 1020708:	2002dd1e 	bne	r4,zero,1021280 <___svfiprintf_internal_r+0x11e0>
 102070c:	008040f4 	movhi	r2,259
 1020710:	10aa8004 	addi	r2,r2,-22016
 1020714:	d8802915 	stw	r2,164(sp)
 1020718:	9080080c 	andi	r2,r18,32
 102071c:	103f461e 	bne	r2,zero,1020438 <__alt_data_end+0xff020438>
 1020720:	9080040c 	andi	r2,r18,16
 1020724:	10022e1e 	bne	r2,zero,1020fe0 <___svfiprintf_internal_r+0xf40>
 1020728:	9080100c 	andi	r2,r18,64
 102072c:	dac02317 	ldw	r11,140(sp)
 1020730:	10027326 	beq	r2,zero,1021100 <___svfiprintf_internal_r+0x1060>
 1020734:	5f00000b 	ldhu	fp,0(r11)
 1020738:	5ac00104 	addi	r11,r11,4
 102073c:	0013883a 	mov	r9,zero
 1020740:	dac02315 	stw	r11,140(sp)
 1020744:	003f4106 	br	102044c <__alt_data_end+0xff02044c>
 1020748:	21003fcc 	andi	r4,r4,255
 102074c:	2002e11e 	bne	r4,zero,10212d4 <___svfiprintf_internal_r+0x1234>
 1020750:	9080080c 	andi	r2,r18,32
 1020754:	1002011e 	bne	r2,zero,1020f5c <___svfiprintf_internal_r+0xebc>
 1020758:	9080040c 	andi	r2,r18,16
 102075c:	10023e1e 	bne	r2,zero,1021058 <___svfiprintf_internal_r+0xfb8>
 1020760:	9480100c 	andi	r18,r18,64
 1020764:	90023c26 	beq	r18,zero,1021058 <___svfiprintf_internal_r+0xfb8>
 1020768:	dac02317 	ldw	r11,140(sp)
 102076c:	58800017 	ldw	r2,0(r11)
 1020770:	5ac00104 	addi	r11,r11,4
 1020774:	dac02315 	stw	r11,140(sp)
 1020778:	dac02517 	ldw	r11,148(sp)
 102077c:	12c0000d 	sth	r11,0(r2)
 1020780:	003e6e06 	br	102013c <__alt_data_end+0xff02013c>
 1020784:	98c00007 	ldb	r3,0(r19)
 1020788:	1a422926 	beq	r3,r9,1021030 <___svfiprintf_internal_r+0xf90>
 102078c:	94800414 	ori	r18,r18,16
 1020790:	003e9206 	br	10201dc <__alt_data_end+0xff0201dc>
 1020794:	94801014 	ori	r18,r18,64
 1020798:	98c00007 	ldb	r3,0(r19)
 102079c:	003e8f06 	br	10201dc <__alt_data_end+0xff0201dc>
 10207a0:	21003fcc 	andi	r4,r4,255
 10207a4:	2002c71e 	bne	r4,zero,10212c4 <___svfiprintf_internal_r+0x1224>
 10207a8:	9080080c 	andi	r2,r18,32
 10207ac:	10004926 	beq	r2,zero,10208d4 <___svfiprintf_internal_r+0x834>
 10207b0:	dac02317 	ldw	r11,140(sp)
 10207b4:	58800117 	ldw	r2,4(r11)
 10207b8:	5f000017 	ldw	fp,0(r11)
 10207bc:	5ac00204 	addi	r11,r11,8
 10207c0:	dac02315 	stw	r11,140(sp)
 10207c4:	1013883a 	mov	r9,r2
 10207c8:	10004b16 	blt	r2,zero,10208f8 <___svfiprintf_internal_r+0x858>
 10207cc:	da801d83 	ldbu	r10,118(sp)
 10207d0:	8001cb16 	blt	r16,zero,1020f00 <___svfiprintf_internal_r+0xe60>
 10207d4:	00ffdfc4 	movi	r3,-129
 10207d8:	e244b03a 	or	r2,fp,r9
 10207dc:	90e4703a 	and	r18,r18,r3
 10207e0:	103f4726 	beq	r2,zero,1020500 <__alt_data_end+0xff020500>
 10207e4:	48008c26 	beq	r9,zero,1020a18 <___svfiprintf_internal_r+0x978>
 10207e8:	dc802015 	stw	r18,128(sp)
 10207ec:	dc002115 	stw	r16,132(sp)
 10207f0:	dc401a04 	addi	r17,sp,104
 10207f4:	e021883a 	mov	r16,fp
 10207f8:	da002215 	stw	r8,136(sp)
 10207fc:	5039883a 	mov	fp,r10
 1020800:	4825883a 	mov	r18,r9
 1020804:	8009883a 	mov	r4,r16
 1020808:	900b883a 	mov	r5,r18
 102080c:	01800284 	movi	r6,10
 1020810:	000f883a 	mov	r7,zero
 1020814:	10237d00 	call	10237d0 <__umoddi3>
 1020818:	10800c04 	addi	r2,r2,48
 102081c:	8c7fffc4 	addi	r17,r17,-1
 1020820:	8009883a 	mov	r4,r16
 1020824:	900b883a 	mov	r5,r18
 1020828:	88800005 	stb	r2,0(r17)
 102082c:	01800284 	movi	r6,10
 1020830:	000f883a 	mov	r7,zero
 1020834:	10232580 	call	1023258 <__udivdi3>
 1020838:	1021883a 	mov	r16,r2
 102083c:	10c4b03a 	or	r2,r2,r3
 1020840:	1825883a 	mov	r18,r3
 1020844:	103fef1e 	bne	r2,zero,1020804 <__alt_data_end+0xff020804>
 1020848:	dc802017 	ldw	r18,128(sp)
 102084c:	dc002117 	ldw	r16,132(sp)
 1020850:	da002217 	ldw	r8,136(sp)
 1020854:	e015883a 	mov	r10,fp
 1020858:	d8c01e17 	ldw	r3,120(sp)
 102085c:	1c47c83a 	sub	r3,r3,r17
 1020860:	d8c02115 	stw	r3,132(sp)
 1020864:	003f2a06 	br	1020510 <__alt_data_end+0xff020510>
 1020868:	dac02317 	ldw	r11,140(sp)
 102086c:	d8001d85 	stb	zero,118(sp)
 1020870:	5c400017 	ldw	r17,0(r11)
 1020874:	5f000104 	addi	fp,r11,4
 1020878:	88022f26 	beq	r17,zero,1021138 <___svfiprintf_internal_r+0x1098>
 102087c:	80022516 	blt	r16,zero,1021114 <___svfiprintf_internal_r+0x1074>
 1020880:	800d883a 	mov	r6,r16
 1020884:	000b883a 	mov	r5,zero
 1020888:	8809883a 	mov	r4,r17
 102088c:	da002c15 	stw	r8,176(sp)
 1020890:	101e2280 	call	101e228 <memchr>
 1020894:	da002c17 	ldw	r8,176(sp)
 1020898:	10026426 	beq	r2,zero,102122c <___svfiprintf_internal_r+0x118c>
 102089c:	1445c83a 	sub	r2,r2,r17
 10208a0:	d8802115 	stw	r2,132(sp)
 10208a4:	da801d83 	ldbu	r10,118(sp)
 10208a8:	df002315 	stw	fp,140(sp)
 10208ac:	0021883a 	mov	r16,zero
 10208b0:	003f1706 	br	1020510 <__alt_data_end+0xff020510>
 10208b4:	94800814 	ori	r18,r18,32
 10208b8:	98c00007 	ldb	r3,0(r19)
 10208bc:	003e4706 	br	10201dc <__alt_data_end+0xff0201dc>
 10208c0:	21003fcc 	andi	r4,r4,255
 10208c4:	2002701e 	bne	r4,zero,1021288 <___svfiprintf_internal_r+0x11e8>
 10208c8:	94800414 	ori	r18,r18,16
 10208cc:	9080080c 	andi	r2,r18,32
 10208d0:	103fb71e 	bne	r2,zero,10207b0 <__alt_data_end+0xff0207b0>
 10208d4:	9080040c 	andi	r2,r18,16
 10208d8:	1001ab26 	beq	r2,zero,1020f88 <___svfiprintf_internal_r+0xee8>
 10208dc:	dac02317 	ldw	r11,140(sp)
 10208e0:	5f000017 	ldw	fp,0(r11)
 10208e4:	5ac00104 	addi	r11,r11,4
 10208e8:	dac02315 	stw	r11,140(sp)
 10208ec:	e013d7fa 	srai	r9,fp,31
 10208f0:	4805883a 	mov	r2,r9
 10208f4:	103fb50e 	bge	r2,zero,10207cc <__alt_data_end+0xff0207cc>
 10208f8:	0739c83a 	sub	fp,zero,fp
 10208fc:	02800b44 	movi	r10,45
 1020900:	e004c03a 	cmpne	r2,fp,zero
 1020904:	0253c83a 	sub	r9,zero,r9
 1020908:	da801d85 	stb	r10,118(sp)
 102090c:	4893c83a 	sub	r9,r9,r2
 1020910:	80023016 	blt	r16,zero,10211d4 <___svfiprintf_internal_r+0x1134>
 1020914:	00bfdfc4 	movi	r2,-129
 1020918:	90a4703a 	and	r18,r18,r2
 102091c:	483fb21e 	bne	r9,zero,10207e8 <__alt_data_end+0xff0207e8>
 1020920:	00003d06 	br	1020a18 <___svfiprintf_internal_r+0x978>
 1020924:	9817883a 	mov	r11,r19
 1020928:	d8002415 	stw	zero,144(sp)
 102092c:	18bff404 	addi	r2,r3,-48
 1020930:	0019883a 	mov	r12,zero
 1020934:	58c00007 	ldb	r3,0(r11)
 1020938:	630002a4 	muli	r12,r12,10
 102093c:	9cc00044 	addi	r19,r19,1
 1020940:	9817883a 	mov	r11,r19
 1020944:	1319883a 	add	r12,r2,r12
 1020948:	18bff404 	addi	r2,r3,-48
 102094c:	30bff92e 	bgeu	r6,r2,1020934 <__alt_data_end+0xff020934>
 1020950:	db002415 	stw	r12,144(sp)
 1020954:	18bff804 	addi	r2,r3,-32
 1020958:	28be232e 	bgeu	r5,r2,10201e8 <__alt_data_end+0xff0201e8>
 102095c:	21003fcc 	andi	r4,r4,255
 1020960:	20024b1e 	bne	r4,zero,1021290 <___svfiprintf_internal_r+0x11f0>
 1020964:	1800d626 	beq	r3,zero,1020cc0 <___svfiprintf_internal_r+0xc20>
 1020968:	02c00044 	movi	r11,1
 102096c:	dac02015 	stw	r11,128(sp)
 1020970:	d8c01005 	stb	r3,64(sp)
 1020974:	d8001d85 	stb	zero,118(sp)
 1020978:	dac02115 	stw	r11,132(sp)
 102097c:	dc401004 	addi	r17,sp,64
 1020980:	003f2606 	br	102061c <__alt_data_end+0xff02061c>
 1020984:	94802014 	ori	r18,r18,128
 1020988:	98c00007 	ldb	r3,0(r19)
 102098c:	003e1306 	br	10201dc <__alt_data_end+0xff0201dc>
 1020990:	98c00007 	ldb	r3,0(r19)
 1020994:	9ac00044 	addi	r11,r19,1
 1020998:	1a822b26 	beq	r3,r10,1021248 <___svfiprintf_internal_r+0x11a8>
 102099c:	18bff404 	addi	r2,r3,-48
 10209a0:	0021883a 	mov	r16,zero
 10209a4:	30821e36 	bltu	r6,r2,1021220 <___svfiprintf_internal_r+0x1180>
 10209a8:	58c00007 	ldb	r3,0(r11)
 10209ac:	840002a4 	muli	r16,r16,10
 10209b0:	5cc00044 	addi	r19,r11,1
 10209b4:	9817883a 	mov	r11,r19
 10209b8:	80a1883a 	add	r16,r16,r2
 10209bc:	18bff404 	addi	r2,r3,-48
 10209c0:	30bff92e 	bgeu	r6,r2,10209a8 <__alt_data_end+0xff0209a8>
 10209c4:	803e060e 	bge	r16,zero,10201e0 <__alt_data_end+0xff0201e0>
 10209c8:	043fffc4 	movi	r16,-1
 10209cc:	003e0406 	br	10201e0 <__alt_data_end+0xff0201e0>
 10209d0:	21003fcc 	andi	r4,r4,255
 10209d4:	2002371e 	bne	r4,zero,10212b4 <___svfiprintf_internal_r+0x1214>
 10209d8:	94800414 	ori	r18,r18,16
 10209dc:	9080080c 	andi	r2,r18,32
 10209e0:	103ebb1e 	bne	r2,zero,10204d0 <__alt_data_end+0xff0204d0>
 10209e4:	9080040c 	andi	r2,r18,16
 10209e8:	10013b26 	beq	r2,zero,1020ed8 <___svfiprintf_internal_r+0xe38>
 10209ec:	dac02317 	ldw	r11,140(sp)
 10209f0:	d8001d85 	stb	zero,118(sp)
 10209f4:	0013883a 	mov	r9,zero
 10209f8:	58800104 	addi	r2,r11,4
 10209fc:	5f000017 	ldw	fp,0(r11)
 1020a00:	80013d16 	blt	r16,zero,1020ef8 <___svfiprintf_internal_r+0xe58>
 1020a04:	00ffdfc4 	movi	r3,-129
 1020a08:	d8802315 	stw	r2,140(sp)
 1020a0c:	90e4703a 	and	r18,r18,r3
 1020a10:	0015883a 	mov	r10,zero
 1020a14:	e03eba26 	beq	fp,zero,1020500 <__alt_data_end+0xff020500>
 1020a18:	00800244 	movi	r2,9
 1020a1c:	173f7236 	bltu	r2,fp,10207e8 <__alt_data_end+0xff0207e8>
 1020a20:	dac02b17 	ldw	r11,172(sp)
 1020a24:	e7000c04 	addi	fp,fp,48
 1020a28:	df0019c5 	stb	fp,103(sp)
 1020a2c:	dac02115 	stw	r11,132(sp)
 1020a30:	dc4019c4 	addi	r17,sp,103
 1020a34:	003eb606 	br	1020510 <__alt_data_end+0xff020510>
 1020a38:	21003fcc 	andi	r4,r4,255
 1020a3c:	20021f1e 	bne	r4,zero,10212bc <___svfiprintf_internal_r+0x121c>
 1020a40:	94800414 	ori	r18,r18,16
 1020a44:	9080080c 	andi	r2,r18,32
 1020a48:	103ec51e 	bne	r2,zero,1020560 <__alt_data_end+0xff020560>
 1020a4c:	9080040c 	andi	r2,r18,16
 1020a50:	10016926 	beq	r2,zero,1020ff8 <___svfiprintf_internal_r+0xf58>
 1020a54:	dac02317 	ldw	r11,140(sp)
 1020a58:	d8001d85 	stb	zero,118(sp)
 1020a5c:	0013883a 	mov	r9,zero
 1020a60:	58800104 	addi	r2,r11,4
 1020a64:	5f000017 	ldw	fp,0(r11)
 1020a68:	80016b16 	blt	r16,zero,1021018 <___svfiprintf_internal_r+0xf78>
 1020a6c:	00ffdfc4 	movi	r3,-129
 1020a70:	d8802315 	stw	r2,140(sp)
 1020a74:	90e4703a 	and	r18,r18,r3
 1020a78:	e03ec41e 	bne	fp,zero,102058c <__alt_data_end+0xff02058c>
 1020a7c:	0015883a 	mov	r10,zero
 1020a80:	8001c226 	beq	r16,zero,102118c <___svfiprintf_internal_r+0x10ec>
 1020a84:	0039883a 	mov	fp,zero
 1020a88:	0013883a 	mov	r9,zero
 1020a8c:	003ec006 	br	1020590 <__alt_data_end+0xff020590>
 1020a90:	d8c01c17 	ldw	r3,112(sp)
 1020a94:	d8801b17 	ldw	r2,108(sp)
 1020a98:	d9001d87 	ldb	r4,118(sp)
 1020a9c:	20000b26 	beq	r4,zero,1020acc <___svfiprintf_internal_r+0xa2c>
 1020aa0:	d9001d84 	addi	r4,sp,118
 1020aa4:	18c00044 	addi	r3,r3,1
 1020aa8:	10800044 	addi	r2,r2,1
 1020aac:	41000015 	stw	r4,0(r8)
 1020ab0:	01000044 	movi	r4,1
 1020ab4:	41000115 	stw	r4,4(r8)
 1020ab8:	d8c01c15 	stw	r3,112(sp)
 1020abc:	d8801b15 	stw	r2,108(sp)
 1020ac0:	010001c4 	movi	r4,7
 1020ac4:	2080e116 	blt	r4,r2,1020e4c <___svfiprintf_internal_r+0xdac>
 1020ac8:	42000204 	addi	r8,r8,8
 1020acc:	dac02217 	ldw	r11,136(sp)
 1020ad0:	58000b26 	beq	r11,zero,1020b00 <___svfiprintf_internal_r+0xa60>
 1020ad4:	d9001d04 	addi	r4,sp,116
 1020ad8:	18c00084 	addi	r3,r3,2
 1020adc:	10800044 	addi	r2,r2,1
 1020ae0:	41000015 	stw	r4,0(r8)
 1020ae4:	01000084 	movi	r4,2
 1020ae8:	41000115 	stw	r4,4(r8)
 1020aec:	d8c01c15 	stw	r3,112(sp)
 1020af0:	d8801b15 	stw	r2,108(sp)
 1020af4:	010001c4 	movi	r4,7
 1020af8:	2080dd16 	blt	r4,r2,1020e70 <___svfiprintf_internal_r+0xdd0>
 1020afc:	42000204 	addi	r8,r8,8
 1020b00:	dac02617 	ldw	r11,152(sp)
 1020b04:	01002004 	movi	r4,128
 1020b08:	59008426 	beq	r11,r4,1020d1c <___svfiprintf_internal_r+0xc7c>
 1020b0c:	dac02117 	ldw	r11,132(sp)
 1020b10:	82e1c83a 	sub	r16,r16,r11
 1020b14:	0400270e 	bge	zero,r16,1020bb4 <___svfiprintf_internal_r+0xb14>
 1020b18:	01c00404 	movi	r7,16
 1020b1c:	3c016a0e 	bge	r7,r16,10210c8 <___svfiprintf_internal_r+0x1028>
 1020b20:	014040f4 	movhi	r5,259
 1020b24:	296aed04 	addi	r5,r5,-21580
 1020b28:	d9402215 	stw	r5,136(sp)
 1020b2c:	070001c4 	movi	fp,7
 1020b30:	00000306 	br	1020b40 <___svfiprintf_internal_r+0xaa0>
 1020b34:	843ffc04 	addi	r16,r16,-16
 1020b38:	42000204 	addi	r8,r8,8
 1020b3c:	3c00130e 	bge	r7,r16,1020b8c <___svfiprintf_internal_r+0xaec>
 1020b40:	18c00404 	addi	r3,r3,16
 1020b44:	10800044 	addi	r2,r2,1
 1020b48:	45000015 	stw	r20,0(r8)
 1020b4c:	41c00115 	stw	r7,4(r8)
 1020b50:	d8c01c15 	stw	r3,112(sp)
 1020b54:	d8801b15 	stw	r2,108(sp)
 1020b58:	e0bff60e 	bge	fp,r2,1020b34 <__alt_data_end+0xff020b34>
 1020b5c:	d9801a04 	addi	r6,sp,104
 1020b60:	b80b883a 	mov	r5,r23
 1020b64:	a809883a 	mov	r4,r21
 1020b68:	d9c02c15 	stw	r7,176(sp)
 1020b6c:	101fed00 	call	101fed0 <__ssprint_r>
 1020b70:	d9c02c17 	ldw	r7,176(sp)
 1020b74:	1000581e 	bne	r2,zero,1020cd8 <___svfiprintf_internal_r+0xc38>
 1020b78:	843ffc04 	addi	r16,r16,-16
 1020b7c:	d8c01c17 	ldw	r3,112(sp)
 1020b80:	d8801b17 	ldw	r2,108(sp)
 1020b84:	d811883a 	mov	r8,sp
 1020b88:	3c3fed16 	blt	r7,r16,1020b40 <__alt_data_end+0xff020b40>
 1020b8c:	dac02217 	ldw	r11,136(sp)
 1020b90:	1c07883a 	add	r3,r3,r16
 1020b94:	10800044 	addi	r2,r2,1
 1020b98:	42c00015 	stw	r11,0(r8)
 1020b9c:	44000115 	stw	r16,4(r8)
 1020ba0:	d8c01c15 	stw	r3,112(sp)
 1020ba4:	d8801b15 	stw	r2,108(sp)
 1020ba8:	010001c4 	movi	r4,7
 1020bac:	20809e16 	blt	r4,r2,1020e28 <___svfiprintf_internal_r+0xd88>
 1020bb0:	42000204 	addi	r8,r8,8
 1020bb4:	dac02117 	ldw	r11,132(sp)
 1020bb8:	10800044 	addi	r2,r2,1
 1020bbc:	44400015 	stw	r17,0(r8)
 1020bc0:	58c7883a 	add	r3,r11,r3
 1020bc4:	42c00115 	stw	r11,4(r8)
 1020bc8:	d8c01c15 	stw	r3,112(sp)
 1020bcc:	d8801b15 	stw	r2,108(sp)
 1020bd0:	010001c4 	movi	r4,7
 1020bd4:	20807f16 	blt	r4,r2,1020dd4 <___svfiprintf_internal_r+0xd34>
 1020bd8:	42000204 	addi	r8,r8,8
 1020bdc:	9480010c 	andi	r18,r18,4
 1020be0:	90002926 	beq	r18,zero,1020c88 <___svfiprintf_internal_r+0xbe8>
 1020be4:	dac02417 	ldw	r11,144(sp)
 1020be8:	d8802017 	ldw	r2,128(sp)
 1020bec:	58a1c83a 	sub	r16,r11,r2
 1020bf0:	0400250e 	bge	zero,r16,1020c88 <___svfiprintf_internal_r+0xbe8>
 1020bf4:	04400404 	movi	r17,16
 1020bf8:	d8801b17 	ldw	r2,108(sp)
 1020bfc:	8c017c0e 	bge	r17,r16,10211f0 <___svfiprintf_internal_r+0x1150>
 1020c00:	014040f4 	movhi	r5,259
 1020c04:	296af104 	addi	r5,r5,-21564
 1020c08:	d9402815 	stw	r5,160(sp)
 1020c0c:	048001c4 	movi	r18,7
 1020c10:	00000306 	br	1020c20 <___svfiprintf_internal_r+0xb80>
 1020c14:	843ffc04 	addi	r16,r16,-16
 1020c18:	42000204 	addi	r8,r8,8
 1020c1c:	8c00110e 	bge	r17,r16,1020c64 <___svfiprintf_internal_r+0xbc4>
 1020c20:	18c00404 	addi	r3,r3,16
 1020c24:	10800044 	addi	r2,r2,1
 1020c28:	45800015 	stw	r22,0(r8)
 1020c2c:	44400115 	stw	r17,4(r8)
 1020c30:	d8c01c15 	stw	r3,112(sp)
 1020c34:	d8801b15 	stw	r2,108(sp)
 1020c38:	90bff60e 	bge	r18,r2,1020c14 <__alt_data_end+0xff020c14>
 1020c3c:	d9801a04 	addi	r6,sp,104
 1020c40:	b80b883a 	mov	r5,r23
 1020c44:	a809883a 	mov	r4,r21
 1020c48:	101fed00 	call	101fed0 <__ssprint_r>
 1020c4c:	1000221e 	bne	r2,zero,1020cd8 <___svfiprintf_internal_r+0xc38>
 1020c50:	843ffc04 	addi	r16,r16,-16
 1020c54:	d8c01c17 	ldw	r3,112(sp)
 1020c58:	d8801b17 	ldw	r2,108(sp)
 1020c5c:	d811883a 	mov	r8,sp
 1020c60:	8c3fef16 	blt	r17,r16,1020c20 <__alt_data_end+0xff020c20>
 1020c64:	dac02817 	ldw	r11,160(sp)
 1020c68:	1c07883a 	add	r3,r3,r16
 1020c6c:	10800044 	addi	r2,r2,1
 1020c70:	42c00015 	stw	r11,0(r8)
 1020c74:	44000115 	stw	r16,4(r8)
 1020c78:	d8c01c15 	stw	r3,112(sp)
 1020c7c:	d8801b15 	stw	r2,108(sp)
 1020c80:	010001c4 	movi	r4,7
 1020c84:	2080aa16 	blt	r4,r2,1020f30 <___svfiprintf_internal_r+0xe90>
 1020c88:	d8802417 	ldw	r2,144(sp)
 1020c8c:	dac02017 	ldw	r11,128(sp)
 1020c90:	12c0010e 	bge	r2,r11,1020c98 <___svfiprintf_internal_r+0xbf8>
 1020c94:	5805883a 	mov	r2,r11
 1020c98:	dac02517 	ldw	r11,148(sp)
 1020c9c:	5897883a 	add	r11,r11,r2
 1020ca0:	dac02515 	stw	r11,148(sp)
 1020ca4:	1800531e 	bne	r3,zero,1020df4 <___svfiprintf_internal_r+0xd54>
 1020ca8:	98800007 	ldb	r2,0(r19)
 1020cac:	d8001b15 	stw	zero,108(sp)
 1020cb0:	d811883a 	mov	r8,sp
 1020cb4:	103d231e 	bne	r2,zero,1020144 <__alt_data_end+0xff020144>
 1020cb8:	9823883a 	mov	r17,r19
 1020cbc:	003d3906 	br	10201a4 <__alt_data_end+0xff0201a4>
 1020cc0:	d8801c17 	ldw	r2,112(sp)
 1020cc4:	10000426 	beq	r2,zero,1020cd8 <___svfiprintf_internal_r+0xc38>
 1020cc8:	d9402717 	ldw	r5,156(sp)
 1020ccc:	d9002a17 	ldw	r4,168(sp)
 1020cd0:	d9801a04 	addi	r6,sp,104
 1020cd4:	101fed00 	call	101fed0 <__ssprint_r>
 1020cd8:	dac02717 	ldw	r11,156(sp)
 1020cdc:	d8802517 	ldw	r2,148(sp)
 1020ce0:	58c0030b 	ldhu	r3,12(r11)
 1020ce4:	18c0100c 	andi	r3,r3,64
 1020ce8:	1801381e 	bne	r3,zero,10211cc <___svfiprintf_internal_r+0x112c>
 1020cec:	dfc03717 	ldw	ra,220(sp)
 1020cf0:	df003617 	ldw	fp,216(sp)
 1020cf4:	ddc03517 	ldw	r23,212(sp)
 1020cf8:	dd803417 	ldw	r22,208(sp)
 1020cfc:	dd403317 	ldw	r21,204(sp)
 1020d00:	dd003217 	ldw	r20,200(sp)
 1020d04:	dcc03117 	ldw	r19,196(sp)
 1020d08:	dc803017 	ldw	r18,192(sp)
 1020d0c:	dc402f17 	ldw	r17,188(sp)
 1020d10:	dc002e17 	ldw	r16,184(sp)
 1020d14:	dec03804 	addi	sp,sp,224
 1020d18:	f800283a 	ret
 1020d1c:	dac02417 	ldw	r11,144(sp)
 1020d20:	d9002017 	ldw	r4,128(sp)
 1020d24:	5939c83a 	sub	fp,r11,r4
 1020d28:	073f780e 	bge	zero,fp,1020b0c <__alt_data_end+0xff020b0c>
 1020d2c:	02400404 	movi	r9,16
 1020d30:	4f01370e 	bge	r9,fp,1021210 <___svfiprintf_internal_r+0x1170>
 1020d34:	02c040f4 	movhi	r11,259
 1020d38:	5aeaed04 	addi	r11,r11,-21580
 1020d3c:	dac02215 	stw	r11,136(sp)
 1020d40:	028001c4 	movi	r10,7
 1020d44:	00000306 	br	1020d54 <___svfiprintf_internal_r+0xcb4>
 1020d48:	e73ffc04 	addi	fp,fp,-16
 1020d4c:	42000204 	addi	r8,r8,8
 1020d50:	4f00150e 	bge	r9,fp,1020da8 <___svfiprintf_internal_r+0xd08>
 1020d54:	18c00404 	addi	r3,r3,16
 1020d58:	10800044 	addi	r2,r2,1
 1020d5c:	45000015 	stw	r20,0(r8)
 1020d60:	42400115 	stw	r9,4(r8)
 1020d64:	d8c01c15 	stw	r3,112(sp)
 1020d68:	d8801b15 	stw	r2,108(sp)
 1020d6c:	50bff60e 	bge	r10,r2,1020d48 <__alt_data_end+0xff020d48>
 1020d70:	d9801a04 	addi	r6,sp,104
 1020d74:	b80b883a 	mov	r5,r23
 1020d78:	a809883a 	mov	r4,r21
 1020d7c:	da402c15 	stw	r9,176(sp)
 1020d80:	da802d15 	stw	r10,180(sp)
 1020d84:	101fed00 	call	101fed0 <__ssprint_r>
 1020d88:	da402c17 	ldw	r9,176(sp)
 1020d8c:	da802d17 	ldw	r10,180(sp)
 1020d90:	103fd11e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 1020d94:	e73ffc04 	addi	fp,fp,-16
 1020d98:	d8c01c17 	ldw	r3,112(sp)
 1020d9c:	d8801b17 	ldw	r2,108(sp)
 1020da0:	d811883a 	mov	r8,sp
 1020da4:	4f3feb16 	blt	r9,fp,1020d54 <__alt_data_end+0xff020d54>
 1020da8:	dac02217 	ldw	r11,136(sp)
 1020dac:	1f07883a 	add	r3,r3,fp
 1020db0:	10800044 	addi	r2,r2,1
 1020db4:	42c00015 	stw	r11,0(r8)
 1020db8:	47000115 	stw	fp,4(r8)
 1020dbc:	d8c01c15 	stw	r3,112(sp)
 1020dc0:	d8801b15 	stw	r2,108(sp)
 1020dc4:	010001c4 	movi	r4,7
 1020dc8:	2080b616 	blt	r4,r2,10210a4 <___svfiprintf_internal_r+0x1004>
 1020dcc:	42000204 	addi	r8,r8,8
 1020dd0:	003f4e06 	br	1020b0c <__alt_data_end+0xff020b0c>
 1020dd4:	d9801a04 	addi	r6,sp,104
 1020dd8:	b80b883a 	mov	r5,r23
 1020ddc:	a809883a 	mov	r4,r21
 1020de0:	101fed00 	call	101fed0 <__ssprint_r>
 1020de4:	103fbc1e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 1020de8:	d8c01c17 	ldw	r3,112(sp)
 1020dec:	d811883a 	mov	r8,sp
 1020df0:	003f7a06 	br	1020bdc <__alt_data_end+0xff020bdc>
 1020df4:	d9801a04 	addi	r6,sp,104
 1020df8:	b80b883a 	mov	r5,r23
 1020dfc:	a809883a 	mov	r4,r21
 1020e00:	101fed00 	call	101fed0 <__ssprint_r>
 1020e04:	103fa826 	beq	r2,zero,1020ca8 <__alt_data_end+0xff020ca8>
 1020e08:	003fb306 	br	1020cd8 <__alt_data_end+0xff020cd8>
 1020e0c:	d9801a04 	addi	r6,sp,104
 1020e10:	b80b883a 	mov	r5,r23
 1020e14:	a809883a 	mov	r4,r21
 1020e18:	101fed00 	call	101fed0 <__ssprint_r>
 1020e1c:	103fae1e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 1020e20:	d811883a 	mov	r8,sp
 1020e24:	003cdc06 	br	1020198 <__alt_data_end+0xff020198>
 1020e28:	d9801a04 	addi	r6,sp,104
 1020e2c:	b80b883a 	mov	r5,r23
 1020e30:	a809883a 	mov	r4,r21
 1020e34:	101fed00 	call	101fed0 <__ssprint_r>
 1020e38:	103fa71e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 1020e3c:	d8c01c17 	ldw	r3,112(sp)
 1020e40:	d8801b17 	ldw	r2,108(sp)
 1020e44:	d811883a 	mov	r8,sp
 1020e48:	003f5a06 	br	1020bb4 <__alt_data_end+0xff020bb4>
 1020e4c:	d9801a04 	addi	r6,sp,104
 1020e50:	b80b883a 	mov	r5,r23
 1020e54:	a809883a 	mov	r4,r21
 1020e58:	101fed00 	call	101fed0 <__ssprint_r>
 1020e5c:	103f9e1e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 1020e60:	d8c01c17 	ldw	r3,112(sp)
 1020e64:	d8801b17 	ldw	r2,108(sp)
 1020e68:	d811883a 	mov	r8,sp
 1020e6c:	003f1706 	br	1020acc <__alt_data_end+0xff020acc>
 1020e70:	d9801a04 	addi	r6,sp,104
 1020e74:	b80b883a 	mov	r5,r23
 1020e78:	a809883a 	mov	r4,r21
 1020e7c:	101fed00 	call	101fed0 <__ssprint_r>
 1020e80:	103f951e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 1020e84:	d8c01c17 	ldw	r3,112(sp)
 1020e88:	d8801b17 	ldw	r2,108(sp)
 1020e8c:	d811883a 	mov	r8,sp
 1020e90:	003f1b06 	br	1020b00 <__alt_data_end+0xff020b00>
 1020e94:	d8001d85 	stb	zero,118(sp)
 1020e98:	80007b16 	blt	r16,zero,1021088 <___svfiprintf_internal_r+0xfe8>
 1020e9c:	00ffdfc4 	movi	r3,-129
 1020ea0:	e244b03a 	or	r2,fp,r9
 1020ea4:	90e4703a 	and	r18,r18,r3
 1020ea8:	103d7026 	beq	r2,zero,102046c <__alt_data_end+0xff02046c>
 1020eac:	0015883a 	mov	r10,zero
 1020eb0:	003d7206 	br	102047c <__alt_data_end+0xff02047c>
 1020eb4:	d9801a04 	addi	r6,sp,104
 1020eb8:	b80b883a 	mov	r5,r23
 1020ebc:	a809883a 	mov	r4,r21
 1020ec0:	101fed00 	call	101fed0 <__ssprint_r>
 1020ec4:	103f841e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 1020ec8:	d8c01c17 	ldw	r3,112(sp)
 1020ecc:	d8801b17 	ldw	r2,108(sp)
 1020ed0:	d811883a 	mov	r8,sp
 1020ed4:	003ef006 	br	1020a98 <__alt_data_end+0xff020a98>
 1020ed8:	9080100c 	andi	r2,r18,64
 1020edc:	d8001d85 	stb	zero,118(sp)
 1020ee0:	dac02317 	ldw	r11,140(sp)
 1020ee4:	10008126 	beq	r2,zero,10210ec <___svfiprintf_internal_r+0x104c>
 1020ee8:	58800104 	addi	r2,r11,4
 1020eec:	5f00000b 	ldhu	fp,0(r11)
 1020ef0:	0013883a 	mov	r9,zero
 1020ef4:	803ec30e 	bge	r16,zero,1020a04 <__alt_data_end+0xff020a04>
 1020ef8:	d8802315 	stw	r2,140(sp)
 1020efc:	0015883a 	mov	r10,zero
 1020f00:	e244b03a 	or	r2,fp,r9
 1020f04:	103e371e 	bne	r2,zero,10207e4 <__alt_data_end+0xff0207e4>
 1020f08:	00800044 	movi	r2,1
 1020f0c:	10803fcc 	andi	r2,r2,255
 1020f10:	00c00044 	movi	r3,1
 1020f14:	10c06126 	beq	r2,r3,102109c <___svfiprintf_internal_r+0xffc>
 1020f18:	00c00084 	movi	r3,2
 1020f1c:	10fd5526 	beq	r2,r3,1020474 <__alt_data_end+0xff020474>
 1020f20:	003ed806 	br	1020a84 <__alt_data_end+0xff020a84>
 1020f24:	d8802315 	stw	r2,140(sp)
 1020f28:	98c00007 	ldb	r3,0(r19)
 1020f2c:	003cab06 	br	10201dc <__alt_data_end+0xff0201dc>
 1020f30:	d9801a04 	addi	r6,sp,104
 1020f34:	b80b883a 	mov	r5,r23
 1020f38:	a809883a 	mov	r4,r21
 1020f3c:	101fed00 	call	101fed0 <__ssprint_r>
 1020f40:	103f651e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 1020f44:	d8c01c17 	ldw	r3,112(sp)
 1020f48:	003f4f06 	br	1020c88 <__alt_data_end+0xff020c88>
 1020f4c:	008040f4 	movhi	r2,259
 1020f50:	10aa8504 	addi	r2,r2,-21996
 1020f54:	d8802915 	stw	r2,164(sp)
 1020f58:	003d4406 	br	102046c <__alt_data_end+0xff02046c>
 1020f5c:	dac02317 	ldw	r11,140(sp)
 1020f60:	58800017 	ldw	r2,0(r11)
 1020f64:	dac02517 	ldw	r11,148(sp)
 1020f68:	5807d7fa 	srai	r3,r11,31
 1020f6c:	dac02317 	ldw	r11,140(sp)
 1020f70:	10c00115 	stw	r3,4(r2)
 1020f74:	5ac00104 	addi	r11,r11,4
 1020f78:	dac02315 	stw	r11,140(sp)
 1020f7c:	dac02517 	ldw	r11,148(sp)
 1020f80:	12c00015 	stw	r11,0(r2)
 1020f84:	003c6d06 	br	102013c <__alt_data_end+0xff02013c>
 1020f88:	9080100c 	andi	r2,r18,64
 1020f8c:	dac02317 	ldw	r11,140(sp)
 1020f90:	103e5326 	beq	r2,zero,10208e0 <__alt_data_end+0xff0208e0>
 1020f94:	5f00000f 	ldh	fp,0(r11)
 1020f98:	5ac00104 	addi	r11,r11,4
 1020f9c:	dac02315 	stw	r11,140(sp)
 1020fa0:	e013d7fa 	srai	r9,fp,31
 1020fa4:	4805883a 	mov	r2,r9
 1020fa8:	003e0706 	br	10207c8 <__alt_data_end+0xff0207c8>
 1020fac:	00800c04 	movi	r2,48
 1020fb0:	d8801d05 	stb	r2,116(sp)
 1020fb4:	d8c01d45 	stb	r3,117(sp)
 1020fb8:	d8001d85 	stb	zero,118(sp)
 1020fbc:	90800094 	ori	r2,r18,2
 1020fc0:	80008f16 	blt	r16,zero,1021200 <___svfiprintf_internal_r+0x1160>
 1020fc4:	00bfdfc4 	movi	r2,-129
 1020fc8:	90a4703a 	and	r18,r18,r2
 1020fcc:	94800094 	ori	r18,r18,2
 1020fd0:	0015883a 	mov	r10,zero
 1020fd4:	003d2906 	br	102047c <__alt_data_end+0xff02047c>
 1020fd8:	98c00007 	ldb	r3,0(r19)
 1020fdc:	003c7f06 	br	10201dc <__alt_data_end+0xff0201dc>
 1020fe0:	dac02317 	ldw	r11,140(sp)
 1020fe4:	0013883a 	mov	r9,zero
 1020fe8:	5f000017 	ldw	fp,0(r11)
 1020fec:	5ac00104 	addi	r11,r11,4
 1020ff0:	dac02315 	stw	r11,140(sp)
 1020ff4:	003d1506 	br	102044c <__alt_data_end+0xff02044c>
 1020ff8:	9080100c 	andi	r2,r18,64
 1020ffc:	d8001d85 	stb	zero,118(sp)
 1021000:	dac02317 	ldw	r11,140(sp)
 1021004:	10003426 	beq	r2,zero,10210d8 <___svfiprintf_internal_r+0x1038>
 1021008:	58800104 	addi	r2,r11,4
 102100c:	5f00000b 	ldhu	fp,0(r11)
 1021010:	0013883a 	mov	r9,zero
 1021014:	803e950e 	bge	r16,zero,1020a6c <__alt_data_end+0xff020a6c>
 1021018:	e246b03a 	or	r3,fp,r9
 102101c:	d8802315 	stw	r2,140(sp)
 1021020:	183d5a1e 	bne	r3,zero,102058c <__alt_data_end+0xff02058c>
 1021024:	0015883a 	mov	r10,zero
 1021028:	0005883a 	mov	r2,zero
 102102c:	003fb706 	br	1020f0c <__alt_data_end+0xff020f0c>
 1021030:	98c00043 	ldbu	r3,1(r19)
 1021034:	94800814 	ori	r18,r18,32
 1021038:	9cc00044 	addi	r19,r19,1
 102103c:	18c03fcc 	andi	r3,r3,255
 1021040:	18c0201c 	xori	r3,r3,128
 1021044:	18ffe004 	addi	r3,r3,-128
 1021048:	003c6406 	br	10201dc <__alt_data_end+0xff0201dc>
 102104c:	d8c02315 	stw	r3,140(sp)
 1021050:	0015883a 	mov	r10,zero
 1021054:	003faa06 	br	1020f00 <__alt_data_end+0xff020f00>
 1021058:	dac02317 	ldw	r11,140(sp)
 102105c:	58800017 	ldw	r2,0(r11)
 1021060:	5ac00104 	addi	r11,r11,4
 1021064:	dac02315 	stw	r11,140(sp)
 1021068:	dac02517 	ldw	r11,148(sp)
 102106c:	12c00015 	stw	r11,0(r2)
 1021070:	003c3206 	br	102013c <__alt_data_end+0xff02013c>
 1021074:	010040f4 	movhi	r4,259
 1021078:	212a8504 	addi	r4,r4,-21996
 102107c:	d9002915 	stw	r4,164(sp)
 1021080:	d8c02315 	stw	r3,140(sp)
 1021084:	1025883a 	mov	r18,r2
 1021088:	e244b03a 	or	r2,fp,r9
 102108c:	103f871e 	bne	r2,zero,1020eac <__alt_data_end+0xff020eac>
 1021090:	0015883a 	mov	r10,zero
 1021094:	00800084 	movi	r2,2
 1021098:	003f9c06 	br	1020f0c <__alt_data_end+0xff020f0c>
 102109c:	0039883a 	mov	fp,zero
 10210a0:	003e5f06 	br	1020a20 <__alt_data_end+0xff020a20>
 10210a4:	d9801a04 	addi	r6,sp,104
 10210a8:	b80b883a 	mov	r5,r23
 10210ac:	a809883a 	mov	r4,r21
 10210b0:	101fed00 	call	101fed0 <__ssprint_r>
 10210b4:	103f081e 	bne	r2,zero,1020cd8 <__alt_data_end+0xff020cd8>
 10210b8:	d8c01c17 	ldw	r3,112(sp)
 10210bc:	d8801b17 	ldw	r2,108(sp)
 10210c0:	d811883a 	mov	r8,sp
 10210c4:	003e9106 	br	1020b0c <__alt_data_end+0xff020b0c>
 10210c8:	010040f4 	movhi	r4,259
 10210cc:	212aed04 	addi	r4,r4,-21580
 10210d0:	d9002215 	stw	r4,136(sp)
 10210d4:	003ead06 	br	1020b8c <__alt_data_end+0xff020b8c>
 10210d8:	58800104 	addi	r2,r11,4
 10210dc:	5f000017 	ldw	fp,0(r11)
 10210e0:	0013883a 	mov	r9,zero
 10210e4:	803e610e 	bge	r16,zero,1020a6c <__alt_data_end+0xff020a6c>
 10210e8:	003fcb06 	br	1021018 <__alt_data_end+0xff021018>
 10210ec:	58800104 	addi	r2,r11,4
 10210f0:	5f000017 	ldw	fp,0(r11)
 10210f4:	0013883a 	mov	r9,zero
 10210f8:	803e420e 	bge	r16,zero,1020a04 <__alt_data_end+0xff020a04>
 10210fc:	003f7e06 	br	1020ef8 <__alt_data_end+0xff020ef8>
 1021100:	5f000017 	ldw	fp,0(r11)
 1021104:	5ac00104 	addi	r11,r11,4
 1021108:	0013883a 	mov	r9,zero
 102110c:	dac02315 	stw	r11,140(sp)
 1021110:	003cce06 	br	102044c <__alt_data_end+0xff02044c>
 1021114:	8809883a 	mov	r4,r17
 1021118:	da002c15 	stw	r8,176(sp)
 102111c:	10165b40 	call	10165b4 <strlen>
 1021120:	d8802115 	stw	r2,132(sp)
 1021124:	da801d83 	ldbu	r10,118(sp)
 1021128:	df002315 	stw	fp,140(sp)
 102112c:	0021883a 	mov	r16,zero
 1021130:	da002c17 	ldw	r8,176(sp)
 1021134:	003cf606 	br	1020510 <__alt_data_end+0xff020510>
 1021138:	00800184 	movi	r2,6
 102113c:	1400012e 	bgeu	r2,r16,1021144 <___svfiprintf_internal_r+0x10a4>
 1021140:	1021883a 	mov	r16,r2
 1021144:	dc002115 	stw	r16,132(sp)
 1021148:	8005883a 	mov	r2,r16
 102114c:	80003c16 	blt	r16,zero,1021240 <___svfiprintf_internal_r+0x11a0>
 1021150:	044040f4 	movhi	r17,259
 1021154:	d8802015 	stw	r2,128(sp)
 1021158:	df002315 	stw	fp,140(sp)
 102115c:	8c6a8a04 	addi	r17,r17,-21976
 1021160:	003d2e06 	br	102061c <__alt_data_end+0xff02061c>
 1021164:	04001004 	movi	r16,64
 1021168:	800b883a 	mov	r5,r16
 102116c:	101da1c0 	call	101da1c <_malloc_r>
 1021170:	dac02717 	ldw	r11,156(sp)
 1021174:	58800015 	stw	r2,0(r11)
 1021178:	58800415 	stw	r2,16(r11)
 102117c:	10004826 	beq	r2,zero,10212a0 <___svfiprintf_internal_r+0x1200>
 1021180:	dac02717 	ldw	r11,156(sp)
 1021184:	5c000515 	stw	r16,20(r11)
 1021188:	003bd906 	br	10200f0 <__alt_data_end+0xff0200f0>
 102118c:	9080004c 	andi	r2,r18,1
 1021190:	0015883a 	mov	r10,zero
 1021194:	10000626 	beq	r2,zero,10211b0 <___svfiprintf_internal_r+0x1110>
 1021198:	dac02b17 	ldw	r11,172(sp)
 102119c:	00800c04 	movi	r2,48
 10211a0:	d88019c5 	stb	r2,103(sp)
 10211a4:	dac02115 	stw	r11,132(sp)
 10211a8:	dc4019c4 	addi	r17,sp,103
 10211ac:	003cd806 	br	1020510 <__alt_data_end+0xff020510>
 10211b0:	d8002115 	stw	zero,132(sp)
 10211b4:	dc401a04 	addi	r17,sp,104
 10211b8:	003cd506 	br	1020510 <__alt_data_end+0xff020510>
 10211bc:	010040f4 	movhi	r4,259
 10211c0:	212af104 	addi	r4,r4,-21564
 10211c4:	d9002815 	stw	r4,160(sp)
 10211c8:	003d4306 	br	10206d8 <__alt_data_end+0xff0206d8>
 10211cc:	00bfffc4 	movi	r2,-1
 10211d0:	003ec606 	br	1020cec <__alt_data_end+0xff020cec>
 10211d4:	00800044 	movi	r2,1
 10211d8:	10803fcc 	andi	r2,r2,255
 10211dc:	00c00044 	movi	r3,1
 10211e0:	10fd8026 	beq	r2,r3,10207e4 <__alt_data_end+0xff0207e4>
 10211e4:	00c00084 	movi	r3,2
 10211e8:	10fca426 	beq	r2,r3,102047c <__alt_data_end+0xff02047c>
 10211ec:	003ce806 	br	1020590 <__alt_data_end+0xff020590>
 10211f0:	010040f4 	movhi	r4,259
 10211f4:	212af104 	addi	r4,r4,-21564
 10211f8:	d9002815 	stw	r4,160(sp)
 10211fc:	003e9906 	br	1020c64 <__alt_data_end+0xff020c64>
 1021200:	1025883a 	mov	r18,r2
 1021204:	0015883a 	mov	r10,zero
 1021208:	00800084 	movi	r2,2
 102120c:	003ff206 	br	10211d8 <__alt_data_end+0xff0211d8>
 1021210:	014040f4 	movhi	r5,259
 1021214:	296aed04 	addi	r5,r5,-21580
 1021218:	d9402215 	stw	r5,136(sp)
 102121c:	003ee206 	br	1020da8 <__alt_data_end+0xff020da8>
 1021220:	5827883a 	mov	r19,r11
 1021224:	0021883a 	mov	r16,zero
 1021228:	003bed06 	br	10201e0 <__alt_data_end+0xff0201e0>
 102122c:	dc002115 	stw	r16,132(sp)
 1021230:	da801d83 	ldbu	r10,118(sp)
 1021234:	df002315 	stw	fp,140(sp)
 1021238:	0021883a 	mov	r16,zero
 102123c:	003cb406 	br	1020510 <__alt_data_end+0xff020510>
 1021240:	0005883a 	mov	r2,zero
 1021244:	003fc206 	br	1021150 <__alt_data_end+0xff021150>
 1021248:	d8802317 	ldw	r2,140(sp)
 102124c:	98c00043 	ldbu	r3,1(r19)
 1021250:	5827883a 	mov	r19,r11
 1021254:	14000017 	ldw	r16,0(r2)
 1021258:	10800104 	addi	r2,r2,4
 102125c:	d8802315 	stw	r2,140(sp)
 1021260:	803f760e 	bge	r16,zero,102103c <__alt_data_end+0xff02103c>
 1021264:	18c03fcc 	andi	r3,r3,255
 1021268:	18c0201c 	xori	r3,r3,128
 102126c:	043fffc4 	movi	r16,-1
 1021270:	18ffe004 	addi	r3,r3,-128
 1021274:	003bd906 	br	10201dc <__alt_data_end+0xff0201dc>
 1021278:	d9c01d85 	stb	r7,118(sp)
 102127c:	003cb606 	br	1020558 <__alt_data_end+0xff020558>
 1021280:	d9c01d85 	stb	r7,118(sp)
 1021284:	003d2106 	br	102070c <__alt_data_end+0xff02070c>
 1021288:	d9c01d85 	stb	r7,118(sp)
 102128c:	003d8e06 	br	10208c8 <__alt_data_end+0xff0208c8>
 1021290:	d9c01d85 	stb	r7,118(sp)
 1021294:	003db306 	br	1020964 <__alt_data_end+0xff020964>
 1021298:	d9c01d85 	stb	r7,118(sp)
 102129c:	003c8a06 	br	10204c8 <__alt_data_end+0xff0204c8>
 10212a0:	dac02a17 	ldw	r11,168(sp)
 10212a4:	00800304 	movi	r2,12
 10212a8:	58800015 	stw	r2,0(r11)
 10212ac:	00bfffc4 	movi	r2,-1
 10212b0:	003e8e06 	br	1020cec <__alt_data_end+0xff020cec>
 10212b4:	d9c01d85 	stb	r7,118(sp)
 10212b8:	003dc706 	br	10209d8 <__alt_data_end+0xff0209d8>
 10212bc:	d9c01d85 	stb	r7,118(sp)
 10212c0:	003ddf06 	br	1020a40 <__alt_data_end+0xff020a40>
 10212c4:	d9c01d85 	stb	r7,118(sp)
 10212c8:	003d3706 	br	10207a8 <__alt_data_end+0xff0207a8>
 10212cc:	d9c01d85 	stb	r7,118(sp)
 10212d0:	003c5406 	br	1020424 <__alt_data_end+0xff020424>
 10212d4:	d9c01d85 	stb	r7,118(sp)
 10212d8:	003d1d06 	br	1020750 <__alt_data_end+0xff020750>

010212dc <__sprint_r.part.0>:
 10212dc:	28801917 	ldw	r2,100(r5)
 10212e0:	defff604 	addi	sp,sp,-40
 10212e4:	dd400515 	stw	r21,20(sp)
 10212e8:	dfc00915 	stw	ra,36(sp)
 10212ec:	df000815 	stw	fp,32(sp)
 10212f0:	ddc00715 	stw	r23,28(sp)
 10212f4:	dd800615 	stw	r22,24(sp)
 10212f8:	dd000415 	stw	r20,16(sp)
 10212fc:	dcc00315 	stw	r19,12(sp)
 1021300:	dc800215 	stw	r18,8(sp)
 1021304:	dc400115 	stw	r17,4(sp)
 1021308:	dc000015 	stw	r16,0(sp)
 102130c:	1088000c 	andi	r2,r2,8192
 1021310:	302b883a 	mov	r21,r6
 1021314:	10002e26 	beq	r2,zero,10213d0 <__sprint_r.part.0+0xf4>
 1021318:	30800217 	ldw	r2,8(r6)
 102131c:	35800017 	ldw	r22,0(r6)
 1021320:	10002926 	beq	r2,zero,10213c8 <__sprint_r.part.0+0xec>
 1021324:	2827883a 	mov	r19,r5
 1021328:	2029883a 	mov	r20,r4
 102132c:	b5c00104 	addi	r23,r22,4
 1021330:	04bfffc4 	movi	r18,-1
 1021334:	bc400017 	ldw	r17,0(r23)
 1021338:	b4000017 	ldw	r16,0(r22)
 102133c:	0039883a 	mov	fp,zero
 1021340:	8822d0ba 	srli	r17,r17,2
 1021344:	8800031e 	bne	r17,zero,1021354 <__sprint_r.part.0+0x78>
 1021348:	00001806 	br	10213ac <__sprint_r.part.0+0xd0>
 102134c:	84000104 	addi	r16,r16,4
 1021350:	8f001526 	beq	r17,fp,10213a8 <__sprint_r.part.0+0xcc>
 1021354:	81400017 	ldw	r5,0(r16)
 1021358:	980d883a 	mov	r6,r19
 102135c:	a009883a 	mov	r4,r20
 1021360:	1022d040 	call	1022d04 <_fputwc_r>
 1021364:	e7000044 	addi	fp,fp,1
 1021368:	14bff81e 	bne	r2,r18,102134c <__alt_data_end+0xff02134c>
 102136c:	9005883a 	mov	r2,r18
 1021370:	a8000215 	stw	zero,8(r21)
 1021374:	a8000115 	stw	zero,4(r21)
 1021378:	dfc00917 	ldw	ra,36(sp)
 102137c:	df000817 	ldw	fp,32(sp)
 1021380:	ddc00717 	ldw	r23,28(sp)
 1021384:	dd800617 	ldw	r22,24(sp)
 1021388:	dd400517 	ldw	r21,20(sp)
 102138c:	dd000417 	ldw	r20,16(sp)
 1021390:	dcc00317 	ldw	r19,12(sp)
 1021394:	dc800217 	ldw	r18,8(sp)
 1021398:	dc400117 	ldw	r17,4(sp)
 102139c:	dc000017 	ldw	r16,0(sp)
 10213a0:	dec00a04 	addi	sp,sp,40
 10213a4:	f800283a 	ret
 10213a8:	a8800217 	ldw	r2,8(r21)
 10213ac:	8c63883a 	add	r17,r17,r17
 10213b0:	8c63883a 	add	r17,r17,r17
 10213b4:	1445c83a 	sub	r2,r2,r17
 10213b8:	a8800215 	stw	r2,8(r21)
 10213bc:	b5800204 	addi	r22,r22,8
 10213c0:	bdc00204 	addi	r23,r23,8
 10213c4:	103fdb1e 	bne	r2,zero,1021334 <__alt_data_end+0xff021334>
 10213c8:	0005883a 	mov	r2,zero
 10213cc:	003fe806 	br	1021370 <__alt_data_end+0xff021370>
 10213d0:	101d1400 	call	101d140 <__sfvwrite_r>
 10213d4:	003fe606 	br	1021370 <__alt_data_end+0xff021370>

010213d8 <__sprint_r>:
 10213d8:	30c00217 	ldw	r3,8(r6)
 10213dc:	18000126 	beq	r3,zero,10213e4 <__sprint_r+0xc>
 10213e0:	10212dc1 	jmpi	10212dc <__sprint_r.part.0>
 10213e4:	30000115 	stw	zero,4(r6)
 10213e8:	0005883a 	mov	r2,zero
 10213ec:	f800283a 	ret

010213f0 <___vfiprintf_internal_r>:
 10213f0:	deffc904 	addi	sp,sp,-220
 10213f4:	df003515 	stw	fp,212(sp)
 10213f8:	dd003115 	stw	r20,196(sp)
 10213fc:	dfc03615 	stw	ra,216(sp)
 1021400:	ddc03415 	stw	r23,208(sp)
 1021404:	dd803315 	stw	r22,204(sp)
 1021408:	dd403215 	stw	r21,200(sp)
 102140c:	dcc03015 	stw	r19,192(sp)
 1021410:	dc802f15 	stw	r18,188(sp)
 1021414:	dc402e15 	stw	r17,184(sp)
 1021418:	dc002d15 	stw	r16,180(sp)
 102141c:	d9002015 	stw	r4,128(sp)
 1021420:	d9c02215 	stw	r7,136(sp)
 1021424:	2829883a 	mov	r20,r5
 1021428:	3039883a 	mov	fp,r6
 102142c:	20000226 	beq	r4,zero,1021438 <___vfiprintf_internal_r+0x48>
 1021430:	20800e17 	ldw	r2,56(r4)
 1021434:	1000cf26 	beq	r2,zero,1021774 <___vfiprintf_internal_r+0x384>
 1021438:	a080030b 	ldhu	r2,12(r20)
 102143c:	10c8000c 	andi	r3,r2,8192
 1021440:	1800061e 	bne	r3,zero,102145c <___vfiprintf_internal_r+0x6c>
 1021444:	a1001917 	ldw	r4,100(r20)
 1021448:	00f7ffc4 	movi	r3,-8193
 102144c:	10880014 	ori	r2,r2,8192
 1021450:	20c6703a 	and	r3,r4,r3
 1021454:	a080030d 	sth	r2,12(r20)
 1021458:	a0c01915 	stw	r3,100(r20)
 102145c:	10c0020c 	andi	r3,r2,8
 1021460:	1800a926 	beq	r3,zero,1021708 <___vfiprintf_internal_r+0x318>
 1021464:	a0c00417 	ldw	r3,16(r20)
 1021468:	1800a726 	beq	r3,zero,1021708 <___vfiprintf_internal_r+0x318>
 102146c:	1080068c 	andi	r2,r2,26
 1021470:	00c00284 	movi	r3,10
 1021474:	10c0ac26 	beq	r2,r3,1021728 <___vfiprintf_internal_r+0x338>
 1021478:	da801a04 	addi	r10,sp,104
 102147c:	da801e15 	stw	r10,120(sp)
 1021480:	d8801e17 	ldw	r2,120(sp)
 1021484:	da8019c4 	addi	r10,sp,103
 1021488:	058040f4 	movhi	r22,259
 102148c:	05c040f4 	movhi	r23,259
 1021490:	da801f15 	stw	r10,124(sp)
 1021494:	1295c83a 	sub	r10,r2,r10
 1021498:	b5aaf904 	addi	r22,r22,-21532
 102149c:	bdeaf504 	addi	r23,r23,-21548
 10214a0:	dec01a15 	stw	sp,104(sp)
 10214a4:	d8001c15 	stw	zero,112(sp)
 10214a8:	d8001b15 	stw	zero,108(sp)
 10214ac:	d8002615 	stw	zero,152(sp)
 10214b0:	d8002315 	stw	zero,140(sp)
 10214b4:	da802715 	stw	r10,156(sp)
 10214b8:	d811883a 	mov	r8,sp
 10214bc:	dd002115 	stw	r20,132(sp)
 10214c0:	e021883a 	mov	r16,fp
 10214c4:	80800007 	ldb	r2,0(r16)
 10214c8:	1003ea26 	beq	r2,zero,1022474 <___vfiprintf_internal_r+0x1084>
 10214cc:	00c00944 	movi	r3,37
 10214d0:	8025883a 	mov	r18,r16
 10214d4:	10c0021e 	bne	r2,r3,10214e0 <___vfiprintf_internal_r+0xf0>
 10214d8:	00001606 	br	1021534 <___vfiprintf_internal_r+0x144>
 10214dc:	10c00326 	beq	r2,r3,10214ec <___vfiprintf_internal_r+0xfc>
 10214e0:	94800044 	addi	r18,r18,1
 10214e4:	90800007 	ldb	r2,0(r18)
 10214e8:	103ffc1e 	bne	r2,zero,10214dc <__alt_data_end+0xff0214dc>
 10214ec:	9423c83a 	sub	r17,r18,r16
 10214f0:	88001026 	beq	r17,zero,1021534 <___vfiprintf_internal_r+0x144>
 10214f4:	d8c01c17 	ldw	r3,112(sp)
 10214f8:	d8801b17 	ldw	r2,108(sp)
 10214fc:	44000015 	stw	r16,0(r8)
 1021500:	88c7883a 	add	r3,r17,r3
 1021504:	10800044 	addi	r2,r2,1
 1021508:	44400115 	stw	r17,4(r8)
 102150c:	d8c01c15 	stw	r3,112(sp)
 1021510:	d8801b15 	stw	r2,108(sp)
 1021514:	010001c4 	movi	r4,7
 1021518:	2080760e 	bge	r4,r2,10216f4 <___vfiprintf_internal_r+0x304>
 102151c:	1803821e 	bne	r3,zero,1022328 <___vfiprintf_internal_r+0xf38>
 1021520:	da802317 	ldw	r10,140(sp)
 1021524:	d8001b15 	stw	zero,108(sp)
 1021528:	d811883a 	mov	r8,sp
 102152c:	5455883a 	add	r10,r10,r17
 1021530:	da802315 	stw	r10,140(sp)
 1021534:	90800007 	ldb	r2,0(r18)
 1021538:	10044626 	beq	r2,zero,1022654 <___vfiprintf_internal_r+0x1264>
 102153c:	90c00047 	ldb	r3,1(r18)
 1021540:	94000044 	addi	r16,r18,1
 1021544:	d8001d85 	stb	zero,118(sp)
 1021548:	0009883a 	mov	r4,zero
 102154c:	000f883a 	mov	r7,zero
 1021550:	027fffc4 	movi	r9,-1
 1021554:	0023883a 	mov	r17,zero
 1021558:	0029883a 	mov	r20,zero
 102155c:	01401604 	movi	r5,88
 1021560:	01800244 	movi	r6,9
 1021564:	03400a84 	movi	r13,42
 1021568:	03001b04 	movi	r12,108
 102156c:	84000044 	addi	r16,r16,1
 1021570:	18bff804 	addi	r2,r3,-32
 1021574:	28827336 	bltu	r5,r2,1021f44 <___vfiprintf_internal_r+0xb54>
 1021578:	100490ba 	slli	r2,r2,2
 102157c:	028040b4 	movhi	r10,258
 1021580:	52856404 	addi	r10,r10,5520
 1021584:	1285883a 	add	r2,r2,r10
 1021588:	10800017 	ldw	r2,0(r2)
 102158c:	1000683a 	jmp	r2
 1021590:	01021c78 	rdprs	r4,zero,2161
 1021594:	01021f44 	movi	r4,2173
 1021598:	01021f44 	movi	r4,2173
 102159c:	01021c98 	cmpnei	r4,zero,2162
 10215a0:	01021f44 	movi	r4,2173
 10215a4:	01021f44 	movi	r4,2173
 10215a8:	01021f44 	movi	r4,2173
 10215ac:	01021f44 	movi	r4,2173
 10215b0:	01021f44 	movi	r4,2173
 10215b4:	01021f44 	movi	r4,2173
 10215b8:	01021e80 	call	1021e8 <__reset-0xefde18>
 10215bc:	01021e9c 	xori	r4,zero,2170
 10215c0:	01021f44 	movi	r4,2173
 10215c4:	01021784 	movi	r4,2142
 10215c8:	01021eac 	andhi	r4,zero,2170
 10215cc:	01021f44 	movi	r4,2173
 10215d0:	01021ca4 	muli	r4,zero,2162
 10215d4:	01021cb0 	cmpltui	r4,zero,2162
 10215d8:	01021cb0 	cmpltui	r4,zero,2162
 10215dc:	01021cb0 	cmpltui	r4,zero,2162
 10215e0:	01021cb0 	cmpltui	r4,zero,2162
 10215e4:	01021cb0 	cmpltui	r4,zero,2162
 10215e8:	01021cb0 	cmpltui	r4,zero,2162
 10215ec:	01021cb0 	cmpltui	r4,zero,2162
 10215f0:	01021cb0 	cmpltui	r4,zero,2162
 10215f4:	01021cb0 	cmpltui	r4,zero,2162
 10215f8:	01021f44 	movi	r4,2173
 10215fc:	01021f44 	movi	r4,2173
 1021600:	01021f44 	movi	r4,2173
 1021604:	01021f44 	movi	r4,2173
 1021608:	01021f44 	movi	r4,2173
 102160c:	01021f44 	movi	r4,2173
 1021610:	01021f44 	movi	r4,2173
 1021614:	01021f44 	movi	r4,2173
 1021618:	01021f44 	movi	r4,2173
 102161c:	01021f44 	movi	r4,2173
 1021620:	01021cdc 	xori	r4,zero,2163
 1021624:	01021f44 	movi	r4,2173
 1021628:	01021f44 	movi	r4,2173
 102162c:	01021f44 	movi	r4,2173
 1021630:	01021f44 	movi	r4,2173
 1021634:	01021f44 	movi	r4,2173
 1021638:	01021f44 	movi	r4,2173
 102163c:	01021f44 	movi	r4,2173
 1021640:	01021f44 	movi	r4,2173
 1021644:	01021f44 	movi	r4,2173
 1021648:	01021f44 	movi	r4,2173
 102164c:	01021d14 	movui	r4,2164
 1021650:	01021f44 	movi	r4,2173
 1021654:	01021f44 	movi	r4,2173
 1021658:	01021f44 	movi	r4,2173
 102165c:	01021f44 	movi	r4,2173
 1021660:	01021f44 	movi	r4,2173
 1021664:	01021d6c 	andhi	r4,zero,2165
 1021668:	01021f44 	movi	r4,2173
 102166c:	01021f44 	movi	r4,2173
 1021670:	01021ddc 	xori	r4,zero,2167
 1021674:	01021f44 	movi	r4,2173
 1021678:	01021f44 	movi	r4,2173
 102167c:	01021f44 	movi	r4,2173
 1021680:	01021f44 	movi	r4,2173
 1021684:	01021f44 	movi	r4,2173
 1021688:	01021f44 	movi	r4,2173
 102168c:	01021f44 	movi	r4,2173
 1021690:	01021f44 	movi	r4,2173
 1021694:	01021f44 	movi	r4,2173
 1021698:	01021f44 	movi	r4,2173
 102169c:	01021b88 	cmpgei	r4,zero,2158
 10216a0:	01021bb4 	movhi	r4,2158
 10216a4:	01021f44 	movi	r4,2173
 10216a8:	01021f44 	movi	r4,2173
 10216ac:	01021f44 	movi	r4,2173
 10216b0:	01021eec 	andhi	r4,zero,2171
 10216b4:	01021bb4 	movhi	r4,2158
 10216b8:	01021f44 	movi	r4,2173
 10216bc:	01021f44 	movi	r4,2173
 10216c0:	01021a48 	cmpgei	r4,zero,2153
 10216c4:	01021f44 	movi	r4,2173
 10216c8:	01021a58 	cmpnei	r4,zero,2153
 10216cc:	01021a94 	movui	r4,2154
 10216d0:	01021790 	cmplti	r4,zero,2142
 10216d4:	01021a3c 	xorhi	r4,zero,2152
 10216d8:	01021f44 	movi	r4,2173
 10216dc:	01021e18 	cmpnei	r4,zero,2168
 10216e0:	01021f44 	movi	r4,2173
 10216e4:	01021e70 	cmpltui	r4,zero,2169
 10216e8:	01021f44 	movi	r4,2173
 10216ec:	01021f44 	movi	r4,2173
 10216f0:	01021b34 	movhi	r4,2156
 10216f4:	42000204 	addi	r8,r8,8
 10216f8:	da802317 	ldw	r10,140(sp)
 10216fc:	5455883a 	add	r10,r10,r17
 1021700:	da802315 	stw	r10,140(sp)
 1021704:	003f8b06 	br	1021534 <__alt_data_end+0xff021534>
 1021708:	d9002017 	ldw	r4,128(sp)
 102170c:	a00b883a 	mov	r5,r20
 1021710:	101acd00 	call	101acd0 <__swsetup_r>
 1021714:	1003b11e 	bne	r2,zero,10225dc <___vfiprintf_internal_r+0x11ec>
 1021718:	a080030b 	ldhu	r2,12(r20)
 102171c:	00c00284 	movi	r3,10
 1021720:	1080068c 	andi	r2,r2,26
 1021724:	10ff541e 	bne	r2,r3,1021478 <__alt_data_end+0xff021478>
 1021728:	a080038f 	ldh	r2,14(r20)
 102172c:	103f5216 	blt	r2,zero,1021478 <__alt_data_end+0xff021478>
 1021730:	d9c02217 	ldw	r7,136(sp)
 1021734:	d9002017 	ldw	r4,128(sp)
 1021738:	e00d883a 	mov	r6,fp
 102173c:	a00b883a 	mov	r5,r20
 1021740:	10228680 	call	1022868 <__sbprintf>
 1021744:	dfc03617 	ldw	ra,216(sp)
 1021748:	df003517 	ldw	fp,212(sp)
 102174c:	ddc03417 	ldw	r23,208(sp)
 1021750:	dd803317 	ldw	r22,204(sp)
 1021754:	dd403217 	ldw	r21,200(sp)
 1021758:	dd003117 	ldw	r20,196(sp)
 102175c:	dcc03017 	ldw	r19,192(sp)
 1021760:	dc802f17 	ldw	r18,188(sp)
 1021764:	dc402e17 	ldw	r17,184(sp)
 1021768:	dc002d17 	ldw	r16,180(sp)
 102176c:	dec03704 	addi	sp,sp,220
 1021770:	f800283a 	ret
 1021774:	101ccbc0 	call	101ccbc <__sinit>
 1021778:	003f2f06 	br	1021438 <__alt_data_end+0xff021438>
 102177c:	0463c83a 	sub	r17,zero,r17
 1021780:	d8802215 	stw	r2,136(sp)
 1021784:	a5000114 	ori	r20,r20,4
 1021788:	80c00007 	ldb	r3,0(r16)
 102178c:	003f7706 	br	102156c <__alt_data_end+0xff02156c>
 1021790:	00800c04 	movi	r2,48
 1021794:	da802217 	ldw	r10,136(sp)
 1021798:	d8801d05 	stb	r2,116(sp)
 102179c:	00801e04 	movi	r2,120
 10217a0:	d8801d45 	stb	r2,117(sp)
 10217a4:	d8001d85 	stb	zero,118(sp)
 10217a8:	50c00104 	addi	r3,r10,4
 10217ac:	54800017 	ldw	r18,0(r10)
 10217b0:	0027883a 	mov	r19,zero
 10217b4:	a0800094 	ori	r2,r20,2
 10217b8:	48030b16 	blt	r9,zero,10223e8 <___vfiprintf_internal_r+0xff8>
 10217bc:	00bfdfc4 	movi	r2,-129
 10217c0:	a096703a 	and	r11,r20,r2
 10217c4:	d8c02215 	stw	r3,136(sp)
 10217c8:	5d000094 	ori	r20,r11,2
 10217cc:	90032b1e 	bne	r18,zero,102247c <___vfiprintf_internal_r+0x108c>
 10217d0:	008040f4 	movhi	r2,259
 10217d4:	10aa8504 	addi	r2,r2,-21996
 10217d8:	d8802615 	stw	r2,152(sp)
 10217dc:	0039883a 	mov	fp,zero
 10217e0:	48017b1e 	bne	r9,zero,1021dd0 <___vfiprintf_internal_r+0x9e0>
 10217e4:	0013883a 	mov	r9,zero
 10217e8:	0027883a 	mov	r19,zero
 10217ec:	dd401a04 	addi	r21,sp,104
 10217f0:	4825883a 	mov	r18,r9
 10217f4:	4cc0010e 	bge	r9,r19,10217fc <___vfiprintf_internal_r+0x40c>
 10217f8:	9825883a 	mov	r18,r19
 10217fc:	e7003fcc 	andi	fp,fp,255
 1021800:	e700201c 	xori	fp,fp,128
 1021804:	e73fe004 	addi	fp,fp,-128
 1021808:	e0000126 	beq	fp,zero,1021810 <___vfiprintf_internal_r+0x420>
 102180c:	94800044 	addi	r18,r18,1
 1021810:	a380008c 	andi	r14,r20,2
 1021814:	70000126 	beq	r14,zero,102181c <___vfiprintf_internal_r+0x42c>
 1021818:	94800084 	addi	r18,r18,2
 102181c:	a700210c 	andi	fp,r20,132
 1021820:	e001df1e 	bne	fp,zero,1021fa0 <___vfiprintf_internal_r+0xbb0>
 1021824:	8c87c83a 	sub	r3,r17,r18
 1021828:	00c1dd0e 	bge	zero,r3,1021fa0 <___vfiprintf_internal_r+0xbb0>
 102182c:	01c00404 	movi	r7,16
 1021830:	d8801c17 	ldw	r2,112(sp)
 1021834:	38c3ad0e 	bge	r7,r3,10226ec <___vfiprintf_internal_r+0x12fc>
 1021838:	028040f4 	movhi	r10,259
 102183c:	52aaf904 	addi	r10,r10,-21532
 1021840:	dc002915 	stw	r16,164(sp)
 1021844:	d9801b17 	ldw	r6,108(sp)
 1021848:	da802415 	stw	r10,144(sp)
 102184c:	03c001c4 	movi	r15,7
 1021850:	da402515 	stw	r9,148(sp)
 1021854:	db802815 	stw	r14,160(sp)
 1021858:	1821883a 	mov	r16,r3
 102185c:	00000506 	br	1021874 <___vfiprintf_internal_r+0x484>
 1021860:	31400084 	addi	r5,r6,2
 1021864:	42000204 	addi	r8,r8,8
 1021868:	200d883a 	mov	r6,r4
 102186c:	843ffc04 	addi	r16,r16,-16
 1021870:	3c000d0e 	bge	r7,r16,10218a8 <___vfiprintf_internal_r+0x4b8>
 1021874:	10800404 	addi	r2,r2,16
 1021878:	31000044 	addi	r4,r6,1
 102187c:	45800015 	stw	r22,0(r8)
 1021880:	41c00115 	stw	r7,4(r8)
 1021884:	d8801c15 	stw	r2,112(sp)
 1021888:	d9001b15 	stw	r4,108(sp)
 102188c:	793ff40e 	bge	r15,r4,1021860 <__alt_data_end+0xff021860>
 1021890:	1001b51e 	bne	r2,zero,1021f68 <___vfiprintf_internal_r+0xb78>
 1021894:	843ffc04 	addi	r16,r16,-16
 1021898:	000d883a 	mov	r6,zero
 102189c:	01400044 	movi	r5,1
 10218a0:	d811883a 	mov	r8,sp
 10218a4:	3c3ff316 	blt	r7,r16,1021874 <__alt_data_end+0xff021874>
 10218a8:	8007883a 	mov	r3,r16
 10218ac:	da402517 	ldw	r9,148(sp)
 10218b0:	db802817 	ldw	r14,160(sp)
 10218b4:	dc002917 	ldw	r16,164(sp)
 10218b8:	da802417 	ldw	r10,144(sp)
 10218bc:	1885883a 	add	r2,r3,r2
 10218c0:	40c00115 	stw	r3,4(r8)
 10218c4:	42800015 	stw	r10,0(r8)
 10218c8:	d8801c15 	stw	r2,112(sp)
 10218cc:	d9401b15 	stw	r5,108(sp)
 10218d0:	00c001c4 	movi	r3,7
 10218d4:	19426016 	blt	r3,r5,1022258 <___vfiprintf_internal_r+0xe68>
 10218d8:	d8c01d87 	ldb	r3,118(sp)
 10218dc:	42000204 	addi	r8,r8,8
 10218e0:	29000044 	addi	r4,r5,1
 10218e4:	1801b31e 	bne	r3,zero,1021fb4 <___vfiprintf_internal_r+0xbc4>
 10218e8:	7001c026 	beq	r14,zero,1021fec <___vfiprintf_internal_r+0xbfc>
 10218ec:	d8c01d04 	addi	r3,sp,116
 10218f0:	10800084 	addi	r2,r2,2
 10218f4:	40c00015 	stw	r3,0(r8)
 10218f8:	00c00084 	movi	r3,2
 10218fc:	40c00115 	stw	r3,4(r8)
 1021900:	d8801c15 	stw	r2,112(sp)
 1021904:	d9001b15 	stw	r4,108(sp)
 1021908:	00c001c4 	movi	r3,7
 102190c:	1902650e 	bge	r3,r4,10222a4 <___vfiprintf_internal_r+0xeb4>
 1021910:	10029a1e 	bne	r2,zero,102237c <___vfiprintf_internal_r+0xf8c>
 1021914:	00c02004 	movi	r3,128
 1021918:	01000044 	movi	r4,1
 102191c:	000b883a 	mov	r5,zero
 1021920:	d811883a 	mov	r8,sp
 1021924:	e0c1b31e 	bne	fp,r3,1021ff4 <___vfiprintf_internal_r+0xc04>
 1021928:	8cb9c83a 	sub	fp,r17,r18
 102192c:	0701b10e 	bge	zero,fp,1021ff4 <___vfiprintf_internal_r+0xc04>
 1021930:	01c00404 	movi	r7,16
 1021934:	3f03890e 	bge	r7,fp,102275c <___vfiprintf_internal_r+0x136c>
 1021938:	00c040f4 	movhi	r3,259
 102193c:	18eaf504 	addi	r3,r3,-21548
 1021940:	d8c02415 	stw	r3,144(sp)
 1021944:	8007883a 	mov	r3,r16
 1021948:	034001c4 	movi	r13,7
 102194c:	e021883a 	mov	r16,fp
 1021950:	da402515 	stw	r9,148(sp)
 1021954:	1839883a 	mov	fp,r3
 1021958:	00000506 	br	1021970 <___vfiprintf_internal_r+0x580>
 102195c:	29800084 	addi	r6,r5,2
 1021960:	42000204 	addi	r8,r8,8
 1021964:	180b883a 	mov	r5,r3
 1021968:	843ffc04 	addi	r16,r16,-16
 102196c:	3c000d0e 	bge	r7,r16,10219a4 <___vfiprintf_internal_r+0x5b4>
 1021970:	10800404 	addi	r2,r2,16
 1021974:	28c00044 	addi	r3,r5,1
 1021978:	45c00015 	stw	r23,0(r8)
 102197c:	41c00115 	stw	r7,4(r8)
 1021980:	d8801c15 	stw	r2,112(sp)
 1021984:	d8c01b15 	stw	r3,108(sp)
 1021988:	68fff40e 	bge	r13,r3,102195c <__alt_data_end+0xff02195c>
 102198c:	1002241e 	bne	r2,zero,1022220 <___vfiprintf_internal_r+0xe30>
 1021990:	843ffc04 	addi	r16,r16,-16
 1021994:	01800044 	movi	r6,1
 1021998:	000b883a 	mov	r5,zero
 102199c:	d811883a 	mov	r8,sp
 10219a0:	3c3ff316 	blt	r7,r16,1021970 <__alt_data_end+0xff021970>
 10219a4:	da402517 	ldw	r9,148(sp)
 10219a8:	e007883a 	mov	r3,fp
 10219ac:	8039883a 	mov	fp,r16
 10219b0:	1821883a 	mov	r16,r3
 10219b4:	d8c02417 	ldw	r3,144(sp)
 10219b8:	1705883a 	add	r2,r2,fp
 10219bc:	47000115 	stw	fp,4(r8)
 10219c0:	40c00015 	stw	r3,0(r8)
 10219c4:	d8801c15 	stw	r2,112(sp)
 10219c8:	d9801b15 	stw	r6,108(sp)
 10219cc:	00c001c4 	movi	r3,7
 10219d0:	19827616 	blt	r3,r6,10223ac <___vfiprintf_internal_r+0xfbc>
 10219d4:	4cf9c83a 	sub	fp,r9,r19
 10219d8:	42000204 	addi	r8,r8,8
 10219dc:	31000044 	addi	r4,r6,1
 10219e0:	300b883a 	mov	r5,r6
 10219e4:	07018516 	blt	zero,fp,1021ffc <___vfiprintf_internal_r+0xc0c>
 10219e8:	9885883a 	add	r2,r19,r2
 10219ec:	45400015 	stw	r21,0(r8)
 10219f0:	44c00115 	stw	r19,4(r8)
 10219f4:	d8801c15 	stw	r2,112(sp)
 10219f8:	d9001b15 	stw	r4,108(sp)
 10219fc:	00c001c4 	movi	r3,7
 1021a00:	1901dd0e 	bge	r3,r4,1022178 <___vfiprintf_internal_r+0xd88>
 1021a04:	1002401e 	bne	r2,zero,1022308 <___vfiprintf_internal_r+0xf18>
 1021a08:	d8001b15 	stw	zero,108(sp)
 1021a0c:	a2c0010c 	andi	r11,r20,4
 1021a10:	58000226 	beq	r11,zero,1021a1c <___vfiprintf_internal_r+0x62c>
 1021a14:	8ca7c83a 	sub	r19,r17,r18
 1021a18:	04c2f216 	blt	zero,r19,10225e4 <___vfiprintf_internal_r+0x11f4>
 1021a1c:	8c80010e 	bge	r17,r18,1021a24 <___vfiprintf_internal_r+0x634>
 1021a20:	9023883a 	mov	r17,r18
 1021a24:	da802317 	ldw	r10,140(sp)
 1021a28:	5455883a 	add	r10,r10,r17
 1021a2c:	da802315 	stw	r10,140(sp)
 1021a30:	d8001b15 	stw	zero,108(sp)
 1021a34:	d811883a 	mov	r8,sp
 1021a38:	003ea206 	br	10214c4 <__alt_data_end+0xff0214c4>
 1021a3c:	a5000814 	ori	r20,r20,32
 1021a40:	80c00007 	ldb	r3,0(r16)
 1021a44:	003ec906 	br	102156c <__alt_data_end+0xff02156c>
 1021a48:	80c00007 	ldb	r3,0(r16)
 1021a4c:	1b030926 	beq	r3,r12,1022674 <___vfiprintf_internal_r+0x1284>
 1021a50:	a5000414 	ori	r20,r20,16
 1021a54:	003ec506 	br	102156c <__alt_data_end+0xff02156c>
 1021a58:	21003fcc 	andi	r4,r4,255
 1021a5c:	20035e1e 	bne	r4,zero,10227d8 <___vfiprintf_internal_r+0x13e8>
 1021a60:	a080080c 	andi	r2,r20,32
 1021a64:	1002a526 	beq	r2,zero,10224fc <___vfiprintf_internal_r+0x110c>
 1021a68:	da802217 	ldw	r10,136(sp)
 1021a6c:	50800017 	ldw	r2,0(r10)
 1021a70:	da802317 	ldw	r10,140(sp)
 1021a74:	5007d7fa 	srai	r3,r10,31
 1021a78:	da802217 	ldw	r10,136(sp)
 1021a7c:	10c00115 	stw	r3,4(r2)
 1021a80:	52800104 	addi	r10,r10,4
 1021a84:	da802215 	stw	r10,136(sp)
 1021a88:	da802317 	ldw	r10,140(sp)
 1021a8c:	12800015 	stw	r10,0(r2)
 1021a90:	003e8c06 	br	10214c4 <__alt_data_end+0xff0214c4>
 1021a94:	21003fcc 	andi	r4,r4,255
 1021a98:	2003511e 	bne	r4,zero,10227e0 <___vfiprintf_internal_r+0x13f0>
 1021a9c:	a080080c 	andi	r2,r20,32
 1021aa0:	1000a126 	beq	r2,zero,1021d28 <___vfiprintf_internal_r+0x938>
 1021aa4:	da802217 	ldw	r10,136(sp)
 1021aa8:	d8001d85 	stb	zero,118(sp)
 1021aac:	50800204 	addi	r2,r10,8
 1021ab0:	54800017 	ldw	r18,0(r10)
 1021ab4:	54c00117 	ldw	r19,4(r10)
 1021ab8:	4802b416 	blt	r9,zero,102258c <___vfiprintf_internal_r+0x119c>
 1021abc:	013fdfc4 	movi	r4,-129
 1021ac0:	94c6b03a 	or	r3,r18,r19
 1021ac4:	d8802215 	stw	r2,136(sp)
 1021ac8:	a128703a 	and	r20,r20,r4
 1021acc:	1800a226 	beq	r3,zero,1021d58 <___vfiprintf_internal_r+0x968>
 1021ad0:	0039883a 	mov	fp,zero
 1021ad4:	dd401a04 	addi	r21,sp,104
 1021ad8:	9006d0fa 	srli	r3,r18,3
 1021adc:	9808977a 	slli	r4,r19,29
 1021ae0:	9826d0fa 	srli	r19,r19,3
 1021ae4:	948001cc 	andi	r18,r18,7
 1021ae8:	90800c04 	addi	r2,r18,48
 1021aec:	ad7fffc4 	addi	r21,r21,-1
 1021af0:	20e4b03a 	or	r18,r4,r3
 1021af4:	a8800005 	stb	r2,0(r21)
 1021af8:	94c6b03a 	or	r3,r18,r19
 1021afc:	183ff61e 	bne	r3,zero,1021ad8 <__alt_data_end+0xff021ad8>
 1021b00:	a0c0004c 	andi	r3,r20,1
 1021b04:	18005926 	beq	r3,zero,1021c6c <___vfiprintf_internal_r+0x87c>
 1021b08:	10803fcc 	andi	r2,r2,255
 1021b0c:	1080201c 	xori	r2,r2,128
 1021b10:	10bfe004 	addi	r2,r2,-128
 1021b14:	00c00c04 	movi	r3,48
 1021b18:	10c05426 	beq	r2,r3,1021c6c <___vfiprintf_internal_r+0x87c>
 1021b1c:	da801e17 	ldw	r10,120(sp)
 1021b20:	a8bfffc4 	addi	r2,r21,-1
 1021b24:	a8ffffc5 	stb	r3,-1(r21)
 1021b28:	50a7c83a 	sub	r19,r10,r2
 1021b2c:	102b883a 	mov	r21,r2
 1021b30:	003f2f06 	br	10217f0 <__alt_data_end+0xff0217f0>
 1021b34:	21003fcc 	andi	r4,r4,255
 1021b38:	2003421e 	bne	r4,zero,1022844 <___vfiprintf_internal_r+0x1454>
 1021b3c:	008040f4 	movhi	r2,259
 1021b40:	10aa8504 	addi	r2,r2,-21996
 1021b44:	d8802615 	stw	r2,152(sp)
 1021b48:	a080080c 	andi	r2,r20,32
 1021b4c:	1000aa26 	beq	r2,zero,1021df8 <___vfiprintf_internal_r+0xa08>
 1021b50:	da802217 	ldw	r10,136(sp)
 1021b54:	54800017 	ldw	r18,0(r10)
 1021b58:	54c00117 	ldw	r19,4(r10)
 1021b5c:	52800204 	addi	r10,r10,8
 1021b60:	da802215 	stw	r10,136(sp)
 1021b64:	a080004c 	andi	r2,r20,1
 1021b68:	1001d226 	beq	r2,zero,10222b4 <___vfiprintf_internal_r+0xec4>
 1021b6c:	94c4b03a 	or	r2,r18,r19
 1021b70:	1002351e 	bne	r2,zero,1022448 <___vfiprintf_internal_r+0x1058>
 1021b74:	d8001d85 	stb	zero,118(sp)
 1021b78:	48022216 	blt	r9,zero,1022404 <___vfiprintf_internal_r+0x1014>
 1021b7c:	00bfdfc4 	movi	r2,-129
 1021b80:	a0a8703a 	and	r20,r20,r2
 1021b84:	003f1506 	br	10217dc <__alt_data_end+0xff0217dc>
 1021b88:	da802217 	ldw	r10,136(sp)
 1021b8c:	04800044 	movi	r18,1
 1021b90:	d8001d85 	stb	zero,118(sp)
 1021b94:	50800017 	ldw	r2,0(r10)
 1021b98:	52800104 	addi	r10,r10,4
 1021b9c:	da802215 	stw	r10,136(sp)
 1021ba0:	d8801005 	stb	r2,64(sp)
 1021ba4:	9027883a 	mov	r19,r18
 1021ba8:	dd401004 	addi	r21,sp,64
 1021bac:	0013883a 	mov	r9,zero
 1021bb0:	003f1706 	br	1021810 <__alt_data_end+0xff021810>
 1021bb4:	21003fcc 	andi	r4,r4,255
 1021bb8:	2003201e 	bne	r4,zero,102283c <___vfiprintf_internal_r+0x144c>
 1021bbc:	a080080c 	andi	r2,r20,32
 1021bc0:	10004b26 	beq	r2,zero,1021cf0 <___vfiprintf_internal_r+0x900>
 1021bc4:	da802217 	ldw	r10,136(sp)
 1021bc8:	50800117 	ldw	r2,4(r10)
 1021bcc:	54800017 	ldw	r18,0(r10)
 1021bd0:	52800204 	addi	r10,r10,8
 1021bd4:	da802215 	stw	r10,136(sp)
 1021bd8:	1027883a 	mov	r19,r2
 1021bdc:	10022c16 	blt	r2,zero,1022490 <___vfiprintf_internal_r+0x10a0>
 1021be0:	df001d83 	ldbu	fp,118(sp)
 1021be4:	48007216 	blt	r9,zero,1021db0 <___vfiprintf_internal_r+0x9c0>
 1021be8:	00ffdfc4 	movi	r3,-129
 1021bec:	94c4b03a 	or	r2,r18,r19
 1021bf0:	a0e8703a 	and	r20,r20,r3
 1021bf4:	1000cc26 	beq	r2,zero,1021f28 <___vfiprintf_internal_r+0xb38>
 1021bf8:	98021026 	beq	r19,zero,102243c <___vfiprintf_internal_r+0x104c>
 1021bfc:	dc402415 	stw	r17,144(sp)
 1021c00:	dc002515 	stw	r16,148(sp)
 1021c04:	9823883a 	mov	r17,r19
 1021c08:	9021883a 	mov	r16,r18
 1021c0c:	dd401a04 	addi	r21,sp,104
 1021c10:	4825883a 	mov	r18,r9
 1021c14:	4027883a 	mov	r19,r8
 1021c18:	8009883a 	mov	r4,r16
 1021c1c:	880b883a 	mov	r5,r17
 1021c20:	01800284 	movi	r6,10
 1021c24:	000f883a 	mov	r7,zero
 1021c28:	10237d00 	call	10237d0 <__umoddi3>
 1021c2c:	10800c04 	addi	r2,r2,48
 1021c30:	ad7fffc4 	addi	r21,r21,-1
 1021c34:	8009883a 	mov	r4,r16
 1021c38:	880b883a 	mov	r5,r17
 1021c3c:	a8800005 	stb	r2,0(r21)
 1021c40:	01800284 	movi	r6,10
 1021c44:	000f883a 	mov	r7,zero
 1021c48:	10232580 	call	1023258 <__udivdi3>
 1021c4c:	1021883a 	mov	r16,r2
 1021c50:	10c4b03a 	or	r2,r2,r3
 1021c54:	1823883a 	mov	r17,r3
 1021c58:	103fef1e 	bne	r2,zero,1021c18 <__alt_data_end+0xff021c18>
 1021c5c:	dc402417 	ldw	r17,144(sp)
 1021c60:	dc002517 	ldw	r16,148(sp)
 1021c64:	9013883a 	mov	r9,r18
 1021c68:	9811883a 	mov	r8,r19
 1021c6c:	da801e17 	ldw	r10,120(sp)
 1021c70:	5567c83a 	sub	r19,r10,r21
 1021c74:	003ede06 	br	10217f0 <__alt_data_end+0xff0217f0>
 1021c78:	38803fcc 	andi	r2,r7,255
 1021c7c:	1080201c 	xori	r2,r2,128
 1021c80:	10bfe004 	addi	r2,r2,-128
 1021c84:	1002371e 	bne	r2,zero,1022564 <___vfiprintf_internal_r+0x1174>
 1021c88:	01000044 	movi	r4,1
 1021c8c:	01c00804 	movi	r7,32
 1021c90:	80c00007 	ldb	r3,0(r16)
 1021c94:	003e3506 	br	102156c <__alt_data_end+0xff02156c>
 1021c98:	a5000054 	ori	r20,r20,1
 1021c9c:	80c00007 	ldb	r3,0(r16)
 1021ca0:	003e3206 	br	102156c <__alt_data_end+0xff02156c>
 1021ca4:	a5002014 	ori	r20,r20,128
 1021ca8:	80c00007 	ldb	r3,0(r16)
 1021cac:	003e2f06 	br	102156c <__alt_data_end+0xff02156c>
 1021cb0:	8015883a 	mov	r10,r16
 1021cb4:	0023883a 	mov	r17,zero
 1021cb8:	18bff404 	addi	r2,r3,-48
 1021cbc:	50c00007 	ldb	r3,0(r10)
 1021cc0:	8c4002a4 	muli	r17,r17,10
 1021cc4:	84000044 	addi	r16,r16,1
 1021cc8:	8015883a 	mov	r10,r16
 1021ccc:	1463883a 	add	r17,r2,r17
 1021cd0:	18bff404 	addi	r2,r3,-48
 1021cd4:	30bff92e 	bgeu	r6,r2,1021cbc <__alt_data_end+0xff021cbc>
 1021cd8:	003e2506 	br	1021570 <__alt_data_end+0xff021570>
 1021cdc:	21003fcc 	andi	r4,r4,255
 1021ce0:	2002d41e 	bne	r4,zero,1022834 <___vfiprintf_internal_r+0x1444>
 1021ce4:	a5000414 	ori	r20,r20,16
 1021ce8:	a080080c 	andi	r2,r20,32
 1021cec:	103fb51e 	bne	r2,zero,1021bc4 <__alt_data_end+0xff021bc4>
 1021cf0:	a080040c 	andi	r2,r20,16
 1021cf4:	1001f826 	beq	r2,zero,10224d8 <___vfiprintf_internal_r+0x10e8>
 1021cf8:	da802217 	ldw	r10,136(sp)
 1021cfc:	54800017 	ldw	r18,0(r10)
 1021d00:	52800104 	addi	r10,r10,4
 1021d04:	da802215 	stw	r10,136(sp)
 1021d08:	9027d7fa 	srai	r19,r18,31
 1021d0c:	9805883a 	mov	r2,r19
 1021d10:	003fb206 	br	1021bdc <__alt_data_end+0xff021bdc>
 1021d14:	21003fcc 	andi	r4,r4,255
 1021d18:	2002c41e 	bne	r4,zero,102282c <___vfiprintf_internal_r+0x143c>
 1021d1c:	a5000414 	ori	r20,r20,16
 1021d20:	a080080c 	andi	r2,r20,32
 1021d24:	103f5f1e 	bne	r2,zero,1021aa4 <__alt_data_end+0xff021aa4>
 1021d28:	a080040c 	andi	r2,r20,16
 1021d2c:	10020f26 	beq	r2,zero,102256c <___vfiprintf_internal_r+0x117c>
 1021d30:	da802217 	ldw	r10,136(sp)
 1021d34:	d8001d85 	stb	zero,118(sp)
 1021d38:	0027883a 	mov	r19,zero
 1021d3c:	50800104 	addi	r2,r10,4
 1021d40:	54800017 	ldw	r18,0(r10)
 1021d44:	48021116 	blt	r9,zero,102258c <___vfiprintf_internal_r+0x119c>
 1021d48:	00ffdfc4 	movi	r3,-129
 1021d4c:	d8802215 	stw	r2,136(sp)
 1021d50:	a0e8703a 	and	r20,r20,r3
 1021d54:	903f5e1e 	bne	r18,zero,1021ad0 <__alt_data_end+0xff021ad0>
 1021d58:	0039883a 	mov	fp,zero
 1021d5c:	4802a626 	beq	r9,zero,10227f8 <___vfiprintf_internal_r+0x1408>
 1021d60:	0025883a 	mov	r18,zero
 1021d64:	0027883a 	mov	r19,zero
 1021d68:	003f5a06 	br	1021ad4 <__alt_data_end+0xff021ad4>
 1021d6c:	21003fcc 	andi	r4,r4,255
 1021d70:	20029f1e 	bne	r4,zero,10227f0 <___vfiprintf_internal_r+0x1400>
 1021d74:	a5000414 	ori	r20,r20,16
 1021d78:	a080080c 	andi	r2,r20,32
 1021d7c:	10005e1e 	bne	r2,zero,1021ef8 <___vfiprintf_internal_r+0xb08>
 1021d80:	a080040c 	andi	r2,r20,16
 1021d84:	1001a21e 	bne	r2,zero,1022410 <___vfiprintf_internal_r+0x1020>
 1021d88:	a080100c 	andi	r2,r20,64
 1021d8c:	d8001d85 	stb	zero,118(sp)
 1021d90:	da802217 	ldw	r10,136(sp)
 1021d94:	1002231e 	bne	r2,zero,1022624 <___vfiprintf_internal_r+0x1234>
 1021d98:	50800104 	addi	r2,r10,4
 1021d9c:	54800017 	ldw	r18,0(r10)
 1021da0:	0027883a 	mov	r19,zero
 1021da4:	4801a00e 	bge	r9,zero,1022428 <___vfiprintf_internal_r+0x1038>
 1021da8:	d8802215 	stw	r2,136(sp)
 1021dac:	0039883a 	mov	fp,zero
 1021db0:	94c4b03a 	or	r2,r18,r19
 1021db4:	103f901e 	bne	r2,zero,1021bf8 <__alt_data_end+0xff021bf8>
 1021db8:	00800044 	movi	r2,1
 1021dbc:	10803fcc 	andi	r2,r2,255
 1021dc0:	00c00044 	movi	r3,1
 1021dc4:	10c05926 	beq	r2,r3,1021f2c <___vfiprintf_internal_r+0xb3c>
 1021dc8:	00c00084 	movi	r3,2
 1021dcc:	10ffe41e 	bne	r2,r3,1021d60 <__alt_data_end+0xff021d60>
 1021dd0:	0025883a 	mov	r18,zero
 1021dd4:	0027883a 	mov	r19,zero
 1021dd8:	00013d06 	br	10222d0 <___vfiprintf_internal_r+0xee0>
 1021ddc:	21003fcc 	andi	r4,r4,255
 1021de0:	2002811e 	bne	r4,zero,10227e8 <___vfiprintf_internal_r+0x13f8>
 1021de4:	008040f4 	movhi	r2,259
 1021de8:	10aa8004 	addi	r2,r2,-22016
 1021dec:	d8802615 	stw	r2,152(sp)
 1021df0:	a080080c 	andi	r2,r20,32
 1021df4:	103f561e 	bne	r2,zero,1021b50 <__alt_data_end+0xff021b50>
 1021df8:	a080040c 	andi	r2,r20,16
 1021dfc:	1001d126 	beq	r2,zero,1022544 <___vfiprintf_internal_r+0x1154>
 1021e00:	da802217 	ldw	r10,136(sp)
 1021e04:	0027883a 	mov	r19,zero
 1021e08:	54800017 	ldw	r18,0(r10)
 1021e0c:	52800104 	addi	r10,r10,4
 1021e10:	da802215 	stw	r10,136(sp)
 1021e14:	003f5306 	br	1021b64 <__alt_data_end+0xff021b64>
 1021e18:	da802217 	ldw	r10,136(sp)
 1021e1c:	d8001d85 	stb	zero,118(sp)
 1021e20:	55400017 	ldw	r21,0(r10)
 1021e24:	50c00104 	addi	r3,r10,4
 1021e28:	a8024226 	beq	r21,zero,1022734 <___vfiprintf_internal_r+0x1344>
 1021e2c:	48021816 	blt	r9,zero,1022690 <___vfiprintf_internal_r+0x12a0>
 1021e30:	480d883a 	mov	r6,r9
 1021e34:	000b883a 	mov	r5,zero
 1021e38:	a809883a 	mov	r4,r21
 1021e3c:	d8c02a15 	stw	r3,168(sp)
 1021e40:	da002b15 	stw	r8,172(sp)
 1021e44:	da402c15 	stw	r9,176(sp)
 1021e48:	101e2280 	call	101e228 <memchr>
 1021e4c:	d8c02a17 	ldw	r3,168(sp)
 1021e50:	da002b17 	ldw	r8,172(sp)
 1021e54:	da402c17 	ldw	r9,176(sp)
 1021e58:	10024826 	beq	r2,zero,102277c <___vfiprintf_internal_r+0x138c>
 1021e5c:	1567c83a 	sub	r19,r2,r21
 1021e60:	df001d83 	ldbu	fp,118(sp)
 1021e64:	d8c02215 	stw	r3,136(sp)
 1021e68:	0013883a 	mov	r9,zero
 1021e6c:	003e6006 	br	10217f0 <__alt_data_end+0xff0217f0>
 1021e70:	21003fcc 	andi	r4,r4,255
 1021e74:	203fc026 	beq	r4,zero,1021d78 <__alt_data_end+0xff021d78>
 1021e78:	d9c01d85 	stb	r7,118(sp)
 1021e7c:	003fbe06 	br	1021d78 <__alt_data_end+0xff021d78>
 1021e80:	da802217 	ldw	r10,136(sp)
 1021e84:	54400017 	ldw	r17,0(r10)
 1021e88:	50800104 	addi	r2,r10,4
 1021e8c:	883e3b16 	blt	r17,zero,102177c <__alt_data_end+0xff02177c>
 1021e90:	d8802215 	stw	r2,136(sp)
 1021e94:	80c00007 	ldb	r3,0(r16)
 1021e98:	003db406 	br	102156c <__alt_data_end+0xff02156c>
 1021e9c:	01000044 	movi	r4,1
 1021ea0:	01c00ac4 	movi	r7,43
 1021ea4:	80c00007 	ldb	r3,0(r16)
 1021ea8:	003db006 	br	102156c <__alt_data_end+0xff02156c>
 1021eac:	80c00007 	ldb	r3,0(r16)
 1021eb0:	82800044 	addi	r10,r16,1
 1021eb4:	1b423c26 	beq	r3,r13,10227a8 <___vfiprintf_internal_r+0x13b8>
 1021eb8:	18bff404 	addi	r2,r3,-48
 1021ebc:	0013883a 	mov	r9,zero
 1021ec0:	30822b36 	bltu	r6,r2,1022770 <___vfiprintf_internal_r+0x1380>
 1021ec4:	50c00007 	ldb	r3,0(r10)
 1021ec8:	4a4002a4 	muli	r9,r9,10
 1021ecc:	54000044 	addi	r16,r10,1
 1021ed0:	8015883a 	mov	r10,r16
 1021ed4:	4893883a 	add	r9,r9,r2
 1021ed8:	18bff404 	addi	r2,r3,-48
 1021edc:	30bff92e 	bgeu	r6,r2,1021ec4 <__alt_data_end+0xff021ec4>
 1021ee0:	483da30e 	bge	r9,zero,1021570 <__alt_data_end+0xff021570>
 1021ee4:	027fffc4 	movi	r9,-1
 1021ee8:	003da106 	br	1021570 <__alt_data_end+0xff021570>
 1021eec:	a5001014 	ori	r20,r20,64
 1021ef0:	80c00007 	ldb	r3,0(r16)
 1021ef4:	003d9d06 	br	102156c <__alt_data_end+0xff02156c>
 1021ef8:	da802217 	ldw	r10,136(sp)
 1021efc:	d8001d85 	stb	zero,118(sp)
 1021f00:	50c00204 	addi	r3,r10,8
 1021f04:	54800017 	ldw	r18,0(r10)
 1021f08:	54c00117 	ldw	r19,4(r10)
 1021f0c:	4801ca16 	blt	r9,zero,1022638 <___vfiprintf_internal_r+0x1248>
 1021f10:	013fdfc4 	movi	r4,-129
 1021f14:	94c4b03a 	or	r2,r18,r19
 1021f18:	d8c02215 	stw	r3,136(sp)
 1021f1c:	a128703a 	and	r20,r20,r4
 1021f20:	0039883a 	mov	fp,zero
 1021f24:	103f341e 	bne	r2,zero,1021bf8 <__alt_data_end+0xff021bf8>
 1021f28:	483e2e26 	beq	r9,zero,10217e4 <__alt_data_end+0xff0217e4>
 1021f2c:	0025883a 	mov	r18,zero
 1021f30:	94800c04 	addi	r18,r18,48
 1021f34:	dc8019c5 	stb	r18,103(sp)
 1021f38:	dcc02717 	ldw	r19,156(sp)
 1021f3c:	dd4019c4 	addi	r21,sp,103
 1021f40:	003e2b06 	br	10217f0 <__alt_data_end+0xff0217f0>
 1021f44:	21003fcc 	andi	r4,r4,255
 1021f48:	2002361e 	bne	r4,zero,1022824 <___vfiprintf_internal_r+0x1434>
 1021f4c:	1801c126 	beq	r3,zero,1022654 <___vfiprintf_internal_r+0x1264>
 1021f50:	04800044 	movi	r18,1
 1021f54:	d8c01005 	stb	r3,64(sp)
 1021f58:	d8001d85 	stb	zero,118(sp)
 1021f5c:	9027883a 	mov	r19,r18
 1021f60:	dd401004 	addi	r21,sp,64
 1021f64:	003f1106 	br	1021bac <__alt_data_end+0xff021bac>
 1021f68:	d9402117 	ldw	r5,132(sp)
 1021f6c:	d9002017 	ldw	r4,128(sp)
 1021f70:	d9801a04 	addi	r6,sp,104
 1021f74:	d9c02b15 	stw	r7,172(sp)
 1021f78:	dbc02a15 	stw	r15,168(sp)
 1021f7c:	10212dc0 	call	10212dc <__sprint_r.part.0>
 1021f80:	d9c02b17 	ldw	r7,172(sp)
 1021f84:	dbc02a17 	ldw	r15,168(sp)
 1021f88:	10006d1e 	bne	r2,zero,1022140 <___vfiprintf_internal_r+0xd50>
 1021f8c:	d9801b17 	ldw	r6,108(sp)
 1021f90:	d8801c17 	ldw	r2,112(sp)
 1021f94:	d811883a 	mov	r8,sp
 1021f98:	31400044 	addi	r5,r6,1
 1021f9c:	003e3306 	br	102186c <__alt_data_end+0xff02186c>
 1021fa0:	d9401b17 	ldw	r5,108(sp)
 1021fa4:	d8801c17 	ldw	r2,112(sp)
 1021fa8:	29000044 	addi	r4,r5,1
 1021fac:	d8c01d87 	ldb	r3,118(sp)
 1021fb0:	183e4d26 	beq	r3,zero,10218e8 <__alt_data_end+0xff0218e8>
 1021fb4:	00c00044 	movi	r3,1
 1021fb8:	d9401d84 	addi	r5,sp,118
 1021fbc:	10c5883a 	add	r2,r2,r3
 1021fc0:	41400015 	stw	r5,0(r8)
 1021fc4:	40c00115 	stw	r3,4(r8)
 1021fc8:	d8801c15 	stw	r2,112(sp)
 1021fcc:	d9001b15 	stw	r4,108(sp)
 1021fd0:	014001c4 	movi	r5,7
 1021fd4:	2900a90e 	bge	r5,r4,102227c <___vfiprintf_internal_r+0xe8c>
 1021fd8:	1000da1e 	bne	r2,zero,1022344 <___vfiprintf_internal_r+0xf54>
 1021fdc:	7000ab1e 	bne	r14,zero,102228c <___vfiprintf_internal_r+0xe9c>
 1021fe0:	000b883a 	mov	r5,zero
 1021fe4:	1809883a 	mov	r4,r3
 1021fe8:	d811883a 	mov	r8,sp
 1021fec:	00c02004 	movi	r3,128
 1021ff0:	e0fe4d26 	beq	fp,r3,1021928 <__alt_data_end+0xff021928>
 1021ff4:	4cf9c83a 	sub	fp,r9,r19
 1021ff8:	073e7b0e 	bge	zero,fp,10219e8 <__alt_data_end+0xff0219e8>
 1021ffc:	01c00404 	movi	r7,16
 1022000:	3f01900e 	bge	r7,fp,1022644 <___vfiprintf_internal_r+0x1254>
 1022004:	00c040f4 	movhi	r3,259
 1022008:	18eaf504 	addi	r3,r3,-21548
 102200c:	d8c02415 	stw	r3,144(sp)
 1022010:	034001c4 	movi	r13,7
 1022014:	00000506 	br	102202c <___vfiprintf_internal_r+0xc3c>
 1022018:	29000084 	addi	r4,r5,2
 102201c:	42000204 	addi	r8,r8,8
 1022020:	180b883a 	mov	r5,r3
 1022024:	e73ffc04 	addi	fp,fp,-16
 1022028:	3f000d0e 	bge	r7,fp,1022060 <___vfiprintf_internal_r+0xc70>
 102202c:	10800404 	addi	r2,r2,16
 1022030:	28c00044 	addi	r3,r5,1
 1022034:	45c00015 	stw	r23,0(r8)
 1022038:	41c00115 	stw	r7,4(r8)
 102203c:	d8801c15 	stw	r2,112(sp)
 1022040:	d8c01b15 	stw	r3,108(sp)
 1022044:	68fff40e 	bge	r13,r3,1022018 <__alt_data_end+0xff022018>
 1022048:	1000101e 	bne	r2,zero,102208c <___vfiprintf_internal_r+0xc9c>
 102204c:	e73ffc04 	addi	fp,fp,-16
 1022050:	01000044 	movi	r4,1
 1022054:	000b883a 	mov	r5,zero
 1022058:	d811883a 	mov	r8,sp
 102205c:	3f3ff316 	blt	r7,fp,102202c <__alt_data_end+0xff02202c>
 1022060:	da802417 	ldw	r10,144(sp)
 1022064:	1705883a 	add	r2,r2,fp
 1022068:	47000115 	stw	fp,4(r8)
 102206c:	42800015 	stw	r10,0(r8)
 1022070:	d8801c15 	stw	r2,112(sp)
 1022074:	d9001b15 	stw	r4,108(sp)
 1022078:	00c001c4 	movi	r3,7
 102207c:	19003616 	blt	r3,r4,1022158 <___vfiprintf_internal_r+0xd68>
 1022080:	42000204 	addi	r8,r8,8
 1022084:	21000044 	addi	r4,r4,1
 1022088:	003e5706 	br	10219e8 <__alt_data_end+0xff0219e8>
 102208c:	d9402117 	ldw	r5,132(sp)
 1022090:	d9002017 	ldw	r4,128(sp)
 1022094:	d9801a04 	addi	r6,sp,104
 1022098:	d9c02b15 	stw	r7,172(sp)
 102209c:	db402a15 	stw	r13,168(sp)
 10220a0:	10212dc0 	call	10212dc <__sprint_r.part.0>
 10220a4:	d9c02b17 	ldw	r7,172(sp)
 10220a8:	db402a17 	ldw	r13,168(sp)
 10220ac:	1000241e 	bne	r2,zero,1022140 <___vfiprintf_internal_r+0xd50>
 10220b0:	d9401b17 	ldw	r5,108(sp)
 10220b4:	d8801c17 	ldw	r2,112(sp)
 10220b8:	d811883a 	mov	r8,sp
 10220bc:	29000044 	addi	r4,r5,1
 10220c0:	003fd806 	br	1022024 <__alt_data_end+0xff022024>
 10220c4:	d9401b17 	ldw	r5,108(sp)
 10220c8:	00c040f4 	movhi	r3,259
 10220cc:	18eaf904 	addi	r3,r3,-21532
 10220d0:	d8c02415 	stw	r3,144(sp)
 10220d4:	29400044 	addi	r5,r5,1
 10220d8:	d8c02417 	ldw	r3,144(sp)
 10220dc:	14c5883a 	add	r2,r2,r19
 10220e0:	44c00115 	stw	r19,4(r8)
 10220e4:	40c00015 	stw	r3,0(r8)
 10220e8:	d8801c15 	stw	r2,112(sp)
 10220ec:	d9401b15 	stw	r5,108(sp)
 10220f0:	00c001c4 	movi	r3,7
 10220f4:	1940070e 	bge	r3,r5,1022114 <___vfiprintf_internal_r+0xd24>
 10220f8:	103e4826 	beq	r2,zero,1021a1c <__alt_data_end+0xff021a1c>
 10220fc:	d9402117 	ldw	r5,132(sp)
 1022100:	d9002017 	ldw	r4,128(sp)
 1022104:	d9801a04 	addi	r6,sp,104
 1022108:	10212dc0 	call	10212dc <__sprint_r.part.0>
 102210c:	10000c1e 	bne	r2,zero,1022140 <___vfiprintf_internal_r+0xd50>
 1022110:	d8801c17 	ldw	r2,112(sp)
 1022114:	8c80010e 	bge	r17,r18,102211c <___vfiprintf_internal_r+0xd2c>
 1022118:	9023883a 	mov	r17,r18
 102211c:	da802317 	ldw	r10,140(sp)
 1022120:	5455883a 	add	r10,r10,r17
 1022124:	da802315 	stw	r10,140(sp)
 1022128:	103e4126 	beq	r2,zero,1021a30 <__alt_data_end+0xff021a30>
 102212c:	d9402117 	ldw	r5,132(sp)
 1022130:	d9002017 	ldw	r4,128(sp)
 1022134:	d9801a04 	addi	r6,sp,104
 1022138:	10212dc0 	call	10212dc <__sprint_r.part.0>
 102213c:	103e3c26 	beq	r2,zero,1021a30 <__alt_data_end+0xff021a30>
 1022140:	dd002117 	ldw	r20,132(sp)
 1022144:	a080030b 	ldhu	r2,12(r20)
 1022148:	1080100c 	andi	r2,r2,64
 102214c:	1001231e 	bne	r2,zero,10225dc <___vfiprintf_internal_r+0x11ec>
 1022150:	d8802317 	ldw	r2,140(sp)
 1022154:	003d7b06 	br	1021744 <__alt_data_end+0xff021744>
 1022158:	1000991e 	bne	r2,zero,10223c0 <___vfiprintf_internal_r+0xfd0>
 102215c:	00c00044 	movi	r3,1
 1022160:	9805883a 	mov	r2,r19
 1022164:	dd400015 	stw	r21,0(sp)
 1022168:	dcc00115 	stw	r19,4(sp)
 102216c:	dcc01c15 	stw	r19,112(sp)
 1022170:	d8c01b15 	stw	r3,108(sp)
 1022174:	d811883a 	mov	r8,sp
 1022178:	42000204 	addi	r8,r8,8
 102217c:	a2c0010c 	andi	r11,r20,4
 1022180:	583fe426 	beq	r11,zero,1022114 <__alt_data_end+0xff022114>
 1022184:	8ca7c83a 	sub	r19,r17,r18
 1022188:	04ffe20e 	bge	zero,r19,1022114 <__alt_data_end+0xff022114>
 102218c:	01c00404 	movi	r7,16
 1022190:	3cffcc0e 	bge	r7,r19,10220c4 <__alt_data_end+0xff0220c4>
 1022194:	028040f4 	movhi	r10,259
 1022198:	52aaf904 	addi	r10,r10,-21532
 102219c:	d9001b17 	ldw	r4,108(sp)
 10221a0:	da802415 	stw	r10,144(sp)
 10221a4:	382b883a 	mov	r21,r7
 10221a8:	050001c4 	movi	r20,7
 10221ac:	df002017 	ldw	fp,128(sp)
 10221b0:	00000506 	br	10221c8 <___vfiprintf_internal_r+0xdd8>
 10221b4:	21400084 	addi	r5,r4,2
 10221b8:	42000204 	addi	r8,r8,8
 10221bc:	1809883a 	mov	r4,r3
 10221c0:	9cfffc04 	addi	r19,r19,-16
 10221c4:	acffc40e 	bge	r21,r19,10220d8 <__alt_data_end+0xff0220d8>
 10221c8:	10800404 	addi	r2,r2,16
 10221cc:	20c00044 	addi	r3,r4,1
 10221d0:	45800015 	stw	r22,0(r8)
 10221d4:	45400115 	stw	r21,4(r8)
 10221d8:	d8801c15 	stw	r2,112(sp)
 10221dc:	d8c01b15 	stw	r3,108(sp)
 10221e0:	a0fff40e 	bge	r20,r3,10221b4 <__alt_data_end+0xff0221b4>
 10221e4:	1000041e 	bne	r2,zero,10221f8 <___vfiprintf_internal_r+0xe08>
 10221e8:	01400044 	movi	r5,1
 10221ec:	0009883a 	mov	r4,zero
 10221f0:	d811883a 	mov	r8,sp
 10221f4:	003ff206 	br	10221c0 <__alt_data_end+0xff0221c0>
 10221f8:	d9402117 	ldw	r5,132(sp)
 10221fc:	d9801a04 	addi	r6,sp,104
 1022200:	e009883a 	mov	r4,fp
 1022204:	10212dc0 	call	10212dc <__sprint_r.part.0>
 1022208:	103fcd1e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 102220c:	d9001b17 	ldw	r4,108(sp)
 1022210:	d8801c17 	ldw	r2,112(sp)
 1022214:	d811883a 	mov	r8,sp
 1022218:	21400044 	addi	r5,r4,1
 102221c:	003fe806 	br	10221c0 <__alt_data_end+0xff0221c0>
 1022220:	d9402117 	ldw	r5,132(sp)
 1022224:	d9002017 	ldw	r4,128(sp)
 1022228:	d9801a04 	addi	r6,sp,104
 102222c:	d9c02b15 	stw	r7,172(sp)
 1022230:	db402a15 	stw	r13,168(sp)
 1022234:	10212dc0 	call	10212dc <__sprint_r.part.0>
 1022238:	d9c02b17 	ldw	r7,172(sp)
 102223c:	db402a17 	ldw	r13,168(sp)
 1022240:	103fbf1e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 1022244:	d9401b17 	ldw	r5,108(sp)
 1022248:	d8801c17 	ldw	r2,112(sp)
 102224c:	d811883a 	mov	r8,sp
 1022250:	29800044 	addi	r6,r5,1
 1022254:	003dc406 	br	1021968 <__alt_data_end+0xff021968>
 1022258:	1000d21e 	bne	r2,zero,10225a4 <___vfiprintf_internal_r+0x11b4>
 102225c:	d8c01d87 	ldb	r3,118(sp)
 1022260:	18009526 	beq	r3,zero,10224b8 <___vfiprintf_internal_r+0x10c8>
 1022264:	00800044 	movi	r2,1
 1022268:	d8c01d84 	addi	r3,sp,118
 102226c:	1009883a 	mov	r4,r2
 1022270:	d8c00015 	stw	r3,0(sp)
 1022274:	d8800115 	stw	r2,4(sp)
 1022278:	d811883a 	mov	r8,sp
 102227c:	200b883a 	mov	r5,r4
 1022280:	42000204 	addi	r8,r8,8
 1022284:	21000044 	addi	r4,r4,1
 1022288:	003d9706 	br	10218e8 <__alt_data_end+0xff0218e8>
 102228c:	d9001d04 	addi	r4,sp,116
 1022290:	00800084 	movi	r2,2
 1022294:	d9000015 	stw	r4,0(sp)
 1022298:	d8800115 	stw	r2,4(sp)
 102229c:	1809883a 	mov	r4,r3
 10222a0:	d811883a 	mov	r8,sp
 10222a4:	200b883a 	mov	r5,r4
 10222a8:	42000204 	addi	r8,r8,8
 10222ac:	21000044 	addi	r4,r4,1
 10222b0:	003f4e06 	br	1021fec <__alt_data_end+0xff021fec>
 10222b4:	d8001d85 	stb	zero,118(sp)
 10222b8:	48005016 	blt	r9,zero,10223fc <___vfiprintf_internal_r+0x100c>
 10222bc:	00ffdfc4 	movi	r3,-129
 10222c0:	94c4b03a 	or	r2,r18,r19
 10222c4:	a0e8703a 	and	r20,r20,r3
 10222c8:	103d4426 	beq	r2,zero,10217dc <__alt_data_end+0xff0217dc>
 10222cc:	0039883a 	mov	fp,zero
 10222d0:	d9002617 	ldw	r4,152(sp)
 10222d4:	dd401a04 	addi	r21,sp,104
 10222d8:	908003cc 	andi	r2,r18,15
 10222dc:	9806973a 	slli	r3,r19,28
 10222e0:	2085883a 	add	r2,r4,r2
 10222e4:	9024d13a 	srli	r18,r18,4
 10222e8:	10800003 	ldbu	r2,0(r2)
 10222ec:	9826d13a 	srli	r19,r19,4
 10222f0:	ad7fffc4 	addi	r21,r21,-1
 10222f4:	1ca4b03a 	or	r18,r3,r18
 10222f8:	a8800005 	stb	r2,0(r21)
 10222fc:	94c4b03a 	or	r2,r18,r19
 1022300:	103ff51e 	bne	r2,zero,10222d8 <__alt_data_end+0xff0222d8>
 1022304:	003e5906 	br	1021c6c <__alt_data_end+0xff021c6c>
 1022308:	d9402117 	ldw	r5,132(sp)
 102230c:	d9002017 	ldw	r4,128(sp)
 1022310:	d9801a04 	addi	r6,sp,104
 1022314:	10212dc0 	call	10212dc <__sprint_r.part.0>
 1022318:	103f891e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 102231c:	d8801c17 	ldw	r2,112(sp)
 1022320:	d811883a 	mov	r8,sp
 1022324:	003f9506 	br	102217c <__alt_data_end+0xff02217c>
 1022328:	d9402117 	ldw	r5,132(sp)
 102232c:	d9002017 	ldw	r4,128(sp)
 1022330:	d9801a04 	addi	r6,sp,104
 1022334:	10212dc0 	call	10212dc <__sprint_r.part.0>
 1022338:	103f811e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 102233c:	d811883a 	mov	r8,sp
 1022340:	003ced06 	br	10216f8 <__alt_data_end+0xff0216f8>
 1022344:	d9402117 	ldw	r5,132(sp)
 1022348:	d9002017 	ldw	r4,128(sp)
 102234c:	d9801a04 	addi	r6,sp,104
 1022350:	da402c15 	stw	r9,176(sp)
 1022354:	db802a15 	stw	r14,168(sp)
 1022358:	10212dc0 	call	10212dc <__sprint_r.part.0>
 102235c:	da402c17 	ldw	r9,176(sp)
 1022360:	db802a17 	ldw	r14,168(sp)
 1022364:	103f761e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 1022368:	d9401b17 	ldw	r5,108(sp)
 102236c:	d8801c17 	ldw	r2,112(sp)
 1022370:	d811883a 	mov	r8,sp
 1022374:	29000044 	addi	r4,r5,1
 1022378:	003d5b06 	br	10218e8 <__alt_data_end+0xff0218e8>
 102237c:	d9402117 	ldw	r5,132(sp)
 1022380:	d9002017 	ldw	r4,128(sp)
 1022384:	d9801a04 	addi	r6,sp,104
 1022388:	da402c15 	stw	r9,176(sp)
 102238c:	10212dc0 	call	10212dc <__sprint_r.part.0>
 1022390:	da402c17 	ldw	r9,176(sp)
 1022394:	103f6a1e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 1022398:	d9401b17 	ldw	r5,108(sp)
 102239c:	d8801c17 	ldw	r2,112(sp)
 10223a0:	d811883a 	mov	r8,sp
 10223a4:	29000044 	addi	r4,r5,1
 10223a8:	003f1006 	br	1021fec <__alt_data_end+0xff021fec>
 10223ac:	1000c31e 	bne	r2,zero,10226bc <___vfiprintf_internal_r+0x12cc>
 10223b0:	01000044 	movi	r4,1
 10223b4:	000b883a 	mov	r5,zero
 10223b8:	d811883a 	mov	r8,sp
 10223bc:	003f0d06 	br	1021ff4 <__alt_data_end+0xff021ff4>
 10223c0:	d9402117 	ldw	r5,132(sp)
 10223c4:	d9002017 	ldw	r4,128(sp)
 10223c8:	d9801a04 	addi	r6,sp,104
 10223cc:	10212dc0 	call	10212dc <__sprint_r.part.0>
 10223d0:	103f5b1e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 10223d4:	d9001b17 	ldw	r4,108(sp)
 10223d8:	d8801c17 	ldw	r2,112(sp)
 10223dc:	d811883a 	mov	r8,sp
 10223e0:	21000044 	addi	r4,r4,1
 10223e4:	003d8006 	br	10219e8 <__alt_data_end+0xff0219e8>
 10223e8:	010040f4 	movhi	r4,259
 10223ec:	212a8504 	addi	r4,r4,-21996
 10223f0:	d9002615 	stw	r4,152(sp)
 10223f4:	d8c02215 	stw	r3,136(sp)
 10223f8:	1029883a 	mov	r20,r2
 10223fc:	94c4b03a 	or	r2,r18,r19
 1022400:	103fb21e 	bne	r2,zero,10222cc <__alt_data_end+0xff0222cc>
 1022404:	0039883a 	mov	fp,zero
 1022408:	00800084 	movi	r2,2
 102240c:	003e6b06 	br	1021dbc <__alt_data_end+0xff021dbc>
 1022410:	da802217 	ldw	r10,136(sp)
 1022414:	d8001d85 	stb	zero,118(sp)
 1022418:	0027883a 	mov	r19,zero
 102241c:	50800104 	addi	r2,r10,4
 1022420:	54800017 	ldw	r18,0(r10)
 1022424:	483e6016 	blt	r9,zero,1021da8 <__alt_data_end+0xff021da8>
 1022428:	00ffdfc4 	movi	r3,-129
 102242c:	d8802215 	stw	r2,136(sp)
 1022430:	a0e8703a 	and	r20,r20,r3
 1022434:	0039883a 	mov	fp,zero
 1022438:	903ebb26 	beq	r18,zero,1021f28 <__alt_data_end+0xff021f28>
 102243c:	00800244 	movi	r2,9
 1022440:	14bdee36 	bltu	r2,r18,1021bfc <__alt_data_end+0xff021bfc>
 1022444:	003eba06 	br	1021f30 <__alt_data_end+0xff021f30>
 1022448:	00800c04 	movi	r2,48
 102244c:	d8c01d45 	stb	r3,117(sp)
 1022450:	d8801d05 	stb	r2,116(sp)
 1022454:	d8001d85 	stb	zero,118(sp)
 1022458:	a0c00094 	ori	r3,r20,2
 102245c:	4800a916 	blt	r9,zero,1022704 <___vfiprintf_internal_r+0x1314>
 1022460:	00bfdfc4 	movi	r2,-129
 1022464:	a096703a 	and	r11,r20,r2
 1022468:	5d000094 	ori	r20,r11,2
 102246c:	0039883a 	mov	fp,zero
 1022470:	003f9706 	br	10222d0 <__alt_data_end+0xff0222d0>
 1022474:	8025883a 	mov	r18,r16
 1022478:	003c2e06 	br	1021534 <__alt_data_end+0xff021534>
 102247c:	008040f4 	movhi	r2,259
 1022480:	10aa8504 	addi	r2,r2,-21996
 1022484:	0039883a 	mov	fp,zero
 1022488:	d8802615 	stw	r2,152(sp)
 102248c:	003f9006 	br	10222d0 <__alt_data_end+0xff0222d0>
 1022490:	04a5c83a 	sub	r18,zero,r18
 1022494:	07000b44 	movi	fp,45
 1022498:	9004c03a 	cmpne	r2,r18,zero
 102249c:	04e7c83a 	sub	r19,zero,r19
 10224a0:	df001d85 	stb	fp,118(sp)
 10224a4:	98a7c83a 	sub	r19,r19,r2
 10224a8:	48009f16 	blt	r9,zero,1022728 <___vfiprintf_internal_r+0x1338>
 10224ac:	00bfdfc4 	movi	r2,-129
 10224b0:	a0a8703a 	and	r20,r20,r2
 10224b4:	003dd006 	br	1021bf8 <__alt_data_end+0xff021bf8>
 10224b8:	70004c26 	beq	r14,zero,10225ec <___vfiprintf_internal_r+0x11fc>
 10224bc:	00800084 	movi	r2,2
 10224c0:	d8c01d04 	addi	r3,sp,116
 10224c4:	d8c00015 	stw	r3,0(sp)
 10224c8:	d8800115 	stw	r2,4(sp)
 10224cc:	01000044 	movi	r4,1
 10224d0:	d811883a 	mov	r8,sp
 10224d4:	003f7306 	br	10222a4 <__alt_data_end+0xff0222a4>
 10224d8:	a080100c 	andi	r2,r20,64
 10224dc:	da802217 	ldw	r10,136(sp)
 10224e0:	103e0626 	beq	r2,zero,1021cfc <__alt_data_end+0xff021cfc>
 10224e4:	5480000f 	ldh	r18,0(r10)
 10224e8:	52800104 	addi	r10,r10,4
 10224ec:	da802215 	stw	r10,136(sp)
 10224f0:	9027d7fa 	srai	r19,r18,31
 10224f4:	9805883a 	mov	r2,r19
 10224f8:	003db806 	br	1021bdc <__alt_data_end+0xff021bdc>
 10224fc:	a080040c 	andi	r2,r20,16
 1022500:	1000091e 	bne	r2,zero,1022528 <___vfiprintf_internal_r+0x1138>
 1022504:	a2c0100c 	andi	r11,r20,64
 1022508:	58000726 	beq	r11,zero,1022528 <___vfiprintf_internal_r+0x1138>
 102250c:	da802217 	ldw	r10,136(sp)
 1022510:	50800017 	ldw	r2,0(r10)
 1022514:	52800104 	addi	r10,r10,4
 1022518:	da802215 	stw	r10,136(sp)
 102251c:	da802317 	ldw	r10,140(sp)
 1022520:	1280000d 	sth	r10,0(r2)
 1022524:	003be706 	br	10214c4 <__alt_data_end+0xff0214c4>
 1022528:	da802217 	ldw	r10,136(sp)
 102252c:	50800017 	ldw	r2,0(r10)
 1022530:	52800104 	addi	r10,r10,4
 1022534:	da802215 	stw	r10,136(sp)
 1022538:	da802317 	ldw	r10,140(sp)
 102253c:	12800015 	stw	r10,0(r2)
 1022540:	003be006 	br	10214c4 <__alt_data_end+0xff0214c4>
 1022544:	a080100c 	andi	r2,r20,64
 1022548:	da802217 	ldw	r10,136(sp)
 102254c:	10003026 	beq	r2,zero,1022610 <___vfiprintf_internal_r+0x1220>
 1022550:	5480000b 	ldhu	r18,0(r10)
 1022554:	52800104 	addi	r10,r10,4
 1022558:	0027883a 	mov	r19,zero
 102255c:	da802215 	stw	r10,136(sp)
 1022560:	003d8006 	br	1021b64 <__alt_data_end+0xff021b64>
 1022564:	80c00007 	ldb	r3,0(r16)
 1022568:	003c0006 	br	102156c <__alt_data_end+0xff02156c>
 102256c:	a080100c 	andi	r2,r20,64
 1022570:	d8001d85 	stb	zero,118(sp)
 1022574:	da802217 	ldw	r10,136(sp)
 1022578:	1000201e 	bne	r2,zero,10225fc <___vfiprintf_internal_r+0x120c>
 102257c:	50800104 	addi	r2,r10,4
 1022580:	54800017 	ldw	r18,0(r10)
 1022584:	0027883a 	mov	r19,zero
 1022588:	483def0e 	bge	r9,zero,1021d48 <__alt_data_end+0xff021d48>
 102258c:	94c6b03a 	or	r3,r18,r19
 1022590:	d8802215 	stw	r2,136(sp)
 1022594:	183d4e1e 	bne	r3,zero,1021ad0 <__alt_data_end+0xff021ad0>
 1022598:	0039883a 	mov	fp,zero
 102259c:	0005883a 	mov	r2,zero
 10225a0:	003e0606 	br	1021dbc <__alt_data_end+0xff021dbc>
 10225a4:	d9402117 	ldw	r5,132(sp)
 10225a8:	d9002017 	ldw	r4,128(sp)
 10225ac:	d9801a04 	addi	r6,sp,104
 10225b0:	da402c15 	stw	r9,176(sp)
 10225b4:	db802a15 	stw	r14,168(sp)
 10225b8:	10212dc0 	call	10212dc <__sprint_r.part.0>
 10225bc:	da402c17 	ldw	r9,176(sp)
 10225c0:	db802a17 	ldw	r14,168(sp)
 10225c4:	103ede1e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 10225c8:	d9401b17 	ldw	r5,108(sp)
 10225cc:	d8801c17 	ldw	r2,112(sp)
 10225d0:	d811883a 	mov	r8,sp
 10225d4:	29000044 	addi	r4,r5,1
 10225d8:	003e7406 	br	1021fac <__alt_data_end+0xff021fac>
 10225dc:	00bfffc4 	movi	r2,-1
 10225e0:	003c5806 	br	1021744 <__alt_data_end+0xff021744>
 10225e4:	d811883a 	mov	r8,sp
 10225e8:	003ee806 	br	102218c <__alt_data_end+0xff02218c>
 10225ec:	000b883a 	mov	r5,zero
 10225f0:	01000044 	movi	r4,1
 10225f4:	d811883a 	mov	r8,sp
 10225f8:	003e7c06 	br	1021fec <__alt_data_end+0xff021fec>
 10225fc:	50800104 	addi	r2,r10,4
 1022600:	5480000b 	ldhu	r18,0(r10)
 1022604:	0027883a 	mov	r19,zero
 1022608:	483dcf0e 	bge	r9,zero,1021d48 <__alt_data_end+0xff021d48>
 102260c:	003fdf06 	br	102258c <__alt_data_end+0xff02258c>
 1022610:	54800017 	ldw	r18,0(r10)
 1022614:	52800104 	addi	r10,r10,4
 1022618:	0027883a 	mov	r19,zero
 102261c:	da802215 	stw	r10,136(sp)
 1022620:	003d5006 	br	1021b64 <__alt_data_end+0xff021b64>
 1022624:	50800104 	addi	r2,r10,4
 1022628:	5480000b 	ldhu	r18,0(r10)
 102262c:	0027883a 	mov	r19,zero
 1022630:	483f7d0e 	bge	r9,zero,1022428 <__alt_data_end+0xff022428>
 1022634:	003ddc06 	br	1021da8 <__alt_data_end+0xff021da8>
 1022638:	d8c02215 	stw	r3,136(sp)
 102263c:	0039883a 	mov	fp,zero
 1022640:	003ddb06 	br	1021db0 <__alt_data_end+0xff021db0>
 1022644:	028040f4 	movhi	r10,259
 1022648:	52aaf504 	addi	r10,r10,-21548
 102264c:	da802415 	stw	r10,144(sp)
 1022650:	003e8306 	br	1022060 <__alt_data_end+0xff022060>
 1022654:	d8801c17 	ldw	r2,112(sp)
 1022658:	dd002117 	ldw	r20,132(sp)
 102265c:	103eb926 	beq	r2,zero,1022144 <__alt_data_end+0xff022144>
 1022660:	d9002017 	ldw	r4,128(sp)
 1022664:	d9801a04 	addi	r6,sp,104
 1022668:	a00b883a 	mov	r5,r20
 102266c:	10212dc0 	call	10212dc <__sprint_r.part.0>
 1022670:	003eb406 	br	1022144 <__alt_data_end+0xff022144>
 1022674:	80c00043 	ldbu	r3,1(r16)
 1022678:	a5000814 	ori	r20,r20,32
 102267c:	84000044 	addi	r16,r16,1
 1022680:	18c03fcc 	andi	r3,r3,255
 1022684:	18c0201c 	xori	r3,r3,128
 1022688:	18ffe004 	addi	r3,r3,-128
 102268c:	003bb706 	br	102156c <__alt_data_end+0xff02156c>
 1022690:	a809883a 	mov	r4,r21
 1022694:	d8c02a15 	stw	r3,168(sp)
 1022698:	da002b15 	stw	r8,172(sp)
 102269c:	10165b40 	call	10165b4 <strlen>
 10226a0:	d8c02a17 	ldw	r3,168(sp)
 10226a4:	1027883a 	mov	r19,r2
 10226a8:	df001d83 	ldbu	fp,118(sp)
 10226ac:	d8c02215 	stw	r3,136(sp)
 10226b0:	0013883a 	mov	r9,zero
 10226b4:	da002b17 	ldw	r8,172(sp)
 10226b8:	003c4d06 	br	10217f0 <__alt_data_end+0xff0217f0>
 10226bc:	d9402117 	ldw	r5,132(sp)
 10226c0:	d9002017 	ldw	r4,128(sp)
 10226c4:	d9801a04 	addi	r6,sp,104
 10226c8:	da402c15 	stw	r9,176(sp)
 10226cc:	10212dc0 	call	10212dc <__sprint_r.part.0>
 10226d0:	da402c17 	ldw	r9,176(sp)
 10226d4:	103e9a1e 	bne	r2,zero,1022140 <__alt_data_end+0xff022140>
 10226d8:	d9401b17 	ldw	r5,108(sp)
 10226dc:	d8801c17 	ldw	r2,112(sp)
 10226e0:	d811883a 	mov	r8,sp
 10226e4:	29000044 	addi	r4,r5,1
 10226e8:	003e4206 	br	1021ff4 <__alt_data_end+0xff021ff4>
 10226ec:	d9401b17 	ldw	r5,108(sp)
 10226f0:	010040f4 	movhi	r4,259
 10226f4:	212af904 	addi	r4,r4,-21532
 10226f8:	d9002415 	stw	r4,144(sp)
 10226fc:	29400044 	addi	r5,r5,1
 1022700:	003c6d06 	br	10218b8 <__alt_data_end+0xff0218b8>
 1022704:	0039883a 	mov	fp,zero
 1022708:	00800084 	movi	r2,2
 102270c:	10803fcc 	andi	r2,r2,255
 1022710:	01000044 	movi	r4,1
 1022714:	11001e26 	beq	r2,r4,1022790 <___vfiprintf_internal_r+0x13a0>
 1022718:	01000084 	movi	r4,2
 102271c:	11001e1e 	bne	r2,r4,1022798 <___vfiprintf_internal_r+0x13a8>
 1022720:	1829883a 	mov	r20,r3
 1022724:	003eea06 	br	10222d0 <__alt_data_end+0xff0222d0>
 1022728:	a007883a 	mov	r3,r20
 102272c:	00800044 	movi	r2,1
 1022730:	003ff606 	br	102270c <__alt_data_end+0xff02270c>
 1022734:	00800184 	movi	r2,6
 1022738:	1240012e 	bgeu	r2,r9,1022740 <___vfiprintf_internal_r+0x1350>
 102273c:	1013883a 	mov	r9,r2
 1022740:	4827883a 	mov	r19,r9
 1022744:	4825883a 	mov	r18,r9
 1022748:	48001516 	blt	r9,zero,10227a0 <___vfiprintf_internal_r+0x13b0>
 102274c:	054040f4 	movhi	r21,259
 1022750:	d8c02215 	stw	r3,136(sp)
 1022754:	ad6a8a04 	addi	r21,r21,-21976
 1022758:	003d1406 	br	1021bac <__alt_data_end+0xff021bac>
 102275c:	028040f4 	movhi	r10,259
 1022760:	52aaf504 	addi	r10,r10,-21548
 1022764:	da802415 	stw	r10,144(sp)
 1022768:	200d883a 	mov	r6,r4
 102276c:	003c9106 	br	10219b4 <__alt_data_end+0xff0219b4>
 1022770:	5021883a 	mov	r16,r10
 1022774:	0013883a 	mov	r9,zero
 1022778:	003b7d06 	br	1021570 <__alt_data_end+0xff021570>
 102277c:	4827883a 	mov	r19,r9
 1022780:	df001d83 	ldbu	fp,118(sp)
 1022784:	d8c02215 	stw	r3,136(sp)
 1022788:	0013883a 	mov	r9,zero
 102278c:	003c1806 	br	10217f0 <__alt_data_end+0xff0217f0>
 1022790:	1829883a 	mov	r20,r3
 1022794:	003d1806 	br	1021bf8 <__alt_data_end+0xff021bf8>
 1022798:	1829883a 	mov	r20,r3
 102279c:	003ccd06 	br	1021ad4 <__alt_data_end+0xff021ad4>
 10227a0:	0025883a 	mov	r18,zero
 10227a4:	003fe906 	br	102274c <__alt_data_end+0xff02274c>
 10227a8:	d8802217 	ldw	r2,136(sp)
 10227ac:	80c00043 	ldbu	r3,1(r16)
 10227b0:	5021883a 	mov	r16,r10
 10227b4:	12400017 	ldw	r9,0(r2)
 10227b8:	10800104 	addi	r2,r2,4
 10227bc:	d8802215 	stw	r2,136(sp)
 10227c0:	483faf0e 	bge	r9,zero,1022680 <__alt_data_end+0xff022680>
 10227c4:	18c03fcc 	andi	r3,r3,255
 10227c8:	18c0201c 	xori	r3,r3,128
 10227cc:	027fffc4 	movi	r9,-1
 10227d0:	18ffe004 	addi	r3,r3,-128
 10227d4:	003b6506 	br	102156c <__alt_data_end+0xff02156c>
 10227d8:	d9c01d85 	stb	r7,118(sp)
 10227dc:	003ca006 	br	1021a60 <__alt_data_end+0xff021a60>
 10227e0:	d9c01d85 	stb	r7,118(sp)
 10227e4:	003cad06 	br	1021a9c <__alt_data_end+0xff021a9c>
 10227e8:	d9c01d85 	stb	r7,118(sp)
 10227ec:	003d7d06 	br	1021de4 <__alt_data_end+0xff021de4>
 10227f0:	d9c01d85 	stb	r7,118(sp)
 10227f4:	003d5f06 	br	1021d74 <__alt_data_end+0xff021d74>
 10227f8:	a080004c 	andi	r2,r20,1
 10227fc:	0039883a 	mov	fp,zero
 1022800:	10000526 	beq	r2,zero,1022818 <___vfiprintf_internal_r+0x1428>
 1022804:	00800c04 	movi	r2,48
 1022808:	d88019c5 	stb	r2,103(sp)
 102280c:	dcc02717 	ldw	r19,156(sp)
 1022810:	dd4019c4 	addi	r21,sp,103
 1022814:	003bf606 	br	10217f0 <__alt_data_end+0xff0217f0>
 1022818:	0027883a 	mov	r19,zero
 102281c:	dd401a04 	addi	r21,sp,104
 1022820:	003bf306 	br	10217f0 <__alt_data_end+0xff0217f0>
 1022824:	d9c01d85 	stb	r7,118(sp)
 1022828:	003dc806 	br	1021f4c <__alt_data_end+0xff021f4c>
 102282c:	d9c01d85 	stb	r7,118(sp)
 1022830:	003d3a06 	br	1021d1c <__alt_data_end+0xff021d1c>
 1022834:	d9c01d85 	stb	r7,118(sp)
 1022838:	003d2a06 	br	1021ce4 <__alt_data_end+0xff021ce4>
 102283c:	d9c01d85 	stb	r7,118(sp)
 1022840:	003cde06 	br	1021bbc <__alt_data_end+0xff021bbc>
 1022844:	d9c01d85 	stb	r7,118(sp)
 1022848:	003cbc06 	br	1021b3c <__alt_data_end+0xff021b3c>

0102284c <__vfiprintf_internal>:
 102284c:	008040f4 	movhi	r2,259
 1022850:	10b25d04 	addi	r2,r2,-13964
 1022854:	300f883a 	mov	r7,r6
 1022858:	280d883a 	mov	r6,r5
 102285c:	200b883a 	mov	r5,r4
 1022860:	11000017 	ldw	r4,0(r2)
 1022864:	10213f01 	jmpi	10213f0 <___vfiprintf_internal_r>

01022868 <__sbprintf>:
 1022868:	2880030b 	ldhu	r2,12(r5)
 102286c:	2ac01917 	ldw	r11,100(r5)
 1022870:	2a80038b 	ldhu	r10,14(r5)
 1022874:	2a400717 	ldw	r9,28(r5)
 1022878:	2a000917 	ldw	r8,36(r5)
 102287c:	defee204 	addi	sp,sp,-1144
 1022880:	00c10004 	movi	r3,1024
 1022884:	dc011a15 	stw	r16,1128(sp)
 1022888:	10bfff4c 	andi	r2,r2,65533
 102288c:	2821883a 	mov	r16,r5
 1022890:	d8cb883a 	add	r5,sp,r3
 1022894:	dc811c15 	stw	r18,1136(sp)
 1022898:	dc411b15 	stw	r17,1132(sp)
 102289c:	dfc11d15 	stw	ra,1140(sp)
 10228a0:	2025883a 	mov	r18,r4
 10228a4:	d881030d 	sth	r2,1036(sp)
 10228a8:	dac11915 	stw	r11,1124(sp)
 10228ac:	da81038d 	sth	r10,1038(sp)
 10228b0:	da410715 	stw	r9,1052(sp)
 10228b4:	da010915 	stw	r8,1060(sp)
 10228b8:	dec10015 	stw	sp,1024(sp)
 10228bc:	dec10415 	stw	sp,1040(sp)
 10228c0:	d8c10215 	stw	r3,1032(sp)
 10228c4:	d8c10515 	stw	r3,1044(sp)
 10228c8:	d8010615 	stw	zero,1048(sp)
 10228cc:	10213f00 	call	10213f0 <___vfiprintf_internal_r>
 10228d0:	1023883a 	mov	r17,r2
 10228d4:	10000416 	blt	r2,zero,10228e8 <__sbprintf+0x80>
 10228d8:	d9410004 	addi	r5,sp,1024
 10228dc:	9009883a 	mov	r4,r18
 10228e0:	101c8e00 	call	101c8e0 <_fflush_r>
 10228e4:	10000d1e 	bne	r2,zero,102291c <__sbprintf+0xb4>
 10228e8:	d881030b 	ldhu	r2,1036(sp)
 10228ec:	1080100c 	andi	r2,r2,64
 10228f0:	10000326 	beq	r2,zero,1022900 <__sbprintf+0x98>
 10228f4:	8080030b 	ldhu	r2,12(r16)
 10228f8:	10801014 	ori	r2,r2,64
 10228fc:	8080030d 	sth	r2,12(r16)
 1022900:	8805883a 	mov	r2,r17
 1022904:	dfc11d17 	ldw	ra,1140(sp)
 1022908:	dc811c17 	ldw	r18,1136(sp)
 102290c:	dc411b17 	ldw	r17,1132(sp)
 1022910:	dc011a17 	ldw	r16,1128(sp)
 1022914:	dec11e04 	addi	sp,sp,1144
 1022918:	f800283a 	ret
 102291c:	047fffc4 	movi	r17,-1
 1022920:	003ff106 	br	10228e8 <__alt_data_end+0xff0228e8>

01022924 <_write_r>:
 1022924:	defffd04 	addi	sp,sp,-12
 1022928:	2805883a 	mov	r2,r5
 102292c:	dc000015 	stw	r16,0(sp)
 1022930:	040040f4 	movhi	r16,259
 1022934:	dc400115 	stw	r17,4(sp)
 1022938:	300b883a 	mov	r5,r6
 102293c:	8439ad04 	addi	r16,r16,-6476
 1022940:	2023883a 	mov	r17,r4
 1022944:	380d883a 	mov	r6,r7
 1022948:	1009883a 	mov	r4,r2
 102294c:	dfc00215 	stw	ra,8(sp)
 1022950:	80000015 	stw	zero,0(r16)
 1022954:	10271d00 	call	10271d0 <write>
 1022958:	00ffffc4 	movi	r3,-1
 102295c:	10c00526 	beq	r2,r3,1022974 <_write_r+0x50>
 1022960:	dfc00217 	ldw	ra,8(sp)
 1022964:	dc400117 	ldw	r17,4(sp)
 1022968:	dc000017 	ldw	r16,0(sp)
 102296c:	dec00304 	addi	sp,sp,12
 1022970:	f800283a 	ret
 1022974:	80c00017 	ldw	r3,0(r16)
 1022978:	183ff926 	beq	r3,zero,1022960 <__alt_data_end+0xff022960>
 102297c:	88c00015 	stw	r3,0(r17)
 1022980:	003ff706 	br	1022960 <__alt_data_end+0xff022960>

01022984 <_close_r>:
 1022984:	defffd04 	addi	sp,sp,-12
 1022988:	dc000015 	stw	r16,0(sp)
 102298c:	040040f4 	movhi	r16,259
 1022990:	dc400115 	stw	r17,4(sp)
 1022994:	8439ad04 	addi	r16,r16,-6476
 1022998:	2023883a 	mov	r17,r4
 102299c:	2809883a 	mov	r4,r5
 10229a0:	dfc00215 	stw	ra,8(sp)
 10229a4:	80000015 	stw	zero,0(r16)
 10229a8:	10265600 	call	1026560 <close>
 10229ac:	00ffffc4 	movi	r3,-1
 10229b0:	10c00526 	beq	r2,r3,10229c8 <_close_r+0x44>
 10229b4:	dfc00217 	ldw	ra,8(sp)
 10229b8:	dc400117 	ldw	r17,4(sp)
 10229bc:	dc000017 	ldw	r16,0(sp)
 10229c0:	dec00304 	addi	sp,sp,12
 10229c4:	f800283a 	ret
 10229c8:	80c00017 	ldw	r3,0(r16)
 10229cc:	183ff926 	beq	r3,zero,10229b4 <__alt_data_end+0xff0229b4>
 10229d0:	88c00015 	stw	r3,0(r17)
 10229d4:	003ff706 	br	10229b4 <__alt_data_end+0xff0229b4>

010229d8 <_calloc_r>:
 10229d8:	298b383a 	mul	r5,r5,r6
 10229dc:	defffe04 	addi	sp,sp,-8
 10229e0:	dfc00115 	stw	ra,4(sp)
 10229e4:	dc000015 	stw	r16,0(sp)
 10229e8:	101da1c0 	call	101da1c <_malloc_r>
 10229ec:	10002926 	beq	r2,zero,1022a94 <_calloc_r+0xbc>
 10229f0:	11bfff17 	ldw	r6,-4(r2)
 10229f4:	1021883a 	mov	r16,r2
 10229f8:	00bfff04 	movi	r2,-4
 10229fc:	308c703a 	and	r6,r6,r2
 1022a00:	00c00904 	movi	r3,36
 1022a04:	308d883a 	add	r6,r6,r2
 1022a08:	19801636 	bltu	r3,r6,1022a64 <_calloc_r+0x8c>
 1022a0c:	008004c4 	movi	r2,19
 1022a10:	11800b2e 	bgeu	r2,r6,1022a40 <_calloc_r+0x68>
 1022a14:	80000015 	stw	zero,0(r16)
 1022a18:	80000115 	stw	zero,4(r16)
 1022a1c:	008006c4 	movi	r2,27
 1022a20:	11801a2e 	bgeu	r2,r6,1022a8c <_calloc_r+0xb4>
 1022a24:	80000215 	stw	zero,8(r16)
 1022a28:	80000315 	stw	zero,12(r16)
 1022a2c:	30c0151e 	bne	r6,r3,1022a84 <_calloc_r+0xac>
 1022a30:	80000415 	stw	zero,16(r16)
 1022a34:	80800604 	addi	r2,r16,24
 1022a38:	80000515 	stw	zero,20(r16)
 1022a3c:	00000106 	br	1022a44 <_calloc_r+0x6c>
 1022a40:	8005883a 	mov	r2,r16
 1022a44:	10000015 	stw	zero,0(r2)
 1022a48:	10000115 	stw	zero,4(r2)
 1022a4c:	10000215 	stw	zero,8(r2)
 1022a50:	8005883a 	mov	r2,r16
 1022a54:	dfc00117 	ldw	ra,4(sp)
 1022a58:	dc000017 	ldw	r16,0(sp)
 1022a5c:	dec00204 	addi	sp,sp,8
 1022a60:	f800283a 	ret
 1022a64:	000b883a 	mov	r5,zero
 1022a68:	8009883a 	mov	r4,r16
 1022a6c:	1015a3c0 	call	1015a3c <memset>
 1022a70:	8005883a 	mov	r2,r16
 1022a74:	dfc00117 	ldw	ra,4(sp)
 1022a78:	dc000017 	ldw	r16,0(sp)
 1022a7c:	dec00204 	addi	sp,sp,8
 1022a80:	f800283a 	ret
 1022a84:	80800404 	addi	r2,r16,16
 1022a88:	003fee06 	br	1022a44 <__alt_data_end+0xff022a44>
 1022a8c:	80800204 	addi	r2,r16,8
 1022a90:	003fec06 	br	1022a44 <__alt_data_end+0xff022a44>
 1022a94:	0005883a 	mov	r2,zero
 1022a98:	003fee06 	br	1022a54 <__alt_data_end+0xff022a54>

01022a9c <_fclose_r>:
 1022a9c:	28003926 	beq	r5,zero,1022b84 <_fclose_r+0xe8>
 1022aa0:	defffc04 	addi	sp,sp,-16
 1022aa4:	dc400115 	stw	r17,4(sp)
 1022aa8:	dc000015 	stw	r16,0(sp)
 1022aac:	dfc00315 	stw	ra,12(sp)
 1022ab0:	dc800215 	stw	r18,8(sp)
 1022ab4:	2023883a 	mov	r17,r4
 1022ab8:	2821883a 	mov	r16,r5
 1022abc:	20000226 	beq	r4,zero,1022ac8 <_fclose_r+0x2c>
 1022ac0:	20800e17 	ldw	r2,56(r4)
 1022ac4:	10002726 	beq	r2,zero,1022b64 <_fclose_r+0xc8>
 1022ac8:	8080030f 	ldh	r2,12(r16)
 1022acc:	1000071e 	bne	r2,zero,1022aec <_fclose_r+0x50>
 1022ad0:	0005883a 	mov	r2,zero
 1022ad4:	dfc00317 	ldw	ra,12(sp)
 1022ad8:	dc800217 	ldw	r18,8(sp)
 1022adc:	dc400117 	ldw	r17,4(sp)
 1022ae0:	dc000017 	ldw	r16,0(sp)
 1022ae4:	dec00404 	addi	sp,sp,16
 1022ae8:	f800283a 	ret
 1022aec:	800b883a 	mov	r5,r16
 1022af0:	8809883a 	mov	r4,r17
 1022af4:	101c6c40 	call	101c6c4 <__sflush_r>
 1022af8:	1025883a 	mov	r18,r2
 1022afc:	80800b17 	ldw	r2,44(r16)
 1022b00:	10000426 	beq	r2,zero,1022b14 <_fclose_r+0x78>
 1022b04:	81400717 	ldw	r5,28(r16)
 1022b08:	8809883a 	mov	r4,r17
 1022b0c:	103ee83a 	callr	r2
 1022b10:	10001616 	blt	r2,zero,1022b6c <_fclose_r+0xd0>
 1022b14:	8080030b 	ldhu	r2,12(r16)
 1022b18:	1080200c 	andi	r2,r2,128
 1022b1c:	1000151e 	bne	r2,zero,1022b74 <_fclose_r+0xd8>
 1022b20:	81400c17 	ldw	r5,48(r16)
 1022b24:	28000526 	beq	r5,zero,1022b3c <_fclose_r+0xa0>
 1022b28:	80801004 	addi	r2,r16,64
 1022b2c:	28800226 	beq	r5,r2,1022b38 <_fclose_r+0x9c>
 1022b30:	8809883a 	mov	r4,r17
 1022b34:	101ce300 	call	101ce30 <_free_r>
 1022b38:	80000c15 	stw	zero,48(r16)
 1022b3c:	81401117 	ldw	r5,68(r16)
 1022b40:	28000326 	beq	r5,zero,1022b50 <_fclose_r+0xb4>
 1022b44:	8809883a 	mov	r4,r17
 1022b48:	101ce300 	call	101ce30 <_free_r>
 1022b4c:	80001115 	stw	zero,68(r16)
 1022b50:	101cccc0 	call	101cccc <__sfp_lock_acquire>
 1022b54:	8000030d 	sth	zero,12(r16)
 1022b58:	101ccd00 	call	101ccd0 <__sfp_lock_release>
 1022b5c:	9005883a 	mov	r2,r18
 1022b60:	003fdc06 	br	1022ad4 <__alt_data_end+0xff022ad4>
 1022b64:	101ccbc0 	call	101ccbc <__sinit>
 1022b68:	003fd706 	br	1022ac8 <__alt_data_end+0xff022ac8>
 1022b6c:	04bfffc4 	movi	r18,-1
 1022b70:	003fe806 	br	1022b14 <__alt_data_end+0xff022b14>
 1022b74:	81400417 	ldw	r5,16(r16)
 1022b78:	8809883a 	mov	r4,r17
 1022b7c:	101ce300 	call	101ce30 <_free_r>
 1022b80:	003fe706 	br	1022b20 <__alt_data_end+0xff022b20>
 1022b84:	0005883a 	mov	r2,zero
 1022b88:	f800283a 	ret

01022b8c <fclose>:
 1022b8c:	008040f4 	movhi	r2,259
 1022b90:	10b25d04 	addi	r2,r2,-13964
 1022b94:	200b883a 	mov	r5,r4
 1022b98:	11000017 	ldw	r4,0(r2)
 1022b9c:	1022a9c1 	jmpi	1022a9c <_fclose_r>

01022ba0 <__fputwc>:
 1022ba0:	defff804 	addi	sp,sp,-32
 1022ba4:	dcc00415 	stw	r19,16(sp)
 1022ba8:	dc800315 	stw	r18,12(sp)
 1022bac:	dc000115 	stw	r16,4(sp)
 1022bb0:	dfc00715 	stw	ra,28(sp)
 1022bb4:	dd400615 	stw	r21,24(sp)
 1022bb8:	dd000515 	stw	r20,20(sp)
 1022bbc:	dc400215 	stw	r17,8(sp)
 1022bc0:	2027883a 	mov	r19,r4
 1022bc4:	2825883a 	mov	r18,r5
 1022bc8:	3021883a 	mov	r16,r6
 1022bcc:	101d80c0 	call	101d80c <__locale_mb_cur_max>
 1022bd0:	00c00044 	movi	r3,1
 1022bd4:	10c03e26 	beq	r2,r3,1022cd0 <__fputwc+0x130>
 1022bd8:	81c01704 	addi	r7,r16,92
 1022bdc:	900d883a 	mov	r6,r18
 1022be0:	d80b883a 	mov	r5,sp
 1022be4:	9809883a 	mov	r4,r19
 1022be8:	10230700 	call	1023070 <_wcrtomb_r>
 1022bec:	1029883a 	mov	r20,r2
 1022bf0:	00bfffc4 	movi	r2,-1
 1022bf4:	a0802026 	beq	r20,r2,1022c78 <__fputwc+0xd8>
 1022bf8:	d9400003 	ldbu	r5,0(sp)
 1022bfc:	a0001c26 	beq	r20,zero,1022c70 <__fputwc+0xd0>
 1022c00:	0023883a 	mov	r17,zero
 1022c04:	05400284 	movi	r21,10
 1022c08:	00000906 	br	1022c30 <__fputwc+0x90>
 1022c0c:	80800017 	ldw	r2,0(r16)
 1022c10:	11400005 	stb	r5,0(r2)
 1022c14:	80c00017 	ldw	r3,0(r16)
 1022c18:	18c00044 	addi	r3,r3,1
 1022c1c:	80c00015 	stw	r3,0(r16)
 1022c20:	8c400044 	addi	r17,r17,1
 1022c24:	dc45883a 	add	r2,sp,r17
 1022c28:	8d00112e 	bgeu	r17,r20,1022c70 <__fputwc+0xd0>
 1022c2c:	11400003 	ldbu	r5,0(r2)
 1022c30:	80c00217 	ldw	r3,8(r16)
 1022c34:	18ffffc4 	addi	r3,r3,-1
 1022c38:	80c00215 	stw	r3,8(r16)
 1022c3c:	183ff30e 	bge	r3,zero,1022c0c <__alt_data_end+0xff022c0c>
 1022c40:	80800617 	ldw	r2,24(r16)
 1022c44:	18801916 	blt	r3,r2,1022cac <__fputwc+0x10c>
 1022c48:	80800017 	ldw	r2,0(r16)
 1022c4c:	11400005 	stb	r5,0(r2)
 1022c50:	80800017 	ldw	r2,0(r16)
 1022c54:	10c00003 	ldbu	r3,0(r2)
 1022c58:	10800044 	addi	r2,r2,1
 1022c5c:	1d402326 	beq	r3,r21,1022cec <__fputwc+0x14c>
 1022c60:	80800015 	stw	r2,0(r16)
 1022c64:	8c400044 	addi	r17,r17,1
 1022c68:	dc45883a 	add	r2,sp,r17
 1022c6c:	8d3fef36 	bltu	r17,r20,1022c2c <__alt_data_end+0xff022c2c>
 1022c70:	9005883a 	mov	r2,r18
 1022c74:	00000406 	br	1022c88 <__fputwc+0xe8>
 1022c78:	80c0030b 	ldhu	r3,12(r16)
 1022c7c:	a005883a 	mov	r2,r20
 1022c80:	18c01014 	ori	r3,r3,64
 1022c84:	80c0030d 	sth	r3,12(r16)
 1022c88:	dfc00717 	ldw	ra,28(sp)
 1022c8c:	dd400617 	ldw	r21,24(sp)
 1022c90:	dd000517 	ldw	r20,20(sp)
 1022c94:	dcc00417 	ldw	r19,16(sp)
 1022c98:	dc800317 	ldw	r18,12(sp)
 1022c9c:	dc400217 	ldw	r17,8(sp)
 1022ca0:	dc000117 	ldw	r16,4(sp)
 1022ca4:	dec00804 	addi	sp,sp,32
 1022ca8:	f800283a 	ret
 1022cac:	800d883a 	mov	r6,r16
 1022cb0:	29403fcc 	andi	r5,r5,255
 1022cb4:	9809883a 	mov	r4,r19
 1022cb8:	1022f180 	call	1022f18 <__swbuf_r>
 1022cbc:	10bfffe0 	cmpeqi	r2,r2,-1
 1022cc0:	10803fcc 	andi	r2,r2,255
 1022cc4:	103fd626 	beq	r2,zero,1022c20 <__alt_data_end+0xff022c20>
 1022cc8:	00bfffc4 	movi	r2,-1
 1022ccc:	003fee06 	br	1022c88 <__alt_data_end+0xff022c88>
 1022cd0:	90ffffc4 	addi	r3,r18,-1
 1022cd4:	01003f84 	movi	r4,254
 1022cd8:	20ffbf36 	bltu	r4,r3,1022bd8 <__alt_data_end+0xff022bd8>
 1022cdc:	900b883a 	mov	r5,r18
 1022ce0:	dc800005 	stb	r18,0(sp)
 1022ce4:	1029883a 	mov	r20,r2
 1022ce8:	003fc506 	br	1022c00 <__alt_data_end+0xff022c00>
 1022cec:	800d883a 	mov	r6,r16
 1022cf0:	a80b883a 	mov	r5,r21
 1022cf4:	9809883a 	mov	r4,r19
 1022cf8:	1022f180 	call	1022f18 <__swbuf_r>
 1022cfc:	10bfffe0 	cmpeqi	r2,r2,-1
 1022d00:	003fef06 	br	1022cc0 <__alt_data_end+0xff022cc0>

01022d04 <_fputwc_r>:
 1022d04:	3080030b 	ldhu	r2,12(r6)
 1022d08:	10c8000c 	andi	r3,r2,8192
 1022d0c:	1800051e 	bne	r3,zero,1022d24 <_fputwc_r+0x20>
 1022d10:	30c01917 	ldw	r3,100(r6)
 1022d14:	10880014 	ori	r2,r2,8192
 1022d18:	3080030d 	sth	r2,12(r6)
 1022d1c:	18880014 	ori	r2,r3,8192
 1022d20:	30801915 	stw	r2,100(r6)
 1022d24:	1022ba01 	jmpi	1022ba0 <__fputwc>

01022d28 <fputwc>:
 1022d28:	008040f4 	movhi	r2,259
 1022d2c:	defffc04 	addi	sp,sp,-16
 1022d30:	10b25d04 	addi	r2,r2,-13964
 1022d34:	dc000115 	stw	r16,4(sp)
 1022d38:	14000017 	ldw	r16,0(r2)
 1022d3c:	dc400215 	stw	r17,8(sp)
 1022d40:	dfc00315 	stw	ra,12(sp)
 1022d44:	2023883a 	mov	r17,r4
 1022d48:	80000226 	beq	r16,zero,1022d54 <fputwc+0x2c>
 1022d4c:	80800e17 	ldw	r2,56(r16)
 1022d50:	10001026 	beq	r2,zero,1022d94 <fputwc+0x6c>
 1022d54:	2880030b 	ldhu	r2,12(r5)
 1022d58:	10c8000c 	andi	r3,r2,8192
 1022d5c:	1800051e 	bne	r3,zero,1022d74 <fputwc+0x4c>
 1022d60:	28c01917 	ldw	r3,100(r5)
 1022d64:	10880014 	ori	r2,r2,8192
 1022d68:	2880030d 	sth	r2,12(r5)
 1022d6c:	18880014 	ori	r2,r3,8192
 1022d70:	28801915 	stw	r2,100(r5)
 1022d74:	280d883a 	mov	r6,r5
 1022d78:	8009883a 	mov	r4,r16
 1022d7c:	880b883a 	mov	r5,r17
 1022d80:	dfc00317 	ldw	ra,12(sp)
 1022d84:	dc400217 	ldw	r17,8(sp)
 1022d88:	dc000117 	ldw	r16,4(sp)
 1022d8c:	dec00404 	addi	sp,sp,16
 1022d90:	1022ba01 	jmpi	1022ba0 <__fputwc>
 1022d94:	8009883a 	mov	r4,r16
 1022d98:	d9400015 	stw	r5,0(sp)
 1022d9c:	101ccbc0 	call	101ccbc <__sinit>
 1022da0:	d9400017 	ldw	r5,0(sp)
 1022da4:	003feb06 	br	1022d54 <__alt_data_end+0xff022d54>

01022da8 <_fstat_r>:
 1022da8:	defffd04 	addi	sp,sp,-12
 1022dac:	2805883a 	mov	r2,r5
 1022db0:	dc000015 	stw	r16,0(sp)
 1022db4:	040040f4 	movhi	r16,259
 1022db8:	dc400115 	stw	r17,4(sp)
 1022dbc:	8439ad04 	addi	r16,r16,-6476
 1022dc0:	2023883a 	mov	r17,r4
 1022dc4:	300b883a 	mov	r5,r6
 1022dc8:	1009883a 	mov	r4,r2
 1022dcc:	dfc00215 	stw	ra,8(sp)
 1022dd0:	80000015 	stw	zero,0(r16)
 1022dd4:	102678c0 	call	102678c <fstat>
 1022dd8:	00ffffc4 	movi	r3,-1
 1022ddc:	10c00526 	beq	r2,r3,1022df4 <_fstat_r+0x4c>
 1022de0:	dfc00217 	ldw	ra,8(sp)
 1022de4:	dc400117 	ldw	r17,4(sp)
 1022de8:	dc000017 	ldw	r16,0(sp)
 1022dec:	dec00304 	addi	sp,sp,12
 1022df0:	f800283a 	ret
 1022df4:	80c00017 	ldw	r3,0(r16)
 1022df8:	183ff926 	beq	r3,zero,1022de0 <__alt_data_end+0xff022de0>
 1022dfc:	88c00015 	stw	r3,0(r17)
 1022e00:	003ff706 	br	1022de0 <__alt_data_end+0xff022de0>

01022e04 <_isatty_r>:
 1022e04:	defffd04 	addi	sp,sp,-12
 1022e08:	dc000015 	stw	r16,0(sp)
 1022e0c:	040040f4 	movhi	r16,259
 1022e10:	dc400115 	stw	r17,4(sp)
 1022e14:	8439ad04 	addi	r16,r16,-6476
 1022e18:	2023883a 	mov	r17,r4
 1022e1c:	2809883a 	mov	r4,r5
 1022e20:	dfc00215 	stw	ra,8(sp)
 1022e24:	80000015 	stw	zero,0(r16)
 1022e28:	1026a480 	call	1026a48 <isatty>
 1022e2c:	00ffffc4 	movi	r3,-1
 1022e30:	10c00526 	beq	r2,r3,1022e48 <_isatty_r+0x44>
 1022e34:	dfc00217 	ldw	ra,8(sp)
 1022e38:	dc400117 	ldw	r17,4(sp)
 1022e3c:	dc000017 	ldw	r16,0(sp)
 1022e40:	dec00304 	addi	sp,sp,12
 1022e44:	f800283a 	ret
 1022e48:	80c00017 	ldw	r3,0(r16)
 1022e4c:	183ff926 	beq	r3,zero,1022e34 <__alt_data_end+0xff022e34>
 1022e50:	88c00015 	stw	r3,0(r17)
 1022e54:	003ff706 	br	1022e34 <__alt_data_end+0xff022e34>

01022e58 <_lseek_r>:
 1022e58:	defffd04 	addi	sp,sp,-12
 1022e5c:	2805883a 	mov	r2,r5
 1022e60:	dc000015 	stw	r16,0(sp)
 1022e64:	040040f4 	movhi	r16,259
 1022e68:	dc400115 	stw	r17,4(sp)
 1022e6c:	300b883a 	mov	r5,r6
 1022e70:	8439ad04 	addi	r16,r16,-6476
 1022e74:	2023883a 	mov	r17,r4
 1022e78:	380d883a 	mov	r6,r7
 1022e7c:	1009883a 	mov	r4,r2
 1022e80:	dfc00215 	stw	ra,8(sp)
 1022e84:	80000015 	stw	zero,0(r16)
 1022e88:	1026d800 	call	1026d80 <lseek>
 1022e8c:	00ffffc4 	movi	r3,-1
 1022e90:	10c00526 	beq	r2,r3,1022ea8 <_lseek_r+0x50>
 1022e94:	dfc00217 	ldw	ra,8(sp)
 1022e98:	dc400117 	ldw	r17,4(sp)
 1022e9c:	dc000017 	ldw	r16,0(sp)
 1022ea0:	dec00304 	addi	sp,sp,12
 1022ea4:	f800283a 	ret
 1022ea8:	80c00017 	ldw	r3,0(r16)
 1022eac:	183ff926 	beq	r3,zero,1022e94 <__alt_data_end+0xff022e94>
 1022eb0:	88c00015 	stw	r3,0(r17)
 1022eb4:	003ff706 	br	1022e94 <__alt_data_end+0xff022e94>

01022eb8 <_read_r>:
 1022eb8:	defffd04 	addi	sp,sp,-12
 1022ebc:	2805883a 	mov	r2,r5
 1022ec0:	dc000015 	stw	r16,0(sp)
 1022ec4:	040040f4 	movhi	r16,259
 1022ec8:	dc400115 	stw	r17,4(sp)
 1022ecc:	300b883a 	mov	r5,r6
 1022ed0:	8439ad04 	addi	r16,r16,-6476
 1022ed4:	2023883a 	mov	r17,r4
 1022ed8:	380d883a 	mov	r6,r7
 1022edc:	1009883a 	mov	r4,r2
 1022ee0:	dfc00215 	stw	ra,8(sp)
 1022ee4:	80000015 	stw	zero,0(r16)
 1022ee8:	1026f540 	call	1026f54 <read>
 1022eec:	00ffffc4 	movi	r3,-1
 1022ef0:	10c00526 	beq	r2,r3,1022f08 <_read_r+0x50>
 1022ef4:	dfc00217 	ldw	ra,8(sp)
 1022ef8:	dc400117 	ldw	r17,4(sp)
 1022efc:	dc000017 	ldw	r16,0(sp)
 1022f00:	dec00304 	addi	sp,sp,12
 1022f04:	f800283a 	ret
 1022f08:	80c00017 	ldw	r3,0(r16)
 1022f0c:	183ff926 	beq	r3,zero,1022ef4 <__alt_data_end+0xff022ef4>
 1022f10:	88c00015 	stw	r3,0(r17)
 1022f14:	003ff706 	br	1022ef4 <__alt_data_end+0xff022ef4>

01022f18 <__swbuf_r>:
 1022f18:	defffb04 	addi	sp,sp,-20
 1022f1c:	dcc00315 	stw	r19,12(sp)
 1022f20:	dc800215 	stw	r18,8(sp)
 1022f24:	dc000015 	stw	r16,0(sp)
 1022f28:	dfc00415 	stw	ra,16(sp)
 1022f2c:	dc400115 	stw	r17,4(sp)
 1022f30:	2025883a 	mov	r18,r4
 1022f34:	2827883a 	mov	r19,r5
 1022f38:	3021883a 	mov	r16,r6
 1022f3c:	20000226 	beq	r4,zero,1022f48 <__swbuf_r+0x30>
 1022f40:	20800e17 	ldw	r2,56(r4)
 1022f44:	10004226 	beq	r2,zero,1023050 <__swbuf_r+0x138>
 1022f48:	80800617 	ldw	r2,24(r16)
 1022f4c:	8100030b 	ldhu	r4,12(r16)
 1022f50:	80800215 	stw	r2,8(r16)
 1022f54:	2080020c 	andi	r2,r4,8
 1022f58:	10003626 	beq	r2,zero,1023034 <__swbuf_r+0x11c>
 1022f5c:	80c00417 	ldw	r3,16(r16)
 1022f60:	18003426 	beq	r3,zero,1023034 <__swbuf_r+0x11c>
 1022f64:	2088000c 	andi	r2,r4,8192
 1022f68:	9c403fcc 	andi	r17,r19,255
 1022f6c:	10001a26 	beq	r2,zero,1022fd8 <__swbuf_r+0xc0>
 1022f70:	80800017 	ldw	r2,0(r16)
 1022f74:	81000517 	ldw	r4,20(r16)
 1022f78:	10c7c83a 	sub	r3,r2,r3
 1022f7c:	1900200e 	bge	r3,r4,1023000 <__swbuf_r+0xe8>
 1022f80:	18c00044 	addi	r3,r3,1
 1022f84:	81000217 	ldw	r4,8(r16)
 1022f88:	11400044 	addi	r5,r2,1
 1022f8c:	81400015 	stw	r5,0(r16)
 1022f90:	213fffc4 	addi	r4,r4,-1
 1022f94:	81000215 	stw	r4,8(r16)
 1022f98:	14c00005 	stb	r19,0(r2)
 1022f9c:	80800517 	ldw	r2,20(r16)
 1022fa0:	10c01e26 	beq	r2,r3,102301c <__swbuf_r+0x104>
 1022fa4:	8080030b 	ldhu	r2,12(r16)
 1022fa8:	1080004c 	andi	r2,r2,1
 1022fac:	10000226 	beq	r2,zero,1022fb8 <__swbuf_r+0xa0>
 1022fb0:	00800284 	movi	r2,10
 1022fb4:	88801926 	beq	r17,r2,102301c <__swbuf_r+0x104>
 1022fb8:	8805883a 	mov	r2,r17
 1022fbc:	dfc00417 	ldw	ra,16(sp)
 1022fc0:	dcc00317 	ldw	r19,12(sp)
 1022fc4:	dc800217 	ldw	r18,8(sp)
 1022fc8:	dc400117 	ldw	r17,4(sp)
 1022fcc:	dc000017 	ldw	r16,0(sp)
 1022fd0:	dec00504 	addi	sp,sp,20
 1022fd4:	f800283a 	ret
 1022fd8:	81401917 	ldw	r5,100(r16)
 1022fdc:	00b7ffc4 	movi	r2,-8193
 1022fe0:	21080014 	ori	r4,r4,8192
 1022fe4:	2884703a 	and	r2,r5,r2
 1022fe8:	80801915 	stw	r2,100(r16)
 1022fec:	80800017 	ldw	r2,0(r16)
 1022ff0:	8100030d 	sth	r4,12(r16)
 1022ff4:	81000517 	ldw	r4,20(r16)
 1022ff8:	10c7c83a 	sub	r3,r2,r3
 1022ffc:	193fe016 	blt	r3,r4,1022f80 <__alt_data_end+0xff022f80>
 1023000:	800b883a 	mov	r5,r16
 1023004:	9009883a 	mov	r4,r18
 1023008:	101c8e00 	call	101c8e0 <_fflush_r>
 102300c:	1000071e 	bne	r2,zero,102302c <__swbuf_r+0x114>
 1023010:	80800017 	ldw	r2,0(r16)
 1023014:	00c00044 	movi	r3,1
 1023018:	003fda06 	br	1022f84 <__alt_data_end+0xff022f84>
 102301c:	800b883a 	mov	r5,r16
 1023020:	9009883a 	mov	r4,r18
 1023024:	101c8e00 	call	101c8e0 <_fflush_r>
 1023028:	103fe326 	beq	r2,zero,1022fb8 <__alt_data_end+0xff022fb8>
 102302c:	00bfffc4 	movi	r2,-1
 1023030:	003fe206 	br	1022fbc <__alt_data_end+0xff022fbc>
 1023034:	800b883a 	mov	r5,r16
 1023038:	9009883a 	mov	r4,r18
 102303c:	101acd00 	call	101acd0 <__swsetup_r>
 1023040:	103ffa1e 	bne	r2,zero,102302c <__alt_data_end+0xff02302c>
 1023044:	8100030b 	ldhu	r4,12(r16)
 1023048:	80c00417 	ldw	r3,16(r16)
 102304c:	003fc506 	br	1022f64 <__alt_data_end+0xff022f64>
 1023050:	101ccbc0 	call	101ccbc <__sinit>
 1023054:	003fbc06 	br	1022f48 <__alt_data_end+0xff022f48>

01023058 <__swbuf>:
 1023058:	008040f4 	movhi	r2,259
 102305c:	10b25d04 	addi	r2,r2,-13964
 1023060:	280d883a 	mov	r6,r5
 1023064:	200b883a 	mov	r5,r4
 1023068:	11000017 	ldw	r4,0(r2)
 102306c:	1022f181 	jmpi	1022f18 <__swbuf_r>

01023070 <_wcrtomb_r>:
 1023070:	defff604 	addi	sp,sp,-40
 1023074:	008040f4 	movhi	r2,259
 1023078:	dc800815 	stw	r18,32(sp)
 102307c:	dc400715 	stw	r17,28(sp)
 1023080:	dc000615 	stw	r16,24(sp)
 1023084:	10b26104 	addi	r2,r2,-13948
 1023088:	dfc00915 	stw	ra,36(sp)
 102308c:	2021883a 	mov	r16,r4
 1023090:	3823883a 	mov	r17,r7
 1023094:	14800017 	ldw	r18,0(r2)
 1023098:	28001426 	beq	r5,zero,10230ec <_wcrtomb_r+0x7c>
 102309c:	d9400415 	stw	r5,16(sp)
 10230a0:	d9800515 	stw	r6,20(sp)
 10230a4:	101d8000 	call	101d800 <__locale_charset>
 10230a8:	d9800517 	ldw	r6,20(sp)
 10230ac:	d9400417 	ldw	r5,16(sp)
 10230b0:	100f883a 	mov	r7,r2
 10230b4:	dc400015 	stw	r17,0(sp)
 10230b8:	8009883a 	mov	r4,r16
 10230bc:	903ee83a 	callr	r18
 10230c0:	00ffffc4 	movi	r3,-1
 10230c4:	10c0031e 	bne	r2,r3,10230d4 <_wcrtomb_r+0x64>
 10230c8:	88000015 	stw	zero,0(r17)
 10230cc:	00c02284 	movi	r3,138
 10230d0:	80c00015 	stw	r3,0(r16)
 10230d4:	dfc00917 	ldw	ra,36(sp)
 10230d8:	dc800817 	ldw	r18,32(sp)
 10230dc:	dc400717 	ldw	r17,28(sp)
 10230e0:	dc000617 	ldw	r16,24(sp)
 10230e4:	dec00a04 	addi	sp,sp,40
 10230e8:	f800283a 	ret
 10230ec:	101d8000 	call	101d800 <__locale_charset>
 10230f0:	100f883a 	mov	r7,r2
 10230f4:	dc400015 	stw	r17,0(sp)
 10230f8:	000d883a 	mov	r6,zero
 10230fc:	d9400104 	addi	r5,sp,4
 1023100:	8009883a 	mov	r4,r16
 1023104:	903ee83a 	callr	r18
 1023108:	003fed06 	br	10230c0 <__alt_data_end+0xff0230c0>

0102310c <wcrtomb>:
 102310c:	defff604 	addi	sp,sp,-40
 1023110:	008040f4 	movhi	r2,259
 1023114:	dc800615 	stw	r18,24(sp)
 1023118:	dc400515 	stw	r17,20(sp)
 102311c:	10b25d04 	addi	r2,r2,-13964
 1023120:	dfc00915 	stw	ra,36(sp)
 1023124:	dd000815 	stw	r20,32(sp)
 1023128:	dcc00715 	stw	r19,28(sp)
 102312c:	dc000415 	stw	r16,16(sp)
 1023130:	3025883a 	mov	r18,r6
 1023134:	14400017 	ldw	r17,0(r2)
 1023138:	20001926 	beq	r4,zero,10231a0 <wcrtomb+0x94>
 102313c:	008040f4 	movhi	r2,259
 1023140:	10b26104 	addi	r2,r2,-13948
 1023144:	15000017 	ldw	r20,0(r2)
 1023148:	2021883a 	mov	r16,r4
 102314c:	2827883a 	mov	r19,r5
 1023150:	101d8000 	call	101d800 <__locale_charset>
 1023154:	100f883a 	mov	r7,r2
 1023158:	dc800015 	stw	r18,0(sp)
 102315c:	980d883a 	mov	r6,r19
 1023160:	800b883a 	mov	r5,r16
 1023164:	8809883a 	mov	r4,r17
 1023168:	a03ee83a 	callr	r20
 102316c:	00ffffc4 	movi	r3,-1
 1023170:	10c0031e 	bne	r2,r3,1023180 <wcrtomb+0x74>
 1023174:	90000015 	stw	zero,0(r18)
 1023178:	00c02284 	movi	r3,138
 102317c:	88c00015 	stw	r3,0(r17)
 1023180:	dfc00917 	ldw	ra,36(sp)
 1023184:	dd000817 	ldw	r20,32(sp)
 1023188:	dcc00717 	ldw	r19,28(sp)
 102318c:	dc800617 	ldw	r18,24(sp)
 1023190:	dc400517 	ldw	r17,20(sp)
 1023194:	dc000417 	ldw	r16,16(sp)
 1023198:	dec00a04 	addi	sp,sp,40
 102319c:	f800283a 	ret
 10231a0:	008040f4 	movhi	r2,259
 10231a4:	10b26104 	addi	r2,r2,-13948
 10231a8:	14000017 	ldw	r16,0(r2)
 10231ac:	101d8000 	call	101d800 <__locale_charset>
 10231b0:	100f883a 	mov	r7,r2
 10231b4:	dc800015 	stw	r18,0(sp)
 10231b8:	000d883a 	mov	r6,zero
 10231bc:	d9400104 	addi	r5,sp,4
 10231c0:	8809883a 	mov	r4,r17
 10231c4:	803ee83a 	callr	r16
 10231c8:	003fe806 	br	102316c <__alt_data_end+0xff02316c>

010231cc <__ascii_wctomb>:
 10231cc:	28000526 	beq	r5,zero,10231e4 <__ascii_wctomb+0x18>
 10231d0:	00803fc4 	movi	r2,255
 10231d4:	11800536 	bltu	r2,r6,10231ec <__ascii_wctomb+0x20>
 10231d8:	29800005 	stb	r6,0(r5)
 10231dc:	00800044 	movi	r2,1
 10231e0:	f800283a 	ret
 10231e4:	0005883a 	mov	r2,zero
 10231e8:	f800283a 	ret
 10231ec:	00802284 	movi	r2,138
 10231f0:	20800015 	stw	r2,0(r4)
 10231f4:	00bfffc4 	movi	r2,-1
 10231f8:	f800283a 	ret

010231fc <_wctomb_r>:
 10231fc:	008040f4 	movhi	r2,259
 1023200:	defff904 	addi	sp,sp,-28
 1023204:	10b26104 	addi	r2,r2,-13948
 1023208:	dfc00615 	stw	ra,24(sp)
 102320c:	dc400515 	stw	r17,20(sp)
 1023210:	dc000415 	stw	r16,16(sp)
 1023214:	3823883a 	mov	r17,r7
 1023218:	14000017 	ldw	r16,0(r2)
 102321c:	d9000115 	stw	r4,4(sp)
 1023220:	d9400215 	stw	r5,8(sp)
 1023224:	d9800315 	stw	r6,12(sp)
 1023228:	101d8000 	call	101d800 <__locale_charset>
 102322c:	d9800317 	ldw	r6,12(sp)
 1023230:	d9400217 	ldw	r5,8(sp)
 1023234:	d9000117 	ldw	r4,4(sp)
 1023238:	100f883a 	mov	r7,r2
 102323c:	dc400015 	stw	r17,0(sp)
 1023240:	803ee83a 	callr	r16
 1023244:	dfc00617 	ldw	ra,24(sp)
 1023248:	dc400517 	ldw	r17,20(sp)
 102324c:	dc000417 	ldw	r16,16(sp)
 1023250:	dec00704 	addi	sp,sp,28
 1023254:	f800283a 	ret

01023258 <__udivdi3>:
 1023258:	defff504 	addi	sp,sp,-44
 102325c:	dcc00415 	stw	r19,16(sp)
 1023260:	dc000115 	stw	r16,4(sp)
 1023264:	dfc00a15 	stw	ra,40(sp)
 1023268:	df000915 	stw	fp,36(sp)
 102326c:	ddc00815 	stw	r23,32(sp)
 1023270:	dd800715 	stw	r22,28(sp)
 1023274:	dd400615 	stw	r21,24(sp)
 1023278:	dd000515 	stw	r20,20(sp)
 102327c:	dc800315 	stw	r18,12(sp)
 1023280:	dc400215 	stw	r17,8(sp)
 1023284:	2027883a 	mov	r19,r4
 1023288:	2821883a 	mov	r16,r5
 102328c:	3800411e 	bne	r7,zero,1023394 <__udivdi3+0x13c>
 1023290:	3023883a 	mov	r17,r6
 1023294:	2025883a 	mov	r18,r4
 1023298:	2980522e 	bgeu	r5,r6,10233e4 <__udivdi3+0x18c>
 102329c:	00bfffd4 	movui	r2,65535
 10232a0:	282d883a 	mov	r22,r5
 10232a4:	1180a836 	bltu	r2,r6,1023548 <__udivdi3+0x2f0>
 10232a8:	00803fc4 	movi	r2,255
 10232ac:	1185803a 	cmpltu	r2,r2,r6
 10232b0:	100490fa 	slli	r2,r2,3
 10232b4:	3086d83a 	srl	r3,r6,r2
 10232b8:	010040f4 	movhi	r4,259
 10232bc:	212afd04 	addi	r4,r4,-21516
 10232c0:	20c7883a 	add	r3,r4,r3
 10232c4:	18c00003 	ldbu	r3,0(r3)
 10232c8:	1885883a 	add	r2,r3,r2
 10232cc:	00c00804 	movi	r3,32
 10232d0:	1887c83a 	sub	r3,r3,r2
 10232d4:	18000526 	beq	r3,zero,10232ec <__udivdi3+0x94>
 10232d8:	80e0983a 	sll	r16,r16,r3
 10232dc:	9884d83a 	srl	r2,r19,r2
 10232e0:	30e2983a 	sll	r17,r6,r3
 10232e4:	98e4983a 	sll	r18,r19,r3
 10232e8:	142cb03a 	or	r22,r2,r16
 10232ec:	882ad43a 	srli	r21,r17,16
 10232f0:	b009883a 	mov	r4,r22
 10232f4:	8d3fffcc 	andi	r20,r17,65535
 10232f8:	a80b883a 	mov	r5,r21
 10232fc:	1023e640 	call	1023e64 <__umodsi3>
 1023300:	b009883a 	mov	r4,r22
 1023304:	a80b883a 	mov	r5,r21
 1023308:	1027883a 	mov	r19,r2
 102330c:	1023e000 	call	1023e00 <__udivsi3>
 1023310:	102d883a 	mov	r22,r2
 1023314:	9826943a 	slli	r19,r19,16
 1023318:	9004d43a 	srli	r2,r18,16
 102331c:	a5a1383a 	mul	r16,r20,r22
 1023320:	14c4b03a 	or	r2,r2,r19
 1023324:	1400052e 	bgeu	r2,r16,102333c <__udivdi3+0xe4>
 1023328:	1445883a 	add	r2,r2,r17
 102332c:	b0ffffc4 	addi	r3,r22,-1
 1023330:	14400136 	bltu	r2,r17,1023338 <__udivdi3+0xe0>
 1023334:	14012336 	bltu	r2,r16,10237c4 <__udivdi3+0x56c>
 1023338:	182d883a 	mov	r22,r3
 102333c:	1421c83a 	sub	r16,r2,r16
 1023340:	a80b883a 	mov	r5,r21
 1023344:	8009883a 	mov	r4,r16
 1023348:	1023e640 	call	1023e64 <__umodsi3>
 102334c:	1027883a 	mov	r19,r2
 1023350:	a80b883a 	mov	r5,r21
 1023354:	8009883a 	mov	r4,r16
 1023358:	1023e000 	call	1023e00 <__udivsi3>
 102335c:	9826943a 	slli	r19,r19,16
 1023360:	a0a9383a 	mul	r20,r20,r2
 1023364:	94bfffcc 	andi	r18,r18,65535
 1023368:	94e4b03a 	or	r18,r18,r19
 102336c:	9500052e 	bgeu	r18,r20,1023384 <__udivdi3+0x12c>
 1023370:	8ca5883a 	add	r18,r17,r18
 1023374:	10ffffc4 	addi	r3,r2,-1
 1023378:	9440f136 	bltu	r18,r17,1023740 <__udivdi3+0x4e8>
 102337c:	9500f02e 	bgeu	r18,r20,1023740 <__udivdi3+0x4e8>
 1023380:	10bfff84 	addi	r2,r2,-2
 1023384:	b00c943a 	slli	r6,r22,16
 1023388:	0007883a 	mov	r3,zero
 102338c:	3084b03a 	or	r2,r6,r2
 1023390:	00005906 	br	10234f8 <__udivdi3+0x2a0>
 1023394:	29c05636 	bltu	r5,r7,10234f0 <__udivdi3+0x298>
 1023398:	00bfffd4 	movui	r2,65535
 102339c:	11c0622e 	bgeu	r2,r7,1023528 <__udivdi3+0x2d0>
 10233a0:	00804034 	movhi	r2,256
 10233a4:	10bfffc4 	addi	r2,r2,-1
 10233a8:	11c0ee36 	bltu	r2,r7,1023764 <__udivdi3+0x50c>
 10233ac:	00800404 	movi	r2,16
 10233b0:	3886d83a 	srl	r3,r7,r2
 10233b4:	010040f4 	movhi	r4,259
 10233b8:	212afd04 	addi	r4,r4,-21516
 10233bc:	20c7883a 	add	r3,r4,r3
 10233c0:	18c00003 	ldbu	r3,0(r3)
 10233c4:	05400804 	movi	r21,32
 10233c8:	1885883a 	add	r2,r3,r2
 10233cc:	a8abc83a 	sub	r21,r21,r2
 10233d0:	a800621e 	bne	r21,zero,102355c <__udivdi3+0x304>
 10233d4:	3c00e936 	bltu	r7,r16,102377c <__udivdi3+0x524>
 10233d8:	9985403a 	cmpgeu	r2,r19,r6
 10233dc:	0007883a 	mov	r3,zero
 10233e0:	00004506 	br	10234f8 <__udivdi3+0x2a0>
 10233e4:	3000041e 	bne	r6,zero,10233f8 <__udivdi3+0x1a0>
 10233e8:	000b883a 	mov	r5,zero
 10233ec:	01000044 	movi	r4,1
 10233f0:	1023e000 	call	1023e00 <__udivsi3>
 10233f4:	1023883a 	mov	r17,r2
 10233f8:	00bfffd4 	movui	r2,65535
 10233fc:	14404e2e 	bgeu	r2,r17,1023538 <__udivdi3+0x2e0>
 1023400:	00804034 	movhi	r2,256
 1023404:	10bfffc4 	addi	r2,r2,-1
 1023408:	1440d836 	bltu	r2,r17,102376c <__udivdi3+0x514>
 102340c:	00800404 	movi	r2,16
 1023410:	8886d83a 	srl	r3,r17,r2
 1023414:	010040f4 	movhi	r4,259
 1023418:	212afd04 	addi	r4,r4,-21516
 102341c:	20c7883a 	add	r3,r4,r3
 1023420:	18c00003 	ldbu	r3,0(r3)
 1023424:	1885883a 	add	r2,r3,r2
 1023428:	00c00804 	movi	r3,32
 102342c:	1887c83a 	sub	r3,r3,r2
 1023430:	18008f1e 	bne	r3,zero,1023670 <__udivdi3+0x418>
 1023434:	882ad43a 	srli	r21,r17,16
 1023438:	8461c83a 	sub	r16,r16,r17
 102343c:	8d3fffcc 	andi	r20,r17,65535
 1023440:	00c00044 	movi	r3,1
 1023444:	8009883a 	mov	r4,r16
 1023448:	a80b883a 	mov	r5,r21
 102344c:	d8c00015 	stw	r3,0(sp)
 1023450:	1023e640 	call	1023e64 <__umodsi3>
 1023454:	8009883a 	mov	r4,r16
 1023458:	a80b883a 	mov	r5,r21
 102345c:	1027883a 	mov	r19,r2
 1023460:	1023e000 	call	1023e00 <__udivsi3>
 1023464:	9826943a 	slli	r19,r19,16
 1023468:	9008d43a 	srli	r4,r18,16
 102346c:	1521383a 	mul	r16,r2,r20
 1023470:	102d883a 	mov	r22,r2
 1023474:	24c8b03a 	or	r4,r4,r19
 1023478:	d8c00017 	ldw	r3,0(sp)
 102347c:	2400052e 	bgeu	r4,r16,1023494 <__udivdi3+0x23c>
 1023480:	2449883a 	add	r4,r4,r17
 1023484:	b0bfffc4 	addi	r2,r22,-1
 1023488:	24400136 	bltu	r4,r17,1023490 <__udivdi3+0x238>
 102348c:	2400ca36 	bltu	r4,r16,10237b8 <__udivdi3+0x560>
 1023490:	102d883a 	mov	r22,r2
 1023494:	2421c83a 	sub	r16,r4,r16
 1023498:	a80b883a 	mov	r5,r21
 102349c:	8009883a 	mov	r4,r16
 10234a0:	d8c00015 	stw	r3,0(sp)
 10234a4:	1023e640 	call	1023e64 <__umodsi3>
 10234a8:	1027883a 	mov	r19,r2
 10234ac:	a80b883a 	mov	r5,r21
 10234b0:	8009883a 	mov	r4,r16
 10234b4:	1023e000 	call	1023e00 <__udivsi3>
 10234b8:	9826943a 	slli	r19,r19,16
 10234bc:	1529383a 	mul	r20,r2,r20
 10234c0:	94bfffcc 	andi	r18,r18,65535
 10234c4:	94e4b03a 	or	r18,r18,r19
 10234c8:	d8c00017 	ldw	r3,0(sp)
 10234cc:	9500052e 	bgeu	r18,r20,10234e4 <__udivdi3+0x28c>
 10234d0:	8ca5883a 	add	r18,r17,r18
 10234d4:	113fffc4 	addi	r4,r2,-1
 10234d8:	94409736 	bltu	r18,r17,1023738 <__udivdi3+0x4e0>
 10234dc:	9500962e 	bgeu	r18,r20,1023738 <__udivdi3+0x4e0>
 10234e0:	10bfff84 	addi	r2,r2,-2
 10234e4:	b00c943a 	slli	r6,r22,16
 10234e8:	3084b03a 	or	r2,r6,r2
 10234ec:	00000206 	br	10234f8 <__udivdi3+0x2a0>
 10234f0:	0007883a 	mov	r3,zero
 10234f4:	0005883a 	mov	r2,zero
 10234f8:	dfc00a17 	ldw	ra,40(sp)
 10234fc:	df000917 	ldw	fp,36(sp)
 1023500:	ddc00817 	ldw	r23,32(sp)
 1023504:	dd800717 	ldw	r22,28(sp)
 1023508:	dd400617 	ldw	r21,24(sp)
 102350c:	dd000517 	ldw	r20,20(sp)
 1023510:	dcc00417 	ldw	r19,16(sp)
 1023514:	dc800317 	ldw	r18,12(sp)
 1023518:	dc400217 	ldw	r17,8(sp)
 102351c:	dc000117 	ldw	r16,4(sp)
 1023520:	dec00b04 	addi	sp,sp,44
 1023524:	f800283a 	ret
 1023528:	00803fc4 	movi	r2,255
 102352c:	11c5803a 	cmpltu	r2,r2,r7
 1023530:	100490fa 	slli	r2,r2,3
 1023534:	003f9e06 	br	10233b0 <__alt_data_end+0xff0233b0>
 1023538:	00803fc4 	movi	r2,255
 102353c:	1445803a 	cmpltu	r2,r2,r17
 1023540:	100490fa 	slli	r2,r2,3
 1023544:	003fb206 	br	1023410 <__alt_data_end+0xff023410>
 1023548:	00804034 	movhi	r2,256
 102354c:	10bfffc4 	addi	r2,r2,-1
 1023550:	11808836 	bltu	r2,r6,1023774 <__udivdi3+0x51c>
 1023554:	00800404 	movi	r2,16
 1023558:	003f5606 	br	10232b4 <__alt_data_end+0xff0232b4>
 102355c:	30aed83a 	srl	r23,r6,r2
 1023560:	3d4e983a 	sll	r7,r7,r21
 1023564:	80acd83a 	srl	r22,r16,r2
 1023568:	9884d83a 	srl	r2,r19,r2
 102356c:	3deeb03a 	or	r23,r7,r23
 1023570:	b824d43a 	srli	r18,r23,16
 1023574:	8560983a 	sll	r16,r16,r21
 1023578:	b009883a 	mov	r4,r22
 102357c:	900b883a 	mov	r5,r18
 1023580:	3568983a 	sll	r20,r6,r21
 1023584:	1420b03a 	or	r16,r2,r16
 1023588:	1023e640 	call	1023e64 <__umodsi3>
 102358c:	b009883a 	mov	r4,r22
 1023590:	900b883a 	mov	r5,r18
 1023594:	1023883a 	mov	r17,r2
 1023598:	1023e000 	call	1023e00 <__udivsi3>
 102359c:	8808943a 	slli	r4,r17,16
 10235a0:	bf3fffcc 	andi	fp,r23,65535
 10235a4:	8006d43a 	srli	r3,r16,16
 10235a8:	e0a3383a 	mul	r17,fp,r2
 10235ac:	100d883a 	mov	r6,r2
 10235b0:	1906b03a 	or	r3,r3,r4
 10235b4:	1c40042e 	bgeu	r3,r17,10235c8 <__udivdi3+0x370>
 10235b8:	1dc7883a 	add	r3,r3,r23
 10235bc:	10bfffc4 	addi	r2,r2,-1
 10235c0:	1dc0752e 	bgeu	r3,r23,1023798 <__udivdi3+0x540>
 10235c4:	100d883a 	mov	r6,r2
 10235c8:	1c63c83a 	sub	r17,r3,r17
 10235cc:	900b883a 	mov	r5,r18
 10235d0:	8809883a 	mov	r4,r17
 10235d4:	d9800015 	stw	r6,0(sp)
 10235d8:	1023e640 	call	1023e64 <__umodsi3>
 10235dc:	102d883a 	mov	r22,r2
 10235e0:	8809883a 	mov	r4,r17
 10235e4:	900b883a 	mov	r5,r18
 10235e8:	1023e000 	call	1023e00 <__udivsi3>
 10235ec:	b02c943a 	slli	r22,r22,16
 10235f0:	e089383a 	mul	r4,fp,r2
 10235f4:	843fffcc 	andi	r16,r16,65535
 10235f8:	85a0b03a 	or	r16,r16,r22
 10235fc:	d9800017 	ldw	r6,0(sp)
 1023600:	8100042e 	bgeu	r16,r4,1023614 <__udivdi3+0x3bc>
 1023604:	85e1883a 	add	r16,r16,r23
 1023608:	10ffffc4 	addi	r3,r2,-1
 102360c:	85c05e2e 	bgeu	r16,r23,1023788 <__udivdi3+0x530>
 1023610:	1805883a 	mov	r2,r3
 1023614:	300c943a 	slli	r6,r6,16
 1023618:	a17fffcc 	andi	r5,r20,65535
 102361c:	a028d43a 	srli	r20,r20,16
 1023620:	3084b03a 	or	r2,r6,r2
 1023624:	10ffffcc 	andi	r3,r2,65535
 1023628:	100cd43a 	srli	r6,r2,16
 102362c:	194f383a 	mul	r7,r3,r5
 1023630:	1d07383a 	mul	r3,r3,r20
 1023634:	314b383a 	mul	r5,r6,r5
 1023638:	3810d43a 	srli	r8,r7,16
 102363c:	8121c83a 	sub	r16,r16,r4
 1023640:	1947883a 	add	r3,r3,r5
 1023644:	40c7883a 	add	r3,r8,r3
 1023648:	350d383a 	mul	r6,r6,r20
 102364c:	1940022e 	bgeu	r3,r5,1023658 <__udivdi3+0x400>
 1023650:	01000074 	movhi	r4,1
 1023654:	310d883a 	add	r6,r6,r4
 1023658:	1828d43a 	srli	r20,r3,16
 102365c:	a18d883a 	add	r6,r20,r6
 1023660:	81803e36 	bltu	r16,r6,102375c <__udivdi3+0x504>
 1023664:	81803826 	beq	r16,r6,1023748 <__udivdi3+0x4f0>
 1023668:	0007883a 	mov	r3,zero
 102366c:	003fa206 	br	10234f8 <__alt_data_end+0xff0234f8>
 1023670:	88e2983a 	sll	r17,r17,r3
 1023674:	80a8d83a 	srl	r20,r16,r2
 1023678:	80e0983a 	sll	r16,r16,r3
 102367c:	882ad43a 	srli	r21,r17,16
 1023680:	9884d83a 	srl	r2,r19,r2
 1023684:	a009883a 	mov	r4,r20
 1023688:	a80b883a 	mov	r5,r21
 102368c:	142eb03a 	or	r23,r2,r16
 1023690:	98e4983a 	sll	r18,r19,r3
 1023694:	1023e640 	call	1023e64 <__umodsi3>
 1023698:	a009883a 	mov	r4,r20
 102369c:	a80b883a 	mov	r5,r21
 10236a0:	1021883a 	mov	r16,r2
 10236a4:	1023e000 	call	1023e00 <__udivsi3>
 10236a8:	1039883a 	mov	fp,r2
 10236ac:	8d3fffcc 	andi	r20,r17,65535
 10236b0:	8020943a 	slli	r16,r16,16
 10236b4:	b804d43a 	srli	r2,r23,16
 10236b8:	a72d383a 	mul	r22,r20,fp
 10236bc:	1404b03a 	or	r2,r2,r16
 10236c0:	1580062e 	bgeu	r2,r22,10236dc <__udivdi3+0x484>
 10236c4:	1445883a 	add	r2,r2,r17
 10236c8:	e0ffffc4 	addi	r3,fp,-1
 10236cc:	14403836 	bltu	r2,r17,10237b0 <__udivdi3+0x558>
 10236d0:	1580372e 	bgeu	r2,r22,10237b0 <__udivdi3+0x558>
 10236d4:	e73fff84 	addi	fp,fp,-2
 10236d8:	1445883a 	add	r2,r2,r17
 10236dc:	15adc83a 	sub	r22,r2,r22
 10236e0:	a80b883a 	mov	r5,r21
 10236e4:	b009883a 	mov	r4,r22
 10236e8:	1023e640 	call	1023e64 <__umodsi3>
 10236ec:	1027883a 	mov	r19,r2
 10236f0:	b009883a 	mov	r4,r22
 10236f4:	a80b883a 	mov	r5,r21
 10236f8:	1023e000 	call	1023e00 <__udivsi3>
 10236fc:	9826943a 	slli	r19,r19,16
 1023700:	a0a1383a 	mul	r16,r20,r2
 1023704:	b93fffcc 	andi	r4,r23,65535
 1023708:	24c8b03a 	or	r4,r4,r19
 102370c:	2400062e 	bgeu	r4,r16,1023728 <__udivdi3+0x4d0>
 1023710:	2449883a 	add	r4,r4,r17
 1023714:	10ffffc4 	addi	r3,r2,-1
 1023718:	24402336 	bltu	r4,r17,10237a8 <__udivdi3+0x550>
 102371c:	2400222e 	bgeu	r4,r16,10237a8 <__udivdi3+0x550>
 1023720:	10bfff84 	addi	r2,r2,-2
 1023724:	2449883a 	add	r4,r4,r17
 1023728:	e038943a 	slli	fp,fp,16
 102372c:	2421c83a 	sub	r16,r4,r16
 1023730:	e086b03a 	or	r3,fp,r2
 1023734:	003f4306 	br	1023444 <__alt_data_end+0xff023444>
 1023738:	2005883a 	mov	r2,r4
 102373c:	003f6906 	br	10234e4 <__alt_data_end+0xff0234e4>
 1023740:	1805883a 	mov	r2,r3
 1023744:	003f0f06 	br	1023384 <__alt_data_end+0xff023384>
 1023748:	1806943a 	slli	r3,r3,16
 102374c:	9d66983a 	sll	r19,r19,r21
 1023750:	39ffffcc 	andi	r7,r7,65535
 1023754:	19c7883a 	add	r3,r3,r7
 1023758:	98ffc32e 	bgeu	r19,r3,1023668 <__alt_data_end+0xff023668>
 102375c:	10bfffc4 	addi	r2,r2,-1
 1023760:	003fc106 	br	1023668 <__alt_data_end+0xff023668>
 1023764:	00800604 	movi	r2,24
 1023768:	003f1106 	br	10233b0 <__alt_data_end+0xff0233b0>
 102376c:	00800604 	movi	r2,24
 1023770:	003f2706 	br	1023410 <__alt_data_end+0xff023410>
 1023774:	00800604 	movi	r2,24
 1023778:	003ece06 	br	10232b4 <__alt_data_end+0xff0232b4>
 102377c:	0007883a 	mov	r3,zero
 1023780:	00800044 	movi	r2,1
 1023784:	003f5c06 	br	10234f8 <__alt_data_end+0xff0234f8>
 1023788:	813fa12e 	bgeu	r16,r4,1023610 <__alt_data_end+0xff023610>
 102378c:	10bfff84 	addi	r2,r2,-2
 1023790:	85e1883a 	add	r16,r16,r23
 1023794:	003f9f06 	br	1023614 <__alt_data_end+0xff023614>
 1023798:	1c7f8a2e 	bgeu	r3,r17,10235c4 <__alt_data_end+0xff0235c4>
 102379c:	31bfff84 	addi	r6,r6,-2
 10237a0:	1dc7883a 	add	r3,r3,r23
 10237a4:	003f8806 	br	10235c8 <__alt_data_end+0xff0235c8>
 10237a8:	1805883a 	mov	r2,r3
 10237ac:	003fde06 	br	1023728 <__alt_data_end+0xff023728>
 10237b0:	1839883a 	mov	fp,r3
 10237b4:	003fc906 	br	10236dc <__alt_data_end+0xff0236dc>
 10237b8:	b5bfff84 	addi	r22,r22,-2
 10237bc:	2449883a 	add	r4,r4,r17
 10237c0:	003f3406 	br	1023494 <__alt_data_end+0xff023494>
 10237c4:	b5bfff84 	addi	r22,r22,-2
 10237c8:	1445883a 	add	r2,r2,r17
 10237cc:	003edb06 	br	102333c <__alt_data_end+0xff02333c>

010237d0 <__umoddi3>:
 10237d0:	defff404 	addi	sp,sp,-48
 10237d4:	df000a15 	stw	fp,40(sp)
 10237d8:	dc400315 	stw	r17,12(sp)
 10237dc:	dc000215 	stw	r16,8(sp)
 10237e0:	dfc00b15 	stw	ra,44(sp)
 10237e4:	ddc00915 	stw	r23,36(sp)
 10237e8:	dd800815 	stw	r22,32(sp)
 10237ec:	dd400715 	stw	r21,28(sp)
 10237f0:	dd000615 	stw	r20,24(sp)
 10237f4:	dcc00515 	stw	r19,20(sp)
 10237f8:	dc800415 	stw	r18,16(sp)
 10237fc:	2021883a 	mov	r16,r4
 1023800:	2823883a 	mov	r17,r5
 1023804:	2839883a 	mov	fp,r5
 1023808:	38003c1e 	bne	r7,zero,10238fc <__umoddi3+0x12c>
 102380c:	3027883a 	mov	r19,r6
 1023810:	2029883a 	mov	r20,r4
 1023814:	2980512e 	bgeu	r5,r6,102395c <__umoddi3+0x18c>
 1023818:	00bfffd4 	movui	r2,65535
 102381c:	11809a36 	bltu	r2,r6,1023a88 <__umoddi3+0x2b8>
 1023820:	01003fc4 	movi	r4,255
 1023824:	2189803a 	cmpltu	r4,r4,r6
 1023828:	200890fa 	slli	r4,r4,3
 102382c:	3104d83a 	srl	r2,r6,r4
 1023830:	00c040f4 	movhi	r3,259
 1023834:	18eafd04 	addi	r3,r3,-21516
 1023838:	1885883a 	add	r2,r3,r2
 102383c:	10c00003 	ldbu	r3,0(r2)
 1023840:	00800804 	movi	r2,32
 1023844:	1909883a 	add	r4,r3,r4
 1023848:	1125c83a 	sub	r18,r2,r4
 102384c:	90000526 	beq	r18,zero,1023864 <__umoddi3+0x94>
 1023850:	8ca2983a 	sll	r17,r17,r18
 1023854:	8108d83a 	srl	r4,r16,r4
 1023858:	34a6983a 	sll	r19,r6,r18
 102385c:	84a8983a 	sll	r20,r16,r18
 1023860:	2478b03a 	or	fp,r4,r17
 1023864:	982ed43a 	srli	r23,r19,16
 1023868:	e009883a 	mov	r4,fp
 102386c:	9dbfffcc 	andi	r22,r19,65535
 1023870:	b80b883a 	mov	r5,r23
 1023874:	1023e640 	call	1023e64 <__umodsi3>
 1023878:	e009883a 	mov	r4,fp
 102387c:	b80b883a 	mov	r5,r23
 1023880:	102b883a 	mov	r21,r2
 1023884:	1023e000 	call	1023e00 <__udivsi3>
 1023888:	a806943a 	slli	r3,r21,16
 102388c:	a008d43a 	srli	r4,r20,16
 1023890:	b085383a 	mul	r2,r22,r2
 1023894:	20c8b03a 	or	r4,r4,r3
 1023898:	2080032e 	bgeu	r4,r2,10238a8 <__umoddi3+0xd8>
 102389c:	24c9883a 	add	r4,r4,r19
 10238a0:	24c00136 	bltu	r4,r19,10238a8 <__umoddi3+0xd8>
 10238a4:	20811036 	bltu	r4,r2,1023ce8 <__umoddi3+0x518>
 10238a8:	20abc83a 	sub	r21,r4,r2
 10238ac:	b80b883a 	mov	r5,r23
 10238b0:	a809883a 	mov	r4,r21
 10238b4:	1023e640 	call	1023e64 <__umodsi3>
 10238b8:	1023883a 	mov	r17,r2
 10238bc:	b80b883a 	mov	r5,r23
 10238c0:	a809883a 	mov	r4,r21
 10238c4:	1023e000 	call	1023e00 <__udivsi3>
 10238c8:	8822943a 	slli	r17,r17,16
 10238cc:	b085383a 	mul	r2,r22,r2
 10238d0:	a0ffffcc 	andi	r3,r20,65535
 10238d4:	1c46b03a 	or	r3,r3,r17
 10238d8:	1880042e 	bgeu	r3,r2,10238ec <__umoddi3+0x11c>
 10238dc:	1cc7883a 	add	r3,r3,r19
 10238e0:	1cc00236 	bltu	r3,r19,10238ec <__umoddi3+0x11c>
 10238e4:	1880012e 	bgeu	r3,r2,10238ec <__umoddi3+0x11c>
 10238e8:	1cc7883a 	add	r3,r3,r19
 10238ec:	1885c83a 	sub	r2,r3,r2
 10238f0:	1484d83a 	srl	r2,r2,r18
 10238f4:	0007883a 	mov	r3,zero
 10238f8:	00004f06 	br	1023a38 <__umoddi3+0x268>
 10238fc:	29c04c36 	bltu	r5,r7,1023a30 <__umoddi3+0x260>
 1023900:	00bfffd4 	movui	r2,65535
 1023904:	11c0582e 	bgeu	r2,r7,1023a68 <__umoddi3+0x298>
 1023908:	00804034 	movhi	r2,256
 102390c:	10bfffc4 	addi	r2,r2,-1
 1023910:	11c0e736 	bltu	r2,r7,1023cb0 <__umoddi3+0x4e0>
 1023914:	01000404 	movi	r4,16
 1023918:	3904d83a 	srl	r2,r7,r4
 102391c:	00c040f4 	movhi	r3,259
 1023920:	18eafd04 	addi	r3,r3,-21516
 1023924:	1885883a 	add	r2,r3,r2
 1023928:	14c00003 	ldbu	r19,0(r2)
 102392c:	00c00804 	movi	r3,32
 1023930:	9927883a 	add	r19,r19,r4
 1023934:	1ce9c83a 	sub	r20,r3,r19
 1023938:	a000581e 	bne	r20,zero,1023a9c <__umoddi3+0x2cc>
 102393c:	3c400136 	bltu	r7,r17,1023944 <__umoddi3+0x174>
 1023940:	8180eb36 	bltu	r16,r6,1023cf0 <__umoddi3+0x520>
 1023944:	8185c83a 	sub	r2,r16,r6
 1023948:	89e3c83a 	sub	r17,r17,r7
 102394c:	8089803a 	cmpltu	r4,r16,r2
 1023950:	8939c83a 	sub	fp,r17,r4
 1023954:	e007883a 	mov	r3,fp
 1023958:	00003706 	br	1023a38 <__umoddi3+0x268>
 102395c:	3000041e 	bne	r6,zero,1023970 <__umoddi3+0x1a0>
 1023960:	000b883a 	mov	r5,zero
 1023964:	01000044 	movi	r4,1
 1023968:	1023e000 	call	1023e00 <__udivsi3>
 102396c:	1027883a 	mov	r19,r2
 1023970:	00bfffd4 	movui	r2,65535
 1023974:	14c0402e 	bgeu	r2,r19,1023a78 <__umoddi3+0x2a8>
 1023978:	00804034 	movhi	r2,256
 102397c:	10bfffc4 	addi	r2,r2,-1
 1023980:	14c0cd36 	bltu	r2,r19,1023cb8 <__umoddi3+0x4e8>
 1023984:	00800404 	movi	r2,16
 1023988:	9886d83a 	srl	r3,r19,r2
 102398c:	010040f4 	movhi	r4,259
 1023990:	212afd04 	addi	r4,r4,-21516
 1023994:	20c7883a 	add	r3,r4,r3
 1023998:	18c00003 	ldbu	r3,0(r3)
 102399c:	1887883a 	add	r3,r3,r2
 10239a0:	00800804 	movi	r2,32
 10239a4:	10e5c83a 	sub	r18,r2,r3
 10239a8:	9000901e 	bne	r18,zero,1023bec <__umoddi3+0x41c>
 10239ac:	982cd43a 	srli	r22,r19,16
 10239b0:	8ce3c83a 	sub	r17,r17,r19
 10239b4:	9d7fffcc 	andi	r21,r19,65535
 10239b8:	b00b883a 	mov	r5,r22
 10239bc:	8809883a 	mov	r4,r17
 10239c0:	1023e640 	call	1023e64 <__umodsi3>
 10239c4:	8809883a 	mov	r4,r17
 10239c8:	b00b883a 	mov	r5,r22
 10239cc:	1021883a 	mov	r16,r2
 10239d0:	1023e000 	call	1023e00 <__udivsi3>
 10239d4:	8006943a 	slli	r3,r16,16
 10239d8:	a008d43a 	srli	r4,r20,16
 10239dc:	1545383a 	mul	r2,r2,r21
 10239e0:	20c8b03a 	or	r4,r4,r3
 10239e4:	2080042e 	bgeu	r4,r2,10239f8 <__umoddi3+0x228>
 10239e8:	24c9883a 	add	r4,r4,r19
 10239ec:	24c00236 	bltu	r4,r19,10239f8 <__umoddi3+0x228>
 10239f0:	2080012e 	bgeu	r4,r2,10239f8 <__umoddi3+0x228>
 10239f4:	24c9883a 	add	r4,r4,r19
 10239f8:	20a1c83a 	sub	r16,r4,r2
 10239fc:	b00b883a 	mov	r5,r22
 1023a00:	8009883a 	mov	r4,r16
 1023a04:	1023e640 	call	1023e64 <__umodsi3>
 1023a08:	1023883a 	mov	r17,r2
 1023a0c:	b00b883a 	mov	r5,r22
 1023a10:	8009883a 	mov	r4,r16
 1023a14:	1023e000 	call	1023e00 <__udivsi3>
 1023a18:	8822943a 	slli	r17,r17,16
 1023a1c:	1545383a 	mul	r2,r2,r21
 1023a20:	a53fffcc 	andi	r20,r20,65535
 1023a24:	a446b03a 	or	r3,r20,r17
 1023a28:	18bfb02e 	bgeu	r3,r2,10238ec <__alt_data_end+0xff0238ec>
 1023a2c:	003fab06 	br	10238dc <__alt_data_end+0xff0238dc>
 1023a30:	2005883a 	mov	r2,r4
 1023a34:	2807883a 	mov	r3,r5
 1023a38:	dfc00b17 	ldw	ra,44(sp)
 1023a3c:	df000a17 	ldw	fp,40(sp)
 1023a40:	ddc00917 	ldw	r23,36(sp)
 1023a44:	dd800817 	ldw	r22,32(sp)
 1023a48:	dd400717 	ldw	r21,28(sp)
 1023a4c:	dd000617 	ldw	r20,24(sp)
 1023a50:	dcc00517 	ldw	r19,20(sp)
 1023a54:	dc800417 	ldw	r18,16(sp)
 1023a58:	dc400317 	ldw	r17,12(sp)
 1023a5c:	dc000217 	ldw	r16,8(sp)
 1023a60:	dec00c04 	addi	sp,sp,48
 1023a64:	f800283a 	ret
 1023a68:	04c03fc4 	movi	r19,255
 1023a6c:	99c9803a 	cmpltu	r4,r19,r7
 1023a70:	200890fa 	slli	r4,r4,3
 1023a74:	003fa806 	br	1023918 <__alt_data_end+0xff023918>
 1023a78:	00803fc4 	movi	r2,255
 1023a7c:	14c5803a 	cmpltu	r2,r2,r19
 1023a80:	100490fa 	slli	r2,r2,3
 1023a84:	003fc006 	br	1023988 <__alt_data_end+0xff023988>
 1023a88:	00804034 	movhi	r2,256
 1023a8c:	10bfffc4 	addi	r2,r2,-1
 1023a90:	11808b36 	bltu	r2,r6,1023cc0 <__umoddi3+0x4f0>
 1023a94:	01000404 	movi	r4,16
 1023a98:	003f6406 	br	102382c <__alt_data_end+0xff02382c>
 1023a9c:	34c4d83a 	srl	r2,r6,r19
 1023aa0:	3d0e983a 	sll	r7,r7,r20
 1023aa4:	8cf8d83a 	srl	fp,r17,r19
 1023aa8:	8d10983a 	sll	r8,r17,r20
 1023aac:	38aab03a 	or	r21,r7,r2
 1023ab0:	a82cd43a 	srli	r22,r21,16
 1023ab4:	84e2d83a 	srl	r17,r16,r19
 1023ab8:	e009883a 	mov	r4,fp
 1023abc:	b00b883a 	mov	r5,r22
 1023ac0:	8a22b03a 	or	r17,r17,r8
 1023ac4:	3524983a 	sll	r18,r6,r20
 1023ac8:	1023e640 	call	1023e64 <__umodsi3>
 1023acc:	e009883a 	mov	r4,fp
 1023ad0:	b00b883a 	mov	r5,r22
 1023ad4:	102f883a 	mov	r23,r2
 1023ad8:	1023e000 	call	1023e00 <__udivsi3>
 1023adc:	100d883a 	mov	r6,r2
 1023ae0:	b808943a 	slli	r4,r23,16
 1023ae4:	aa3fffcc 	andi	r8,r21,65535
 1023ae8:	8804d43a 	srli	r2,r17,16
 1023aec:	41af383a 	mul	r23,r8,r6
 1023af0:	8520983a 	sll	r16,r16,r20
 1023af4:	1104b03a 	or	r2,r2,r4
 1023af8:	15c0042e 	bgeu	r2,r23,1023b0c <__umoddi3+0x33c>
 1023afc:	1545883a 	add	r2,r2,r21
 1023b00:	30ffffc4 	addi	r3,r6,-1
 1023b04:	1540742e 	bgeu	r2,r21,1023cd8 <__umoddi3+0x508>
 1023b08:	180d883a 	mov	r6,r3
 1023b0c:	15efc83a 	sub	r23,r2,r23
 1023b10:	b00b883a 	mov	r5,r22
 1023b14:	b809883a 	mov	r4,r23
 1023b18:	d9800115 	stw	r6,4(sp)
 1023b1c:	da000015 	stw	r8,0(sp)
 1023b20:	1023e640 	call	1023e64 <__umodsi3>
 1023b24:	b00b883a 	mov	r5,r22
 1023b28:	b809883a 	mov	r4,r23
 1023b2c:	1039883a 	mov	fp,r2
 1023b30:	1023e000 	call	1023e00 <__udivsi3>
 1023b34:	da000017 	ldw	r8,0(sp)
 1023b38:	e038943a 	slli	fp,fp,16
 1023b3c:	100b883a 	mov	r5,r2
 1023b40:	4089383a 	mul	r4,r8,r2
 1023b44:	8a3fffcc 	andi	r8,r17,65535
 1023b48:	4710b03a 	or	r8,r8,fp
 1023b4c:	d9800117 	ldw	r6,4(sp)
 1023b50:	4100042e 	bgeu	r8,r4,1023b64 <__umoddi3+0x394>
 1023b54:	4551883a 	add	r8,r8,r21
 1023b58:	10bfffc4 	addi	r2,r2,-1
 1023b5c:	45405a2e 	bgeu	r8,r21,1023cc8 <__umoddi3+0x4f8>
 1023b60:	100b883a 	mov	r5,r2
 1023b64:	300c943a 	slli	r6,r6,16
 1023b68:	91ffffcc 	andi	r7,r18,65535
 1023b6c:	9004d43a 	srli	r2,r18,16
 1023b70:	314cb03a 	or	r6,r6,r5
 1023b74:	317fffcc 	andi	r5,r6,65535
 1023b78:	300cd43a 	srli	r6,r6,16
 1023b7c:	29d3383a 	mul	r9,r5,r7
 1023b80:	288b383a 	mul	r5,r5,r2
 1023b84:	31cf383a 	mul	r7,r6,r7
 1023b88:	4806d43a 	srli	r3,r9,16
 1023b8c:	4111c83a 	sub	r8,r8,r4
 1023b90:	29cb883a 	add	r5,r5,r7
 1023b94:	194b883a 	add	r5,r3,r5
 1023b98:	3085383a 	mul	r2,r6,r2
 1023b9c:	29c0022e 	bgeu	r5,r7,1023ba8 <__umoddi3+0x3d8>
 1023ba0:	00c00074 	movhi	r3,1
 1023ba4:	10c5883a 	add	r2,r2,r3
 1023ba8:	2808d43a 	srli	r4,r5,16
 1023bac:	280a943a 	slli	r5,r5,16
 1023bb0:	4a7fffcc 	andi	r9,r9,65535
 1023bb4:	2085883a 	add	r2,r4,r2
 1023bb8:	2a4b883a 	add	r5,r5,r9
 1023bbc:	40803636 	bltu	r8,r2,1023c98 <__umoddi3+0x4c8>
 1023bc0:	40804d26 	beq	r8,r2,1023cf8 <__umoddi3+0x528>
 1023bc4:	4089c83a 	sub	r4,r8,r2
 1023bc8:	280f883a 	mov	r7,r5
 1023bcc:	81cfc83a 	sub	r7,r16,r7
 1023bd0:	81c7803a 	cmpltu	r3,r16,r7
 1023bd4:	20c7c83a 	sub	r3,r4,r3
 1023bd8:	1cc4983a 	sll	r2,r3,r19
 1023bdc:	3d0ed83a 	srl	r7,r7,r20
 1023be0:	1d06d83a 	srl	r3,r3,r20
 1023be4:	11c4b03a 	or	r2,r2,r7
 1023be8:	003f9306 	br	1023a38 <__alt_data_end+0xff023a38>
 1023bec:	9ca6983a 	sll	r19,r19,r18
 1023bf0:	88e8d83a 	srl	r20,r17,r3
 1023bf4:	80c4d83a 	srl	r2,r16,r3
 1023bf8:	982cd43a 	srli	r22,r19,16
 1023bfc:	8ca2983a 	sll	r17,r17,r18
 1023c00:	a009883a 	mov	r4,r20
 1023c04:	b00b883a 	mov	r5,r22
 1023c08:	1478b03a 	or	fp,r2,r17
 1023c0c:	1023e640 	call	1023e64 <__umodsi3>
 1023c10:	a009883a 	mov	r4,r20
 1023c14:	b00b883a 	mov	r5,r22
 1023c18:	1023883a 	mov	r17,r2
 1023c1c:	1023e000 	call	1023e00 <__udivsi3>
 1023c20:	9d7fffcc 	andi	r21,r19,65535
 1023c24:	880a943a 	slli	r5,r17,16
 1023c28:	e008d43a 	srli	r4,fp,16
 1023c2c:	a885383a 	mul	r2,r21,r2
 1023c30:	84a8983a 	sll	r20,r16,r18
 1023c34:	2148b03a 	or	r4,r4,r5
 1023c38:	2080042e 	bgeu	r4,r2,1023c4c <__umoddi3+0x47c>
 1023c3c:	24c9883a 	add	r4,r4,r19
 1023c40:	24c00236 	bltu	r4,r19,1023c4c <__umoddi3+0x47c>
 1023c44:	2080012e 	bgeu	r4,r2,1023c4c <__umoddi3+0x47c>
 1023c48:	24c9883a 	add	r4,r4,r19
 1023c4c:	20a3c83a 	sub	r17,r4,r2
 1023c50:	b00b883a 	mov	r5,r22
 1023c54:	8809883a 	mov	r4,r17
 1023c58:	1023e640 	call	1023e64 <__umodsi3>
 1023c5c:	102f883a 	mov	r23,r2
 1023c60:	8809883a 	mov	r4,r17
 1023c64:	b00b883a 	mov	r5,r22
 1023c68:	1023e000 	call	1023e00 <__udivsi3>
 1023c6c:	b82e943a 	slli	r23,r23,16
 1023c70:	a885383a 	mul	r2,r21,r2
 1023c74:	e13fffcc 	andi	r4,fp,65535
 1023c78:	25c8b03a 	or	r4,r4,r23
 1023c7c:	2080042e 	bgeu	r4,r2,1023c90 <__umoddi3+0x4c0>
 1023c80:	24c9883a 	add	r4,r4,r19
 1023c84:	24c00236 	bltu	r4,r19,1023c90 <__umoddi3+0x4c0>
 1023c88:	2080012e 	bgeu	r4,r2,1023c90 <__umoddi3+0x4c0>
 1023c8c:	24c9883a 	add	r4,r4,r19
 1023c90:	20a3c83a 	sub	r17,r4,r2
 1023c94:	003f4806 	br	10239b8 <__alt_data_end+0xff0239b8>
 1023c98:	2c8fc83a 	sub	r7,r5,r18
 1023c9c:	1545c83a 	sub	r2,r2,r21
 1023ca0:	29cb803a 	cmpltu	r5,r5,r7
 1023ca4:	1145c83a 	sub	r2,r2,r5
 1023ca8:	4089c83a 	sub	r4,r8,r2
 1023cac:	003fc706 	br	1023bcc <__alt_data_end+0xff023bcc>
 1023cb0:	01000604 	movi	r4,24
 1023cb4:	003f1806 	br	1023918 <__alt_data_end+0xff023918>
 1023cb8:	00800604 	movi	r2,24
 1023cbc:	003f3206 	br	1023988 <__alt_data_end+0xff023988>
 1023cc0:	01000604 	movi	r4,24
 1023cc4:	003ed906 	br	102382c <__alt_data_end+0xff02382c>
 1023cc8:	413fa52e 	bgeu	r8,r4,1023b60 <__alt_data_end+0xff023b60>
 1023ccc:	297fff84 	addi	r5,r5,-2
 1023cd0:	4551883a 	add	r8,r8,r21
 1023cd4:	003fa306 	br	1023b64 <__alt_data_end+0xff023b64>
 1023cd8:	15ff8b2e 	bgeu	r2,r23,1023b08 <__alt_data_end+0xff023b08>
 1023cdc:	31bfff84 	addi	r6,r6,-2
 1023ce0:	1545883a 	add	r2,r2,r21
 1023ce4:	003f8906 	br	1023b0c <__alt_data_end+0xff023b0c>
 1023ce8:	24c9883a 	add	r4,r4,r19
 1023cec:	003eee06 	br	10238a8 <__alt_data_end+0xff0238a8>
 1023cf0:	8005883a 	mov	r2,r16
 1023cf4:	003f1706 	br	1023954 <__alt_data_end+0xff023954>
 1023cf8:	817fe736 	bltu	r16,r5,1023c98 <__alt_data_end+0xff023c98>
 1023cfc:	280f883a 	mov	r7,r5
 1023d00:	0009883a 	mov	r4,zero
 1023d04:	003fb106 	br	1023bcc <__alt_data_end+0xff023bcc>

01023d08 <__divsi3>:
 1023d08:	20001b16 	blt	r4,zero,1023d78 <__divsi3+0x70>
 1023d0c:	000f883a 	mov	r7,zero
 1023d10:	28001616 	blt	r5,zero,1023d6c <__divsi3+0x64>
 1023d14:	200d883a 	mov	r6,r4
 1023d18:	29001a2e 	bgeu	r5,r4,1023d84 <__divsi3+0x7c>
 1023d1c:	00800804 	movi	r2,32
 1023d20:	00c00044 	movi	r3,1
 1023d24:	00000106 	br	1023d2c <__divsi3+0x24>
 1023d28:	10000d26 	beq	r2,zero,1023d60 <__divsi3+0x58>
 1023d2c:	294b883a 	add	r5,r5,r5
 1023d30:	10bfffc4 	addi	r2,r2,-1
 1023d34:	18c7883a 	add	r3,r3,r3
 1023d38:	293ffb36 	bltu	r5,r4,1023d28 <__alt_data_end+0xff023d28>
 1023d3c:	0005883a 	mov	r2,zero
 1023d40:	18000726 	beq	r3,zero,1023d60 <__divsi3+0x58>
 1023d44:	0005883a 	mov	r2,zero
 1023d48:	31400236 	bltu	r6,r5,1023d54 <__divsi3+0x4c>
 1023d4c:	314dc83a 	sub	r6,r6,r5
 1023d50:	10c4b03a 	or	r2,r2,r3
 1023d54:	1806d07a 	srli	r3,r3,1
 1023d58:	280ad07a 	srli	r5,r5,1
 1023d5c:	183ffa1e 	bne	r3,zero,1023d48 <__alt_data_end+0xff023d48>
 1023d60:	38000126 	beq	r7,zero,1023d68 <__divsi3+0x60>
 1023d64:	0085c83a 	sub	r2,zero,r2
 1023d68:	f800283a 	ret
 1023d6c:	014bc83a 	sub	r5,zero,r5
 1023d70:	39c0005c 	xori	r7,r7,1
 1023d74:	003fe706 	br	1023d14 <__alt_data_end+0xff023d14>
 1023d78:	0109c83a 	sub	r4,zero,r4
 1023d7c:	01c00044 	movi	r7,1
 1023d80:	003fe306 	br	1023d10 <__alt_data_end+0xff023d10>
 1023d84:	00c00044 	movi	r3,1
 1023d88:	003fee06 	br	1023d44 <__alt_data_end+0xff023d44>

01023d8c <__modsi3>:
 1023d8c:	20001716 	blt	r4,zero,1023dec <__modsi3+0x60>
 1023d90:	000f883a 	mov	r7,zero
 1023d94:	2005883a 	mov	r2,r4
 1023d98:	28001216 	blt	r5,zero,1023de4 <__modsi3+0x58>
 1023d9c:	2900162e 	bgeu	r5,r4,1023df8 <__modsi3+0x6c>
 1023da0:	01800804 	movi	r6,32
 1023da4:	00c00044 	movi	r3,1
 1023da8:	00000106 	br	1023db0 <__modsi3+0x24>
 1023dac:	30000a26 	beq	r6,zero,1023dd8 <__modsi3+0x4c>
 1023db0:	294b883a 	add	r5,r5,r5
 1023db4:	31bfffc4 	addi	r6,r6,-1
 1023db8:	18c7883a 	add	r3,r3,r3
 1023dbc:	293ffb36 	bltu	r5,r4,1023dac <__alt_data_end+0xff023dac>
 1023dc0:	18000526 	beq	r3,zero,1023dd8 <__modsi3+0x4c>
 1023dc4:	1806d07a 	srli	r3,r3,1
 1023dc8:	11400136 	bltu	r2,r5,1023dd0 <__modsi3+0x44>
 1023dcc:	1145c83a 	sub	r2,r2,r5
 1023dd0:	280ad07a 	srli	r5,r5,1
 1023dd4:	183ffb1e 	bne	r3,zero,1023dc4 <__alt_data_end+0xff023dc4>
 1023dd8:	38000126 	beq	r7,zero,1023de0 <__modsi3+0x54>
 1023ddc:	0085c83a 	sub	r2,zero,r2
 1023de0:	f800283a 	ret
 1023de4:	014bc83a 	sub	r5,zero,r5
 1023de8:	003fec06 	br	1023d9c <__alt_data_end+0xff023d9c>
 1023dec:	0109c83a 	sub	r4,zero,r4
 1023df0:	01c00044 	movi	r7,1
 1023df4:	003fe706 	br	1023d94 <__alt_data_end+0xff023d94>
 1023df8:	00c00044 	movi	r3,1
 1023dfc:	003ff106 	br	1023dc4 <__alt_data_end+0xff023dc4>

01023e00 <__udivsi3>:
 1023e00:	200d883a 	mov	r6,r4
 1023e04:	2900152e 	bgeu	r5,r4,1023e5c <__udivsi3+0x5c>
 1023e08:	28001416 	blt	r5,zero,1023e5c <__udivsi3+0x5c>
 1023e0c:	00800804 	movi	r2,32
 1023e10:	00c00044 	movi	r3,1
 1023e14:	00000206 	br	1023e20 <__udivsi3+0x20>
 1023e18:	10000e26 	beq	r2,zero,1023e54 <__udivsi3+0x54>
 1023e1c:	28000516 	blt	r5,zero,1023e34 <__udivsi3+0x34>
 1023e20:	294b883a 	add	r5,r5,r5
 1023e24:	10bfffc4 	addi	r2,r2,-1
 1023e28:	18c7883a 	add	r3,r3,r3
 1023e2c:	293ffa36 	bltu	r5,r4,1023e18 <__alt_data_end+0xff023e18>
 1023e30:	18000826 	beq	r3,zero,1023e54 <__udivsi3+0x54>
 1023e34:	0005883a 	mov	r2,zero
 1023e38:	31400236 	bltu	r6,r5,1023e44 <__udivsi3+0x44>
 1023e3c:	314dc83a 	sub	r6,r6,r5
 1023e40:	10c4b03a 	or	r2,r2,r3
 1023e44:	1806d07a 	srli	r3,r3,1
 1023e48:	280ad07a 	srli	r5,r5,1
 1023e4c:	183ffa1e 	bne	r3,zero,1023e38 <__alt_data_end+0xff023e38>
 1023e50:	f800283a 	ret
 1023e54:	0005883a 	mov	r2,zero
 1023e58:	f800283a 	ret
 1023e5c:	00c00044 	movi	r3,1
 1023e60:	003ff406 	br	1023e34 <__alt_data_end+0xff023e34>

01023e64 <__umodsi3>:
 1023e64:	2005883a 	mov	r2,r4
 1023e68:	2900122e 	bgeu	r5,r4,1023eb4 <__umodsi3+0x50>
 1023e6c:	28001116 	blt	r5,zero,1023eb4 <__umodsi3+0x50>
 1023e70:	01800804 	movi	r6,32
 1023e74:	00c00044 	movi	r3,1
 1023e78:	00000206 	br	1023e84 <__umodsi3+0x20>
 1023e7c:	30000c26 	beq	r6,zero,1023eb0 <__umodsi3+0x4c>
 1023e80:	28000516 	blt	r5,zero,1023e98 <__umodsi3+0x34>
 1023e84:	294b883a 	add	r5,r5,r5
 1023e88:	31bfffc4 	addi	r6,r6,-1
 1023e8c:	18c7883a 	add	r3,r3,r3
 1023e90:	293ffa36 	bltu	r5,r4,1023e7c <__alt_data_end+0xff023e7c>
 1023e94:	18000626 	beq	r3,zero,1023eb0 <__umodsi3+0x4c>
 1023e98:	1806d07a 	srli	r3,r3,1
 1023e9c:	11400136 	bltu	r2,r5,1023ea4 <__umodsi3+0x40>
 1023ea0:	1145c83a 	sub	r2,r2,r5
 1023ea4:	280ad07a 	srli	r5,r5,1
 1023ea8:	183ffb1e 	bne	r3,zero,1023e98 <__alt_data_end+0xff023e98>
 1023eac:	f800283a 	ret
 1023eb0:	f800283a 	ret
 1023eb4:	00c00044 	movi	r3,1
 1023eb8:	003ff706 	br	1023e98 <__alt_data_end+0xff023e98>

01023ebc <__adddf3>:
 1023ebc:	02c00434 	movhi	r11,16
 1023ec0:	5affffc4 	addi	r11,r11,-1
 1023ec4:	2806d7fa 	srli	r3,r5,31
 1023ec8:	2ad4703a 	and	r10,r5,r11
 1023ecc:	3ad2703a 	and	r9,r7,r11
 1023ed0:	3804d53a 	srli	r2,r7,20
 1023ed4:	3018d77a 	srli	r12,r6,29
 1023ed8:	280ad53a 	srli	r5,r5,20
 1023edc:	501490fa 	slli	r10,r10,3
 1023ee0:	2010d77a 	srli	r8,r4,29
 1023ee4:	481290fa 	slli	r9,r9,3
 1023ee8:	380ed7fa 	srli	r7,r7,31
 1023eec:	defffb04 	addi	sp,sp,-20
 1023ef0:	dc800215 	stw	r18,8(sp)
 1023ef4:	dc400115 	stw	r17,4(sp)
 1023ef8:	dc000015 	stw	r16,0(sp)
 1023efc:	dfc00415 	stw	ra,16(sp)
 1023f00:	dcc00315 	stw	r19,12(sp)
 1023f04:	1c803fcc 	andi	r18,r3,255
 1023f08:	2c01ffcc 	andi	r16,r5,2047
 1023f0c:	5210b03a 	or	r8,r10,r8
 1023f10:	202290fa 	slli	r17,r4,3
 1023f14:	1081ffcc 	andi	r2,r2,2047
 1023f18:	4b12b03a 	or	r9,r9,r12
 1023f1c:	300c90fa 	slli	r6,r6,3
 1023f20:	91c07526 	beq	r18,r7,10240f8 <__adddf3+0x23c>
 1023f24:	8087c83a 	sub	r3,r16,r2
 1023f28:	00c0ab0e 	bge	zero,r3,10241d8 <__adddf3+0x31c>
 1023f2c:	10002a1e 	bne	r2,zero,1023fd8 <__adddf3+0x11c>
 1023f30:	4984b03a 	or	r2,r9,r6
 1023f34:	1000961e 	bne	r2,zero,1024190 <__adddf3+0x2d4>
 1023f38:	888001cc 	andi	r2,r17,7
 1023f3c:	10000726 	beq	r2,zero,1023f5c <__adddf3+0xa0>
 1023f40:	888003cc 	andi	r2,r17,15
 1023f44:	00c00104 	movi	r3,4
 1023f48:	10c00426 	beq	r2,r3,1023f5c <__adddf3+0xa0>
 1023f4c:	88c7883a 	add	r3,r17,r3
 1023f50:	1c63803a 	cmpltu	r17,r3,r17
 1023f54:	4451883a 	add	r8,r8,r17
 1023f58:	1823883a 	mov	r17,r3
 1023f5c:	4080202c 	andhi	r2,r8,128
 1023f60:	10005926 	beq	r2,zero,10240c8 <__adddf3+0x20c>
 1023f64:	84000044 	addi	r16,r16,1
 1023f68:	0081ffc4 	movi	r2,2047
 1023f6c:	8080ba26 	beq	r16,r2,1024258 <__adddf3+0x39c>
 1023f70:	00bfe034 	movhi	r2,65408
 1023f74:	10bfffc4 	addi	r2,r2,-1
 1023f78:	4090703a 	and	r8,r8,r2
 1023f7c:	4004977a 	slli	r2,r8,29
 1023f80:	4010927a 	slli	r8,r8,9
 1023f84:	8822d0fa 	srli	r17,r17,3
 1023f88:	8401ffcc 	andi	r16,r16,2047
 1023f8c:	4010d33a 	srli	r8,r8,12
 1023f90:	9007883a 	mov	r3,r18
 1023f94:	1444b03a 	or	r2,r2,r17
 1023f98:	8401ffcc 	andi	r16,r16,2047
 1023f9c:	8020953a 	slli	r16,r16,20
 1023fa0:	18c03fcc 	andi	r3,r3,255
 1023fa4:	01000434 	movhi	r4,16
 1023fa8:	213fffc4 	addi	r4,r4,-1
 1023fac:	180697fa 	slli	r3,r3,31
 1023fb0:	4110703a 	and	r8,r8,r4
 1023fb4:	4410b03a 	or	r8,r8,r16
 1023fb8:	40c6b03a 	or	r3,r8,r3
 1023fbc:	dfc00417 	ldw	ra,16(sp)
 1023fc0:	dcc00317 	ldw	r19,12(sp)
 1023fc4:	dc800217 	ldw	r18,8(sp)
 1023fc8:	dc400117 	ldw	r17,4(sp)
 1023fcc:	dc000017 	ldw	r16,0(sp)
 1023fd0:	dec00504 	addi	sp,sp,20
 1023fd4:	f800283a 	ret
 1023fd8:	0081ffc4 	movi	r2,2047
 1023fdc:	80bfd626 	beq	r16,r2,1023f38 <__alt_data_end+0xff023f38>
 1023fe0:	4a402034 	orhi	r9,r9,128
 1023fe4:	00800e04 	movi	r2,56
 1023fe8:	10c09f16 	blt	r2,r3,1024268 <__adddf3+0x3ac>
 1023fec:	008007c4 	movi	r2,31
 1023ff0:	10c0c216 	blt	r2,r3,10242fc <__adddf3+0x440>
 1023ff4:	00800804 	movi	r2,32
 1023ff8:	10c5c83a 	sub	r2,r2,r3
 1023ffc:	488a983a 	sll	r5,r9,r2
 1024000:	30c8d83a 	srl	r4,r6,r3
 1024004:	3084983a 	sll	r2,r6,r2
 1024008:	48c6d83a 	srl	r3,r9,r3
 102400c:	290cb03a 	or	r6,r5,r4
 1024010:	1004c03a 	cmpne	r2,r2,zero
 1024014:	308cb03a 	or	r6,r6,r2
 1024018:	898dc83a 	sub	r6,r17,r6
 102401c:	89a3803a 	cmpltu	r17,r17,r6
 1024020:	40d1c83a 	sub	r8,r8,r3
 1024024:	4451c83a 	sub	r8,r8,r17
 1024028:	3023883a 	mov	r17,r6
 102402c:	4080202c 	andhi	r2,r8,128
 1024030:	10002326 	beq	r2,zero,10240c0 <__adddf3+0x204>
 1024034:	04c02034 	movhi	r19,128
 1024038:	9cffffc4 	addi	r19,r19,-1
 102403c:	44e6703a 	and	r19,r8,r19
 1024040:	98007626 	beq	r19,zero,102421c <__adddf3+0x360>
 1024044:	9809883a 	mov	r4,r19
 1024048:	10264c00 	call	10264c0 <__clzsi2>
 102404c:	10fffe04 	addi	r3,r2,-8
 1024050:	010007c4 	movi	r4,31
 1024054:	20c07716 	blt	r4,r3,1024234 <__adddf3+0x378>
 1024058:	00800804 	movi	r2,32
 102405c:	10c5c83a 	sub	r2,r2,r3
 1024060:	8884d83a 	srl	r2,r17,r2
 1024064:	98d0983a 	sll	r8,r19,r3
 1024068:	88e2983a 	sll	r17,r17,r3
 102406c:	1204b03a 	or	r2,r2,r8
 1024070:	1c007416 	blt	r3,r16,1024244 <__adddf3+0x388>
 1024074:	1c21c83a 	sub	r16,r3,r16
 1024078:	82000044 	addi	r8,r16,1
 102407c:	00c007c4 	movi	r3,31
 1024080:	1a009116 	blt	r3,r8,10242c8 <__adddf3+0x40c>
 1024084:	00c00804 	movi	r3,32
 1024088:	1a07c83a 	sub	r3,r3,r8
 102408c:	8a08d83a 	srl	r4,r17,r8
 1024090:	88e2983a 	sll	r17,r17,r3
 1024094:	10c6983a 	sll	r3,r2,r3
 1024098:	1210d83a 	srl	r8,r2,r8
 102409c:	8804c03a 	cmpne	r2,r17,zero
 10240a0:	1906b03a 	or	r3,r3,r4
 10240a4:	18a2b03a 	or	r17,r3,r2
 10240a8:	0021883a 	mov	r16,zero
 10240ac:	003fa206 	br	1023f38 <__alt_data_end+0xff023f38>
 10240b0:	1890b03a 	or	r8,r3,r2
 10240b4:	40017d26 	beq	r8,zero,10246ac <__adddf3+0x7f0>
 10240b8:	1011883a 	mov	r8,r2
 10240bc:	1823883a 	mov	r17,r3
 10240c0:	888001cc 	andi	r2,r17,7
 10240c4:	103f9e1e 	bne	r2,zero,1023f40 <__alt_data_end+0xff023f40>
 10240c8:	4004977a 	slli	r2,r8,29
 10240cc:	8822d0fa 	srli	r17,r17,3
 10240d0:	4010d0fa 	srli	r8,r8,3
 10240d4:	9007883a 	mov	r3,r18
 10240d8:	1444b03a 	or	r2,r2,r17
 10240dc:	0101ffc4 	movi	r4,2047
 10240e0:	81002426 	beq	r16,r4,1024174 <__adddf3+0x2b8>
 10240e4:	8120703a 	and	r16,r16,r4
 10240e8:	01000434 	movhi	r4,16
 10240ec:	213fffc4 	addi	r4,r4,-1
 10240f0:	4110703a 	and	r8,r8,r4
 10240f4:	003fa806 	br	1023f98 <__alt_data_end+0xff023f98>
 10240f8:	8089c83a 	sub	r4,r16,r2
 10240fc:	01005e0e 	bge	zero,r4,1024278 <__adddf3+0x3bc>
 1024100:	10002b26 	beq	r2,zero,10241b0 <__adddf3+0x2f4>
 1024104:	0081ffc4 	movi	r2,2047
 1024108:	80bf8b26 	beq	r16,r2,1023f38 <__alt_data_end+0xff023f38>
 102410c:	4a402034 	orhi	r9,r9,128
 1024110:	00800e04 	movi	r2,56
 1024114:	1100a40e 	bge	r2,r4,10243a8 <__adddf3+0x4ec>
 1024118:	498cb03a 	or	r6,r9,r6
 102411c:	300ac03a 	cmpne	r5,r6,zero
 1024120:	0013883a 	mov	r9,zero
 1024124:	2c4b883a 	add	r5,r5,r17
 1024128:	2c63803a 	cmpltu	r17,r5,r17
 102412c:	4a11883a 	add	r8,r9,r8
 1024130:	8a11883a 	add	r8,r17,r8
 1024134:	2823883a 	mov	r17,r5
 1024138:	4080202c 	andhi	r2,r8,128
 102413c:	103fe026 	beq	r2,zero,10240c0 <__alt_data_end+0xff0240c0>
 1024140:	84000044 	addi	r16,r16,1
 1024144:	0081ffc4 	movi	r2,2047
 1024148:	8080d226 	beq	r16,r2,1024494 <__adddf3+0x5d8>
 102414c:	00bfe034 	movhi	r2,65408
 1024150:	10bfffc4 	addi	r2,r2,-1
 1024154:	4090703a 	and	r8,r8,r2
 1024158:	880ad07a 	srli	r5,r17,1
 102415c:	400897fa 	slli	r4,r8,31
 1024160:	88c0004c 	andi	r3,r17,1
 1024164:	28e2b03a 	or	r17,r5,r3
 1024168:	4010d07a 	srli	r8,r8,1
 102416c:	2462b03a 	or	r17,r4,r17
 1024170:	003f7106 	br	1023f38 <__alt_data_end+0xff023f38>
 1024174:	4088b03a 	or	r4,r8,r2
 1024178:	20014526 	beq	r4,zero,1024690 <__adddf3+0x7d4>
 102417c:	01000434 	movhi	r4,16
 1024180:	42000234 	orhi	r8,r8,8
 1024184:	213fffc4 	addi	r4,r4,-1
 1024188:	4110703a 	and	r8,r8,r4
 102418c:	003f8206 	br	1023f98 <__alt_data_end+0xff023f98>
 1024190:	18ffffc4 	addi	r3,r3,-1
 1024194:	1800491e 	bne	r3,zero,10242bc <__adddf3+0x400>
 1024198:	898bc83a 	sub	r5,r17,r6
 102419c:	8963803a 	cmpltu	r17,r17,r5
 10241a0:	4251c83a 	sub	r8,r8,r9
 10241a4:	4451c83a 	sub	r8,r8,r17
 10241a8:	2823883a 	mov	r17,r5
 10241ac:	003f9f06 	br	102402c <__alt_data_end+0xff02402c>
 10241b0:	4984b03a 	or	r2,r9,r6
 10241b4:	103f6026 	beq	r2,zero,1023f38 <__alt_data_end+0xff023f38>
 10241b8:	213fffc4 	addi	r4,r4,-1
 10241bc:	2000931e 	bne	r4,zero,102440c <__adddf3+0x550>
 10241c0:	898d883a 	add	r6,r17,r6
 10241c4:	3463803a 	cmpltu	r17,r6,r17
 10241c8:	4251883a 	add	r8,r8,r9
 10241cc:	8a11883a 	add	r8,r17,r8
 10241d0:	3023883a 	mov	r17,r6
 10241d4:	003fd806 	br	1024138 <__alt_data_end+0xff024138>
 10241d8:	1800541e 	bne	r3,zero,102432c <__adddf3+0x470>
 10241dc:	80800044 	addi	r2,r16,1
 10241e0:	1081ffcc 	andi	r2,r2,2047
 10241e4:	00c00044 	movi	r3,1
 10241e8:	1880a00e 	bge	r3,r2,102446c <__adddf3+0x5b0>
 10241ec:	8989c83a 	sub	r4,r17,r6
 10241f0:	8905803a 	cmpltu	r2,r17,r4
 10241f4:	4267c83a 	sub	r19,r8,r9
 10241f8:	98a7c83a 	sub	r19,r19,r2
 10241fc:	9880202c 	andhi	r2,r19,128
 1024200:	10006326 	beq	r2,zero,1024390 <__adddf3+0x4d4>
 1024204:	3463c83a 	sub	r17,r6,r17
 1024208:	4a07c83a 	sub	r3,r9,r8
 102420c:	344d803a 	cmpltu	r6,r6,r17
 1024210:	19a7c83a 	sub	r19,r3,r6
 1024214:	3825883a 	mov	r18,r7
 1024218:	983f8a1e 	bne	r19,zero,1024044 <__alt_data_end+0xff024044>
 102421c:	8809883a 	mov	r4,r17
 1024220:	10264c00 	call	10264c0 <__clzsi2>
 1024224:	10800804 	addi	r2,r2,32
 1024228:	10fffe04 	addi	r3,r2,-8
 102422c:	010007c4 	movi	r4,31
 1024230:	20ff890e 	bge	r4,r3,1024058 <__alt_data_end+0xff024058>
 1024234:	10bff604 	addi	r2,r2,-40
 1024238:	8884983a 	sll	r2,r17,r2
 102423c:	0023883a 	mov	r17,zero
 1024240:	1c3f8c0e 	bge	r3,r16,1024074 <__alt_data_end+0xff024074>
 1024244:	023fe034 	movhi	r8,65408
 1024248:	423fffc4 	addi	r8,r8,-1
 102424c:	80e1c83a 	sub	r16,r16,r3
 1024250:	1210703a 	and	r8,r2,r8
 1024254:	003f3806 	br	1023f38 <__alt_data_end+0xff023f38>
 1024258:	9007883a 	mov	r3,r18
 102425c:	0011883a 	mov	r8,zero
 1024260:	0005883a 	mov	r2,zero
 1024264:	003f4c06 	br	1023f98 <__alt_data_end+0xff023f98>
 1024268:	498cb03a 	or	r6,r9,r6
 102426c:	300cc03a 	cmpne	r6,r6,zero
 1024270:	0007883a 	mov	r3,zero
 1024274:	003f6806 	br	1024018 <__alt_data_end+0xff024018>
 1024278:	20009c1e 	bne	r4,zero,10244ec <__adddf3+0x630>
 102427c:	80800044 	addi	r2,r16,1
 1024280:	1141ffcc 	andi	r5,r2,2047
 1024284:	01000044 	movi	r4,1
 1024288:	2140670e 	bge	r4,r5,1024428 <__adddf3+0x56c>
 102428c:	0101ffc4 	movi	r4,2047
 1024290:	11007f26 	beq	r2,r4,1024490 <__adddf3+0x5d4>
 1024294:	898d883a 	add	r6,r17,r6
 1024298:	4247883a 	add	r3,r8,r9
 102429c:	3451803a 	cmpltu	r8,r6,r17
 10242a0:	40d1883a 	add	r8,r8,r3
 10242a4:	402297fa 	slli	r17,r8,31
 10242a8:	300cd07a 	srli	r6,r6,1
 10242ac:	4010d07a 	srli	r8,r8,1
 10242b0:	1021883a 	mov	r16,r2
 10242b4:	89a2b03a 	or	r17,r17,r6
 10242b8:	003f1f06 	br	1023f38 <__alt_data_end+0xff023f38>
 10242bc:	0081ffc4 	movi	r2,2047
 10242c0:	80bf481e 	bne	r16,r2,1023fe4 <__alt_data_end+0xff023fe4>
 10242c4:	003f1c06 	br	1023f38 <__alt_data_end+0xff023f38>
 10242c8:	843ff844 	addi	r16,r16,-31
 10242cc:	01000804 	movi	r4,32
 10242d0:	1406d83a 	srl	r3,r2,r16
 10242d4:	41005026 	beq	r8,r4,1024418 <__adddf3+0x55c>
 10242d8:	01001004 	movi	r4,64
 10242dc:	2211c83a 	sub	r8,r4,r8
 10242e0:	1204983a 	sll	r2,r2,r8
 10242e4:	88a2b03a 	or	r17,r17,r2
 10242e8:	8822c03a 	cmpne	r17,r17,zero
 10242ec:	1c62b03a 	or	r17,r3,r17
 10242f0:	0011883a 	mov	r8,zero
 10242f4:	0021883a 	mov	r16,zero
 10242f8:	003f7106 	br	10240c0 <__alt_data_end+0xff0240c0>
 10242fc:	193ff804 	addi	r4,r3,-32
 1024300:	00800804 	movi	r2,32
 1024304:	4908d83a 	srl	r4,r9,r4
 1024308:	18804526 	beq	r3,r2,1024420 <__adddf3+0x564>
 102430c:	00801004 	movi	r2,64
 1024310:	10c5c83a 	sub	r2,r2,r3
 1024314:	4886983a 	sll	r3,r9,r2
 1024318:	198cb03a 	or	r6,r3,r6
 102431c:	300cc03a 	cmpne	r6,r6,zero
 1024320:	218cb03a 	or	r6,r4,r6
 1024324:	0007883a 	mov	r3,zero
 1024328:	003f3b06 	br	1024018 <__alt_data_end+0xff024018>
 102432c:	80002a26 	beq	r16,zero,10243d8 <__adddf3+0x51c>
 1024330:	0101ffc4 	movi	r4,2047
 1024334:	11006826 	beq	r2,r4,10244d8 <__adddf3+0x61c>
 1024338:	00c7c83a 	sub	r3,zero,r3
 102433c:	42002034 	orhi	r8,r8,128
 1024340:	01000e04 	movi	r4,56
 1024344:	20c07c16 	blt	r4,r3,1024538 <__adddf3+0x67c>
 1024348:	010007c4 	movi	r4,31
 102434c:	20c0da16 	blt	r4,r3,10246b8 <__adddf3+0x7fc>
 1024350:	01000804 	movi	r4,32
 1024354:	20c9c83a 	sub	r4,r4,r3
 1024358:	4114983a 	sll	r10,r8,r4
 102435c:	88cad83a 	srl	r5,r17,r3
 1024360:	8908983a 	sll	r4,r17,r4
 1024364:	40c6d83a 	srl	r3,r8,r3
 1024368:	5162b03a 	or	r17,r10,r5
 102436c:	2008c03a 	cmpne	r4,r4,zero
 1024370:	8922b03a 	or	r17,r17,r4
 1024374:	3463c83a 	sub	r17,r6,r17
 1024378:	48c7c83a 	sub	r3,r9,r3
 102437c:	344d803a 	cmpltu	r6,r6,r17
 1024380:	1991c83a 	sub	r8,r3,r6
 1024384:	1021883a 	mov	r16,r2
 1024388:	3825883a 	mov	r18,r7
 102438c:	003f2706 	br	102402c <__alt_data_end+0xff02402c>
 1024390:	24d0b03a 	or	r8,r4,r19
 1024394:	40001b1e 	bne	r8,zero,1024404 <__adddf3+0x548>
 1024398:	0005883a 	mov	r2,zero
 102439c:	0007883a 	mov	r3,zero
 10243a0:	0021883a 	mov	r16,zero
 10243a4:	003f4d06 	br	10240dc <__alt_data_end+0xff0240dc>
 10243a8:	008007c4 	movi	r2,31
 10243ac:	11003c16 	blt	r2,r4,10244a0 <__adddf3+0x5e4>
 10243b0:	00800804 	movi	r2,32
 10243b4:	1105c83a 	sub	r2,r2,r4
 10243b8:	488e983a 	sll	r7,r9,r2
 10243bc:	310ad83a 	srl	r5,r6,r4
 10243c0:	3084983a 	sll	r2,r6,r2
 10243c4:	4912d83a 	srl	r9,r9,r4
 10243c8:	394ab03a 	or	r5,r7,r5
 10243cc:	1004c03a 	cmpne	r2,r2,zero
 10243d0:	288ab03a 	or	r5,r5,r2
 10243d4:	003f5306 	br	1024124 <__alt_data_end+0xff024124>
 10243d8:	4448b03a 	or	r4,r8,r17
 10243dc:	20003e26 	beq	r4,zero,10244d8 <__adddf3+0x61c>
 10243e0:	00c6303a 	nor	r3,zero,r3
 10243e4:	18003a1e 	bne	r3,zero,10244d0 <__adddf3+0x614>
 10243e8:	3463c83a 	sub	r17,r6,r17
 10243ec:	4a07c83a 	sub	r3,r9,r8
 10243f0:	344d803a 	cmpltu	r6,r6,r17
 10243f4:	1991c83a 	sub	r8,r3,r6
 10243f8:	1021883a 	mov	r16,r2
 10243fc:	3825883a 	mov	r18,r7
 1024400:	003f0a06 	br	102402c <__alt_data_end+0xff02402c>
 1024404:	2023883a 	mov	r17,r4
 1024408:	003f0d06 	br	1024040 <__alt_data_end+0xff024040>
 102440c:	0081ffc4 	movi	r2,2047
 1024410:	80bf3f1e 	bne	r16,r2,1024110 <__alt_data_end+0xff024110>
 1024414:	003ec806 	br	1023f38 <__alt_data_end+0xff023f38>
 1024418:	0005883a 	mov	r2,zero
 102441c:	003fb106 	br	10242e4 <__alt_data_end+0xff0242e4>
 1024420:	0007883a 	mov	r3,zero
 1024424:	003fbc06 	br	1024318 <__alt_data_end+0xff024318>
 1024428:	4444b03a 	or	r2,r8,r17
 102442c:	8000871e 	bne	r16,zero,102464c <__adddf3+0x790>
 1024430:	1000ba26 	beq	r2,zero,102471c <__adddf3+0x860>
 1024434:	4984b03a 	or	r2,r9,r6
 1024438:	103ebf26 	beq	r2,zero,1023f38 <__alt_data_end+0xff023f38>
 102443c:	8985883a 	add	r2,r17,r6
 1024440:	4247883a 	add	r3,r8,r9
 1024444:	1451803a 	cmpltu	r8,r2,r17
 1024448:	40d1883a 	add	r8,r8,r3
 102444c:	40c0202c 	andhi	r3,r8,128
 1024450:	1023883a 	mov	r17,r2
 1024454:	183f1a26 	beq	r3,zero,10240c0 <__alt_data_end+0xff0240c0>
 1024458:	00bfe034 	movhi	r2,65408
 102445c:	10bfffc4 	addi	r2,r2,-1
 1024460:	2021883a 	mov	r16,r4
 1024464:	4090703a 	and	r8,r8,r2
 1024468:	003eb306 	br	1023f38 <__alt_data_end+0xff023f38>
 102446c:	4444b03a 	or	r2,r8,r17
 1024470:	8000291e 	bne	r16,zero,1024518 <__adddf3+0x65c>
 1024474:	10004b1e 	bne	r2,zero,10245a4 <__adddf3+0x6e8>
 1024478:	4990b03a 	or	r8,r9,r6
 102447c:	40008b26 	beq	r8,zero,10246ac <__adddf3+0x7f0>
 1024480:	4811883a 	mov	r8,r9
 1024484:	3023883a 	mov	r17,r6
 1024488:	3825883a 	mov	r18,r7
 102448c:	003eaa06 	br	1023f38 <__alt_data_end+0xff023f38>
 1024490:	1021883a 	mov	r16,r2
 1024494:	0011883a 	mov	r8,zero
 1024498:	0005883a 	mov	r2,zero
 102449c:	003f0f06 	br	10240dc <__alt_data_end+0xff0240dc>
 10244a0:	217ff804 	addi	r5,r4,-32
 10244a4:	00800804 	movi	r2,32
 10244a8:	494ad83a 	srl	r5,r9,r5
 10244ac:	20807d26 	beq	r4,r2,10246a4 <__adddf3+0x7e8>
 10244b0:	00801004 	movi	r2,64
 10244b4:	1109c83a 	sub	r4,r2,r4
 10244b8:	4912983a 	sll	r9,r9,r4
 10244bc:	498cb03a 	or	r6,r9,r6
 10244c0:	300cc03a 	cmpne	r6,r6,zero
 10244c4:	298ab03a 	or	r5,r5,r6
 10244c8:	0013883a 	mov	r9,zero
 10244cc:	003f1506 	br	1024124 <__alt_data_end+0xff024124>
 10244d0:	0101ffc4 	movi	r4,2047
 10244d4:	113f9a1e 	bne	r2,r4,1024340 <__alt_data_end+0xff024340>
 10244d8:	4811883a 	mov	r8,r9
 10244dc:	3023883a 	mov	r17,r6
 10244e0:	1021883a 	mov	r16,r2
 10244e4:	3825883a 	mov	r18,r7
 10244e8:	003e9306 	br	1023f38 <__alt_data_end+0xff023f38>
 10244ec:	8000161e 	bne	r16,zero,1024548 <__adddf3+0x68c>
 10244f0:	444ab03a 	or	r5,r8,r17
 10244f4:	28005126 	beq	r5,zero,102463c <__adddf3+0x780>
 10244f8:	0108303a 	nor	r4,zero,r4
 10244fc:	20004d1e 	bne	r4,zero,1024634 <__adddf3+0x778>
 1024500:	89a3883a 	add	r17,r17,r6
 1024504:	4253883a 	add	r9,r8,r9
 1024508:	898d803a 	cmpltu	r6,r17,r6
 102450c:	3251883a 	add	r8,r6,r9
 1024510:	1021883a 	mov	r16,r2
 1024514:	003f0806 	br	1024138 <__alt_data_end+0xff024138>
 1024518:	1000301e 	bne	r2,zero,10245dc <__adddf3+0x720>
 102451c:	4984b03a 	or	r2,r9,r6
 1024520:	10007126 	beq	r2,zero,10246e8 <__adddf3+0x82c>
 1024524:	4811883a 	mov	r8,r9
 1024528:	3023883a 	mov	r17,r6
 102452c:	3825883a 	mov	r18,r7
 1024530:	0401ffc4 	movi	r16,2047
 1024534:	003e8006 	br	1023f38 <__alt_data_end+0xff023f38>
 1024538:	4462b03a 	or	r17,r8,r17
 102453c:	8822c03a 	cmpne	r17,r17,zero
 1024540:	0007883a 	mov	r3,zero
 1024544:	003f8b06 	br	1024374 <__alt_data_end+0xff024374>
 1024548:	0141ffc4 	movi	r5,2047
 102454c:	11403b26 	beq	r2,r5,102463c <__adddf3+0x780>
 1024550:	0109c83a 	sub	r4,zero,r4
 1024554:	42002034 	orhi	r8,r8,128
 1024558:	01400e04 	movi	r5,56
 102455c:	29006716 	blt	r5,r4,10246fc <__adddf3+0x840>
 1024560:	014007c4 	movi	r5,31
 1024564:	29007016 	blt	r5,r4,1024728 <__adddf3+0x86c>
 1024568:	01400804 	movi	r5,32
 102456c:	290bc83a 	sub	r5,r5,r4
 1024570:	4154983a 	sll	r10,r8,r5
 1024574:	890ed83a 	srl	r7,r17,r4
 1024578:	894a983a 	sll	r5,r17,r5
 102457c:	4108d83a 	srl	r4,r8,r4
 1024580:	51e2b03a 	or	r17,r10,r7
 1024584:	280ac03a 	cmpne	r5,r5,zero
 1024588:	8962b03a 	or	r17,r17,r5
 102458c:	89a3883a 	add	r17,r17,r6
 1024590:	2253883a 	add	r9,r4,r9
 1024594:	898d803a 	cmpltu	r6,r17,r6
 1024598:	3251883a 	add	r8,r6,r9
 102459c:	1021883a 	mov	r16,r2
 10245a0:	003ee506 	br	1024138 <__alt_data_end+0xff024138>
 10245a4:	4984b03a 	or	r2,r9,r6
 10245a8:	103e6326 	beq	r2,zero,1023f38 <__alt_data_end+0xff023f38>
 10245ac:	8987c83a 	sub	r3,r17,r6
 10245b0:	88c9803a 	cmpltu	r4,r17,r3
 10245b4:	4245c83a 	sub	r2,r8,r9
 10245b8:	1105c83a 	sub	r2,r2,r4
 10245bc:	1100202c 	andhi	r4,r2,128
 10245c0:	203ebb26 	beq	r4,zero,10240b0 <__alt_data_end+0xff0240b0>
 10245c4:	3463c83a 	sub	r17,r6,r17
 10245c8:	4a07c83a 	sub	r3,r9,r8
 10245cc:	344d803a 	cmpltu	r6,r6,r17
 10245d0:	1991c83a 	sub	r8,r3,r6
 10245d4:	3825883a 	mov	r18,r7
 10245d8:	003e5706 	br	1023f38 <__alt_data_end+0xff023f38>
 10245dc:	4984b03a 	or	r2,r9,r6
 10245e0:	10002e26 	beq	r2,zero,102469c <__adddf3+0x7e0>
 10245e4:	4004d0fa 	srli	r2,r8,3
 10245e8:	8822d0fa 	srli	r17,r17,3
 10245ec:	4010977a 	slli	r8,r8,29
 10245f0:	10c0022c 	andhi	r3,r2,8
 10245f4:	4462b03a 	or	r17,r8,r17
 10245f8:	18000826 	beq	r3,zero,102461c <__adddf3+0x760>
 10245fc:	4808d0fa 	srli	r4,r9,3
 1024600:	20c0022c 	andhi	r3,r4,8
 1024604:	1800051e 	bne	r3,zero,102461c <__adddf3+0x760>
 1024608:	300cd0fa 	srli	r6,r6,3
 102460c:	4806977a 	slli	r3,r9,29
 1024610:	2005883a 	mov	r2,r4
 1024614:	3825883a 	mov	r18,r7
 1024618:	19a2b03a 	or	r17,r3,r6
 102461c:	8810d77a 	srli	r8,r17,29
 1024620:	100490fa 	slli	r2,r2,3
 1024624:	882290fa 	slli	r17,r17,3
 1024628:	0401ffc4 	movi	r16,2047
 102462c:	4090b03a 	or	r8,r8,r2
 1024630:	003e4106 	br	1023f38 <__alt_data_end+0xff023f38>
 1024634:	0141ffc4 	movi	r5,2047
 1024638:	117fc71e 	bne	r2,r5,1024558 <__alt_data_end+0xff024558>
 102463c:	4811883a 	mov	r8,r9
 1024640:	3023883a 	mov	r17,r6
 1024644:	1021883a 	mov	r16,r2
 1024648:	003e3b06 	br	1023f38 <__alt_data_end+0xff023f38>
 102464c:	10002f26 	beq	r2,zero,102470c <__adddf3+0x850>
 1024650:	4984b03a 	or	r2,r9,r6
 1024654:	10001126 	beq	r2,zero,102469c <__adddf3+0x7e0>
 1024658:	4004d0fa 	srli	r2,r8,3
 102465c:	8822d0fa 	srli	r17,r17,3
 1024660:	4010977a 	slli	r8,r8,29
 1024664:	10c0022c 	andhi	r3,r2,8
 1024668:	4462b03a 	or	r17,r8,r17
 102466c:	183feb26 	beq	r3,zero,102461c <__alt_data_end+0xff02461c>
 1024670:	4808d0fa 	srli	r4,r9,3
 1024674:	20c0022c 	andhi	r3,r4,8
 1024678:	183fe81e 	bne	r3,zero,102461c <__alt_data_end+0xff02461c>
 102467c:	300cd0fa 	srli	r6,r6,3
 1024680:	4806977a 	slli	r3,r9,29
 1024684:	2005883a 	mov	r2,r4
 1024688:	19a2b03a 	or	r17,r3,r6
 102468c:	003fe306 	br	102461c <__alt_data_end+0xff02461c>
 1024690:	0011883a 	mov	r8,zero
 1024694:	0005883a 	mov	r2,zero
 1024698:	003e3f06 	br	1023f98 <__alt_data_end+0xff023f98>
 102469c:	0401ffc4 	movi	r16,2047
 10246a0:	003e2506 	br	1023f38 <__alt_data_end+0xff023f38>
 10246a4:	0013883a 	mov	r9,zero
 10246a8:	003f8406 	br	10244bc <__alt_data_end+0xff0244bc>
 10246ac:	0005883a 	mov	r2,zero
 10246b0:	0007883a 	mov	r3,zero
 10246b4:	003e8906 	br	10240dc <__alt_data_end+0xff0240dc>
 10246b8:	197ff804 	addi	r5,r3,-32
 10246bc:	01000804 	movi	r4,32
 10246c0:	414ad83a 	srl	r5,r8,r5
 10246c4:	19002426 	beq	r3,r4,1024758 <__adddf3+0x89c>
 10246c8:	01001004 	movi	r4,64
 10246cc:	20c7c83a 	sub	r3,r4,r3
 10246d0:	40c6983a 	sll	r3,r8,r3
 10246d4:	1c46b03a 	or	r3,r3,r17
 10246d8:	1806c03a 	cmpne	r3,r3,zero
 10246dc:	28e2b03a 	or	r17,r5,r3
 10246e0:	0007883a 	mov	r3,zero
 10246e4:	003f2306 	br	1024374 <__alt_data_end+0xff024374>
 10246e8:	0007883a 	mov	r3,zero
 10246ec:	5811883a 	mov	r8,r11
 10246f0:	00bfffc4 	movi	r2,-1
 10246f4:	0401ffc4 	movi	r16,2047
 10246f8:	003e7806 	br	10240dc <__alt_data_end+0xff0240dc>
 10246fc:	4462b03a 	or	r17,r8,r17
 1024700:	8822c03a 	cmpne	r17,r17,zero
 1024704:	0009883a 	mov	r4,zero
 1024708:	003fa006 	br	102458c <__alt_data_end+0xff02458c>
 102470c:	4811883a 	mov	r8,r9
 1024710:	3023883a 	mov	r17,r6
 1024714:	0401ffc4 	movi	r16,2047
 1024718:	003e0706 	br	1023f38 <__alt_data_end+0xff023f38>
 102471c:	4811883a 	mov	r8,r9
 1024720:	3023883a 	mov	r17,r6
 1024724:	003e0406 	br	1023f38 <__alt_data_end+0xff023f38>
 1024728:	21fff804 	addi	r7,r4,-32
 102472c:	01400804 	movi	r5,32
 1024730:	41ced83a 	srl	r7,r8,r7
 1024734:	21400a26 	beq	r4,r5,1024760 <__adddf3+0x8a4>
 1024738:	01401004 	movi	r5,64
 102473c:	2909c83a 	sub	r4,r5,r4
 1024740:	4108983a 	sll	r4,r8,r4
 1024744:	2448b03a 	or	r4,r4,r17
 1024748:	2008c03a 	cmpne	r4,r4,zero
 102474c:	3922b03a 	or	r17,r7,r4
 1024750:	0009883a 	mov	r4,zero
 1024754:	003f8d06 	br	102458c <__alt_data_end+0xff02458c>
 1024758:	0007883a 	mov	r3,zero
 102475c:	003fdd06 	br	10246d4 <__alt_data_end+0xff0246d4>
 1024760:	0009883a 	mov	r4,zero
 1024764:	003ff706 	br	1024744 <__alt_data_end+0xff024744>

01024768 <__divdf3>:
 1024768:	defff204 	addi	sp,sp,-56
 102476c:	dd400915 	stw	r21,36(sp)
 1024770:	282ad53a 	srli	r21,r5,20
 1024774:	dd000815 	stw	r20,32(sp)
 1024778:	2828d7fa 	srli	r20,r5,31
 102477c:	dc000415 	stw	r16,16(sp)
 1024780:	04000434 	movhi	r16,16
 1024784:	df000c15 	stw	fp,48(sp)
 1024788:	843fffc4 	addi	r16,r16,-1
 102478c:	dfc00d15 	stw	ra,52(sp)
 1024790:	ddc00b15 	stw	r23,44(sp)
 1024794:	dd800a15 	stw	r22,40(sp)
 1024798:	dcc00715 	stw	r19,28(sp)
 102479c:	dc800615 	stw	r18,24(sp)
 10247a0:	dc400515 	stw	r17,20(sp)
 10247a4:	ad41ffcc 	andi	r21,r21,2047
 10247a8:	2c20703a 	and	r16,r5,r16
 10247ac:	a7003fcc 	andi	fp,r20,255
 10247b0:	a8006126 	beq	r21,zero,1024938 <__divdf3+0x1d0>
 10247b4:	0081ffc4 	movi	r2,2047
 10247b8:	2025883a 	mov	r18,r4
 10247bc:	a8803726 	beq	r21,r2,102489c <__divdf3+0x134>
 10247c0:	80800434 	orhi	r2,r16,16
 10247c4:	100490fa 	slli	r2,r2,3
 10247c8:	2020d77a 	srli	r16,r4,29
 10247cc:	202490fa 	slli	r18,r4,3
 10247d0:	ad7f0044 	addi	r21,r21,-1023
 10247d4:	80a0b03a 	or	r16,r16,r2
 10247d8:	0027883a 	mov	r19,zero
 10247dc:	0013883a 	mov	r9,zero
 10247e0:	3804d53a 	srli	r2,r7,20
 10247e4:	382cd7fa 	srli	r22,r7,31
 10247e8:	04400434 	movhi	r17,16
 10247ec:	8c7fffc4 	addi	r17,r17,-1
 10247f0:	1081ffcc 	andi	r2,r2,2047
 10247f4:	3011883a 	mov	r8,r6
 10247f8:	3c62703a 	and	r17,r7,r17
 10247fc:	b5c03fcc 	andi	r23,r22,255
 1024800:	10006c26 	beq	r2,zero,10249b4 <__divdf3+0x24c>
 1024804:	00c1ffc4 	movi	r3,2047
 1024808:	10c06426 	beq	r2,r3,102499c <__divdf3+0x234>
 102480c:	88c00434 	orhi	r3,r17,16
 1024810:	180690fa 	slli	r3,r3,3
 1024814:	3022d77a 	srli	r17,r6,29
 1024818:	301090fa 	slli	r8,r6,3
 102481c:	10bf0044 	addi	r2,r2,-1023
 1024820:	88e2b03a 	or	r17,r17,r3
 1024824:	000f883a 	mov	r7,zero
 1024828:	a58cf03a 	xor	r6,r20,r22
 102482c:	3cc8b03a 	or	r4,r7,r19
 1024830:	a8abc83a 	sub	r21,r21,r2
 1024834:	008003c4 	movi	r2,15
 1024838:	3007883a 	mov	r3,r6
 102483c:	34c03fcc 	andi	r19,r6,255
 1024840:	11009036 	bltu	r2,r4,1024a84 <__divdf3+0x31c>
 1024844:	200890ba 	slli	r4,r4,2
 1024848:	008040b4 	movhi	r2,258
 102484c:	10921704 	addi	r2,r2,18524
 1024850:	2089883a 	add	r4,r4,r2
 1024854:	20800017 	ldw	r2,0(r4)
 1024858:	1000683a 	jmp	r2
 102485c:	01024a84 	movi	r4,2346
 1024860:	010248d4 	movui	r4,2339
 1024864:	01024a74 	movhi	r4,2345
 1024868:	010248c8 	cmpgei	r4,zero,2339
 102486c:	01024a74 	movhi	r4,2345
 1024870:	01024a48 	cmpgei	r4,zero,2345
 1024874:	01024a74 	movhi	r4,2345
 1024878:	010248c8 	cmpgei	r4,zero,2339
 102487c:	010248d4 	movui	r4,2339
 1024880:	010248d4 	movui	r4,2339
 1024884:	01024a48 	cmpgei	r4,zero,2345
 1024888:	010248c8 	cmpgei	r4,zero,2339
 102488c:	010248b8 	rdprs	r4,zero,2338
 1024890:	010248b8 	rdprs	r4,zero,2338
 1024894:	010248b8 	rdprs	r4,zero,2338
 1024898:	01024d68 	cmpgeui	r4,zero,2357
 102489c:	2404b03a 	or	r2,r4,r16
 10248a0:	1000661e 	bne	r2,zero,1024a3c <__divdf3+0x2d4>
 10248a4:	04c00204 	movi	r19,8
 10248a8:	0021883a 	mov	r16,zero
 10248ac:	0025883a 	mov	r18,zero
 10248b0:	02400084 	movi	r9,2
 10248b4:	003fca06 	br	10247e0 <__alt_data_end+0xff0247e0>
 10248b8:	8023883a 	mov	r17,r16
 10248bc:	9011883a 	mov	r8,r18
 10248c0:	e02f883a 	mov	r23,fp
 10248c4:	480f883a 	mov	r7,r9
 10248c8:	00800084 	movi	r2,2
 10248cc:	3881311e 	bne	r7,r2,1024d94 <__divdf3+0x62c>
 10248d0:	b827883a 	mov	r19,r23
 10248d4:	98c0004c 	andi	r3,r19,1
 10248d8:	0081ffc4 	movi	r2,2047
 10248dc:	000b883a 	mov	r5,zero
 10248e0:	0025883a 	mov	r18,zero
 10248e4:	1004953a 	slli	r2,r2,20
 10248e8:	18c03fcc 	andi	r3,r3,255
 10248ec:	04400434 	movhi	r17,16
 10248f0:	8c7fffc4 	addi	r17,r17,-1
 10248f4:	180697fa 	slli	r3,r3,31
 10248f8:	2c4a703a 	and	r5,r5,r17
 10248fc:	288ab03a 	or	r5,r5,r2
 1024900:	28c6b03a 	or	r3,r5,r3
 1024904:	9005883a 	mov	r2,r18
 1024908:	dfc00d17 	ldw	ra,52(sp)
 102490c:	df000c17 	ldw	fp,48(sp)
 1024910:	ddc00b17 	ldw	r23,44(sp)
 1024914:	dd800a17 	ldw	r22,40(sp)
 1024918:	dd400917 	ldw	r21,36(sp)
 102491c:	dd000817 	ldw	r20,32(sp)
 1024920:	dcc00717 	ldw	r19,28(sp)
 1024924:	dc800617 	ldw	r18,24(sp)
 1024928:	dc400517 	ldw	r17,20(sp)
 102492c:	dc000417 	ldw	r16,16(sp)
 1024930:	dec00e04 	addi	sp,sp,56
 1024934:	f800283a 	ret
 1024938:	2404b03a 	or	r2,r4,r16
 102493c:	2027883a 	mov	r19,r4
 1024940:	10003926 	beq	r2,zero,1024a28 <__divdf3+0x2c0>
 1024944:	80012e26 	beq	r16,zero,1024e00 <__divdf3+0x698>
 1024948:	8009883a 	mov	r4,r16
 102494c:	d9800315 	stw	r6,12(sp)
 1024950:	d9c00215 	stw	r7,8(sp)
 1024954:	10264c00 	call	10264c0 <__clzsi2>
 1024958:	d9800317 	ldw	r6,12(sp)
 102495c:	d9c00217 	ldw	r7,8(sp)
 1024960:	113ffd44 	addi	r4,r2,-11
 1024964:	00c00704 	movi	r3,28
 1024968:	19012116 	blt	r3,r4,1024df0 <__divdf3+0x688>
 102496c:	00c00744 	movi	r3,29
 1024970:	147ffe04 	addi	r17,r2,-8
 1024974:	1907c83a 	sub	r3,r3,r4
 1024978:	8460983a 	sll	r16,r16,r17
 102497c:	98c6d83a 	srl	r3,r19,r3
 1024980:	9c64983a 	sll	r18,r19,r17
 1024984:	1c20b03a 	or	r16,r3,r16
 1024988:	1080fcc4 	addi	r2,r2,1011
 102498c:	00abc83a 	sub	r21,zero,r2
 1024990:	0027883a 	mov	r19,zero
 1024994:	0013883a 	mov	r9,zero
 1024998:	003f9106 	br	10247e0 <__alt_data_end+0xff0247e0>
 102499c:	3446b03a 	or	r3,r6,r17
 10249a0:	18001f1e 	bne	r3,zero,1024a20 <__divdf3+0x2b8>
 10249a4:	0023883a 	mov	r17,zero
 10249a8:	0011883a 	mov	r8,zero
 10249ac:	01c00084 	movi	r7,2
 10249b0:	003f9d06 	br	1024828 <__alt_data_end+0xff024828>
 10249b4:	3446b03a 	or	r3,r6,r17
 10249b8:	18001526 	beq	r3,zero,1024a10 <__divdf3+0x2a8>
 10249bc:	88011b26 	beq	r17,zero,1024e2c <__divdf3+0x6c4>
 10249c0:	8809883a 	mov	r4,r17
 10249c4:	d9800315 	stw	r6,12(sp)
 10249c8:	da400115 	stw	r9,4(sp)
 10249cc:	10264c00 	call	10264c0 <__clzsi2>
 10249d0:	d9800317 	ldw	r6,12(sp)
 10249d4:	da400117 	ldw	r9,4(sp)
 10249d8:	113ffd44 	addi	r4,r2,-11
 10249dc:	00c00704 	movi	r3,28
 10249e0:	19010e16 	blt	r3,r4,1024e1c <__divdf3+0x6b4>
 10249e4:	00c00744 	movi	r3,29
 10249e8:	123ffe04 	addi	r8,r2,-8
 10249ec:	1907c83a 	sub	r3,r3,r4
 10249f0:	8a22983a 	sll	r17,r17,r8
 10249f4:	30c6d83a 	srl	r3,r6,r3
 10249f8:	3210983a 	sll	r8,r6,r8
 10249fc:	1c62b03a 	or	r17,r3,r17
 1024a00:	1080fcc4 	addi	r2,r2,1011
 1024a04:	0085c83a 	sub	r2,zero,r2
 1024a08:	000f883a 	mov	r7,zero
 1024a0c:	003f8606 	br	1024828 <__alt_data_end+0xff024828>
 1024a10:	0023883a 	mov	r17,zero
 1024a14:	0011883a 	mov	r8,zero
 1024a18:	01c00044 	movi	r7,1
 1024a1c:	003f8206 	br	1024828 <__alt_data_end+0xff024828>
 1024a20:	01c000c4 	movi	r7,3
 1024a24:	003f8006 	br	1024828 <__alt_data_end+0xff024828>
 1024a28:	04c00104 	movi	r19,4
 1024a2c:	0021883a 	mov	r16,zero
 1024a30:	0025883a 	mov	r18,zero
 1024a34:	02400044 	movi	r9,1
 1024a38:	003f6906 	br	10247e0 <__alt_data_end+0xff0247e0>
 1024a3c:	04c00304 	movi	r19,12
 1024a40:	024000c4 	movi	r9,3
 1024a44:	003f6606 	br	10247e0 <__alt_data_end+0xff0247e0>
 1024a48:	01400434 	movhi	r5,16
 1024a4c:	0007883a 	mov	r3,zero
 1024a50:	297fffc4 	addi	r5,r5,-1
 1024a54:	04bfffc4 	movi	r18,-1
 1024a58:	0081ffc4 	movi	r2,2047
 1024a5c:	003fa106 	br	10248e4 <__alt_data_end+0xff0248e4>
 1024a60:	00c00044 	movi	r3,1
 1024a64:	1887c83a 	sub	r3,r3,r2
 1024a68:	01000e04 	movi	r4,56
 1024a6c:	20c1210e 	bge	r4,r3,1024ef4 <__divdf3+0x78c>
 1024a70:	98c0004c 	andi	r3,r19,1
 1024a74:	0005883a 	mov	r2,zero
 1024a78:	000b883a 	mov	r5,zero
 1024a7c:	0025883a 	mov	r18,zero
 1024a80:	003f9806 	br	10248e4 <__alt_data_end+0xff0248e4>
 1024a84:	8c00fd36 	bltu	r17,r16,1024e7c <__divdf3+0x714>
 1024a88:	8440fb26 	beq	r16,r17,1024e78 <__divdf3+0x710>
 1024a8c:	8007883a 	mov	r3,r16
 1024a90:	ad7fffc4 	addi	r21,r21,-1
 1024a94:	0021883a 	mov	r16,zero
 1024a98:	4004d63a 	srli	r2,r8,24
 1024a9c:	8822923a 	slli	r17,r17,8
 1024aa0:	1809883a 	mov	r4,r3
 1024aa4:	402c923a 	slli	r22,r8,8
 1024aa8:	88b8b03a 	or	fp,r17,r2
 1024aac:	e028d43a 	srli	r20,fp,16
 1024ab0:	d8c00015 	stw	r3,0(sp)
 1024ab4:	e5ffffcc 	andi	r23,fp,65535
 1024ab8:	a00b883a 	mov	r5,r20
 1024abc:	1023e000 	call	1023e00 <__udivsi3>
 1024ac0:	d8c00017 	ldw	r3,0(sp)
 1024ac4:	a00b883a 	mov	r5,r20
 1024ac8:	d8800315 	stw	r2,12(sp)
 1024acc:	1809883a 	mov	r4,r3
 1024ad0:	1023e640 	call	1023e64 <__umodsi3>
 1024ad4:	d9800317 	ldw	r6,12(sp)
 1024ad8:	1006943a 	slli	r3,r2,16
 1024adc:	9004d43a 	srli	r2,r18,16
 1024ae0:	b9a3383a 	mul	r17,r23,r6
 1024ae4:	10c4b03a 	or	r2,r2,r3
 1024ae8:	1440062e 	bgeu	r2,r17,1024b04 <__divdf3+0x39c>
 1024aec:	1705883a 	add	r2,r2,fp
 1024af0:	30ffffc4 	addi	r3,r6,-1
 1024af4:	1700ee36 	bltu	r2,fp,1024eb0 <__divdf3+0x748>
 1024af8:	1440ed2e 	bgeu	r2,r17,1024eb0 <__divdf3+0x748>
 1024afc:	31bfff84 	addi	r6,r6,-2
 1024b00:	1705883a 	add	r2,r2,fp
 1024b04:	1463c83a 	sub	r17,r2,r17
 1024b08:	a00b883a 	mov	r5,r20
 1024b0c:	8809883a 	mov	r4,r17
 1024b10:	d9800315 	stw	r6,12(sp)
 1024b14:	1023e000 	call	1023e00 <__udivsi3>
 1024b18:	a00b883a 	mov	r5,r20
 1024b1c:	8809883a 	mov	r4,r17
 1024b20:	d8800215 	stw	r2,8(sp)
 1024b24:	1023e640 	call	1023e64 <__umodsi3>
 1024b28:	d9c00217 	ldw	r7,8(sp)
 1024b2c:	1004943a 	slli	r2,r2,16
 1024b30:	94bfffcc 	andi	r18,r18,65535
 1024b34:	b9d1383a 	mul	r8,r23,r7
 1024b38:	90a4b03a 	or	r18,r18,r2
 1024b3c:	d9800317 	ldw	r6,12(sp)
 1024b40:	9200062e 	bgeu	r18,r8,1024b5c <__divdf3+0x3f4>
 1024b44:	9725883a 	add	r18,r18,fp
 1024b48:	38bfffc4 	addi	r2,r7,-1
 1024b4c:	9700d636 	bltu	r18,fp,1024ea8 <__divdf3+0x740>
 1024b50:	9200d52e 	bgeu	r18,r8,1024ea8 <__divdf3+0x740>
 1024b54:	39ffff84 	addi	r7,r7,-2
 1024b58:	9725883a 	add	r18,r18,fp
 1024b5c:	3004943a 	slli	r2,r6,16
 1024b60:	b012d43a 	srli	r9,r22,16
 1024b64:	b1bfffcc 	andi	r6,r22,65535
 1024b68:	11e2b03a 	or	r17,r2,r7
 1024b6c:	8806d43a 	srli	r3,r17,16
 1024b70:	893fffcc 	andi	r4,r17,65535
 1024b74:	218b383a 	mul	r5,r4,r6
 1024b78:	30c5383a 	mul	r2,r6,r3
 1024b7c:	2249383a 	mul	r4,r4,r9
 1024b80:	280ed43a 	srli	r7,r5,16
 1024b84:	9225c83a 	sub	r18,r18,r8
 1024b88:	2089883a 	add	r4,r4,r2
 1024b8c:	3909883a 	add	r4,r7,r4
 1024b90:	1a47383a 	mul	r3,r3,r9
 1024b94:	2080022e 	bgeu	r4,r2,1024ba0 <__divdf3+0x438>
 1024b98:	00800074 	movhi	r2,1
 1024b9c:	1887883a 	add	r3,r3,r2
 1024ba0:	2004d43a 	srli	r2,r4,16
 1024ba4:	2008943a 	slli	r4,r4,16
 1024ba8:	297fffcc 	andi	r5,r5,65535
 1024bac:	10c7883a 	add	r3,r2,r3
 1024bb0:	2149883a 	add	r4,r4,r5
 1024bb4:	90c0a536 	bltu	r18,r3,1024e4c <__divdf3+0x6e4>
 1024bb8:	90c0bf26 	beq	r18,r3,1024eb8 <__divdf3+0x750>
 1024bbc:	90c7c83a 	sub	r3,r18,r3
 1024bc0:	810fc83a 	sub	r7,r16,r4
 1024bc4:	81e5803a 	cmpltu	r18,r16,r7
 1024bc8:	1ca5c83a 	sub	r18,r3,r18
 1024bcc:	e480c126 	beq	fp,r18,1024ed4 <__divdf3+0x76c>
 1024bd0:	a00b883a 	mov	r5,r20
 1024bd4:	9009883a 	mov	r4,r18
 1024bd8:	d9800315 	stw	r6,12(sp)
 1024bdc:	d9c00215 	stw	r7,8(sp)
 1024be0:	da400115 	stw	r9,4(sp)
 1024be4:	1023e000 	call	1023e00 <__udivsi3>
 1024be8:	a00b883a 	mov	r5,r20
 1024bec:	9009883a 	mov	r4,r18
 1024bf0:	d8800015 	stw	r2,0(sp)
 1024bf4:	1023e640 	call	1023e64 <__umodsi3>
 1024bf8:	d9c00217 	ldw	r7,8(sp)
 1024bfc:	da000017 	ldw	r8,0(sp)
 1024c00:	1006943a 	slli	r3,r2,16
 1024c04:	3804d43a 	srli	r2,r7,16
 1024c08:	ba21383a 	mul	r16,r23,r8
 1024c0c:	d9800317 	ldw	r6,12(sp)
 1024c10:	10c4b03a 	or	r2,r2,r3
 1024c14:	da400117 	ldw	r9,4(sp)
 1024c18:	1400062e 	bgeu	r2,r16,1024c34 <__divdf3+0x4cc>
 1024c1c:	1705883a 	add	r2,r2,fp
 1024c20:	40ffffc4 	addi	r3,r8,-1
 1024c24:	1700ad36 	bltu	r2,fp,1024edc <__divdf3+0x774>
 1024c28:	1400ac2e 	bgeu	r2,r16,1024edc <__divdf3+0x774>
 1024c2c:	423fff84 	addi	r8,r8,-2
 1024c30:	1705883a 	add	r2,r2,fp
 1024c34:	1421c83a 	sub	r16,r2,r16
 1024c38:	a00b883a 	mov	r5,r20
 1024c3c:	8009883a 	mov	r4,r16
 1024c40:	d9800315 	stw	r6,12(sp)
 1024c44:	d9c00215 	stw	r7,8(sp)
 1024c48:	da000015 	stw	r8,0(sp)
 1024c4c:	da400115 	stw	r9,4(sp)
 1024c50:	1023e000 	call	1023e00 <__udivsi3>
 1024c54:	8009883a 	mov	r4,r16
 1024c58:	a00b883a 	mov	r5,r20
 1024c5c:	1025883a 	mov	r18,r2
 1024c60:	1023e640 	call	1023e64 <__umodsi3>
 1024c64:	d9c00217 	ldw	r7,8(sp)
 1024c68:	1004943a 	slli	r2,r2,16
 1024c6c:	bcaf383a 	mul	r23,r23,r18
 1024c70:	393fffcc 	andi	r4,r7,65535
 1024c74:	2088b03a 	or	r4,r4,r2
 1024c78:	d9800317 	ldw	r6,12(sp)
 1024c7c:	da000017 	ldw	r8,0(sp)
 1024c80:	da400117 	ldw	r9,4(sp)
 1024c84:	25c0062e 	bgeu	r4,r23,1024ca0 <__divdf3+0x538>
 1024c88:	2709883a 	add	r4,r4,fp
 1024c8c:	90bfffc4 	addi	r2,r18,-1
 1024c90:	27009436 	bltu	r4,fp,1024ee4 <__divdf3+0x77c>
 1024c94:	25c0932e 	bgeu	r4,r23,1024ee4 <__divdf3+0x77c>
 1024c98:	94bfff84 	addi	r18,r18,-2
 1024c9c:	2709883a 	add	r4,r4,fp
 1024ca0:	4004943a 	slli	r2,r8,16
 1024ca4:	25efc83a 	sub	r23,r4,r23
 1024ca8:	1490b03a 	or	r8,r2,r18
 1024cac:	4008d43a 	srli	r4,r8,16
 1024cb0:	40ffffcc 	andi	r3,r8,65535
 1024cb4:	30c5383a 	mul	r2,r6,r3
 1024cb8:	1a47383a 	mul	r3,r3,r9
 1024cbc:	310d383a 	mul	r6,r6,r4
 1024cc0:	100ad43a 	srli	r5,r2,16
 1024cc4:	4913383a 	mul	r9,r9,r4
 1024cc8:	1987883a 	add	r3,r3,r6
 1024ccc:	28c7883a 	add	r3,r5,r3
 1024cd0:	1980022e 	bgeu	r3,r6,1024cdc <__divdf3+0x574>
 1024cd4:	01000074 	movhi	r4,1
 1024cd8:	4913883a 	add	r9,r9,r4
 1024cdc:	1808d43a 	srli	r4,r3,16
 1024ce0:	1806943a 	slli	r3,r3,16
 1024ce4:	10bfffcc 	andi	r2,r2,65535
 1024ce8:	2253883a 	add	r9,r4,r9
 1024cec:	1887883a 	add	r3,r3,r2
 1024cf0:	ba403836 	bltu	r23,r9,1024dd4 <__divdf3+0x66c>
 1024cf4:	ba403626 	beq	r23,r9,1024dd0 <__divdf3+0x668>
 1024cf8:	42000054 	ori	r8,r8,1
 1024cfc:	a880ffc4 	addi	r2,r21,1023
 1024d00:	00bf570e 	bge	zero,r2,1024a60 <__alt_data_end+0xff024a60>
 1024d04:	40c001cc 	andi	r3,r8,7
 1024d08:	18000726 	beq	r3,zero,1024d28 <__divdf3+0x5c0>
 1024d0c:	40c003cc 	andi	r3,r8,15
 1024d10:	01000104 	movi	r4,4
 1024d14:	19000426 	beq	r3,r4,1024d28 <__divdf3+0x5c0>
 1024d18:	4107883a 	add	r3,r8,r4
 1024d1c:	1a11803a 	cmpltu	r8,r3,r8
 1024d20:	8a23883a 	add	r17,r17,r8
 1024d24:	1811883a 	mov	r8,r3
 1024d28:	88c0402c 	andhi	r3,r17,256
 1024d2c:	18000426 	beq	r3,zero,1024d40 <__divdf3+0x5d8>
 1024d30:	00ffc034 	movhi	r3,65280
 1024d34:	18ffffc4 	addi	r3,r3,-1
 1024d38:	a8810004 	addi	r2,r21,1024
 1024d3c:	88e2703a 	and	r17,r17,r3
 1024d40:	00c1ff84 	movi	r3,2046
 1024d44:	18bee316 	blt	r3,r2,10248d4 <__alt_data_end+0xff0248d4>
 1024d48:	8824977a 	slli	r18,r17,29
 1024d4c:	4010d0fa 	srli	r8,r8,3
 1024d50:	8822927a 	slli	r17,r17,9
 1024d54:	1081ffcc 	andi	r2,r2,2047
 1024d58:	9224b03a 	or	r18,r18,r8
 1024d5c:	880ad33a 	srli	r5,r17,12
 1024d60:	98c0004c 	andi	r3,r19,1
 1024d64:	003edf06 	br	10248e4 <__alt_data_end+0xff0248e4>
 1024d68:	8080022c 	andhi	r2,r16,8
 1024d6c:	10001226 	beq	r2,zero,1024db8 <__divdf3+0x650>
 1024d70:	8880022c 	andhi	r2,r17,8
 1024d74:	1000101e 	bne	r2,zero,1024db8 <__divdf3+0x650>
 1024d78:	00800434 	movhi	r2,16
 1024d7c:	89400234 	orhi	r5,r17,8
 1024d80:	10bfffc4 	addi	r2,r2,-1
 1024d84:	b007883a 	mov	r3,r22
 1024d88:	288a703a 	and	r5,r5,r2
 1024d8c:	4025883a 	mov	r18,r8
 1024d90:	003f3106 	br	1024a58 <__alt_data_end+0xff024a58>
 1024d94:	008000c4 	movi	r2,3
 1024d98:	3880a626 	beq	r7,r2,1025034 <__divdf3+0x8cc>
 1024d9c:	00800044 	movi	r2,1
 1024da0:	3880521e 	bne	r7,r2,1024eec <__divdf3+0x784>
 1024da4:	b807883a 	mov	r3,r23
 1024da8:	0005883a 	mov	r2,zero
 1024dac:	000b883a 	mov	r5,zero
 1024db0:	0025883a 	mov	r18,zero
 1024db4:	003ecb06 	br	10248e4 <__alt_data_end+0xff0248e4>
 1024db8:	00800434 	movhi	r2,16
 1024dbc:	81400234 	orhi	r5,r16,8
 1024dc0:	10bfffc4 	addi	r2,r2,-1
 1024dc4:	a007883a 	mov	r3,r20
 1024dc8:	288a703a 	and	r5,r5,r2
 1024dcc:	003f2206 	br	1024a58 <__alt_data_end+0xff024a58>
 1024dd0:	183fca26 	beq	r3,zero,1024cfc <__alt_data_end+0xff024cfc>
 1024dd4:	e5ef883a 	add	r23,fp,r23
 1024dd8:	40bfffc4 	addi	r2,r8,-1
 1024ddc:	bf00392e 	bgeu	r23,fp,1024ec4 <__divdf3+0x75c>
 1024de0:	1011883a 	mov	r8,r2
 1024de4:	ba7fc41e 	bne	r23,r9,1024cf8 <__alt_data_end+0xff024cf8>
 1024de8:	b0ffc31e 	bne	r22,r3,1024cf8 <__alt_data_end+0xff024cf8>
 1024dec:	003fc306 	br	1024cfc <__alt_data_end+0xff024cfc>
 1024df0:	143ff604 	addi	r16,r2,-40
 1024df4:	9c20983a 	sll	r16,r19,r16
 1024df8:	0025883a 	mov	r18,zero
 1024dfc:	003ee206 	br	1024988 <__alt_data_end+0xff024988>
 1024e00:	d9800315 	stw	r6,12(sp)
 1024e04:	d9c00215 	stw	r7,8(sp)
 1024e08:	10264c00 	call	10264c0 <__clzsi2>
 1024e0c:	10800804 	addi	r2,r2,32
 1024e10:	d9c00217 	ldw	r7,8(sp)
 1024e14:	d9800317 	ldw	r6,12(sp)
 1024e18:	003ed106 	br	1024960 <__alt_data_end+0xff024960>
 1024e1c:	147ff604 	addi	r17,r2,-40
 1024e20:	3462983a 	sll	r17,r6,r17
 1024e24:	0011883a 	mov	r8,zero
 1024e28:	003ef506 	br	1024a00 <__alt_data_end+0xff024a00>
 1024e2c:	3009883a 	mov	r4,r6
 1024e30:	d9800315 	stw	r6,12(sp)
 1024e34:	da400115 	stw	r9,4(sp)
 1024e38:	10264c00 	call	10264c0 <__clzsi2>
 1024e3c:	10800804 	addi	r2,r2,32
 1024e40:	da400117 	ldw	r9,4(sp)
 1024e44:	d9800317 	ldw	r6,12(sp)
 1024e48:	003ee306 	br	10249d8 <__alt_data_end+0xff0249d8>
 1024e4c:	85a1883a 	add	r16,r16,r22
 1024e50:	8585803a 	cmpltu	r2,r16,r22
 1024e54:	1705883a 	add	r2,r2,fp
 1024e58:	14a5883a 	add	r18,r2,r18
 1024e5c:	88bfffc4 	addi	r2,r17,-1
 1024e60:	e4800c2e 	bgeu	fp,r18,1024e94 <__divdf3+0x72c>
 1024e64:	90c03e36 	bltu	r18,r3,1024f60 <__divdf3+0x7f8>
 1024e68:	1c806926 	beq	r3,r18,1025010 <__divdf3+0x8a8>
 1024e6c:	90c7c83a 	sub	r3,r18,r3
 1024e70:	1023883a 	mov	r17,r2
 1024e74:	003f5206 	br	1024bc0 <__alt_data_end+0xff024bc0>
 1024e78:	923f0436 	bltu	r18,r8,1024a8c <__alt_data_end+0xff024a8c>
 1024e7c:	800897fa 	slli	r4,r16,31
 1024e80:	9004d07a 	srli	r2,r18,1
 1024e84:	8006d07a 	srli	r3,r16,1
 1024e88:	902097fa 	slli	r16,r18,31
 1024e8c:	20a4b03a 	or	r18,r4,r2
 1024e90:	003f0106 	br	1024a98 <__alt_data_end+0xff024a98>
 1024e94:	e4bff51e 	bne	fp,r18,1024e6c <__alt_data_end+0xff024e6c>
 1024e98:	85bff22e 	bgeu	r16,r22,1024e64 <__alt_data_end+0xff024e64>
 1024e9c:	e0c7c83a 	sub	r3,fp,r3
 1024ea0:	1023883a 	mov	r17,r2
 1024ea4:	003f4606 	br	1024bc0 <__alt_data_end+0xff024bc0>
 1024ea8:	100f883a 	mov	r7,r2
 1024eac:	003f2b06 	br	1024b5c <__alt_data_end+0xff024b5c>
 1024eb0:	180d883a 	mov	r6,r3
 1024eb4:	003f1306 	br	1024b04 <__alt_data_end+0xff024b04>
 1024eb8:	813fe436 	bltu	r16,r4,1024e4c <__alt_data_end+0xff024e4c>
 1024ebc:	0007883a 	mov	r3,zero
 1024ec0:	003f3f06 	br	1024bc0 <__alt_data_end+0xff024bc0>
 1024ec4:	ba402c36 	bltu	r23,r9,1024f78 <__divdf3+0x810>
 1024ec8:	4dc05426 	beq	r9,r23,102501c <__divdf3+0x8b4>
 1024ecc:	1011883a 	mov	r8,r2
 1024ed0:	003f8906 	br	1024cf8 <__alt_data_end+0xff024cf8>
 1024ed4:	023fffc4 	movi	r8,-1
 1024ed8:	003f8806 	br	1024cfc <__alt_data_end+0xff024cfc>
 1024edc:	1811883a 	mov	r8,r3
 1024ee0:	003f5406 	br	1024c34 <__alt_data_end+0xff024c34>
 1024ee4:	1025883a 	mov	r18,r2
 1024ee8:	003f6d06 	br	1024ca0 <__alt_data_end+0xff024ca0>
 1024eec:	b827883a 	mov	r19,r23
 1024ef0:	003f8206 	br	1024cfc <__alt_data_end+0xff024cfc>
 1024ef4:	010007c4 	movi	r4,31
 1024ef8:	20c02616 	blt	r4,r3,1024f94 <__divdf3+0x82c>
 1024efc:	00800804 	movi	r2,32
 1024f00:	10c5c83a 	sub	r2,r2,r3
 1024f04:	888a983a 	sll	r5,r17,r2
 1024f08:	40c8d83a 	srl	r4,r8,r3
 1024f0c:	4084983a 	sll	r2,r8,r2
 1024f10:	88e2d83a 	srl	r17,r17,r3
 1024f14:	2906b03a 	or	r3,r5,r4
 1024f18:	1004c03a 	cmpne	r2,r2,zero
 1024f1c:	1886b03a 	or	r3,r3,r2
 1024f20:	188001cc 	andi	r2,r3,7
 1024f24:	10000726 	beq	r2,zero,1024f44 <__divdf3+0x7dc>
 1024f28:	188003cc 	andi	r2,r3,15
 1024f2c:	01000104 	movi	r4,4
 1024f30:	11000426 	beq	r2,r4,1024f44 <__divdf3+0x7dc>
 1024f34:	1805883a 	mov	r2,r3
 1024f38:	10c00104 	addi	r3,r2,4
 1024f3c:	1885803a 	cmpltu	r2,r3,r2
 1024f40:	88a3883a 	add	r17,r17,r2
 1024f44:	8880202c 	andhi	r2,r17,128
 1024f48:	10002726 	beq	r2,zero,1024fe8 <__divdf3+0x880>
 1024f4c:	98c0004c 	andi	r3,r19,1
 1024f50:	00800044 	movi	r2,1
 1024f54:	000b883a 	mov	r5,zero
 1024f58:	0025883a 	mov	r18,zero
 1024f5c:	003e6106 	br	10248e4 <__alt_data_end+0xff0248e4>
 1024f60:	85a1883a 	add	r16,r16,r22
 1024f64:	8585803a 	cmpltu	r2,r16,r22
 1024f68:	1705883a 	add	r2,r2,fp
 1024f6c:	14a5883a 	add	r18,r2,r18
 1024f70:	8c7fff84 	addi	r17,r17,-2
 1024f74:	003f1106 	br	1024bbc <__alt_data_end+0xff024bbc>
 1024f78:	b589883a 	add	r4,r22,r22
 1024f7c:	25ad803a 	cmpltu	r22,r4,r22
 1024f80:	b739883a 	add	fp,r22,fp
 1024f84:	40bfff84 	addi	r2,r8,-2
 1024f88:	bf2f883a 	add	r23,r23,fp
 1024f8c:	202d883a 	mov	r22,r4
 1024f90:	003f9306 	br	1024de0 <__alt_data_end+0xff024de0>
 1024f94:	013ff844 	movi	r4,-31
 1024f98:	2085c83a 	sub	r2,r4,r2
 1024f9c:	8888d83a 	srl	r4,r17,r2
 1024fa0:	00800804 	movi	r2,32
 1024fa4:	18802126 	beq	r3,r2,102502c <__divdf3+0x8c4>
 1024fa8:	00801004 	movi	r2,64
 1024fac:	10c5c83a 	sub	r2,r2,r3
 1024fb0:	8884983a 	sll	r2,r17,r2
 1024fb4:	1204b03a 	or	r2,r2,r8
 1024fb8:	1004c03a 	cmpne	r2,r2,zero
 1024fbc:	2084b03a 	or	r2,r4,r2
 1024fc0:	144001cc 	andi	r17,r2,7
 1024fc4:	88000d1e 	bne	r17,zero,1024ffc <__divdf3+0x894>
 1024fc8:	000b883a 	mov	r5,zero
 1024fcc:	1024d0fa 	srli	r18,r2,3
 1024fd0:	98c0004c 	andi	r3,r19,1
 1024fd4:	0005883a 	mov	r2,zero
 1024fd8:	9464b03a 	or	r18,r18,r17
 1024fdc:	003e4106 	br	10248e4 <__alt_data_end+0xff0248e4>
 1024fe0:	1007883a 	mov	r3,r2
 1024fe4:	0023883a 	mov	r17,zero
 1024fe8:	880a927a 	slli	r5,r17,9
 1024fec:	1805883a 	mov	r2,r3
 1024ff0:	8822977a 	slli	r17,r17,29
 1024ff4:	280ad33a 	srli	r5,r5,12
 1024ff8:	003ff406 	br	1024fcc <__alt_data_end+0xff024fcc>
 1024ffc:	10c003cc 	andi	r3,r2,15
 1025000:	01000104 	movi	r4,4
 1025004:	193ff626 	beq	r3,r4,1024fe0 <__alt_data_end+0xff024fe0>
 1025008:	0023883a 	mov	r17,zero
 102500c:	003fca06 	br	1024f38 <__alt_data_end+0xff024f38>
 1025010:	813fd336 	bltu	r16,r4,1024f60 <__alt_data_end+0xff024f60>
 1025014:	1023883a 	mov	r17,r2
 1025018:	003fa806 	br	1024ebc <__alt_data_end+0xff024ebc>
 102501c:	b0ffd636 	bltu	r22,r3,1024f78 <__alt_data_end+0xff024f78>
 1025020:	1011883a 	mov	r8,r2
 1025024:	b0ff341e 	bne	r22,r3,1024cf8 <__alt_data_end+0xff024cf8>
 1025028:	003f3406 	br	1024cfc <__alt_data_end+0xff024cfc>
 102502c:	0005883a 	mov	r2,zero
 1025030:	003fe006 	br	1024fb4 <__alt_data_end+0xff024fb4>
 1025034:	00800434 	movhi	r2,16
 1025038:	89400234 	orhi	r5,r17,8
 102503c:	10bfffc4 	addi	r2,r2,-1
 1025040:	b807883a 	mov	r3,r23
 1025044:	288a703a 	and	r5,r5,r2
 1025048:	4025883a 	mov	r18,r8
 102504c:	003e8206 	br	1024a58 <__alt_data_end+0xff024a58>

01025050 <__eqdf2>:
 1025050:	2804d53a 	srli	r2,r5,20
 1025054:	3806d53a 	srli	r3,r7,20
 1025058:	02000434 	movhi	r8,16
 102505c:	423fffc4 	addi	r8,r8,-1
 1025060:	1081ffcc 	andi	r2,r2,2047
 1025064:	0281ffc4 	movi	r10,2047
 1025068:	2a12703a 	and	r9,r5,r8
 102506c:	18c1ffcc 	andi	r3,r3,2047
 1025070:	3a10703a 	and	r8,r7,r8
 1025074:	280ad7fa 	srli	r5,r5,31
 1025078:	380ed7fa 	srli	r7,r7,31
 102507c:	12801026 	beq	r2,r10,10250c0 <__eqdf2+0x70>
 1025080:	0281ffc4 	movi	r10,2047
 1025084:	1a800a26 	beq	r3,r10,10250b0 <__eqdf2+0x60>
 1025088:	10c00226 	beq	r2,r3,1025094 <__eqdf2+0x44>
 102508c:	00800044 	movi	r2,1
 1025090:	f800283a 	ret
 1025094:	4a3ffd1e 	bne	r9,r8,102508c <__alt_data_end+0xff02508c>
 1025098:	21bffc1e 	bne	r4,r6,102508c <__alt_data_end+0xff02508c>
 102509c:	29c00c26 	beq	r5,r7,10250d0 <__eqdf2+0x80>
 10250a0:	103ffa1e 	bne	r2,zero,102508c <__alt_data_end+0xff02508c>
 10250a4:	2244b03a 	or	r2,r4,r9
 10250a8:	1004c03a 	cmpne	r2,r2,zero
 10250ac:	f800283a 	ret
 10250b0:	3214b03a 	or	r10,r6,r8
 10250b4:	503ff426 	beq	r10,zero,1025088 <__alt_data_end+0xff025088>
 10250b8:	00800044 	movi	r2,1
 10250bc:	f800283a 	ret
 10250c0:	2254b03a 	or	r10,r4,r9
 10250c4:	503fee26 	beq	r10,zero,1025080 <__alt_data_end+0xff025080>
 10250c8:	00800044 	movi	r2,1
 10250cc:	f800283a 	ret
 10250d0:	0005883a 	mov	r2,zero
 10250d4:	f800283a 	ret

010250d8 <__gedf2>:
 10250d8:	2804d53a 	srli	r2,r5,20
 10250dc:	3806d53a 	srli	r3,r7,20
 10250e0:	02000434 	movhi	r8,16
 10250e4:	423fffc4 	addi	r8,r8,-1
 10250e8:	1081ffcc 	andi	r2,r2,2047
 10250ec:	0241ffc4 	movi	r9,2047
 10250f0:	2a14703a 	and	r10,r5,r8
 10250f4:	18c1ffcc 	andi	r3,r3,2047
 10250f8:	3a10703a 	and	r8,r7,r8
 10250fc:	280ad7fa 	srli	r5,r5,31
 1025100:	380ed7fa 	srli	r7,r7,31
 1025104:	12401d26 	beq	r2,r9,102517c <__gedf2+0xa4>
 1025108:	0241ffc4 	movi	r9,2047
 102510c:	1a401226 	beq	r3,r9,1025158 <__gedf2+0x80>
 1025110:	1000081e 	bne	r2,zero,1025134 <__gedf2+0x5c>
 1025114:	2296b03a 	or	r11,r4,r10
 1025118:	5813003a 	cmpeq	r9,r11,zero
 102511c:	1800091e 	bne	r3,zero,1025144 <__gedf2+0x6c>
 1025120:	3218b03a 	or	r12,r6,r8
 1025124:	6000071e 	bne	r12,zero,1025144 <__gedf2+0x6c>
 1025128:	0005883a 	mov	r2,zero
 102512c:	5800101e 	bne	r11,zero,1025170 <__gedf2+0x98>
 1025130:	f800283a 	ret
 1025134:	18000c1e 	bne	r3,zero,1025168 <__gedf2+0x90>
 1025138:	3212b03a 	or	r9,r6,r8
 102513c:	48000c26 	beq	r9,zero,1025170 <__gedf2+0x98>
 1025140:	0013883a 	mov	r9,zero
 1025144:	39c03fcc 	andi	r7,r7,255
 1025148:	48000826 	beq	r9,zero,102516c <__gedf2+0x94>
 102514c:	38000926 	beq	r7,zero,1025174 <__gedf2+0x9c>
 1025150:	00800044 	movi	r2,1
 1025154:	f800283a 	ret
 1025158:	3212b03a 	or	r9,r6,r8
 102515c:	483fec26 	beq	r9,zero,1025110 <__alt_data_end+0xff025110>
 1025160:	00bfff84 	movi	r2,-2
 1025164:	f800283a 	ret
 1025168:	39c03fcc 	andi	r7,r7,255
 102516c:	29c00626 	beq	r5,r7,1025188 <__gedf2+0xb0>
 1025170:	283ff726 	beq	r5,zero,1025150 <__alt_data_end+0xff025150>
 1025174:	00bfffc4 	movi	r2,-1
 1025178:	f800283a 	ret
 102517c:	2292b03a 	or	r9,r4,r10
 1025180:	483fe126 	beq	r9,zero,1025108 <__alt_data_end+0xff025108>
 1025184:	003ff606 	br	1025160 <__alt_data_end+0xff025160>
 1025188:	18bff916 	blt	r3,r2,1025170 <__alt_data_end+0xff025170>
 102518c:	10c00316 	blt	r2,r3,102519c <__gedf2+0xc4>
 1025190:	42bff736 	bltu	r8,r10,1025170 <__alt_data_end+0xff025170>
 1025194:	52000326 	beq	r10,r8,10251a4 <__gedf2+0xcc>
 1025198:	5200042e 	bgeu	r10,r8,10251ac <__gedf2+0xd4>
 102519c:	283fec1e 	bne	r5,zero,1025150 <__alt_data_end+0xff025150>
 10251a0:	003ff406 	br	1025174 <__alt_data_end+0xff025174>
 10251a4:	313ff236 	bltu	r6,r4,1025170 <__alt_data_end+0xff025170>
 10251a8:	21bffc36 	bltu	r4,r6,102519c <__alt_data_end+0xff02519c>
 10251ac:	0005883a 	mov	r2,zero
 10251b0:	f800283a 	ret

010251b4 <__ledf2>:
 10251b4:	2804d53a 	srli	r2,r5,20
 10251b8:	3810d53a 	srli	r8,r7,20
 10251bc:	00c00434 	movhi	r3,16
 10251c0:	18ffffc4 	addi	r3,r3,-1
 10251c4:	1081ffcc 	andi	r2,r2,2047
 10251c8:	0241ffc4 	movi	r9,2047
 10251cc:	28d4703a 	and	r10,r5,r3
 10251d0:	4201ffcc 	andi	r8,r8,2047
 10251d4:	38c6703a 	and	r3,r7,r3
 10251d8:	280ad7fa 	srli	r5,r5,31
 10251dc:	380ed7fa 	srli	r7,r7,31
 10251e0:	12401f26 	beq	r2,r9,1025260 <__ledf2+0xac>
 10251e4:	0241ffc4 	movi	r9,2047
 10251e8:	42401426 	beq	r8,r9,102523c <__ledf2+0x88>
 10251ec:	1000091e 	bne	r2,zero,1025214 <__ledf2+0x60>
 10251f0:	2296b03a 	or	r11,r4,r10
 10251f4:	5813003a 	cmpeq	r9,r11,zero
 10251f8:	29403fcc 	andi	r5,r5,255
 10251fc:	40000a1e 	bne	r8,zero,1025228 <__ledf2+0x74>
 1025200:	30d8b03a 	or	r12,r6,r3
 1025204:	6000081e 	bne	r12,zero,1025228 <__ledf2+0x74>
 1025208:	0005883a 	mov	r2,zero
 102520c:	5800111e 	bne	r11,zero,1025254 <__ledf2+0xa0>
 1025210:	f800283a 	ret
 1025214:	29403fcc 	andi	r5,r5,255
 1025218:	40000c1e 	bne	r8,zero,102524c <__ledf2+0x98>
 102521c:	30d2b03a 	or	r9,r6,r3
 1025220:	48000c26 	beq	r9,zero,1025254 <__ledf2+0xa0>
 1025224:	0013883a 	mov	r9,zero
 1025228:	39c03fcc 	andi	r7,r7,255
 102522c:	48000826 	beq	r9,zero,1025250 <__ledf2+0x9c>
 1025230:	38001126 	beq	r7,zero,1025278 <__ledf2+0xc4>
 1025234:	00800044 	movi	r2,1
 1025238:	f800283a 	ret
 102523c:	30d2b03a 	or	r9,r6,r3
 1025240:	483fea26 	beq	r9,zero,10251ec <__alt_data_end+0xff0251ec>
 1025244:	00800084 	movi	r2,2
 1025248:	f800283a 	ret
 102524c:	39c03fcc 	andi	r7,r7,255
 1025250:	39400726 	beq	r7,r5,1025270 <__ledf2+0xbc>
 1025254:	2800081e 	bne	r5,zero,1025278 <__ledf2+0xc4>
 1025258:	00800044 	movi	r2,1
 102525c:	f800283a 	ret
 1025260:	2292b03a 	or	r9,r4,r10
 1025264:	483fdf26 	beq	r9,zero,10251e4 <__alt_data_end+0xff0251e4>
 1025268:	00800084 	movi	r2,2
 102526c:	f800283a 	ret
 1025270:	4080030e 	bge	r8,r2,1025280 <__ledf2+0xcc>
 1025274:	383fef26 	beq	r7,zero,1025234 <__alt_data_end+0xff025234>
 1025278:	00bfffc4 	movi	r2,-1
 102527c:	f800283a 	ret
 1025280:	123feb16 	blt	r2,r8,1025230 <__alt_data_end+0xff025230>
 1025284:	1abff336 	bltu	r3,r10,1025254 <__alt_data_end+0xff025254>
 1025288:	50c00326 	beq	r10,r3,1025298 <__ledf2+0xe4>
 102528c:	50c0042e 	bgeu	r10,r3,10252a0 <__ledf2+0xec>
 1025290:	283fe81e 	bne	r5,zero,1025234 <__alt_data_end+0xff025234>
 1025294:	003ff806 	br	1025278 <__alt_data_end+0xff025278>
 1025298:	313fee36 	bltu	r6,r4,1025254 <__alt_data_end+0xff025254>
 102529c:	21bffc36 	bltu	r4,r6,1025290 <__alt_data_end+0xff025290>
 10252a0:	0005883a 	mov	r2,zero
 10252a4:	f800283a 	ret

010252a8 <__muldf3>:
 10252a8:	defff304 	addi	sp,sp,-52
 10252ac:	2804d53a 	srli	r2,r5,20
 10252b0:	dd800915 	stw	r22,36(sp)
 10252b4:	282cd7fa 	srli	r22,r5,31
 10252b8:	dc000315 	stw	r16,12(sp)
 10252bc:	04000434 	movhi	r16,16
 10252c0:	dd400815 	stw	r21,32(sp)
 10252c4:	dc800515 	stw	r18,20(sp)
 10252c8:	843fffc4 	addi	r16,r16,-1
 10252cc:	dfc00c15 	stw	ra,48(sp)
 10252d0:	df000b15 	stw	fp,44(sp)
 10252d4:	ddc00a15 	stw	r23,40(sp)
 10252d8:	dd000715 	stw	r20,28(sp)
 10252dc:	dcc00615 	stw	r19,24(sp)
 10252e0:	dc400415 	stw	r17,16(sp)
 10252e4:	1481ffcc 	andi	r18,r2,2047
 10252e8:	2c20703a 	and	r16,r5,r16
 10252ec:	b02b883a 	mov	r21,r22
 10252f0:	b2403fcc 	andi	r9,r22,255
 10252f4:	90006026 	beq	r18,zero,1025478 <__muldf3+0x1d0>
 10252f8:	0081ffc4 	movi	r2,2047
 10252fc:	2029883a 	mov	r20,r4
 1025300:	90803626 	beq	r18,r2,10253dc <__muldf3+0x134>
 1025304:	80800434 	orhi	r2,r16,16
 1025308:	100490fa 	slli	r2,r2,3
 102530c:	2020d77a 	srli	r16,r4,29
 1025310:	202890fa 	slli	r20,r4,3
 1025314:	94bf0044 	addi	r18,r18,-1023
 1025318:	80a0b03a 	or	r16,r16,r2
 102531c:	0027883a 	mov	r19,zero
 1025320:	0039883a 	mov	fp,zero
 1025324:	3804d53a 	srli	r2,r7,20
 1025328:	382ed7fa 	srli	r23,r7,31
 102532c:	04400434 	movhi	r17,16
 1025330:	8c7fffc4 	addi	r17,r17,-1
 1025334:	1081ffcc 	andi	r2,r2,2047
 1025338:	3011883a 	mov	r8,r6
 102533c:	3c62703a 	and	r17,r7,r17
 1025340:	ba803fcc 	andi	r10,r23,255
 1025344:	10006d26 	beq	r2,zero,10254fc <__muldf3+0x254>
 1025348:	00c1ffc4 	movi	r3,2047
 102534c:	10c06526 	beq	r2,r3,10254e4 <__muldf3+0x23c>
 1025350:	88c00434 	orhi	r3,r17,16
 1025354:	180690fa 	slli	r3,r3,3
 1025358:	3022d77a 	srli	r17,r6,29
 102535c:	301090fa 	slli	r8,r6,3
 1025360:	10bf0044 	addi	r2,r2,-1023
 1025364:	88e2b03a 	or	r17,r17,r3
 1025368:	000b883a 	mov	r5,zero
 102536c:	9085883a 	add	r2,r18,r2
 1025370:	2cc8b03a 	or	r4,r5,r19
 1025374:	00c003c4 	movi	r3,15
 1025378:	bdacf03a 	xor	r22,r23,r22
 102537c:	12c00044 	addi	r11,r2,1
 1025380:	19009936 	bltu	r3,r4,10255e8 <__muldf3+0x340>
 1025384:	200890ba 	slli	r4,r4,2
 1025388:	00c040b4 	movhi	r3,258
 102538c:	18d4e704 	addi	r3,r3,21404
 1025390:	20c9883a 	add	r4,r4,r3
 1025394:	20c00017 	ldw	r3,0(r4)
 1025398:	1800683a 	jmp	r3
 102539c:	010255e8 	cmpgeui	r4,zero,2391
 10253a0:	010253fc 	xorhi	r4,zero,2383
 10253a4:	010253fc 	xorhi	r4,zero,2383
 10253a8:	010253f8 	rdprs	r4,zero,2383
 10253ac:	010255c4 	movi	r4,2391
 10253b0:	010255c4 	movi	r4,2391
 10253b4:	010255ac 	andhi	r4,zero,2390
 10253b8:	010253f8 	rdprs	r4,zero,2383
 10253bc:	010255c4 	movi	r4,2391
 10253c0:	010255ac 	andhi	r4,zero,2390
 10253c4:	010255c4 	movi	r4,2391
 10253c8:	010253f8 	rdprs	r4,zero,2383
 10253cc:	010255d4 	movui	r4,2391
 10253d0:	010255d4 	movui	r4,2391
 10253d4:	010255d4 	movui	r4,2391
 10253d8:	010257f0 	cmpltui	r4,zero,2399
 10253dc:	2404b03a 	or	r2,r4,r16
 10253e0:	10006f1e 	bne	r2,zero,10255a0 <__muldf3+0x2f8>
 10253e4:	04c00204 	movi	r19,8
 10253e8:	0021883a 	mov	r16,zero
 10253ec:	0029883a 	mov	r20,zero
 10253f0:	07000084 	movi	fp,2
 10253f4:	003fcb06 	br	1025324 <__alt_data_end+0xff025324>
 10253f8:	502d883a 	mov	r22,r10
 10253fc:	00800084 	movi	r2,2
 1025400:	28805726 	beq	r5,r2,1025560 <__muldf3+0x2b8>
 1025404:	008000c4 	movi	r2,3
 1025408:	28816626 	beq	r5,r2,10259a4 <__muldf3+0x6fc>
 102540c:	00800044 	movi	r2,1
 1025410:	2881411e 	bne	r5,r2,1025918 <__muldf3+0x670>
 1025414:	b02b883a 	mov	r21,r22
 1025418:	0005883a 	mov	r2,zero
 102541c:	000b883a 	mov	r5,zero
 1025420:	0029883a 	mov	r20,zero
 1025424:	1004953a 	slli	r2,r2,20
 1025428:	a8c03fcc 	andi	r3,r21,255
 102542c:	04400434 	movhi	r17,16
 1025430:	8c7fffc4 	addi	r17,r17,-1
 1025434:	180697fa 	slli	r3,r3,31
 1025438:	2c4a703a 	and	r5,r5,r17
 102543c:	288ab03a 	or	r5,r5,r2
 1025440:	28c6b03a 	or	r3,r5,r3
 1025444:	a005883a 	mov	r2,r20
 1025448:	dfc00c17 	ldw	ra,48(sp)
 102544c:	df000b17 	ldw	fp,44(sp)
 1025450:	ddc00a17 	ldw	r23,40(sp)
 1025454:	dd800917 	ldw	r22,36(sp)
 1025458:	dd400817 	ldw	r21,32(sp)
 102545c:	dd000717 	ldw	r20,28(sp)
 1025460:	dcc00617 	ldw	r19,24(sp)
 1025464:	dc800517 	ldw	r18,20(sp)
 1025468:	dc400417 	ldw	r17,16(sp)
 102546c:	dc000317 	ldw	r16,12(sp)
 1025470:	dec00d04 	addi	sp,sp,52
 1025474:	f800283a 	ret
 1025478:	2404b03a 	or	r2,r4,r16
 102547c:	2027883a 	mov	r19,r4
 1025480:	10004226 	beq	r2,zero,102558c <__muldf3+0x2e4>
 1025484:	8000fc26 	beq	r16,zero,1025878 <__muldf3+0x5d0>
 1025488:	8009883a 	mov	r4,r16
 102548c:	d9800215 	stw	r6,8(sp)
 1025490:	d9c00015 	stw	r7,0(sp)
 1025494:	da400115 	stw	r9,4(sp)
 1025498:	10264c00 	call	10264c0 <__clzsi2>
 102549c:	d9800217 	ldw	r6,8(sp)
 10254a0:	d9c00017 	ldw	r7,0(sp)
 10254a4:	da400117 	ldw	r9,4(sp)
 10254a8:	113ffd44 	addi	r4,r2,-11
 10254ac:	00c00704 	movi	r3,28
 10254b0:	1900ed16 	blt	r3,r4,1025868 <__muldf3+0x5c0>
 10254b4:	00c00744 	movi	r3,29
 10254b8:	147ffe04 	addi	r17,r2,-8
 10254bc:	1907c83a 	sub	r3,r3,r4
 10254c0:	8460983a 	sll	r16,r16,r17
 10254c4:	98c6d83a 	srl	r3,r19,r3
 10254c8:	9c68983a 	sll	r20,r19,r17
 10254cc:	1c20b03a 	or	r16,r3,r16
 10254d0:	1080fcc4 	addi	r2,r2,1011
 10254d4:	00a5c83a 	sub	r18,zero,r2
 10254d8:	0027883a 	mov	r19,zero
 10254dc:	0039883a 	mov	fp,zero
 10254e0:	003f9006 	br	1025324 <__alt_data_end+0xff025324>
 10254e4:	3446b03a 	or	r3,r6,r17
 10254e8:	1800261e 	bne	r3,zero,1025584 <__muldf3+0x2dc>
 10254ec:	0023883a 	mov	r17,zero
 10254f0:	0011883a 	mov	r8,zero
 10254f4:	01400084 	movi	r5,2
 10254f8:	003f9c06 	br	102536c <__alt_data_end+0xff02536c>
 10254fc:	3446b03a 	or	r3,r6,r17
 1025500:	18001c26 	beq	r3,zero,1025574 <__muldf3+0x2cc>
 1025504:	8800ce26 	beq	r17,zero,1025840 <__muldf3+0x598>
 1025508:	8809883a 	mov	r4,r17
 102550c:	d9800215 	stw	r6,8(sp)
 1025510:	da400115 	stw	r9,4(sp)
 1025514:	da800015 	stw	r10,0(sp)
 1025518:	10264c00 	call	10264c0 <__clzsi2>
 102551c:	d9800217 	ldw	r6,8(sp)
 1025520:	da400117 	ldw	r9,4(sp)
 1025524:	da800017 	ldw	r10,0(sp)
 1025528:	113ffd44 	addi	r4,r2,-11
 102552c:	00c00704 	movi	r3,28
 1025530:	1900bf16 	blt	r3,r4,1025830 <__muldf3+0x588>
 1025534:	00c00744 	movi	r3,29
 1025538:	123ffe04 	addi	r8,r2,-8
 102553c:	1907c83a 	sub	r3,r3,r4
 1025540:	8a22983a 	sll	r17,r17,r8
 1025544:	30c6d83a 	srl	r3,r6,r3
 1025548:	3210983a 	sll	r8,r6,r8
 102554c:	1c62b03a 	or	r17,r3,r17
 1025550:	1080fcc4 	addi	r2,r2,1011
 1025554:	0085c83a 	sub	r2,zero,r2
 1025558:	000b883a 	mov	r5,zero
 102555c:	003f8306 	br	102536c <__alt_data_end+0xff02536c>
 1025560:	b02b883a 	mov	r21,r22
 1025564:	0081ffc4 	movi	r2,2047
 1025568:	000b883a 	mov	r5,zero
 102556c:	0029883a 	mov	r20,zero
 1025570:	003fac06 	br	1025424 <__alt_data_end+0xff025424>
 1025574:	0023883a 	mov	r17,zero
 1025578:	0011883a 	mov	r8,zero
 102557c:	01400044 	movi	r5,1
 1025580:	003f7a06 	br	102536c <__alt_data_end+0xff02536c>
 1025584:	014000c4 	movi	r5,3
 1025588:	003f7806 	br	102536c <__alt_data_end+0xff02536c>
 102558c:	04c00104 	movi	r19,4
 1025590:	0021883a 	mov	r16,zero
 1025594:	0029883a 	mov	r20,zero
 1025598:	07000044 	movi	fp,1
 102559c:	003f6106 	br	1025324 <__alt_data_end+0xff025324>
 10255a0:	04c00304 	movi	r19,12
 10255a4:	070000c4 	movi	fp,3
 10255a8:	003f5e06 	br	1025324 <__alt_data_end+0xff025324>
 10255ac:	01400434 	movhi	r5,16
 10255b0:	002b883a 	mov	r21,zero
 10255b4:	297fffc4 	addi	r5,r5,-1
 10255b8:	053fffc4 	movi	r20,-1
 10255bc:	0081ffc4 	movi	r2,2047
 10255c0:	003f9806 	br	1025424 <__alt_data_end+0xff025424>
 10255c4:	8023883a 	mov	r17,r16
 10255c8:	a011883a 	mov	r8,r20
 10255cc:	e00b883a 	mov	r5,fp
 10255d0:	003f8a06 	br	10253fc <__alt_data_end+0xff0253fc>
 10255d4:	8023883a 	mov	r17,r16
 10255d8:	a011883a 	mov	r8,r20
 10255dc:	482d883a 	mov	r22,r9
 10255e0:	e00b883a 	mov	r5,fp
 10255e4:	003f8506 	br	10253fc <__alt_data_end+0xff0253fc>
 10255e8:	a00ad43a 	srli	r5,r20,16
 10255ec:	401ad43a 	srli	r13,r8,16
 10255f0:	a53fffcc 	andi	r20,r20,65535
 10255f4:	423fffcc 	andi	r8,r8,65535
 10255f8:	4519383a 	mul	r12,r8,r20
 10255fc:	4147383a 	mul	r3,r8,r5
 1025600:	6d09383a 	mul	r4,r13,r20
 1025604:	600cd43a 	srli	r6,r12,16
 1025608:	2b5d383a 	mul	r14,r5,r13
 102560c:	20c9883a 	add	r4,r4,r3
 1025610:	310d883a 	add	r6,r6,r4
 1025614:	30c0022e 	bgeu	r6,r3,1025620 <__muldf3+0x378>
 1025618:	00c00074 	movhi	r3,1
 102561c:	70dd883a 	add	r14,r14,r3
 1025620:	8826d43a 	srli	r19,r17,16
 1025624:	8bffffcc 	andi	r15,r17,65535
 1025628:	7d23383a 	mul	r17,r15,r20
 102562c:	7949383a 	mul	r4,r15,r5
 1025630:	9d29383a 	mul	r20,r19,r20
 1025634:	8814d43a 	srli	r10,r17,16
 1025638:	3012943a 	slli	r9,r6,16
 102563c:	a129883a 	add	r20,r20,r4
 1025640:	633fffcc 	andi	r12,r12,65535
 1025644:	5515883a 	add	r10,r10,r20
 1025648:	3006d43a 	srli	r3,r6,16
 102564c:	4b13883a 	add	r9,r9,r12
 1025650:	2ccb383a 	mul	r5,r5,r19
 1025654:	5100022e 	bgeu	r10,r4,1025660 <__muldf3+0x3b8>
 1025658:	01000074 	movhi	r4,1
 102565c:	290b883a 	add	r5,r5,r4
 1025660:	802ad43a 	srli	r21,r16,16
 1025664:	843fffcc 	andi	r16,r16,65535
 1025668:	440d383a 	mul	r6,r8,r16
 102566c:	4565383a 	mul	r18,r8,r21
 1025670:	8349383a 	mul	r4,r16,r13
 1025674:	500e943a 	slli	r7,r10,16
 1025678:	3010d43a 	srli	r8,r6,16
 102567c:	5028d43a 	srli	r20,r10,16
 1025680:	2489883a 	add	r4,r4,r18
 1025684:	8abfffcc 	andi	r10,r17,65535
 1025688:	3a95883a 	add	r10,r7,r10
 102568c:	4119883a 	add	r12,r8,r4
 1025690:	a169883a 	add	r20,r20,r5
 1025694:	1a87883a 	add	r3,r3,r10
 1025698:	6d5b383a 	mul	r13,r13,r21
 102569c:	6480022e 	bgeu	r12,r18,10256a8 <__muldf3+0x400>
 10256a0:	01000074 	movhi	r4,1
 10256a4:	691b883a 	add	r13,r13,r4
 10256a8:	7c25383a 	mul	r18,r15,r16
 10256ac:	7d4b383a 	mul	r5,r15,r21
 10256b0:	84cf383a 	mul	r7,r16,r19
 10256b4:	901ed43a 	srli	r15,r18,16
 10256b8:	6008d43a 	srli	r4,r12,16
 10256bc:	6010943a 	slli	r8,r12,16
 10256c0:	394f883a 	add	r7,r7,r5
 10256c4:	333fffcc 	andi	r12,r6,65535
 10256c8:	79df883a 	add	r15,r15,r7
 10256cc:	235b883a 	add	r13,r4,r13
 10256d0:	9d63383a 	mul	r17,r19,r21
 10256d4:	4309883a 	add	r4,r8,r12
 10256d8:	7940022e 	bgeu	r15,r5,10256e4 <__muldf3+0x43c>
 10256dc:	01400074 	movhi	r5,1
 10256e0:	8963883a 	add	r17,r17,r5
 10256e4:	780a943a 	slli	r5,r15,16
 10256e8:	91bfffcc 	andi	r6,r18,65535
 10256ec:	70c7883a 	add	r3,r14,r3
 10256f0:	298d883a 	add	r6,r5,r6
 10256f4:	1a8f803a 	cmpltu	r7,r3,r10
 10256f8:	350b883a 	add	r5,r6,r20
 10256fc:	20c7883a 	add	r3,r4,r3
 1025700:	3955883a 	add	r10,r7,r5
 1025704:	1909803a 	cmpltu	r4,r3,r4
 1025708:	6a91883a 	add	r8,r13,r10
 102570c:	780cd43a 	srli	r6,r15,16
 1025710:	2219883a 	add	r12,r4,r8
 1025714:	2d0b803a 	cmpltu	r5,r5,r20
 1025718:	51cf803a 	cmpltu	r7,r10,r7
 102571c:	29ceb03a 	or	r7,r5,r7
 1025720:	4351803a 	cmpltu	r8,r8,r13
 1025724:	610b803a 	cmpltu	r5,r12,r4
 1025728:	4148b03a 	or	r4,r8,r5
 102572c:	398f883a 	add	r7,r7,r6
 1025730:	3909883a 	add	r4,r7,r4
 1025734:	1810927a 	slli	r8,r3,9
 1025738:	2449883a 	add	r4,r4,r17
 102573c:	2008927a 	slli	r4,r4,9
 1025740:	6022d5fa 	srli	r17,r12,23
 1025744:	1806d5fa 	srli	r3,r3,23
 1025748:	4252b03a 	or	r9,r8,r9
 102574c:	600a927a 	slli	r5,r12,9
 1025750:	4810c03a 	cmpne	r8,r9,zero
 1025754:	2462b03a 	or	r17,r4,r17
 1025758:	40c6b03a 	or	r3,r8,r3
 102575c:	8900402c 	andhi	r4,r17,256
 1025760:	1950b03a 	or	r8,r3,r5
 1025764:	20000726 	beq	r4,zero,1025784 <__muldf3+0x4dc>
 1025768:	4006d07a 	srli	r3,r8,1
 102576c:	880497fa 	slli	r2,r17,31
 1025770:	4200004c 	andi	r8,r8,1
 1025774:	8822d07a 	srli	r17,r17,1
 1025778:	1a10b03a 	or	r8,r3,r8
 102577c:	1210b03a 	or	r8,r2,r8
 1025780:	5805883a 	mov	r2,r11
 1025784:	1140ffc4 	addi	r5,r2,1023
 1025788:	0140440e 	bge	zero,r5,102589c <__muldf3+0x5f4>
 102578c:	40c001cc 	andi	r3,r8,7
 1025790:	18000726 	beq	r3,zero,10257b0 <__muldf3+0x508>
 1025794:	40c003cc 	andi	r3,r8,15
 1025798:	01000104 	movi	r4,4
 102579c:	19000426 	beq	r3,r4,10257b0 <__muldf3+0x508>
 10257a0:	4107883a 	add	r3,r8,r4
 10257a4:	1a11803a 	cmpltu	r8,r3,r8
 10257a8:	8a23883a 	add	r17,r17,r8
 10257ac:	1811883a 	mov	r8,r3
 10257b0:	88c0402c 	andhi	r3,r17,256
 10257b4:	18000426 	beq	r3,zero,10257c8 <__muldf3+0x520>
 10257b8:	11410004 	addi	r5,r2,1024
 10257bc:	00bfc034 	movhi	r2,65280
 10257c0:	10bfffc4 	addi	r2,r2,-1
 10257c4:	88a2703a 	and	r17,r17,r2
 10257c8:	0081ff84 	movi	r2,2046
 10257cc:	117f6416 	blt	r2,r5,1025560 <__alt_data_end+0xff025560>
 10257d0:	8828977a 	slli	r20,r17,29
 10257d4:	4010d0fa 	srli	r8,r8,3
 10257d8:	8822927a 	slli	r17,r17,9
 10257dc:	2881ffcc 	andi	r2,r5,2047
 10257e0:	a228b03a 	or	r20,r20,r8
 10257e4:	880ad33a 	srli	r5,r17,12
 10257e8:	b02b883a 	mov	r21,r22
 10257ec:	003f0d06 	br	1025424 <__alt_data_end+0xff025424>
 10257f0:	8080022c 	andhi	r2,r16,8
 10257f4:	10000926 	beq	r2,zero,102581c <__muldf3+0x574>
 10257f8:	8880022c 	andhi	r2,r17,8
 10257fc:	1000071e 	bne	r2,zero,102581c <__muldf3+0x574>
 1025800:	00800434 	movhi	r2,16
 1025804:	89400234 	orhi	r5,r17,8
 1025808:	10bfffc4 	addi	r2,r2,-1
 102580c:	b82b883a 	mov	r21,r23
 1025810:	288a703a 	and	r5,r5,r2
 1025814:	4029883a 	mov	r20,r8
 1025818:	003f6806 	br	10255bc <__alt_data_end+0xff0255bc>
 102581c:	00800434 	movhi	r2,16
 1025820:	81400234 	orhi	r5,r16,8
 1025824:	10bfffc4 	addi	r2,r2,-1
 1025828:	288a703a 	and	r5,r5,r2
 102582c:	003f6306 	br	10255bc <__alt_data_end+0xff0255bc>
 1025830:	147ff604 	addi	r17,r2,-40
 1025834:	3462983a 	sll	r17,r6,r17
 1025838:	0011883a 	mov	r8,zero
 102583c:	003f4406 	br	1025550 <__alt_data_end+0xff025550>
 1025840:	3009883a 	mov	r4,r6
 1025844:	d9800215 	stw	r6,8(sp)
 1025848:	da400115 	stw	r9,4(sp)
 102584c:	da800015 	stw	r10,0(sp)
 1025850:	10264c00 	call	10264c0 <__clzsi2>
 1025854:	10800804 	addi	r2,r2,32
 1025858:	da800017 	ldw	r10,0(sp)
 102585c:	da400117 	ldw	r9,4(sp)
 1025860:	d9800217 	ldw	r6,8(sp)
 1025864:	003f3006 	br	1025528 <__alt_data_end+0xff025528>
 1025868:	143ff604 	addi	r16,r2,-40
 102586c:	9c20983a 	sll	r16,r19,r16
 1025870:	0029883a 	mov	r20,zero
 1025874:	003f1606 	br	10254d0 <__alt_data_end+0xff0254d0>
 1025878:	d9800215 	stw	r6,8(sp)
 102587c:	d9c00015 	stw	r7,0(sp)
 1025880:	da400115 	stw	r9,4(sp)
 1025884:	10264c00 	call	10264c0 <__clzsi2>
 1025888:	10800804 	addi	r2,r2,32
 102588c:	da400117 	ldw	r9,4(sp)
 1025890:	d9c00017 	ldw	r7,0(sp)
 1025894:	d9800217 	ldw	r6,8(sp)
 1025898:	003f0306 	br	10254a8 <__alt_data_end+0xff0254a8>
 102589c:	00c00044 	movi	r3,1
 10258a0:	1947c83a 	sub	r3,r3,r5
 10258a4:	00800e04 	movi	r2,56
 10258a8:	10feda16 	blt	r2,r3,1025414 <__alt_data_end+0xff025414>
 10258ac:	008007c4 	movi	r2,31
 10258b0:	10c01b16 	blt	r2,r3,1025920 <__muldf3+0x678>
 10258b4:	00800804 	movi	r2,32
 10258b8:	10c5c83a 	sub	r2,r2,r3
 10258bc:	888a983a 	sll	r5,r17,r2
 10258c0:	40c8d83a 	srl	r4,r8,r3
 10258c4:	4084983a 	sll	r2,r8,r2
 10258c8:	88e2d83a 	srl	r17,r17,r3
 10258cc:	2906b03a 	or	r3,r5,r4
 10258d0:	1004c03a 	cmpne	r2,r2,zero
 10258d4:	1886b03a 	or	r3,r3,r2
 10258d8:	188001cc 	andi	r2,r3,7
 10258dc:	10000726 	beq	r2,zero,10258fc <__muldf3+0x654>
 10258e0:	188003cc 	andi	r2,r3,15
 10258e4:	01000104 	movi	r4,4
 10258e8:	11000426 	beq	r2,r4,10258fc <__muldf3+0x654>
 10258ec:	1805883a 	mov	r2,r3
 10258f0:	10c00104 	addi	r3,r2,4
 10258f4:	1885803a 	cmpltu	r2,r3,r2
 10258f8:	88a3883a 	add	r17,r17,r2
 10258fc:	8880202c 	andhi	r2,r17,128
 1025900:	10001c26 	beq	r2,zero,1025974 <__muldf3+0x6cc>
 1025904:	b02b883a 	mov	r21,r22
 1025908:	00800044 	movi	r2,1
 102590c:	000b883a 	mov	r5,zero
 1025910:	0029883a 	mov	r20,zero
 1025914:	003ec306 	br	1025424 <__alt_data_end+0xff025424>
 1025918:	5805883a 	mov	r2,r11
 102591c:	003f9906 	br	1025784 <__alt_data_end+0xff025784>
 1025920:	00bff844 	movi	r2,-31
 1025924:	1145c83a 	sub	r2,r2,r5
 1025928:	8888d83a 	srl	r4,r17,r2
 102592c:	00800804 	movi	r2,32
 1025930:	18801a26 	beq	r3,r2,102599c <__muldf3+0x6f4>
 1025934:	00801004 	movi	r2,64
 1025938:	10c5c83a 	sub	r2,r2,r3
 102593c:	8884983a 	sll	r2,r17,r2
 1025940:	1204b03a 	or	r2,r2,r8
 1025944:	1004c03a 	cmpne	r2,r2,zero
 1025948:	2084b03a 	or	r2,r4,r2
 102594c:	144001cc 	andi	r17,r2,7
 1025950:	88000d1e 	bne	r17,zero,1025988 <__muldf3+0x6e0>
 1025954:	000b883a 	mov	r5,zero
 1025958:	1028d0fa 	srli	r20,r2,3
 102595c:	b02b883a 	mov	r21,r22
 1025960:	0005883a 	mov	r2,zero
 1025964:	a468b03a 	or	r20,r20,r17
 1025968:	003eae06 	br	1025424 <__alt_data_end+0xff025424>
 102596c:	1007883a 	mov	r3,r2
 1025970:	0023883a 	mov	r17,zero
 1025974:	880a927a 	slli	r5,r17,9
 1025978:	1805883a 	mov	r2,r3
 102597c:	8822977a 	slli	r17,r17,29
 1025980:	280ad33a 	srli	r5,r5,12
 1025984:	003ff406 	br	1025958 <__alt_data_end+0xff025958>
 1025988:	10c003cc 	andi	r3,r2,15
 102598c:	01000104 	movi	r4,4
 1025990:	193ff626 	beq	r3,r4,102596c <__alt_data_end+0xff02596c>
 1025994:	0023883a 	mov	r17,zero
 1025998:	003fd506 	br	10258f0 <__alt_data_end+0xff0258f0>
 102599c:	0005883a 	mov	r2,zero
 10259a0:	003fe706 	br	1025940 <__alt_data_end+0xff025940>
 10259a4:	00800434 	movhi	r2,16
 10259a8:	89400234 	orhi	r5,r17,8
 10259ac:	10bfffc4 	addi	r2,r2,-1
 10259b0:	b02b883a 	mov	r21,r22
 10259b4:	288a703a 	and	r5,r5,r2
 10259b8:	4029883a 	mov	r20,r8
 10259bc:	003eff06 	br	10255bc <__alt_data_end+0xff0255bc>

010259c0 <__subdf3>:
 10259c0:	02000434 	movhi	r8,16
 10259c4:	423fffc4 	addi	r8,r8,-1
 10259c8:	defffb04 	addi	sp,sp,-20
 10259cc:	2a14703a 	and	r10,r5,r8
 10259d0:	3812d53a 	srli	r9,r7,20
 10259d4:	3a10703a 	and	r8,r7,r8
 10259d8:	2006d77a 	srli	r3,r4,29
 10259dc:	3004d77a 	srli	r2,r6,29
 10259e0:	dc000015 	stw	r16,0(sp)
 10259e4:	501490fa 	slli	r10,r10,3
 10259e8:	2820d53a 	srli	r16,r5,20
 10259ec:	401090fa 	slli	r8,r8,3
 10259f0:	dc800215 	stw	r18,8(sp)
 10259f4:	dc400115 	stw	r17,4(sp)
 10259f8:	dfc00415 	stw	ra,16(sp)
 10259fc:	202290fa 	slli	r17,r4,3
 1025a00:	dcc00315 	stw	r19,12(sp)
 1025a04:	4a41ffcc 	andi	r9,r9,2047
 1025a08:	0101ffc4 	movi	r4,2047
 1025a0c:	2824d7fa 	srli	r18,r5,31
 1025a10:	8401ffcc 	andi	r16,r16,2047
 1025a14:	50c6b03a 	or	r3,r10,r3
 1025a18:	380ed7fa 	srli	r7,r7,31
 1025a1c:	408ab03a 	or	r5,r8,r2
 1025a20:	300c90fa 	slli	r6,r6,3
 1025a24:	49009626 	beq	r9,r4,1025c80 <__subdf3+0x2c0>
 1025a28:	39c0005c 	xori	r7,r7,1
 1025a2c:	8245c83a 	sub	r2,r16,r9
 1025a30:	3c807426 	beq	r7,r18,1025c04 <__subdf3+0x244>
 1025a34:	0080af0e 	bge	zero,r2,1025cf4 <__subdf3+0x334>
 1025a38:	48002a1e 	bne	r9,zero,1025ae4 <__subdf3+0x124>
 1025a3c:	2988b03a 	or	r4,r5,r6
 1025a40:	20009a1e 	bne	r4,zero,1025cac <__subdf3+0x2ec>
 1025a44:	888001cc 	andi	r2,r17,7
 1025a48:	10000726 	beq	r2,zero,1025a68 <__subdf3+0xa8>
 1025a4c:	888003cc 	andi	r2,r17,15
 1025a50:	01000104 	movi	r4,4
 1025a54:	11000426 	beq	r2,r4,1025a68 <__subdf3+0xa8>
 1025a58:	890b883a 	add	r5,r17,r4
 1025a5c:	2c63803a 	cmpltu	r17,r5,r17
 1025a60:	1c47883a 	add	r3,r3,r17
 1025a64:	2823883a 	mov	r17,r5
 1025a68:	1880202c 	andhi	r2,r3,128
 1025a6c:	10005926 	beq	r2,zero,1025bd4 <__subdf3+0x214>
 1025a70:	84000044 	addi	r16,r16,1
 1025a74:	0081ffc4 	movi	r2,2047
 1025a78:	8080be26 	beq	r16,r2,1025d74 <__subdf3+0x3b4>
 1025a7c:	017fe034 	movhi	r5,65408
 1025a80:	297fffc4 	addi	r5,r5,-1
 1025a84:	1946703a 	and	r3,r3,r5
 1025a88:	1804977a 	slli	r2,r3,29
 1025a8c:	1806927a 	slli	r3,r3,9
 1025a90:	8822d0fa 	srli	r17,r17,3
 1025a94:	8401ffcc 	andi	r16,r16,2047
 1025a98:	180ad33a 	srli	r5,r3,12
 1025a9c:	9100004c 	andi	r4,r18,1
 1025aa0:	1444b03a 	or	r2,r2,r17
 1025aa4:	80c1ffcc 	andi	r3,r16,2047
 1025aa8:	1820953a 	slli	r16,r3,20
 1025aac:	20c03fcc 	andi	r3,r4,255
 1025ab0:	180897fa 	slli	r4,r3,31
 1025ab4:	00c00434 	movhi	r3,16
 1025ab8:	18ffffc4 	addi	r3,r3,-1
 1025abc:	28c6703a 	and	r3,r5,r3
 1025ac0:	1c06b03a 	or	r3,r3,r16
 1025ac4:	1906b03a 	or	r3,r3,r4
 1025ac8:	dfc00417 	ldw	ra,16(sp)
 1025acc:	dcc00317 	ldw	r19,12(sp)
 1025ad0:	dc800217 	ldw	r18,8(sp)
 1025ad4:	dc400117 	ldw	r17,4(sp)
 1025ad8:	dc000017 	ldw	r16,0(sp)
 1025adc:	dec00504 	addi	sp,sp,20
 1025ae0:	f800283a 	ret
 1025ae4:	0101ffc4 	movi	r4,2047
 1025ae8:	813fd626 	beq	r16,r4,1025a44 <__alt_data_end+0xff025a44>
 1025aec:	29402034 	orhi	r5,r5,128
 1025af0:	01000e04 	movi	r4,56
 1025af4:	2080a316 	blt	r4,r2,1025d84 <__subdf3+0x3c4>
 1025af8:	010007c4 	movi	r4,31
 1025afc:	2080c616 	blt	r4,r2,1025e18 <__subdf3+0x458>
 1025b00:	01000804 	movi	r4,32
 1025b04:	2089c83a 	sub	r4,r4,r2
 1025b08:	2910983a 	sll	r8,r5,r4
 1025b0c:	308ed83a 	srl	r7,r6,r2
 1025b10:	3108983a 	sll	r4,r6,r4
 1025b14:	2884d83a 	srl	r2,r5,r2
 1025b18:	41ccb03a 	or	r6,r8,r7
 1025b1c:	2008c03a 	cmpne	r4,r4,zero
 1025b20:	310cb03a 	or	r6,r6,r4
 1025b24:	898dc83a 	sub	r6,r17,r6
 1025b28:	89a3803a 	cmpltu	r17,r17,r6
 1025b2c:	1887c83a 	sub	r3,r3,r2
 1025b30:	1c47c83a 	sub	r3,r3,r17
 1025b34:	3023883a 	mov	r17,r6
 1025b38:	1880202c 	andhi	r2,r3,128
 1025b3c:	10002326 	beq	r2,zero,1025bcc <__subdf3+0x20c>
 1025b40:	04c02034 	movhi	r19,128
 1025b44:	9cffffc4 	addi	r19,r19,-1
 1025b48:	1ce6703a 	and	r19,r3,r19
 1025b4c:	98007a26 	beq	r19,zero,1025d38 <__subdf3+0x378>
 1025b50:	9809883a 	mov	r4,r19
 1025b54:	10264c00 	call	10264c0 <__clzsi2>
 1025b58:	113ffe04 	addi	r4,r2,-8
 1025b5c:	00c007c4 	movi	r3,31
 1025b60:	19007b16 	blt	r3,r4,1025d50 <__subdf3+0x390>
 1025b64:	00800804 	movi	r2,32
 1025b68:	1105c83a 	sub	r2,r2,r4
 1025b6c:	8884d83a 	srl	r2,r17,r2
 1025b70:	9906983a 	sll	r3,r19,r4
 1025b74:	8922983a 	sll	r17,r17,r4
 1025b78:	10c4b03a 	or	r2,r2,r3
 1025b7c:	24007816 	blt	r4,r16,1025d60 <__subdf3+0x3a0>
 1025b80:	2421c83a 	sub	r16,r4,r16
 1025b84:	80c00044 	addi	r3,r16,1
 1025b88:	010007c4 	movi	r4,31
 1025b8c:	20c09516 	blt	r4,r3,1025de4 <__subdf3+0x424>
 1025b90:	01400804 	movi	r5,32
 1025b94:	28cbc83a 	sub	r5,r5,r3
 1025b98:	88c8d83a 	srl	r4,r17,r3
 1025b9c:	8962983a 	sll	r17,r17,r5
 1025ba0:	114a983a 	sll	r5,r2,r5
 1025ba4:	10c6d83a 	srl	r3,r2,r3
 1025ba8:	8804c03a 	cmpne	r2,r17,zero
 1025bac:	290ab03a 	or	r5,r5,r4
 1025bb0:	28a2b03a 	or	r17,r5,r2
 1025bb4:	0021883a 	mov	r16,zero
 1025bb8:	003fa206 	br	1025a44 <__alt_data_end+0xff025a44>
 1025bbc:	2090b03a 	or	r8,r4,r2
 1025bc0:	40018e26 	beq	r8,zero,10261fc <__subdf3+0x83c>
 1025bc4:	1007883a 	mov	r3,r2
 1025bc8:	2023883a 	mov	r17,r4
 1025bcc:	888001cc 	andi	r2,r17,7
 1025bd0:	103f9e1e 	bne	r2,zero,1025a4c <__alt_data_end+0xff025a4c>
 1025bd4:	1804977a 	slli	r2,r3,29
 1025bd8:	8822d0fa 	srli	r17,r17,3
 1025bdc:	1810d0fa 	srli	r8,r3,3
 1025be0:	9100004c 	andi	r4,r18,1
 1025be4:	1444b03a 	or	r2,r2,r17
 1025be8:	00c1ffc4 	movi	r3,2047
 1025bec:	80c02826 	beq	r16,r3,1025c90 <__subdf3+0x2d0>
 1025bf0:	01400434 	movhi	r5,16
 1025bf4:	297fffc4 	addi	r5,r5,-1
 1025bf8:	80e0703a 	and	r16,r16,r3
 1025bfc:	414a703a 	and	r5,r8,r5
 1025c00:	003fa806 	br	1025aa4 <__alt_data_end+0xff025aa4>
 1025c04:	0080630e 	bge	zero,r2,1025d94 <__subdf3+0x3d4>
 1025c08:	48003026 	beq	r9,zero,1025ccc <__subdf3+0x30c>
 1025c0c:	0101ffc4 	movi	r4,2047
 1025c10:	813f8c26 	beq	r16,r4,1025a44 <__alt_data_end+0xff025a44>
 1025c14:	29402034 	orhi	r5,r5,128
 1025c18:	01000e04 	movi	r4,56
 1025c1c:	2080a90e 	bge	r4,r2,1025ec4 <__subdf3+0x504>
 1025c20:	298cb03a 	or	r6,r5,r6
 1025c24:	3012c03a 	cmpne	r9,r6,zero
 1025c28:	0005883a 	mov	r2,zero
 1025c2c:	4c53883a 	add	r9,r9,r17
 1025c30:	4c63803a 	cmpltu	r17,r9,r17
 1025c34:	10c7883a 	add	r3,r2,r3
 1025c38:	88c7883a 	add	r3,r17,r3
 1025c3c:	4823883a 	mov	r17,r9
 1025c40:	1880202c 	andhi	r2,r3,128
 1025c44:	1000d026 	beq	r2,zero,1025f88 <__subdf3+0x5c8>
 1025c48:	84000044 	addi	r16,r16,1
 1025c4c:	0081ffc4 	movi	r2,2047
 1025c50:	8080fe26 	beq	r16,r2,102604c <__subdf3+0x68c>
 1025c54:	00bfe034 	movhi	r2,65408
 1025c58:	10bfffc4 	addi	r2,r2,-1
 1025c5c:	1886703a 	and	r3,r3,r2
 1025c60:	880ad07a 	srli	r5,r17,1
 1025c64:	180497fa 	slli	r2,r3,31
 1025c68:	8900004c 	andi	r4,r17,1
 1025c6c:	2922b03a 	or	r17,r5,r4
 1025c70:	1806d07a 	srli	r3,r3,1
 1025c74:	1462b03a 	or	r17,r2,r17
 1025c78:	3825883a 	mov	r18,r7
 1025c7c:	003f7106 	br	1025a44 <__alt_data_end+0xff025a44>
 1025c80:	2984b03a 	or	r2,r5,r6
 1025c84:	103f6826 	beq	r2,zero,1025a28 <__alt_data_end+0xff025a28>
 1025c88:	39c03fcc 	andi	r7,r7,255
 1025c8c:	003f6706 	br	1025a2c <__alt_data_end+0xff025a2c>
 1025c90:	4086b03a 	or	r3,r8,r2
 1025c94:	18015226 	beq	r3,zero,10261e0 <__subdf3+0x820>
 1025c98:	00c00434 	movhi	r3,16
 1025c9c:	41400234 	orhi	r5,r8,8
 1025ca0:	18ffffc4 	addi	r3,r3,-1
 1025ca4:	28ca703a 	and	r5,r5,r3
 1025ca8:	003f7e06 	br	1025aa4 <__alt_data_end+0xff025aa4>
 1025cac:	10bfffc4 	addi	r2,r2,-1
 1025cb0:	1000491e 	bne	r2,zero,1025dd8 <__subdf3+0x418>
 1025cb4:	898fc83a 	sub	r7,r17,r6
 1025cb8:	89e3803a 	cmpltu	r17,r17,r7
 1025cbc:	1947c83a 	sub	r3,r3,r5
 1025cc0:	1c47c83a 	sub	r3,r3,r17
 1025cc4:	3823883a 	mov	r17,r7
 1025cc8:	003f9b06 	br	1025b38 <__alt_data_end+0xff025b38>
 1025ccc:	2988b03a 	or	r4,r5,r6
 1025cd0:	203f5c26 	beq	r4,zero,1025a44 <__alt_data_end+0xff025a44>
 1025cd4:	10bfffc4 	addi	r2,r2,-1
 1025cd8:	1000931e 	bne	r2,zero,1025f28 <__subdf3+0x568>
 1025cdc:	898d883a 	add	r6,r17,r6
 1025ce0:	3463803a 	cmpltu	r17,r6,r17
 1025ce4:	1947883a 	add	r3,r3,r5
 1025ce8:	88c7883a 	add	r3,r17,r3
 1025cec:	3023883a 	mov	r17,r6
 1025cf0:	003fd306 	br	1025c40 <__alt_data_end+0xff025c40>
 1025cf4:	1000541e 	bne	r2,zero,1025e48 <__subdf3+0x488>
 1025cf8:	80800044 	addi	r2,r16,1
 1025cfc:	1081ffcc 	andi	r2,r2,2047
 1025d00:	01000044 	movi	r4,1
 1025d04:	2080a20e 	bge	r4,r2,1025f90 <__subdf3+0x5d0>
 1025d08:	8989c83a 	sub	r4,r17,r6
 1025d0c:	8905803a 	cmpltu	r2,r17,r4
 1025d10:	1967c83a 	sub	r19,r3,r5
 1025d14:	98a7c83a 	sub	r19,r19,r2
 1025d18:	9880202c 	andhi	r2,r19,128
 1025d1c:	10006326 	beq	r2,zero,1025eac <__subdf3+0x4ec>
 1025d20:	3463c83a 	sub	r17,r6,r17
 1025d24:	28c7c83a 	sub	r3,r5,r3
 1025d28:	344d803a 	cmpltu	r6,r6,r17
 1025d2c:	19a7c83a 	sub	r19,r3,r6
 1025d30:	3825883a 	mov	r18,r7
 1025d34:	983f861e 	bne	r19,zero,1025b50 <__alt_data_end+0xff025b50>
 1025d38:	8809883a 	mov	r4,r17
 1025d3c:	10264c00 	call	10264c0 <__clzsi2>
 1025d40:	10800804 	addi	r2,r2,32
 1025d44:	113ffe04 	addi	r4,r2,-8
 1025d48:	00c007c4 	movi	r3,31
 1025d4c:	193f850e 	bge	r3,r4,1025b64 <__alt_data_end+0xff025b64>
 1025d50:	10bff604 	addi	r2,r2,-40
 1025d54:	8884983a 	sll	r2,r17,r2
 1025d58:	0023883a 	mov	r17,zero
 1025d5c:	243f880e 	bge	r4,r16,1025b80 <__alt_data_end+0xff025b80>
 1025d60:	00ffe034 	movhi	r3,65408
 1025d64:	18ffffc4 	addi	r3,r3,-1
 1025d68:	8121c83a 	sub	r16,r16,r4
 1025d6c:	10c6703a 	and	r3,r2,r3
 1025d70:	003f3406 	br	1025a44 <__alt_data_end+0xff025a44>
 1025d74:	9100004c 	andi	r4,r18,1
 1025d78:	000b883a 	mov	r5,zero
 1025d7c:	0005883a 	mov	r2,zero
 1025d80:	003f4806 	br	1025aa4 <__alt_data_end+0xff025aa4>
 1025d84:	298cb03a 	or	r6,r5,r6
 1025d88:	300cc03a 	cmpne	r6,r6,zero
 1025d8c:	0005883a 	mov	r2,zero
 1025d90:	003f6406 	br	1025b24 <__alt_data_end+0xff025b24>
 1025d94:	10009a1e 	bne	r2,zero,1026000 <__subdf3+0x640>
 1025d98:	82400044 	addi	r9,r16,1
 1025d9c:	4881ffcc 	andi	r2,r9,2047
 1025da0:	02800044 	movi	r10,1
 1025da4:	5080670e 	bge	r10,r2,1025f44 <__subdf3+0x584>
 1025da8:	0081ffc4 	movi	r2,2047
 1025dac:	4880af26 	beq	r9,r2,102606c <__subdf3+0x6ac>
 1025db0:	898d883a 	add	r6,r17,r6
 1025db4:	1945883a 	add	r2,r3,r5
 1025db8:	3447803a 	cmpltu	r3,r6,r17
 1025dbc:	1887883a 	add	r3,r3,r2
 1025dc0:	182297fa 	slli	r17,r3,31
 1025dc4:	300cd07a 	srli	r6,r6,1
 1025dc8:	1806d07a 	srli	r3,r3,1
 1025dcc:	4821883a 	mov	r16,r9
 1025dd0:	89a2b03a 	or	r17,r17,r6
 1025dd4:	003f1b06 	br	1025a44 <__alt_data_end+0xff025a44>
 1025dd8:	0101ffc4 	movi	r4,2047
 1025ddc:	813f441e 	bne	r16,r4,1025af0 <__alt_data_end+0xff025af0>
 1025de0:	003f1806 	br	1025a44 <__alt_data_end+0xff025a44>
 1025de4:	843ff844 	addi	r16,r16,-31
 1025de8:	01400804 	movi	r5,32
 1025dec:	1408d83a 	srl	r4,r2,r16
 1025df0:	19405026 	beq	r3,r5,1025f34 <__subdf3+0x574>
 1025df4:	01401004 	movi	r5,64
 1025df8:	28c7c83a 	sub	r3,r5,r3
 1025dfc:	10c4983a 	sll	r2,r2,r3
 1025e00:	88a2b03a 	or	r17,r17,r2
 1025e04:	8822c03a 	cmpne	r17,r17,zero
 1025e08:	2462b03a 	or	r17,r4,r17
 1025e0c:	0007883a 	mov	r3,zero
 1025e10:	0021883a 	mov	r16,zero
 1025e14:	003f6d06 	br	1025bcc <__alt_data_end+0xff025bcc>
 1025e18:	11fff804 	addi	r7,r2,-32
 1025e1c:	01000804 	movi	r4,32
 1025e20:	29ced83a 	srl	r7,r5,r7
 1025e24:	11004526 	beq	r2,r4,1025f3c <__subdf3+0x57c>
 1025e28:	01001004 	movi	r4,64
 1025e2c:	2089c83a 	sub	r4,r4,r2
 1025e30:	2904983a 	sll	r2,r5,r4
 1025e34:	118cb03a 	or	r6,r2,r6
 1025e38:	300cc03a 	cmpne	r6,r6,zero
 1025e3c:	398cb03a 	or	r6,r7,r6
 1025e40:	0005883a 	mov	r2,zero
 1025e44:	003f3706 	br	1025b24 <__alt_data_end+0xff025b24>
 1025e48:	80002a26 	beq	r16,zero,1025ef4 <__subdf3+0x534>
 1025e4c:	0101ffc4 	movi	r4,2047
 1025e50:	49006626 	beq	r9,r4,1025fec <__subdf3+0x62c>
 1025e54:	0085c83a 	sub	r2,zero,r2
 1025e58:	18c02034 	orhi	r3,r3,128
 1025e5c:	01000e04 	movi	r4,56
 1025e60:	20807e16 	blt	r4,r2,102605c <__subdf3+0x69c>
 1025e64:	010007c4 	movi	r4,31
 1025e68:	2080e716 	blt	r4,r2,1026208 <__subdf3+0x848>
 1025e6c:	01000804 	movi	r4,32
 1025e70:	2089c83a 	sub	r4,r4,r2
 1025e74:	1914983a 	sll	r10,r3,r4
 1025e78:	8890d83a 	srl	r8,r17,r2
 1025e7c:	8908983a 	sll	r4,r17,r4
 1025e80:	1884d83a 	srl	r2,r3,r2
 1025e84:	5222b03a 	or	r17,r10,r8
 1025e88:	2006c03a 	cmpne	r3,r4,zero
 1025e8c:	88e2b03a 	or	r17,r17,r3
 1025e90:	3463c83a 	sub	r17,r6,r17
 1025e94:	2885c83a 	sub	r2,r5,r2
 1025e98:	344d803a 	cmpltu	r6,r6,r17
 1025e9c:	1187c83a 	sub	r3,r2,r6
 1025ea0:	4821883a 	mov	r16,r9
 1025ea4:	3825883a 	mov	r18,r7
 1025ea8:	003f2306 	br	1025b38 <__alt_data_end+0xff025b38>
 1025eac:	24d0b03a 	or	r8,r4,r19
 1025eb0:	40001b1e 	bne	r8,zero,1025f20 <__subdf3+0x560>
 1025eb4:	0005883a 	mov	r2,zero
 1025eb8:	0009883a 	mov	r4,zero
 1025ebc:	0021883a 	mov	r16,zero
 1025ec0:	003f4906 	br	1025be8 <__alt_data_end+0xff025be8>
 1025ec4:	010007c4 	movi	r4,31
 1025ec8:	20803a16 	blt	r4,r2,1025fb4 <__subdf3+0x5f4>
 1025ecc:	01000804 	movi	r4,32
 1025ed0:	2089c83a 	sub	r4,r4,r2
 1025ed4:	2912983a 	sll	r9,r5,r4
 1025ed8:	3090d83a 	srl	r8,r6,r2
 1025edc:	3108983a 	sll	r4,r6,r4
 1025ee0:	2884d83a 	srl	r2,r5,r2
 1025ee4:	4a12b03a 	or	r9,r9,r8
 1025ee8:	2008c03a 	cmpne	r4,r4,zero
 1025eec:	4912b03a 	or	r9,r9,r4
 1025ef0:	003f4e06 	br	1025c2c <__alt_data_end+0xff025c2c>
 1025ef4:	1c48b03a 	or	r4,r3,r17
 1025ef8:	20003c26 	beq	r4,zero,1025fec <__subdf3+0x62c>
 1025efc:	0084303a 	nor	r2,zero,r2
 1025f00:	1000381e 	bne	r2,zero,1025fe4 <__subdf3+0x624>
 1025f04:	3463c83a 	sub	r17,r6,r17
 1025f08:	28c5c83a 	sub	r2,r5,r3
 1025f0c:	344d803a 	cmpltu	r6,r6,r17
 1025f10:	1187c83a 	sub	r3,r2,r6
 1025f14:	4821883a 	mov	r16,r9
 1025f18:	3825883a 	mov	r18,r7
 1025f1c:	003f0606 	br	1025b38 <__alt_data_end+0xff025b38>
 1025f20:	2023883a 	mov	r17,r4
 1025f24:	003f0906 	br	1025b4c <__alt_data_end+0xff025b4c>
 1025f28:	0101ffc4 	movi	r4,2047
 1025f2c:	813f3a1e 	bne	r16,r4,1025c18 <__alt_data_end+0xff025c18>
 1025f30:	003ec406 	br	1025a44 <__alt_data_end+0xff025a44>
 1025f34:	0005883a 	mov	r2,zero
 1025f38:	003fb106 	br	1025e00 <__alt_data_end+0xff025e00>
 1025f3c:	0005883a 	mov	r2,zero
 1025f40:	003fbc06 	br	1025e34 <__alt_data_end+0xff025e34>
 1025f44:	1c44b03a 	or	r2,r3,r17
 1025f48:	80008e1e 	bne	r16,zero,1026184 <__subdf3+0x7c4>
 1025f4c:	1000c826 	beq	r2,zero,1026270 <__subdf3+0x8b0>
 1025f50:	2984b03a 	or	r2,r5,r6
 1025f54:	103ebb26 	beq	r2,zero,1025a44 <__alt_data_end+0xff025a44>
 1025f58:	8989883a 	add	r4,r17,r6
 1025f5c:	1945883a 	add	r2,r3,r5
 1025f60:	2447803a 	cmpltu	r3,r4,r17
 1025f64:	1887883a 	add	r3,r3,r2
 1025f68:	1880202c 	andhi	r2,r3,128
 1025f6c:	2023883a 	mov	r17,r4
 1025f70:	103f1626 	beq	r2,zero,1025bcc <__alt_data_end+0xff025bcc>
 1025f74:	00bfe034 	movhi	r2,65408
 1025f78:	10bfffc4 	addi	r2,r2,-1
 1025f7c:	5021883a 	mov	r16,r10
 1025f80:	1886703a 	and	r3,r3,r2
 1025f84:	003eaf06 	br	1025a44 <__alt_data_end+0xff025a44>
 1025f88:	3825883a 	mov	r18,r7
 1025f8c:	003f0f06 	br	1025bcc <__alt_data_end+0xff025bcc>
 1025f90:	1c44b03a 	or	r2,r3,r17
 1025f94:	8000251e 	bne	r16,zero,102602c <__subdf3+0x66c>
 1025f98:	1000661e 	bne	r2,zero,1026134 <__subdf3+0x774>
 1025f9c:	2990b03a 	or	r8,r5,r6
 1025fa0:	40009626 	beq	r8,zero,10261fc <__subdf3+0x83c>
 1025fa4:	2807883a 	mov	r3,r5
 1025fa8:	3023883a 	mov	r17,r6
 1025fac:	3825883a 	mov	r18,r7
 1025fb0:	003ea406 	br	1025a44 <__alt_data_end+0xff025a44>
 1025fb4:	127ff804 	addi	r9,r2,-32
 1025fb8:	01000804 	movi	r4,32
 1025fbc:	2a52d83a 	srl	r9,r5,r9
 1025fc0:	11008c26 	beq	r2,r4,10261f4 <__subdf3+0x834>
 1025fc4:	01001004 	movi	r4,64
 1025fc8:	2085c83a 	sub	r2,r4,r2
 1025fcc:	2884983a 	sll	r2,r5,r2
 1025fd0:	118cb03a 	or	r6,r2,r6
 1025fd4:	300cc03a 	cmpne	r6,r6,zero
 1025fd8:	4992b03a 	or	r9,r9,r6
 1025fdc:	0005883a 	mov	r2,zero
 1025fe0:	003f1206 	br	1025c2c <__alt_data_end+0xff025c2c>
 1025fe4:	0101ffc4 	movi	r4,2047
 1025fe8:	493f9c1e 	bne	r9,r4,1025e5c <__alt_data_end+0xff025e5c>
 1025fec:	2807883a 	mov	r3,r5
 1025ff0:	3023883a 	mov	r17,r6
 1025ff4:	4821883a 	mov	r16,r9
 1025ff8:	3825883a 	mov	r18,r7
 1025ffc:	003e9106 	br	1025a44 <__alt_data_end+0xff025a44>
 1026000:	80001f1e 	bne	r16,zero,1026080 <__subdf3+0x6c0>
 1026004:	1c48b03a 	or	r4,r3,r17
 1026008:	20005a26 	beq	r4,zero,1026174 <__subdf3+0x7b4>
 102600c:	0084303a 	nor	r2,zero,r2
 1026010:	1000561e 	bne	r2,zero,102616c <__subdf3+0x7ac>
 1026014:	89a3883a 	add	r17,r17,r6
 1026018:	1945883a 	add	r2,r3,r5
 102601c:	898d803a 	cmpltu	r6,r17,r6
 1026020:	3087883a 	add	r3,r6,r2
 1026024:	4821883a 	mov	r16,r9
 1026028:	003f0506 	br	1025c40 <__alt_data_end+0xff025c40>
 102602c:	10002b1e 	bne	r2,zero,10260dc <__subdf3+0x71c>
 1026030:	2984b03a 	or	r2,r5,r6
 1026034:	10008026 	beq	r2,zero,1026238 <__subdf3+0x878>
 1026038:	2807883a 	mov	r3,r5
 102603c:	3023883a 	mov	r17,r6
 1026040:	3825883a 	mov	r18,r7
 1026044:	0401ffc4 	movi	r16,2047
 1026048:	003e7e06 	br	1025a44 <__alt_data_end+0xff025a44>
 102604c:	3809883a 	mov	r4,r7
 1026050:	0011883a 	mov	r8,zero
 1026054:	0005883a 	mov	r2,zero
 1026058:	003ee306 	br	1025be8 <__alt_data_end+0xff025be8>
 102605c:	1c62b03a 	or	r17,r3,r17
 1026060:	8822c03a 	cmpne	r17,r17,zero
 1026064:	0005883a 	mov	r2,zero
 1026068:	003f8906 	br	1025e90 <__alt_data_end+0xff025e90>
 102606c:	3809883a 	mov	r4,r7
 1026070:	4821883a 	mov	r16,r9
 1026074:	0011883a 	mov	r8,zero
 1026078:	0005883a 	mov	r2,zero
 102607c:	003eda06 	br	1025be8 <__alt_data_end+0xff025be8>
 1026080:	0101ffc4 	movi	r4,2047
 1026084:	49003b26 	beq	r9,r4,1026174 <__subdf3+0x7b4>
 1026088:	0085c83a 	sub	r2,zero,r2
 102608c:	18c02034 	orhi	r3,r3,128
 1026090:	01000e04 	movi	r4,56
 1026094:	20806e16 	blt	r4,r2,1026250 <__subdf3+0x890>
 1026098:	010007c4 	movi	r4,31
 102609c:	20807716 	blt	r4,r2,102627c <__subdf3+0x8bc>
 10260a0:	01000804 	movi	r4,32
 10260a4:	2089c83a 	sub	r4,r4,r2
 10260a8:	1914983a 	sll	r10,r3,r4
 10260ac:	8890d83a 	srl	r8,r17,r2
 10260b0:	8908983a 	sll	r4,r17,r4
 10260b4:	1884d83a 	srl	r2,r3,r2
 10260b8:	5222b03a 	or	r17,r10,r8
 10260bc:	2006c03a 	cmpne	r3,r4,zero
 10260c0:	88e2b03a 	or	r17,r17,r3
 10260c4:	89a3883a 	add	r17,r17,r6
 10260c8:	1145883a 	add	r2,r2,r5
 10260cc:	898d803a 	cmpltu	r6,r17,r6
 10260d0:	3087883a 	add	r3,r6,r2
 10260d4:	4821883a 	mov	r16,r9
 10260d8:	003ed906 	br	1025c40 <__alt_data_end+0xff025c40>
 10260dc:	2984b03a 	or	r2,r5,r6
 10260e0:	10004226 	beq	r2,zero,10261ec <__subdf3+0x82c>
 10260e4:	1808d0fa 	srli	r4,r3,3
 10260e8:	8822d0fa 	srli	r17,r17,3
 10260ec:	1806977a 	slli	r3,r3,29
 10260f0:	2080022c 	andhi	r2,r4,8
 10260f4:	1c62b03a 	or	r17,r3,r17
 10260f8:	10000826 	beq	r2,zero,102611c <__subdf3+0x75c>
 10260fc:	2812d0fa 	srli	r9,r5,3
 1026100:	4880022c 	andhi	r2,r9,8
 1026104:	1000051e 	bne	r2,zero,102611c <__subdf3+0x75c>
 1026108:	300cd0fa 	srli	r6,r6,3
 102610c:	2804977a 	slli	r2,r5,29
 1026110:	4809883a 	mov	r4,r9
 1026114:	3825883a 	mov	r18,r7
 1026118:	11a2b03a 	or	r17,r2,r6
 102611c:	8806d77a 	srli	r3,r17,29
 1026120:	200890fa 	slli	r4,r4,3
 1026124:	882290fa 	slli	r17,r17,3
 1026128:	0401ffc4 	movi	r16,2047
 102612c:	1906b03a 	or	r3,r3,r4
 1026130:	003e4406 	br	1025a44 <__alt_data_end+0xff025a44>
 1026134:	2984b03a 	or	r2,r5,r6
 1026138:	103e4226 	beq	r2,zero,1025a44 <__alt_data_end+0xff025a44>
 102613c:	8989c83a 	sub	r4,r17,r6
 1026140:	8911803a 	cmpltu	r8,r17,r4
 1026144:	1945c83a 	sub	r2,r3,r5
 1026148:	1205c83a 	sub	r2,r2,r8
 102614c:	1200202c 	andhi	r8,r2,128
 1026150:	403e9a26 	beq	r8,zero,1025bbc <__alt_data_end+0xff025bbc>
 1026154:	3463c83a 	sub	r17,r6,r17
 1026158:	28c5c83a 	sub	r2,r5,r3
 102615c:	344d803a 	cmpltu	r6,r6,r17
 1026160:	1187c83a 	sub	r3,r2,r6
 1026164:	3825883a 	mov	r18,r7
 1026168:	003e3606 	br	1025a44 <__alt_data_end+0xff025a44>
 102616c:	0101ffc4 	movi	r4,2047
 1026170:	493fc71e 	bne	r9,r4,1026090 <__alt_data_end+0xff026090>
 1026174:	2807883a 	mov	r3,r5
 1026178:	3023883a 	mov	r17,r6
 102617c:	4821883a 	mov	r16,r9
 1026180:	003e3006 	br	1025a44 <__alt_data_end+0xff025a44>
 1026184:	10003626 	beq	r2,zero,1026260 <__subdf3+0x8a0>
 1026188:	2984b03a 	or	r2,r5,r6
 102618c:	10001726 	beq	r2,zero,10261ec <__subdf3+0x82c>
 1026190:	1808d0fa 	srli	r4,r3,3
 1026194:	8822d0fa 	srli	r17,r17,3
 1026198:	1806977a 	slli	r3,r3,29
 102619c:	2080022c 	andhi	r2,r4,8
 10261a0:	1c62b03a 	or	r17,r3,r17
 10261a4:	10000726 	beq	r2,zero,10261c4 <__subdf3+0x804>
 10261a8:	2812d0fa 	srli	r9,r5,3
 10261ac:	4880022c 	andhi	r2,r9,8
 10261b0:	1000041e 	bne	r2,zero,10261c4 <__subdf3+0x804>
 10261b4:	300cd0fa 	srli	r6,r6,3
 10261b8:	2804977a 	slli	r2,r5,29
 10261bc:	4809883a 	mov	r4,r9
 10261c0:	11a2b03a 	or	r17,r2,r6
 10261c4:	8806d77a 	srli	r3,r17,29
 10261c8:	200890fa 	slli	r4,r4,3
 10261cc:	882290fa 	slli	r17,r17,3
 10261d0:	3825883a 	mov	r18,r7
 10261d4:	1906b03a 	or	r3,r3,r4
 10261d8:	0401ffc4 	movi	r16,2047
 10261dc:	003e1906 	br	1025a44 <__alt_data_end+0xff025a44>
 10261e0:	000b883a 	mov	r5,zero
 10261e4:	0005883a 	mov	r2,zero
 10261e8:	003e2e06 	br	1025aa4 <__alt_data_end+0xff025aa4>
 10261ec:	0401ffc4 	movi	r16,2047
 10261f0:	003e1406 	br	1025a44 <__alt_data_end+0xff025a44>
 10261f4:	0005883a 	mov	r2,zero
 10261f8:	003f7506 	br	1025fd0 <__alt_data_end+0xff025fd0>
 10261fc:	0005883a 	mov	r2,zero
 1026200:	0009883a 	mov	r4,zero
 1026204:	003e7806 	br	1025be8 <__alt_data_end+0xff025be8>
 1026208:	123ff804 	addi	r8,r2,-32
 102620c:	01000804 	movi	r4,32
 1026210:	1a10d83a 	srl	r8,r3,r8
 1026214:	11002526 	beq	r2,r4,10262ac <__subdf3+0x8ec>
 1026218:	01001004 	movi	r4,64
 102621c:	2085c83a 	sub	r2,r4,r2
 1026220:	1884983a 	sll	r2,r3,r2
 1026224:	1444b03a 	or	r2,r2,r17
 1026228:	1004c03a 	cmpne	r2,r2,zero
 102622c:	40a2b03a 	or	r17,r8,r2
 1026230:	0005883a 	mov	r2,zero
 1026234:	003f1606 	br	1025e90 <__alt_data_end+0xff025e90>
 1026238:	02000434 	movhi	r8,16
 102623c:	0009883a 	mov	r4,zero
 1026240:	423fffc4 	addi	r8,r8,-1
 1026244:	00bfffc4 	movi	r2,-1
 1026248:	0401ffc4 	movi	r16,2047
 102624c:	003e6606 	br	1025be8 <__alt_data_end+0xff025be8>
 1026250:	1c62b03a 	or	r17,r3,r17
 1026254:	8822c03a 	cmpne	r17,r17,zero
 1026258:	0005883a 	mov	r2,zero
 102625c:	003f9906 	br	10260c4 <__alt_data_end+0xff0260c4>
 1026260:	2807883a 	mov	r3,r5
 1026264:	3023883a 	mov	r17,r6
 1026268:	0401ffc4 	movi	r16,2047
 102626c:	003df506 	br	1025a44 <__alt_data_end+0xff025a44>
 1026270:	2807883a 	mov	r3,r5
 1026274:	3023883a 	mov	r17,r6
 1026278:	003df206 	br	1025a44 <__alt_data_end+0xff025a44>
 102627c:	123ff804 	addi	r8,r2,-32
 1026280:	01000804 	movi	r4,32
 1026284:	1a10d83a 	srl	r8,r3,r8
 1026288:	11000a26 	beq	r2,r4,10262b4 <__subdf3+0x8f4>
 102628c:	01001004 	movi	r4,64
 1026290:	2085c83a 	sub	r2,r4,r2
 1026294:	1884983a 	sll	r2,r3,r2
 1026298:	1444b03a 	or	r2,r2,r17
 102629c:	1004c03a 	cmpne	r2,r2,zero
 10262a0:	40a2b03a 	or	r17,r8,r2
 10262a4:	0005883a 	mov	r2,zero
 10262a8:	003f8606 	br	10260c4 <__alt_data_end+0xff0260c4>
 10262ac:	0005883a 	mov	r2,zero
 10262b0:	003fdc06 	br	1026224 <__alt_data_end+0xff026224>
 10262b4:	0005883a 	mov	r2,zero
 10262b8:	003ff706 	br	1026298 <__alt_data_end+0xff026298>

010262bc <__fixdfsi>:
 10262bc:	280cd53a 	srli	r6,r5,20
 10262c0:	00c00434 	movhi	r3,16
 10262c4:	18ffffc4 	addi	r3,r3,-1
 10262c8:	3181ffcc 	andi	r6,r6,2047
 10262cc:	01c0ff84 	movi	r7,1022
 10262d0:	28c6703a 	and	r3,r5,r3
 10262d4:	280ad7fa 	srli	r5,r5,31
 10262d8:	3980120e 	bge	r7,r6,1026324 <__fixdfsi+0x68>
 10262dc:	00810744 	movi	r2,1053
 10262e0:	11800c16 	blt	r2,r6,1026314 <__fixdfsi+0x58>
 10262e4:	00810cc4 	movi	r2,1075
 10262e8:	1185c83a 	sub	r2,r2,r6
 10262ec:	01c007c4 	movi	r7,31
 10262f0:	18c00434 	orhi	r3,r3,16
 10262f4:	38800d16 	blt	r7,r2,102632c <__fixdfsi+0x70>
 10262f8:	31befb44 	addi	r6,r6,-1043
 10262fc:	2084d83a 	srl	r2,r4,r2
 1026300:	1986983a 	sll	r3,r3,r6
 1026304:	1884b03a 	or	r2,r3,r2
 1026308:	28000726 	beq	r5,zero,1026328 <__fixdfsi+0x6c>
 102630c:	0085c83a 	sub	r2,zero,r2
 1026310:	f800283a 	ret
 1026314:	00a00034 	movhi	r2,32768
 1026318:	10bfffc4 	addi	r2,r2,-1
 102631c:	2885883a 	add	r2,r5,r2
 1026320:	f800283a 	ret
 1026324:	0005883a 	mov	r2,zero
 1026328:	f800283a 	ret
 102632c:	008104c4 	movi	r2,1043
 1026330:	1185c83a 	sub	r2,r2,r6
 1026334:	1884d83a 	srl	r2,r3,r2
 1026338:	003ff306 	br	1026308 <__alt_data_end+0xff026308>

0102633c <__floatsidf>:
 102633c:	defffd04 	addi	sp,sp,-12
 1026340:	dfc00215 	stw	ra,8(sp)
 1026344:	dc400115 	stw	r17,4(sp)
 1026348:	dc000015 	stw	r16,0(sp)
 102634c:	20002b26 	beq	r4,zero,10263fc <__floatsidf+0xc0>
 1026350:	2023883a 	mov	r17,r4
 1026354:	2020d7fa 	srli	r16,r4,31
 1026358:	20002d16 	blt	r4,zero,1026410 <__floatsidf+0xd4>
 102635c:	8809883a 	mov	r4,r17
 1026360:	10264c00 	call	10264c0 <__clzsi2>
 1026364:	01410784 	movi	r5,1054
 1026368:	288bc83a 	sub	r5,r5,r2
 102636c:	01010cc4 	movi	r4,1075
 1026370:	2149c83a 	sub	r4,r4,r5
 1026374:	00c007c4 	movi	r3,31
 1026378:	1900160e 	bge	r3,r4,10263d4 <__floatsidf+0x98>
 102637c:	00c104c4 	movi	r3,1043
 1026380:	1947c83a 	sub	r3,r3,r5
 1026384:	88c6983a 	sll	r3,r17,r3
 1026388:	00800434 	movhi	r2,16
 102638c:	10bfffc4 	addi	r2,r2,-1
 1026390:	1886703a 	and	r3,r3,r2
 1026394:	2941ffcc 	andi	r5,r5,2047
 1026398:	800d883a 	mov	r6,r16
 102639c:	0005883a 	mov	r2,zero
 10263a0:	280a953a 	slli	r5,r5,20
 10263a4:	31803fcc 	andi	r6,r6,255
 10263a8:	01000434 	movhi	r4,16
 10263ac:	300c97fa 	slli	r6,r6,31
 10263b0:	213fffc4 	addi	r4,r4,-1
 10263b4:	1906703a 	and	r3,r3,r4
 10263b8:	1946b03a 	or	r3,r3,r5
 10263bc:	1986b03a 	or	r3,r3,r6
 10263c0:	dfc00217 	ldw	ra,8(sp)
 10263c4:	dc400117 	ldw	r17,4(sp)
 10263c8:	dc000017 	ldw	r16,0(sp)
 10263cc:	dec00304 	addi	sp,sp,12
 10263d0:	f800283a 	ret
 10263d4:	00c002c4 	movi	r3,11
 10263d8:	1887c83a 	sub	r3,r3,r2
 10263dc:	88c6d83a 	srl	r3,r17,r3
 10263e0:	8904983a 	sll	r2,r17,r4
 10263e4:	01000434 	movhi	r4,16
 10263e8:	213fffc4 	addi	r4,r4,-1
 10263ec:	2941ffcc 	andi	r5,r5,2047
 10263f0:	1906703a 	and	r3,r3,r4
 10263f4:	800d883a 	mov	r6,r16
 10263f8:	003fe906 	br	10263a0 <__alt_data_end+0xff0263a0>
 10263fc:	000d883a 	mov	r6,zero
 1026400:	000b883a 	mov	r5,zero
 1026404:	0007883a 	mov	r3,zero
 1026408:	0005883a 	mov	r2,zero
 102640c:	003fe406 	br	10263a0 <__alt_data_end+0xff0263a0>
 1026410:	0123c83a 	sub	r17,zero,r4
 1026414:	003fd106 	br	102635c <__alt_data_end+0xff02635c>

01026418 <__floatunsidf>:
 1026418:	defffe04 	addi	sp,sp,-8
 102641c:	dc000015 	stw	r16,0(sp)
 1026420:	dfc00115 	stw	ra,4(sp)
 1026424:	2021883a 	mov	r16,r4
 1026428:	20002226 	beq	r4,zero,10264b4 <__floatunsidf+0x9c>
 102642c:	10264c00 	call	10264c0 <__clzsi2>
 1026430:	01010784 	movi	r4,1054
 1026434:	2089c83a 	sub	r4,r4,r2
 1026438:	01810cc4 	movi	r6,1075
 102643c:	310dc83a 	sub	r6,r6,r4
 1026440:	00c007c4 	movi	r3,31
 1026444:	1980120e 	bge	r3,r6,1026490 <__floatunsidf+0x78>
 1026448:	00c104c4 	movi	r3,1043
 102644c:	1907c83a 	sub	r3,r3,r4
 1026450:	80ca983a 	sll	r5,r16,r3
 1026454:	00800434 	movhi	r2,16
 1026458:	10bfffc4 	addi	r2,r2,-1
 102645c:	2101ffcc 	andi	r4,r4,2047
 1026460:	0021883a 	mov	r16,zero
 1026464:	288a703a 	and	r5,r5,r2
 1026468:	2008953a 	slli	r4,r4,20
 102646c:	00c00434 	movhi	r3,16
 1026470:	18ffffc4 	addi	r3,r3,-1
 1026474:	28c6703a 	and	r3,r5,r3
 1026478:	8005883a 	mov	r2,r16
 102647c:	1906b03a 	or	r3,r3,r4
 1026480:	dfc00117 	ldw	ra,4(sp)
 1026484:	dc000017 	ldw	r16,0(sp)
 1026488:	dec00204 	addi	sp,sp,8
 102648c:	f800283a 	ret
 1026490:	00c002c4 	movi	r3,11
 1026494:	188bc83a 	sub	r5,r3,r2
 1026498:	814ad83a 	srl	r5,r16,r5
 102649c:	00c00434 	movhi	r3,16
 10264a0:	18ffffc4 	addi	r3,r3,-1
 10264a4:	81a0983a 	sll	r16,r16,r6
 10264a8:	2101ffcc 	andi	r4,r4,2047
 10264ac:	28ca703a 	and	r5,r5,r3
 10264b0:	003fed06 	br	1026468 <__alt_data_end+0xff026468>
 10264b4:	0009883a 	mov	r4,zero
 10264b8:	000b883a 	mov	r5,zero
 10264bc:	003fea06 	br	1026468 <__alt_data_end+0xff026468>

010264c0 <__clzsi2>:
 10264c0:	00bfffd4 	movui	r2,65535
 10264c4:	11000536 	bltu	r2,r4,10264dc <__clzsi2+0x1c>
 10264c8:	00803fc4 	movi	r2,255
 10264cc:	11000f36 	bltu	r2,r4,102650c <__clzsi2+0x4c>
 10264d0:	00800804 	movi	r2,32
 10264d4:	0007883a 	mov	r3,zero
 10264d8:	00000506 	br	10264f0 <__clzsi2+0x30>
 10264dc:	00804034 	movhi	r2,256
 10264e0:	10bfffc4 	addi	r2,r2,-1
 10264e4:	11000c2e 	bgeu	r2,r4,1026518 <__clzsi2+0x58>
 10264e8:	00800204 	movi	r2,8
 10264ec:	00c00604 	movi	r3,24
 10264f0:	20c8d83a 	srl	r4,r4,r3
 10264f4:	00c040f4 	movhi	r3,259
 10264f8:	18eafd04 	addi	r3,r3,-21516
 10264fc:	1909883a 	add	r4,r3,r4
 1026500:	20c00003 	ldbu	r3,0(r4)
 1026504:	10c5c83a 	sub	r2,r2,r3
 1026508:	f800283a 	ret
 102650c:	00800604 	movi	r2,24
 1026510:	00c00204 	movi	r3,8
 1026514:	003ff606 	br	10264f0 <__alt_data_end+0xff0264f0>
 1026518:	00800404 	movi	r2,16
 102651c:	1007883a 	mov	r3,r2
 1026520:	003ff306 	br	10264f0 <__alt_data_end+0xff0264f0>

01026524 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1026524:	defffe04 	addi	sp,sp,-8
 1026528:	dfc00115 	stw	ra,4(sp)
 102652c:	df000015 	stw	fp,0(sp)
 1026530:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1026534:	d0a01517 	ldw	r2,-32684(gp)
 1026538:	10000326 	beq	r2,zero,1026548 <alt_get_errno+0x24>
 102653c:	d0a01517 	ldw	r2,-32684(gp)
 1026540:	103ee83a 	callr	r2
 1026544:	00000106 	br	102654c <alt_get_errno+0x28>
 1026548:	d0a75b04 	addi	r2,gp,-25236
}
 102654c:	e037883a 	mov	sp,fp
 1026550:	dfc00117 	ldw	ra,4(sp)
 1026554:	df000017 	ldw	fp,0(sp)
 1026558:	dec00204 	addi	sp,sp,8
 102655c:	f800283a 	ret

01026560 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 1026560:	defffb04 	addi	sp,sp,-20
 1026564:	dfc00415 	stw	ra,16(sp)
 1026568:	df000315 	stw	fp,12(sp)
 102656c:	df000304 	addi	fp,sp,12
 1026570:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 1026574:	e0bfff17 	ldw	r2,-4(fp)
 1026578:	10000616 	blt	r2,zero,1026594 <close+0x34>
 102657c:	e0bfff17 	ldw	r2,-4(fp)
 1026580:	10c00324 	muli	r3,r2,12
 1026584:	008040f4 	movhi	r2,259
 1026588:	10add604 	addi	r2,r2,-18600
 102658c:	1885883a 	add	r2,r3,r2
 1026590:	00000106 	br	1026598 <close+0x38>
 1026594:	0005883a 	mov	r2,zero
 1026598:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 102659c:	e0bffd17 	ldw	r2,-12(fp)
 10265a0:	10001926 	beq	r2,zero,1026608 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 10265a4:	e0bffd17 	ldw	r2,-12(fp)
 10265a8:	10800017 	ldw	r2,0(r2)
 10265ac:	10800417 	ldw	r2,16(r2)
 10265b0:	10000626 	beq	r2,zero,10265cc <close+0x6c>
 10265b4:	e0bffd17 	ldw	r2,-12(fp)
 10265b8:	10800017 	ldw	r2,0(r2)
 10265bc:	10800417 	ldw	r2,16(r2)
 10265c0:	e13ffd17 	ldw	r4,-12(fp)
 10265c4:	103ee83a 	callr	r2
 10265c8:	00000106 	br	10265d0 <close+0x70>
 10265cc:	0005883a 	mov	r2,zero
 10265d0:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 10265d4:	e13fff17 	ldw	r4,-4(fp)
 10265d8:	10270500 	call	1027050 <alt_release_fd>
    if (rval < 0)
 10265dc:	e0bffe17 	ldw	r2,-8(fp)
 10265e0:	1000070e 	bge	r2,zero,1026600 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 10265e4:	10265240 	call	1026524 <alt_get_errno>
 10265e8:	1007883a 	mov	r3,r2
 10265ec:	e0bffe17 	ldw	r2,-8(fp)
 10265f0:	0085c83a 	sub	r2,zero,r2
 10265f4:	18800015 	stw	r2,0(r3)
      return -1;
 10265f8:	00bfffc4 	movi	r2,-1
 10265fc:	00000706 	br	102661c <close+0xbc>
    }
    return 0;
 1026600:	0005883a 	mov	r2,zero
 1026604:	00000506 	br	102661c <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1026608:	10265240 	call	1026524 <alt_get_errno>
 102660c:	1007883a 	mov	r3,r2
 1026610:	00801444 	movi	r2,81
 1026614:	18800015 	stw	r2,0(r3)
    return -1;
 1026618:	00bfffc4 	movi	r2,-1
  }
}
 102661c:	e037883a 	mov	sp,fp
 1026620:	dfc00117 	ldw	ra,4(sp)
 1026624:	df000017 	ldw	fp,0(sp)
 1026628:	dec00204 	addi	sp,sp,8
 102662c:	f800283a 	ret

01026630 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 1026630:	defffb04 	addi	sp,sp,-20
 1026634:	df000415 	stw	fp,16(sp)
 1026638:	df000404 	addi	fp,sp,16
 102663c:	e13ffe15 	stw	r4,-8(fp)
 1026640:	e17fff15 	stw	r5,-4(fp)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 
 1026644:	e0fffe17 	ldw	r3,-8(fp)
 1026648:	e0bfff17 	ldw	r2,-4(fp)
 102664c:	1885883a 	add	r2,r3,r2
 1026650:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 1026654:	e0bffe17 	ldw	r2,-8(fp)
 1026658:	e0bffc15 	stw	r2,-16(fp)
 102665c:	00000506 	br	1026674 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 1026660:	e0bffc17 	ldw	r2,-16(fp)
 1026664:	1000001b 	flushda	0(r2)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 1026668:	e0bffc17 	ldw	r2,-16(fp)
 102666c:	10800804 	addi	r2,r2,32
 1026670:	e0bffc15 	stw	r2,-16(fp)
 1026674:	e0fffc17 	ldw	r3,-16(fp)
 1026678:	e0bffd17 	ldw	r2,-12(fp)
 102667c:	18bff836 	bltu	r3,r2,1026660 <__alt_data_end+0xff026660>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 1026680:	e0bffe17 	ldw	r2,-8(fp)
 1026684:	108007cc 	andi	r2,r2,31
 1026688:	10000226 	beq	r2,zero,1026694 <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 102668c:	e0bffc17 	ldw	r2,-16(fp)
 1026690:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 1026694:	0001883a 	nop
 1026698:	e037883a 	mov	sp,fp
 102669c:	df000017 	ldw	fp,0(sp)
 10266a0:	dec00104 	addi	sp,sp,4
 10266a4:	f800283a 	ret

010266a8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 10266a8:	defffe04 	addi	sp,sp,-8
 10266ac:	df000115 	stw	fp,4(sp)
 10266b0:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 10266b4:	e03fff15 	stw	zero,-4(fp)
 10266b8:	00000506 	br	10266d0 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 10266bc:	e0bfff17 	ldw	r2,-4(fp)
 10266c0:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 10266c4:	e0bfff17 	ldw	r2,-4(fp)
 10266c8:	10800804 	addi	r2,r2,32
 10266cc:	e0bfff15 	stw	r2,-4(fp)
 10266d0:	e0bfff17 	ldw	r2,-4(fp)
 10266d4:	10820030 	cmpltui	r2,r2,2048
 10266d8:	103ff81e 	bne	r2,zero,10266bc <__alt_data_end+0xff0266bc>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 10266dc:	0001883a 	nop
 10266e0:	e037883a 	mov	sp,fp
 10266e4:	df000017 	ldw	fp,0(sp)
 10266e8:	dec00104 	addi	sp,sp,4
 10266ec:	f800283a 	ret

010266f0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 10266f0:	defffc04 	addi	sp,sp,-16
 10266f4:	df000315 	stw	fp,12(sp)
 10266f8:	df000304 	addi	fp,sp,12
 10266fc:	e13ffd15 	stw	r4,-12(fp)
 1026700:	e17ffe15 	stw	r5,-8(fp)
 1026704:	e1bfff15 	stw	r6,-4(fp)
  return len;
 1026708:	e0bfff17 	ldw	r2,-4(fp)
}
 102670c:	e037883a 	mov	sp,fp
 1026710:	df000017 	ldw	fp,0(sp)
 1026714:	dec00104 	addi	sp,sp,4
 1026718:	f800283a 	ret

0102671c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 102671c:	defffd04 	addi	sp,sp,-12
 1026720:	df000215 	stw	fp,8(sp)
 1026724:	df000204 	addi	fp,sp,8
 1026728:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 102672c:	0001883a 	nop
 1026730:	e0bfff17 	ldw	r2,-4(fp)
 1026734:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 1026738:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 102673c:	10000226 	beq	r2,zero,1026748 <_exit+0x2c>
    ALT_SIM_FAIL();
 1026740:	002af070 	cmpltui	zero,zero,43969
 1026744:	00000106 	br	102674c <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 1026748:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 102674c:	003fff06 	br	102674c <__alt_data_end+0xff02674c>

01026750 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1026750:	defffe04 	addi	sp,sp,-8
 1026754:	dfc00115 	stw	ra,4(sp)
 1026758:	df000015 	stw	fp,0(sp)
 102675c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1026760:	d0a01517 	ldw	r2,-32684(gp)
 1026764:	10000326 	beq	r2,zero,1026774 <alt_get_errno+0x24>
 1026768:	d0a01517 	ldw	r2,-32684(gp)
 102676c:	103ee83a 	callr	r2
 1026770:	00000106 	br	1026778 <alt_get_errno+0x28>
 1026774:	d0a75b04 	addi	r2,gp,-25236
}
 1026778:	e037883a 	mov	sp,fp
 102677c:	dfc00117 	ldw	ra,4(sp)
 1026780:	df000017 	ldw	fp,0(sp)
 1026784:	dec00204 	addi	sp,sp,8
 1026788:	f800283a 	ret

0102678c <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 102678c:	defffb04 	addi	sp,sp,-20
 1026790:	dfc00415 	stw	ra,16(sp)
 1026794:	df000315 	stw	fp,12(sp)
 1026798:	df000304 	addi	fp,sp,12
 102679c:	e13ffe15 	stw	r4,-8(fp)
 10267a0:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 10267a4:	e0bffe17 	ldw	r2,-8(fp)
 10267a8:	10000616 	blt	r2,zero,10267c4 <fstat+0x38>
 10267ac:	e0bffe17 	ldw	r2,-8(fp)
 10267b0:	10c00324 	muli	r3,r2,12
 10267b4:	008040f4 	movhi	r2,259
 10267b8:	10add604 	addi	r2,r2,-18600
 10267bc:	1885883a 	add	r2,r3,r2
 10267c0:	00000106 	br	10267c8 <fstat+0x3c>
 10267c4:	0005883a 	mov	r2,zero
 10267c8:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 10267cc:	e0bffd17 	ldw	r2,-12(fp)
 10267d0:	10001026 	beq	r2,zero,1026814 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 10267d4:	e0bffd17 	ldw	r2,-12(fp)
 10267d8:	10800017 	ldw	r2,0(r2)
 10267dc:	10800817 	ldw	r2,32(r2)
 10267e0:	10000726 	beq	r2,zero,1026800 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 10267e4:	e0bffd17 	ldw	r2,-12(fp)
 10267e8:	10800017 	ldw	r2,0(r2)
 10267ec:	10800817 	ldw	r2,32(r2)
 10267f0:	e17fff17 	ldw	r5,-4(fp)
 10267f4:	e13ffd17 	ldw	r4,-12(fp)
 10267f8:	103ee83a 	callr	r2
 10267fc:	00000a06 	br	1026828 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 1026800:	e0bfff17 	ldw	r2,-4(fp)
 1026804:	00c80004 	movi	r3,8192
 1026808:	10c00115 	stw	r3,4(r2)
      return 0;
 102680c:	0005883a 	mov	r2,zero
 1026810:	00000506 	br	1026828 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1026814:	10267500 	call	1026750 <alt_get_errno>
 1026818:	1007883a 	mov	r3,r2
 102681c:	00801444 	movi	r2,81
 1026820:	18800015 	stw	r2,0(r3)
    return -1;
 1026824:	00bfffc4 	movi	r2,-1
  }
}
 1026828:	e037883a 	mov	sp,fp
 102682c:	dfc00117 	ldw	ra,4(sp)
 1026830:	df000017 	ldw	fp,0(sp)
 1026834:	dec00204 	addi	sp,sp,8
 1026838:	f800283a 	ret

0102683c <getpid>:
 *
 * ALT_GETPID is mapped onto the getpid() system call in alt_syscall.h
 */
 
int ALT_GETPID (void)
{
 102683c:	deffff04 	addi	sp,sp,-4
 1026840:	df000015 	stw	fp,0(sp)
 1026844:	d839883a 	mov	fp,sp
  return 0;
 1026848:	0005883a 	mov	r2,zero
}
 102684c:	e037883a 	mov	sp,fp
 1026850:	df000017 	ldw	fp,0(sp)
 1026854:	dec00104 	addi	sp,sp,4
 1026858:	f800283a 	ret

0102685c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 102685c:	defff904 	addi	sp,sp,-28
 1026860:	dfc00615 	stw	ra,24(sp)
 1026864:	df000515 	stw	fp,20(sp)
 1026868:	df000504 	addi	fp,sp,20
 102686c:	e13ffc15 	stw	r4,-16(fp)
 1026870:	e17ffd15 	stw	r5,-12(fp)
 1026874:	e1bffe15 	stw	r6,-8(fp)
 1026878:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 102687c:	e0800217 	ldw	r2,8(fp)
 1026880:	d8800015 	stw	r2,0(sp)
 1026884:	e1ffff17 	ldw	r7,-4(fp)
 1026888:	e1bffe17 	ldw	r6,-8(fp)
 102688c:	e17ffd17 	ldw	r5,-12(fp)
 1026890:	e13ffc17 	ldw	r4,-16(fp)
 1026894:	1000fd00 	call	1000fd0 <alt_iic_isr_register>
}  
 1026898:	e037883a 	mov	sp,fp
 102689c:	dfc00117 	ldw	ra,4(sp)
 10268a0:	df000017 	ldw	fp,0(sp)
 10268a4:	dec00204 	addi	sp,sp,8
 10268a8:	f800283a 	ret

010268ac <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 10268ac:	defff904 	addi	sp,sp,-28
 10268b0:	df000615 	stw	fp,24(sp)
 10268b4:	df000604 	addi	fp,sp,24
 10268b8:	e13ffe15 	stw	r4,-8(fp)
 10268bc:	e17fff15 	stw	r5,-4(fp)
 10268c0:	e0bfff17 	ldw	r2,-4(fp)
 10268c4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10268c8:	0005303a 	rdctl	r2,status
 10268cc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10268d0:	e0fffb17 	ldw	r3,-20(fp)
 10268d4:	00bfff84 	movi	r2,-2
 10268d8:	1884703a 	and	r2,r3,r2
 10268dc:	1001703a 	wrctl	status,r2
  
  return context;
 10268e0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 10268e4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 10268e8:	00c00044 	movi	r3,1
 10268ec:	e0bffa17 	ldw	r2,-24(fp)
 10268f0:	1884983a 	sll	r2,r3,r2
 10268f4:	1007883a 	mov	r3,r2
 10268f8:	d0a75c17 	ldw	r2,-25232(gp)
 10268fc:	1884b03a 	or	r2,r3,r2
 1026900:	d0a75c15 	stw	r2,-25232(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1026904:	d0a75c17 	ldw	r2,-25232(gp)
 1026908:	100170fa 	wrctl	ienable,r2
 102690c:	e0bffc17 	ldw	r2,-16(fp)
 1026910:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1026914:	e0bffd17 	ldw	r2,-12(fp)
 1026918:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 102691c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 1026920:	0001883a 	nop
}
 1026924:	e037883a 	mov	sp,fp
 1026928:	df000017 	ldw	fp,0(sp)
 102692c:	dec00104 	addi	sp,sp,4
 1026930:	f800283a 	ret

01026934 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 1026934:	defff904 	addi	sp,sp,-28
 1026938:	df000615 	stw	fp,24(sp)
 102693c:	df000604 	addi	fp,sp,24
 1026940:	e13ffe15 	stw	r4,-8(fp)
 1026944:	e17fff15 	stw	r5,-4(fp)
 1026948:	e0bfff17 	ldw	r2,-4(fp)
 102694c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1026950:	0005303a 	rdctl	r2,status
 1026954:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1026958:	e0fffb17 	ldw	r3,-20(fp)
 102695c:	00bfff84 	movi	r2,-2
 1026960:	1884703a 	and	r2,r3,r2
 1026964:	1001703a 	wrctl	status,r2
  
  return context;
 1026968:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 102696c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 1026970:	00c00044 	movi	r3,1
 1026974:	e0bffa17 	ldw	r2,-24(fp)
 1026978:	1884983a 	sll	r2,r3,r2
 102697c:	0084303a 	nor	r2,zero,r2
 1026980:	1007883a 	mov	r3,r2
 1026984:	d0a75c17 	ldw	r2,-25232(gp)
 1026988:	1884703a 	and	r2,r3,r2
 102698c:	d0a75c15 	stw	r2,-25232(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1026990:	d0a75c17 	ldw	r2,-25232(gp)
 1026994:	100170fa 	wrctl	ienable,r2
 1026998:	e0bffc17 	ldw	r2,-16(fp)
 102699c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10269a0:	e0bffd17 	ldw	r2,-12(fp)
 10269a4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 10269a8:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 10269ac:	0001883a 	nop
}
 10269b0:	e037883a 	mov	sp,fp
 10269b4:	df000017 	ldw	fp,0(sp)
 10269b8:	dec00104 	addi	sp,sp,4
 10269bc:	f800283a 	ret

010269c0 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 10269c0:	defffc04 	addi	sp,sp,-16
 10269c4:	df000315 	stw	fp,12(sp)
 10269c8:	df000304 	addi	fp,sp,12
 10269cc:	e13ffe15 	stw	r4,-8(fp)
 10269d0:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 10269d4:	000530fa 	rdctl	r2,ienable
 10269d8:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 10269dc:	00c00044 	movi	r3,1
 10269e0:	e0bfff17 	ldw	r2,-4(fp)
 10269e4:	1884983a 	sll	r2,r3,r2
 10269e8:	1007883a 	mov	r3,r2
 10269ec:	e0bffd17 	ldw	r2,-12(fp)
 10269f0:	1884703a 	and	r2,r3,r2
 10269f4:	1004c03a 	cmpne	r2,r2,zero
 10269f8:	10803fcc 	andi	r2,r2,255
}
 10269fc:	e037883a 	mov	sp,fp
 1026a00:	df000017 	ldw	fp,0(sp)
 1026a04:	dec00104 	addi	sp,sp,4
 1026a08:	f800283a 	ret

01026a0c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1026a0c:	defffe04 	addi	sp,sp,-8
 1026a10:	dfc00115 	stw	ra,4(sp)
 1026a14:	df000015 	stw	fp,0(sp)
 1026a18:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1026a1c:	d0a01517 	ldw	r2,-32684(gp)
 1026a20:	10000326 	beq	r2,zero,1026a30 <alt_get_errno+0x24>
 1026a24:	d0a01517 	ldw	r2,-32684(gp)
 1026a28:	103ee83a 	callr	r2
 1026a2c:	00000106 	br	1026a34 <alt_get_errno+0x28>
 1026a30:	d0a75b04 	addi	r2,gp,-25236
}
 1026a34:	e037883a 	mov	sp,fp
 1026a38:	dfc00117 	ldw	ra,4(sp)
 1026a3c:	df000017 	ldw	fp,0(sp)
 1026a40:	dec00204 	addi	sp,sp,8
 1026a44:	f800283a 	ret

01026a48 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 1026a48:	deffed04 	addi	sp,sp,-76
 1026a4c:	dfc01215 	stw	ra,72(sp)
 1026a50:	df001115 	stw	fp,68(sp)
 1026a54:	df001104 	addi	fp,sp,68
 1026a58:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1026a5c:	e0bfff17 	ldw	r2,-4(fp)
 1026a60:	10000616 	blt	r2,zero,1026a7c <isatty+0x34>
 1026a64:	e0bfff17 	ldw	r2,-4(fp)
 1026a68:	10c00324 	muli	r3,r2,12
 1026a6c:	008040f4 	movhi	r2,259
 1026a70:	10add604 	addi	r2,r2,-18600
 1026a74:	1885883a 	add	r2,r3,r2
 1026a78:	00000106 	br	1026a80 <isatty+0x38>
 1026a7c:	0005883a 	mov	r2,zero
 1026a80:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 1026a84:	e0bfef17 	ldw	r2,-68(fp)
 1026a88:	10000e26 	beq	r2,zero,1026ac4 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 1026a8c:	e0bfef17 	ldw	r2,-68(fp)
 1026a90:	10800017 	ldw	r2,0(r2)
 1026a94:	10800817 	ldw	r2,32(r2)
 1026a98:	1000021e 	bne	r2,zero,1026aa4 <isatty+0x5c>
    {
      return 1;
 1026a9c:	00800044 	movi	r2,1
 1026aa0:	00000d06 	br	1026ad8 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 1026aa4:	e0bff004 	addi	r2,fp,-64
 1026aa8:	100b883a 	mov	r5,r2
 1026aac:	e13fff17 	ldw	r4,-4(fp)
 1026ab0:	102678c0 	call	102678c <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 1026ab4:	e0bff117 	ldw	r2,-60(fp)
 1026ab8:	10880020 	cmpeqi	r2,r2,8192
 1026abc:	10803fcc 	andi	r2,r2,255
 1026ac0:	00000506 	br	1026ad8 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1026ac4:	1026a0c0 	call	1026a0c <alt_get_errno>
 1026ac8:	1007883a 	mov	r3,r2
 1026acc:	00801444 	movi	r2,81
 1026ad0:	18800015 	stw	r2,0(r3)
    return 0;
 1026ad4:	0005883a 	mov	r2,zero
  }
}
 1026ad8:	e037883a 	mov	sp,fp
 1026adc:	dfc00117 	ldw	ra,4(sp)
 1026ae0:	df000017 	ldw	fp,0(sp)
 1026ae4:	dec00204 	addi	sp,sp,8
 1026ae8:	f800283a 	ret

01026aec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1026aec:	defffe04 	addi	sp,sp,-8
 1026af0:	dfc00115 	stw	ra,4(sp)
 1026af4:	df000015 	stw	fp,0(sp)
 1026af8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1026afc:	d0a01517 	ldw	r2,-32684(gp)
 1026b00:	10000326 	beq	r2,zero,1026b10 <alt_get_errno+0x24>
 1026b04:	d0a01517 	ldw	r2,-32684(gp)
 1026b08:	103ee83a 	callr	r2
 1026b0c:	00000106 	br	1026b14 <alt_get_errno+0x28>
 1026b10:	d0a75b04 	addi	r2,gp,-25236
}
 1026b14:	e037883a 	mov	sp,fp
 1026b18:	dfc00117 	ldw	ra,4(sp)
 1026b1c:	df000017 	ldw	fp,0(sp)
 1026b20:	dec00204 	addi	sp,sp,8
 1026b24:	f800283a 	ret

01026b28 <kill>:
 *
 * ALT_KILL is mapped onto the kill() system call in alt_syscall.h
 */

int ALT_KILL (int pid, int sig)
{
 1026b28:	defffb04 	addi	sp,sp,-20
 1026b2c:	dfc00415 	stw	ra,16(sp)
 1026b30:	df000315 	stw	fp,12(sp)
 1026b34:	df000304 	addi	fp,sp,12
 1026b38:	e13ffe15 	stw	r4,-8(fp)
 1026b3c:	e17fff15 	stw	r5,-4(fp)
  int status = 0;
 1026b40:	e03ffd15 	stw	zero,-12(fp)

  if (pid <= 0)
 1026b44:	e0bffe17 	ldw	r2,-8(fp)
 1026b48:	00802f16 	blt	zero,r2,1026c08 <kill+0xe0>
  {
    switch (sig)
 1026b4c:	e0bfff17 	ldw	r2,-4(fp)
 1026b50:	10800828 	cmpgeui	r2,r2,32
 1026b54:	1000291e 	bne	r2,zero,1026bfc <kill+0xd4>
 1026b58:	e0bfff17 	ldw	r2,-4(fp)
 1026b5c:	100690ba 	slli	r3,r2,2
 1026b60:	008040b4 	movhi	r2,258
 1026b64:	109add04 	addi	r2,r2,27508
 1026b68:	1885883a 	add	r2,r3,r2
 1026b6c:	10800017 	ldw	r2,0(r2)
 1026b70:	1000683a 	jmp	r2
 1026b74:	01026c1c 	xori	r4,zero,2480
 1026b78:	01026bfc 	xorhi	r4,zero,2479
 1026b7c:	01026bfc 	xorhi	r4,zero,2479
 1026b80:	01026bf4 	movhi	r4,2479
 1026b84:	01026bf4 	movhi	r4,2479
 1026b88:	01026bf4 	movhi	r4,2479
 1026b8c:	01026bf4 	movhi	r4,2479
 1026b90:	01026bfc 	xorhi	r4,zero,2479
 1026b94:	01026bf4 	movhi	r4,2479
 1026b98:	01026bf4 	movhi	r4,2479
 1026b9c:	01026bf4 	movhi	r4,2479
 1026ba0:	01026bf4 	movhi	r4,2479
 1026ba4:	01026bf4 	movhi	r4,2479
 1026ba8:	01026bf4 	movhi	r4,2479
 1026bac:	01026bf4 	movhi	r4,2479
 1026bb0:	01026bf4 	movhi	r4,2479
 1026bb4:	01026c1c 	xori	r4,zero,2480
 1026bb8:	01026bfc 	xorhi	r4,zero,2479
 1026bbc:	01026bfc 	xorhi	r4,zero,2479
 1026bc0:	01026bfc 	xorhi	r4,zero,2479
 1026bc4:	01026c1c 	xori	r4,zero,2480
 1026bc8:	01026bfc 	xorhi	r4,zero,2479
 1026bcc:	01026bfc 	xorhi	r4,zero,2479
 1026bd0:	01026bf4 	movhi	r4,2479
 1026bd4:	01026bf4 	movhi	r4,2479
 1026bd8:	01026bf4 	movhi	r4,2479
 1026bdc:	01026bf4 	movhi	r4,2479
 1026be0:	01026bf4 	movhi	r4,2479
 1026be4:	01026bfc 	xorhi	r4,zero,2479
 1026be8:	01026bfc 	xorhi	r4,zero,2479
 1026bec:	01026bf4 	movhi	r4,2479
 1026bf0:	01026bf4 	movhi	r4,2479
       * The Posix standard defines the default behaviour for all these signals 
       * as being eqivalent to a call to _exit(). No mechanism is provided to 
       * change this behaviour.
       */

      _exit(0);
 1026bf4:	0009883a 	mov	r4,zero
 1026bf8:	102671c0 	call	102671c <_exit>
      break;
    default:

      /* Tried to send an unsupported signal */

      status = EINVAL;
 1026bfc:	00800584 	movi	r2,22
 1026c00:	e0bffd15 	stw	r2,-12(fp)
 1026c04:	00000606 	br	1026c20 <kill+0xf8>
    }
  }

  else if (pid > 0)
 1026c08:	e0bffe17 	ldw	r2,-8(fp)
 1026c0c:	0080040e 	bge	zero,r2,1026c20 <kill+0xf8>
  {
    /* Attempted to signal a non-existant process */

    status = ESRCH;
 1026c10:	008000c4 	movi	r2,3
 1026c14:	e0bffd15 	stw	r2,-12(fp)
 1026c18:	00000106 	br	1026c20 <kill+0xf8>
    {
    case 0:

      /* The null signal is used to check that a pid is valid. */

      break;
 1026c1c:	0001883a 	nop
    /* Attempted to signal a non-existant process */

    status = ESRCH;
  }

  if (status)
 1026c20:	e0bffd17 	ldw	r2,-12(fp)
 1026c24:	10000626 	beq	r2,zero,1026c40 <kill+0x118>
  {
    ALT_ERRNO = status;
 1026c28:	1026aec0 	call	1026aec <alt_get_errno>
 1026c2c:	1007883a 	mov	r3,r2
 1026c30:	e0bffd17 	ldw	r2,-12(fp)
 1026c34:	18800015 	stw	r2,0(r3)
    return -1;
 1026c38:	00bfffc4 	movi	r2,-1
 1026c3c:	00000106 	br	1026c44 <kill+0x11c>
  }

  return 0;
 1026c40:	0005883a 	mov	r2,zero
}
 1026c44:	e037883a 	mov	sp,fp
 1026c48:	dfc00117 	ldw	ra,4(sp)
 1026c4c:	df000017 	ldw	fp,0(sp)
 1026c50:	dec00204 	addi	sp,sp,8
 1026c54:	f800283a 	ret

01026c58 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 1026c58:	defffc04 	addi	sp,sp,-16
 1026c5c:	df000315 	stw	fp,12(sp)
 1026c60:	df000304 	addi	fp,sp,12
 1026c64:	e13ffd15 	stw	r4,-12(fp)
 1026c68:	e17ffe15 	stw	r5,-8(fp)
 1026c6c:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 1026c70:	e0fffe17 	ldw	r3,-8(fp)
 1026c74:	e0bffd17 	ldw	r2,-12(fp)
 1026c78:	18800c26 	beq	r3,r2,1026cac <alt_load_section+0x54>
  {
    while( to != end )
 1026c7c:	00000806 	br	1026ca0 <alt_load_section+0x48>
    {
      *to++ = *from++;
 1026c80:	e0bffe17 	ldw	r2,-8(fp)
 1026c84:	10c00104 	addi	r3,r2,4
 1026c88:	e0fffe15 	stw	r3,-8(fp)
 1026c8c:	e0fffd17 	ldw	r3,-12(fp)
 1026c90:	19000104 	addi	r4,r3,4
 1026c94:	e13ffd15 	stw	r4,-12(fp)
 1026c98:	18c00017 	ldw	r3,0(r3)
 1026c9c:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 1026ca0:	e0fffe17 	ldw	r3,-8(fp)
 1026ca4:	e0bfff17 	ldw	r2,-4(fp)
 1026ca8:	18bff51e 	bne	r3,r2,1026c80 <__alt_data_end+0xff026c80>
    {
      *to++ = *from++;
    }
  }
}
 1026cac:	0001883a 	nop
 1026cb0:	e037883a 	mov	sp,fp
 1026cb4:	df000017 	ldw	fp,0(sp)
 1026cb8:	dec00104 	addi	sp,sp,4
 1026cbc:	f800283a 	ret

01026cc0 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 1026cc0:	defffe04 	addi	sp,sp,-8
 1026cc4:	dfc00115 	stw	ra,4(sp)
 1026cc8:	df000015 	stw	fp,0(sp)
 1026ccc:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 1026cd0:	018040f4 	movhi	r6,259
 1026cd4:	31b26e04 	addi	r6,r6,-13896
 1026cd8:	014040f4 	movhi	r5,259
 1026cdc:	296b4e04 	addi	r5,r5,-21192
 1026ce0:	010040f4 	movhi	r4,259
 1026ce4:	21326e04 	addi	r4,r4,-13896
 1026ce8:	1026c580 	call	1026c58 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 1026cec:	01804034 	movhi	r6,256
 1026cf0:	31809404 	addi	r6,r6,592
 1026cf4:	01404034 	movhi	r5,256
 1026cf8:	29400804 	addi	r5,r5,32
 1026cfc:	01004034 	movhi	r4,256
 1026d00:	21000804 	addi	r4,r4,32
 1026d04:	1026c580 	call	1026c58 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 1026d08:	018040f4 	movhi	r6,259
 1026d0c:	31ab4e04 	addi	r6,r6,-21192
 1026d10:	014040f4 	movhi	r5,259
 1026d14:	29647704 	addi	r5,r5,-28196
 1026d18:	010040f4 	movhi	r4,259
 1026d1c:	21247704 	addi	r4,r4,-28196
 1026d20:	1026c580 	call	1026c58 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 1026d24:	10266a80 	call	10266a8 <alt_dcache_flush_all>
  alt_icache_flush_all();
 1026d28:	102871c0 	call	102871c <alt_icache_flush_all>
}
 1026d2c:	0001883a 	nop
 1026d30:	e037883a 	mov	sp,fp
 1026d34:	dfc00117 	ldw	ra,4(sp)
 1026d38:	df000017 	ldw	fp,0(sp)
 1026d3c:	dec00204 	addi	sp,sp,8
 1026d40:	f800283a 	ret

01026d44 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1026d44:	defffe04 	addi	sp,sp,-8
 1026d48:	dfc00115 	stw	ra,4(sp)
 1026d4c:	df000015 	stw	fp,0(sp)
 1026d50:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1026d54:	d0a01517 	ldw	r2,-32684(gp)
 1026d58:	10000326 	beq	r2,zero,1026d68 <alt_get_errno+0x24>
 1026d5c:	d0a01517 	ldw	r2,-32684(gp)
 1026d60:	103ee83a 	callr	r2
 1026d64:	00000106 	br	1026d6c <alt_get_errno+0x28>
 1026d68:	d0a75b04 	addi	r2,gp,-25236
}
 1026d6c:	e037883a 	mov	sp,fp
 1026d70:	dfc00117 	ldw	ra,4(sp)
 1026d74:	df000017 	ldw	fp,0(sp)
 1026d78:	dec00204 	addi	sp,sp,8
 1026d7c:	f800283a 	ret

01026d80 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 1026d80:	defff904 	addi	sp,sp,-28
 1026d84:	dfc00615 	stw	ra,24(sp)
 1026d88:	df000515 	stw	fp,20(sp)
 1026d8c:	df000504 	addi	fp,sp,20
 1026d90:	e13ffd15 	stw	r4,-12(fp)
 1026d94:	e17ffe15 	stw	r5,-8(fp)
 1026d98:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 1026d9c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1026da0:	e0bffd17 	ldw	r2,-12(fp)
 1026da4:	10000616 	blt	r2,zero,1026dc0 <lseek+0x40>
 1026da8:	e0bffd17 	ldw	r2,-12(fp)
 1026dac:	10c00324 	muli	r3,r2,12
 1026db0:	008040f4 	movhi	r2,259
 1026db4:	10add604 	addi	r2,r2,-18600
 1026db8:	1885883a 	add	r2,r3,r2
 1026dbc:	00000106 	br	1026dc4 <lseek+0x44>
 1026dc0:	0005883a 	mov	r2,zero
 1026dc4:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 1026dc8:	e0bffc17 	ldw	r2,-16(fp)
 1026dcc:	10001026 	beq	r2,zero,1026e10 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 1026dd0:	e0bffc17 	ldw	r2,-16(fp)
 1026dd4:	10800017 	ldw	r2,0(r2)
 1026dd8:	10800717 	ldw	r2,28(r2)
 1026ddc:	10000926 	beq	r2,zero,1026e04 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 1026de0:	e0bffc17 	ldw	r2,-16(fp)
 1026de4:	10800017 	ldw	r2,0(r2)
 1026de8:	10800717 	ldw	r2,28(r2)
 1026dec:	e1bfff17 	ldw	r6,-4(fp)
 1026df0:	e17ffe17 	ldw	r5,-8(fp)
 1026df4:	e13ffc17 	ldw	r4,-16(fp)
 1026df8:	103ee83a 	callr	r2
 1026dfc:	e0bffb15 	stw	r2,-20(fp)
 1026e00:	00000506 	br	1026e18 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 1026e04:	00bfde84 	movi	r2,-134
 1026e08:	e0bffb15 	stw	r2,-20(fp)
 1026e0c:	00000206 	br	1026e18 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 1026e10:	00bfebc4 	movi	r2,-81
 1026e14:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 1026e18:	e0bffb17 	ldw	r2,-20(fp)
 1026e1c:	1000070e 	bge	r2,zero,1026e3c <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 1026e20:	1026d440 	call	1026d44 <alt_get_errno>
 1026e24:	1007883a 	mov	r3,r2
 1026e28:	e0bffb17 	ldw	r2,-20(fp)
 1026e2c:	0085c83a 	sub	r2,zero,r2
 1026e30:	18800015 	stw	r2,0(r3)
    rc = -1;
 1026e34:	00bfffc4 	movi	r2,-1
 1026e38:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 1026e3c:	e0bffb17 	ldw	r2,-20(fp)
}
 1026e40:	e037883a 	mov	sp,fp
 1026e44:	dfc00117 	ldw	ra,4(sp)
 1026e48:	df000017 	ldw	fp,0(sp)
 1026e4c:	dec00204 	addi	sp,sp,8
 1026e50:	f800283a 	ret

01026e54 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 1026e54:	defffd04 	addi	sp,sp,-12
 1026e58:	dfc00215 	stw	ra,8(sp)
 1026e5c:	df000115 	stw	fp,4(sp)
 1026e60:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 1026e64:	0009883a 	mov	r4,zero
 1026e68:	10273a00 	call	10273a0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 1026e6c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 1026e70:	10273d80 	call	10273d8 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 1026e74:	018040f4 	movhi	r6,259
 1026e78:	31ab4004 	addi	r6,r6,-21248
 1026e7c:	014040f4 	movhi	r5,259
 1026e80:	296b4004 	addi	r5,r5,-21248
 1026e84:	010040f4 	movhi	r4,259
 1026e88:	212b4004 	addi	r4,r4,-21248
 1026e8c:	10288140 	call	1028814 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 1026e90:	10285cc0 	call	10285cc <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 1026e94:	010040f4 	movhi	r4,259
 1026e98:	21218b04 	addi	r4,r4,-31188
 1026e9c:	1028ee80 	call	1028ee8 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 1026ea0:	d0a75d17 	ldw	r2,-25228(gp)
 1026ea4:	d0e75e17 	ldw	r3,-25224(gp)
 1026ea8:	d1275f17 	ldw	r4,-25220(gp)
 1026eac:	200d883a 	mov	r6,r4
 1026eb0:	180b883a 	mov	r5,r3
 1026eb4:	1009883a 	mov	r4,r2
 1026eb8:	101494c0 	call	101494c <main>
 1026ebc:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 1026ec0:	01000044 	movi	r4,1
 1026ec4:	10265600 	call	1026560 <close>
  exit (result);
 1026ec8:	e13fff17 	ldw	r4,-4(fp)
 1026ecc:	1028efc0 	call	1028efc <exit>

01026ed0 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 1026ed0:	defffe04 	addi	sp,sp,-8
 1026ed4:	df000115 	stw	fp,4(sp)
 1026ed8:	df000104 	addi	fp,sp,4
 1026edc:	e13fff15 	stw	r4,-4(fp)
}
 1026ee0:	0001883a 	nop
 1026ee4:	e037883a 	mov	sp,fp
 1026ee8:	df000017 	ldw	fp,0(sp)
 1026eec:	dec00104 	addi	sp,sp,4
 1026ef0:	f800283a 	ret

01026ef4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 1026ef4:	defffe04 	addi	sp,sp,-8
 1026ef8:	df000115 	stw	fp,4(sp)
 1026efc:	df000104 	addi	fp,sp,4
 1026f00:	e13fff15 	stw	r4,-4(fp)
}
 1026f04:	0001883a 	nop
 1026f08:	e037883a 	mov	sp,fp
 1026f0c:	df000017 	ldw	fp,0(sp)
 1026f10:	dec00104 	addi	sp,sp,4
 1026f14:	f800283a 	ret

01026f18 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1026f18:	defffe04 	addi	sp,sp,-8
 1026f1c:	dfc00115 	stw	ra,4(sp)
 1026f20:	df000015 	stw	fp,0(sp)
 1026f24:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1026f28:	d0a01517 	ldw	r2,-32684(gp)
 1026f2c:	10000326 	beq	r2,zero,1026f3c <alt_get_errno+0x24>
 1026f30:	d0a01517 	ldw	r2,-32684(gp)
 1026f34:	103ee83a 	callr	r2
 1026f38:	00000106 	br	1026f40 <alt_get_errno+0x28>
 1026f3c:	d0a75b04 	addi	r2,gp,-25236
}
 1026f40:	e037883a 	mov	sp,fp
 1026f44:	dfc00117 	ldw	ra,4(sp)
 1026f48:	df000017 	ldw	fp,0(sp)
 1026f4c:	dec00204 	addi	sp,sp,8
 1026f50:	f800283a 	ret

01026f54 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 1026f54:	defff904 	addi	sp,sp,-28
 1026f58:	dfc00615 	stw	ra,24(sp)
 1026f5c:	df000515 	stw	fp,20(sp)
 1026f60:	df000504 	addi	fp,sp,20
 1026f64:	e13ffd15 	stw	r4,-12(fp)
 1026f68:	e17ffe15 	stw	r5,-8(fp)
 1026f6c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1026f70:	e0bffd17 	ldw	r2,-12(fp)
 1026f74:	10000616 	blt	r2,zero,1026f90 <read+0x3c>
 1026f78:	e0bffd17 	ldw	r2,-12(fp)
 1026f7c:	10c00324 	muli	r3,r2,12
 1026f80:	008040f4 	movhi	r2,259
 1026f84:	10add604 	addi	r2,r2,-18600
 1026f88:	1885883a 	add	r2,r3,r2
 1026f8c:	00000106 	br	1026f94 <read+0x40>
 1026f90:	0005883a 	mov	r2,zero
 1026f94:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 1026f98:	e0bffb17 	ldw	r2,-20(fp)
 1026f9c:	10002226 	beq	r2,zero,1027028 <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1026fa0:	e0bffb17 	ldw	r2,-20(fp)
 1026fa4:	10800217 	ldw	r2,8(r2)
 1026fa8:	108000cc 	andi	r2,r2,3
 1026fac:	10800060 	cmpeqi	r2,r2,1
 1026fb0:	1000181e 	bne	r2,zero,1027014 <read+0xc0>
        (fd->dev->read))
 1026fb4:	e0bffb17 	ldw	r2,-20(fp)
 1026fb8:	10800017 	ldw	r2,0(r2)
 1026fbc:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1026fc0:	10001426 	beq	r2,zero,1027014 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 1026fc4:	e0bffb17 	ldw	r2,-20(fp)
 1026fc8:	10800017 	ldw	r2,0(r2)
 1026fcc:	10800517 	ldw	r2,20(r2)
 1026fd0:	e0ffff17 	ldw	r3,-4(fp)
 1026fd4:	180d883a 	mov	r6,r3
 1026fd8:	e17ffe17 	ldw	r5,-8(fp)
 1026fdc:	e13ffb17 	ldw	r4,-20(fp)
 1026fe0:	103ee83a 	callr	r2
 1026fe4:	e0bffc15 	stw	r2,-16(fp)
 1026fe8:	e0bffc17 	ldw	r2,-16(fp)
 1026fec:	1000070e 	bge	r2,zero,102700c <read+0xb8>
        {
          ALT_ERRNO = -rval;
 1026ff0:	1026f180 	call	1026f18 <alt_get_errno>
 1026ff4:	1007883a 	mov	r3,r2
 1026ff8:	e0bffc17 	ldw	r2,-16(fp)
 1026ffc:	0085c83a 	sub	r2,zero,r2
 1027000:	18800015 	stw	r2,0(r3)
          return -1;
 1027004:	00bfffc4 	movi	r2,-1
 1027008:	00000c06 	br	102703c <read+0xe8>
        }
        return rval;
 102700c:	e0bffc17 	ldw	r2,-16(fp)
 1027010:	00000a06 	br	102703c <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 1027014:	1026f180 	call	1026f18 <alt_get_errno>
 1027018:	1007883a 	mov	r3,r2
 102701c:	00800344 	movi	r2,13
 1027020:	18800015 	stw	r2,0(r3)
 1027024:	00000406 	br	1027038 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 1027028:	1026f180 	call	1026f18 <alt_get_errno>
 102702c:	1007883a 	mov	r3,r2
 1027030:	00801444 	movi	r2,81
 1027034:	18800015 	stw	r2,0(r3)
  }
  return -1;
 1027038:	00bfffc4 	movi	r2,-1
}
 102703c:	e037883a 	mov	sp,fp
 1027040:	dfc00117 	ldw	ra,4(sp)
 1027044:	df000017 	ldw	fp,0(sp)
 1027048:	dec00204 	addi	sp,sp,8
 102704c:	f800283a 	ret

01027050 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 1027050:	defffe04 	addi	sp,sp,-8
 1027054:	df000115 	stw	fp,4(sp)
 1027058:	df000104 	addi	fp,sp,4
 102705c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 1027060:	e0bfff17 	ldw	r2,-4(fp)
 1027064:	108000d0 	cmplti	r2,r2,3
 1027068:	10000d1e 	bne	r2,zero,10270a0 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 102706c:	008040f4 	movhi	r2,259
 1027070:	10add604 	addi	r2,r2,-18600
 1027074:	e0ffff17 	ldw	r3,-4(fp)
 1027078:	18c00324 	muli	r3,r3,12
 102707c:	10c5883a 	add	r2,r2,r3
 1027080:	10800204 	addi	r2,r2,8
 1027084:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 1027088:	008040f4 	movhi	r2,259
 102708c:	10add604 	addi	r2,r2,-18600
 1027090:	e0ffff17 	ldw	r3,-4(fp)
 1027094:	18c00324 	muli	r3,r3,12
 1027098:	10c5883a 	add	r2,r2,r3
 102709c:	10000015 	stw	zero,0(r2)
  }
}
 10270a0:	0001883a 	nop
 10270a4:	e037883a 	mov	sp,fp
 10270a8:	df000017 	ldw	fp,0(sp)
 10270ac:	dec00104 	addi	sp,sp,4
 10270b0:	f800283a 	ret

010270b4 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 10270b4:	defff904 	addi	sp,sp,-28
 10270b8:	df000615 	stw	fp,24(sp)
 10270bc:	df000604 	addi	fp,sp,24
 10270c0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10270c4:	0005303a 	rdctl	r2,status
 10270c8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10270cc:	e0fffe17 	ldw	r3,-8(fp)
 10270d0:	00bfff84 	movi	r2,-2
 10270d4:	1884703a 	and	r2,r3,r2
 10270d8:	1001703a 	wrctl	status,r2
  
  return context;
 10270dc:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 10270e0:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 10270e4:	d0a01717 	ldw	r2,-32676(gp)
 10270e8:	10c000c4 	addi	r3,r2,3
 10270ec:	00bfff04 	movi	r2,-4
 10270f0:	1884703a 	and	r2,r3,r2
 10270f4:	d0a01715 	stw	r2,-32676(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 10270f8:	d0e01717 	ldw	r3,-32676(gp)
 10270fc:	e0bfff17 	ldw	r2,-4(fp)
 1027100:	1887883a 	add	r3,r3,r2
 1027104:	00808034 	movhi	r2,512
 1027108:	10800004 	addi	r2,r2,0
 102710c:	10c0062e 	bgeu	r2,r3,1027128 <sbrk+0x74>
 1027110:	e0bffb17 	ldw	r2,-20(fp)
 1027114:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1027118:	e0bffa17 	ldw	r2,-24(fp)
 102711c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 1027120:	00bfffc4 	movi	r2,-1
 1027124:	00000b06 	br	1027154 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 1027128:	d0a01717 	ldw	r2,-32676(gp)
 102712c:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 1027130:	d0e01717 	ldw	r3,-32676(gp)
 1027134:	e0bfff17 	ldw	r2,-4(fp)
 1027138:	1885883a 	add	r2,r3,r2
 102713c:	d0a01715 	stw	r2,-32676(gp)
 1027140:	e0bffb17 	ldw	r2,-20(fp)
 1027144:	e0bffc15 	stw	r2,-16(fp)
 1027148:	e0bffc17 	ldw	r2,-16(fp)
 102714c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 1027150:	e0bffd17 	ldw	r2,-12(fp)
} 
 1027154:	e037883a 	mov	sp,fp
 1027158:	df000017 	ldw	fp,0(sp)
 102715c:	dec00104 	addi	sp,sp,4
 1027160:	f800283a 	ret

01027164 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 1027164:	defffd04 	addi	sp,sp,-12
 1027168:	dfc00215 	stw	ra,8(sp)
 102716c:	df000115 	stw	fp,4(sp)
 1027170:	df000104 	addi	fp,sp,4
 1027174:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 1027178:	e13fff17 	ldw	r4,-4(fp)
 102717c:	10283940 	call	1028394 <alt_busy_sleep>
}
 1027180:	e037883a 	mov	sp,fp
 1027184:	dfc00117 	ldw	ra,4(sp)
 1027188:	df000017 	ldw	fp,0(sp)
 102718c:	dec00204 	addi	sp,sp,8
 1027190:	f800283a 	ret

01027194 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1027194:	defffe04 	addi	sp,sp,-8
 1027198:	dfc00115 	stw	ra,4(sp)
 102719c:	df000015 	stw	fp,0(sp)
 10271a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 10271a4:	d0a01517 	ldw	r2,-32684(gp)
 10271a8:	10000326 	beq	r2,zero,10271b8 <alt_get_errno+0x24>
 10271ac:	d0a01517 	ldw	r2,-32684(gp)
 10271b0:	103ee83a 	callr	r2
 10271b4:	00000106 	br	10271bc <alt_get_errno+0x28>
 10271b8:	d0a75b04 	addi	r2,gp,-25236
}
 10271bc:	e037883a 	mov	sp,fp
 10271c0:	dfc00117 	ldw	ra,4(sp)
 10271c4:	df000017 	ldw	fp,0(sp)
 10271c8:	dec00204 	addi	sp,sp,8
 10271cc:	f800283a 	ret

010271d0 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 10271d0:	defff904 	addi	sp,sp,-28
 10271d4:	dfc00615 	stw	ra,24(sp)
 10271d8:	df000515 	stw	fp,20(sp)
 10271dc:	df000504 	addi	fp,sp,20
 10271e0:	e13ffd15 	stw	r4,-12(fp)
 10271e4:	e17ffe15 	stw	r5,-8(fp)
 10271e8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 10271ec:	e0bffd17 	ldw	r2,-12(fp)
 10271f0:	10000616 	blt	r2,zero,102720c <write+0x3c>
 10271f4:	e0bffd17 	ldw	r2,-12(fp)
 10271f8:	10c00324 	muli	r3,r2,12
 10271fc:	008040f4 	movhi	r2,259
 1027200:	10add604 	addi	r2,r2,-18600
 1027204:	1885883a 	add	r2,r3,r2
 1027208:	00000106 	br	1027210 <write+0x40>
 102720c:	0005883a 	mov	r2,zero
 1027210:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 1027214:	e0bffb17 	ldw	r2,-20(fp)
 1027218:	10002126 	beq	r2,zero,10272a0 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 102721c:	e0bffb17 	ldw	r2,-20(fp)
 1027220:	10800217 	ldw	r2,8(r2)
 1027224:	108000cc 	andi	r2,r2,3
 1027228:	10001826 	beq	r2,zero,102728c <write+0xbc>
 102722c:	e0bffb17 	ldw	r2,-20(fp)
 1027230:	10800017 	ldw	r2,0(r2)
 1027234:	10800617 	ldw	r2,24(r2)
 1027238:	10001426 	beq	r2,zero,102728c <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 102723c:	e0bffb17 	ldw	r2,-20(fp)
 1027240:	10800017 	ldw	r2,0(r2)
 1027244:	10800617 	ldw	r2,24(r2)
 1027248:	e0ffff17 	ldw	r3,-4(fp)
 102724c:	180d883a 	mov	r6,r3
 1027250:	e17ffe17 	ldw	r5,-8(fp)
 1027254:	e13ffb17 	ldw	r4,-20(fp)
 1027258:	103ee83a 	callr	r2
 102725c:	e0bffc15 	stw	r2,-16(fp)
 1027260:	e0bffc17 	ldw	r2,-16(fp)
 1027264:	1000070e 	bge	r2,zero,1027284 <write+0xb4>
      {
        ALT_ERRNO = -rval;
 1027268:	10271940 	call	1027194 <alt_get_errno>
 102726c:	1007883a 	mov	r3,r2
 1027270:	e0bffc17 	ldw	r2,-16(fp)
 1027274:	0085c83a 	sub	r2,zero,r2
 1027278:	18800015 	stw	r2,0(r3)
        return -1;
 102727c:	00bfffc4 	movi	r2,-1
 1027280:	00000c06 	br	10272b4 <write+0xe4>
      }
      return rval;
 1027284:	e0bffc17 	ldw	r2,-16(fp)
 1027288:	00000a06 	br	10272b4 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 102728c:	10271940 	call	1027194 <alt_get_errno>
 1027290:	1007883a 	mov	r3,r2
 1027294:	00800344 	movi	r2,13
 1027298:	18800015 	stw	r2,0(r3)
 102729c:	00000406 	br	10272b0 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 10272a0:	10271940 	call	1027194 <alt_get_errno>
 10272a4:	1007883a 	mov	r3,r2
 10272a8:	00801444 	movi	r2,81
 10272ac:	18800015 	stw	r2,0(r3)
  }
  return -1;
 10272b0:	00bfffc4 	movi	r2,-1
}
 10272b4:	e037883a 	mov	sp,fp
 10272b8:	dfc00117 	ldw	ra,4(sp)
 10272bc:	df000017 	ldw	fp,0(sp)
 10272c0:	dec00204 	addi	sp,sp,8
 10272c4:	f800283a 	ret

010272c8 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 10272c8:	defffd04 	addi	sp,sp,-12
 10272cc:	dfc00215 	stw	ra,8(sp)
 10272d0:	df000115 	stw	fp,4(sp)
 10272d4:	df000104 	addi	fp,sp,4
 10272d8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 10272dc:	d1601204 	addi	r5,gp,-32696
 10272e0:	e13fff17 	ldw	r4,-4(fp)
 10272e4:	10285280 	call	1028528 <alt_dev_llist_insert>
}
 10272e8:	e037883a 	mov	sp,fp
 10272ec:	dfc00117 	ldw	ra,4(sp)
 10272f0:	df000017 	ldw	fp,0(sp)
 10272f4:	dec00204 	addi	sp,sp,8
 10272f8:	f800283a 	ret

010272fc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 10272fc:	defffe04 	addi	sp,sp,-8
 1027300:	dfc00115 	stw	ra,4(sp)
 1027304:	df000015 	stw	fp,0(sp)
 1027308:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 102730c:	d0a01517 	ldw	r2,-32684(gp)
 1027310:	10000326 	beq	r2,zero,1027320 <alt_get_errno+0x24>
 1027314:	d0a01517 	ldw	r2,-32684(gp)
 1027318:	103ee83a 	callr	r2
 102731c:	00000106 	br	1027324 <alt_get_errno+0x28>
 1027320:	d0a75b04 	addi	r2,gp,-25236
}
 1027324:	e037883a 	mov	sp,fp
 1027328:	dfc00117 	ldw	ra,4(sp)
 102732c:	df000017 	ldw	fp,0(sp)
 1027330:	dec00204 	addi	sp,sp,8
 1027334:	f800283a 	ret

01027338 <alt_avalon_mutex_reg>:
/*
 * Register a Mutex device
 */

static ALT_INLINE int alt_avalon_mutex_reg (alt_mutex_dev* dev)
{
 1027338:	defffc04 	addi	sp,sp,-16
 102733c:	dfc00315 	stw	ra,12(sp)
 1027340:	df000215 	stw	fp,8(sp)
 1027344:	df000204 	addi	fp,sp,8
 1027348:	e13fff15 	stw	r4,-4(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 102734c:	0005883a 	mov	r2,zero
  int ret_code;
  extern alt_llist alt_mutex_list;
  ret_code = ALT_SEM_CREATE (&dev->lock, 1);
 1027350:	e0bffe15 	stw	r2,-8(fp)
  if (!ret_code)
 1027354:	e0bffe17 	ldw	r2,-8(fp)
 1027358:	1000051e 	bne	r2,zero,1027370 <alt_avalon_mutex_reg+0x38>
  {
    ret_code = alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mutex_list);
 102735c:	d1601804 	addi	r5,gp,-32672
 1027360:	e13fff17 	ldw	r4,-4(fp)
 1027364:	10285280 	call	1028528 <alt_dev_llist_insert>
 1027368:	e0bffe15 	stw	r2,-8(fp)
 102736c:	00000606 	br	1027388 <alt_avalon_mutex_reg+0x50>
  }
  else
  {
    ALT_ERRNO = ENOMEM;
 1027370:	10272fc0 	call	10272fc <alt_get_errno>
 1027374:	1007883a 	mov	r3,r2
 1027378:	00800304 	movi	r2,12
 102737c:	18800015 	stw	r2,0(r3)
    ret_code = -ENOMEM;
 1027380:	00bffd04 	movi	r2,-12
 1027384:	e0bffe15 	stw	r2,-8(fp)
  }

  return ret_code;
 1027388:	e0bffe17 	ldw	r2,-8(fp)
}
 102738c:	e037883a 	mov	sp,fp
 1027390:	dfc00117 	ldw	ra,4(sp)
 1027394:	df000017 	ldw	fp,0(sp)
 1027398:	dec00204 	addi	sp,sp,8
 102739c:	f800283a 	ret

010273a0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 10273a0:	defffd04 	addi	sp,sp,-12
 10273a4:	dfc00215 	stw	ra,8(sp)
 10273a8:	df000115 	stw	fp,4(sp)
 10273ac:	df000104 	addi	fp,sp,4
 10273b0:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS_CPU_1, nios_cpu_1);
 10273b4:	1028c880 	call	1028c88 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 10273b8:	00800044 	movi	r2,1
 10273bc:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 10273c0:	0001883a 	nop
 10273c4:	e037883a 	mov	sp,fp
 10273c8:	dfc00117 	ldw	ra,4(sp)
 10273cc:	df000017 	ldw	fp,0(sp)
 10273d0:	dec00204 	addi	sp,sp,8
 10273d4:	f800283a 	ret

010273d8 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 10273d8:	defffe04 	addi	sp,sp,-8
 10273dc:	dfc00115 	stw	ra,4(sp)
 10273e0:	df000015 	stw	fp,0(sp)
 10273e4:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
 10273e8:	01c0fa04 	movi	r7,1000
 10273ec:	01800044 	movi	r6,1
 10273f0:	000b883a 	mov	r5,zero
 10273f4:	01000804 	movi	r4,32
 10273f8:	10281ec0 	call	10281ec <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 10273fc:	000d883a 	mov	r6,zero
 1027400:	000b883a 	mov	r5,zero
 1027404:	010040f4 	movhi	r4,259
 1027408:	212e4004 	addi	r4,r4,-18176
 102740c:	10275a40 	call	10275a4 <altera_avalon_jtag_uart_init>
 1027410:	010040f4 	movhi	r4,259
 1027414:	212e3604 	addi	r4,r4,-18216
 1027418:	10272c80 	call	10272c8 <alt_dev_reg>
    ALTERA_AVALON_MUTEX_INIT ( MUTEX_0, mutex_0);
 102741c:	010040f4 	movhi	r4,259
 1027420:	21324e04 	addi	r4,r4,-14024
 1027424:	10273380 	call	1027338 <alt_avalon_mutex_reg>
}
 1027428:	0001883a 	nop
 102742c:	e037883a 	mov	sp,fp
 1027430:	dfc00117 	ldw	ra,4(sp)
 1027434:	df000017 	ldw	fp,0(sp)
 1027438:	dec00204 	addi	sp,sp,8
 102743c:	f800283a 	ret

01027440 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 1027440:	defffa04 	addi	sp,sp,-24
 1027444:	dfc00515 	stw	ra,20(sp)
 1027448:	df000415 	stw	fp,16(sp)
 102744c:	df000404 	addi	fp,sp,16
 1027450:	e13ffd15 	stw	r4,-12(fp)
 1027454:	e17ffe15 	stw	r5,-8(fp)
 1027458:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 102745c:	e0bffd17 	ldw	r2,-12(fp)
 1027460:	10800017 	ldw	r2,0(r2)
 1027464:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 1027468:	e0bffc17 	ldw	r2,-16(fp)
 102746c:	10c00a04 	addi	r3,r2,40
 1027470:	e0bffd17 	ldw	r2,-12(fp)
 1027474:	10800217 	ldw	r2,8(r2)
 1027478:	100f883a 	mov	r7,r2
 102747c:	e1bfff17 	ldw	r6,-4(fp)
 1027480:	e17ffe17 	ldw	r5,-8(fp)
 1027484:	1809883a 	mov	r4,r3
 1027488:	1027a680 	call	1027a68 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 102748c:	e037883a 	mov	sp,fp
 1027490:	dfc00117 	ldw	ra,4(sp)
 1027494:	df000017 	ldw	fp,0(sp)
 1027498:	dec00204 	addi	sp,sp,8
 102749c:	f800283a 	ret

010274a0 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 10274a0:	defffa04 	addi	sp,sp,-24
 10274a4:	dfc00515 	stw	ra,20(sp)
 10274a8:	df000415 	stw	fp,16(sp)
 10274ac:	df000404 	addi	fp,sp,16
 10274b0:	e13ffd15 	stw	r4,-12(fp)
 10274b4:	e17ffe15 	stw	r5,-8(fp)
 10274b8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 10274bc:	e0bffd17 	ldw	r2,-12(fp)
 10274c0:	10800017 	ldw	r2,0(r2)
 10274c4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 10274c8:	e0bffc17 	ldw	r2,-16(fp)
 10274cc:	10c00a04 	addi	r3,r2,40
 10274d0:	e0bffd17 	ldw	r2,-12(fp)
 10274d4:	10800217 	ldw	r2,8(r2)
 10274d8:	100f883a 	mov	r7,r2
 10274dc:	e1bfff17 	ldw	r6,-4(fp)
 10274e0:	e17ffe17 	ldw	r5,-8(fp)
 10274e4:	1809883a 	mov	r4,r3
 10274e8:	1027c840 	call	1027c84 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 10274ec:	e037883a 	mov	sp,fp
 10274f0:	dfc00117 	ldw	ra,4(sp)
 10274f4:	df000017 	ldw	fp,0(sp)
 10274f8:	dec00204 	addi	sp,sp,8
 10274fc:	f800283a 	ret

01027500 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 1027500:	defffc04 	addi	sp,sp,-16
 1027504:	dfc00315 	stw	ra,12(sp)
 1027508:	df000215 	stw	fp,8(sp)
 102750c:	df000204 	addi	fp,sp,8
 1027510:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1027514:	e0bfff17 	ldw	r2,-4(fp)
 1027518:	10800017 	ldw	r2,0(r2)
 102751c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 1027520:	e0bffe17 	ldw	r2,-8(fp)
 1027524:	10c00a04 	addi	r3,r2,40
 1027528:	e0bfff17 	ldw	r2,-4(fp)
 102752c:	10800217 	ldw	r2,8(r2)
 1027530:	100b883a 	mov	r5,r2
 1027534:	1809883a 	mov	r4,r3
 1027538:	10279100 	call	1027910 <altera_avalon_jtag_uart_close>
}
 102753c:	e037883a 	mov	sp,fp
 1027540:	dfc00117 	ldw	ra,4(sp)
 1027544:	df000017 	ldw	fp,0(sp)
 1027548:	dec00204 	addi	sp,sp,8
 102754c:	f800283a 	ret

01027550 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 1027550:	defffa04 	addi	sp,sp,-24
 1027554:	dfc00515 	stw	ra,20(sp)
 1027558:	df000415 	stw	fp,16(sp)
 102755c:	df000404 	addi	fp,sp,16
 1027560:	e13ffd15 	stw	r4,-12(fp)
 1027564:	e17ffe15 	stw	r5,-8(fp)
 1027568:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 102756c:	e0bffd17 	ldw	r2,-12(fp)
 1027570:	10800017 	ldw	r2,0(r2)
 1027574:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 1027578:	e0bffc17 	ldw	r2,-16(fp)
 102757c:	10800a04 	addi	r2,r2,40
 1027580:	e1bfff17 	ldw	r6,-4(fp)
 1027584:	e17ffe17 	ldw	r5,-8(fp)
 1027588:	1009883a 	mov	r4,r2
 102758c:	10279780 	call	1027978 <altera_avalon_jtag_uart_ioctl>
}
 1027590:	e037883a 	mov	sp,fp
 1027594:	dfc00117 	ldw	ra,4(sp)
 1027598:	df000017 	ldw	fp,0(sp)
 102759c:	dec00204 	addi	sp,sp,8
 10275a0:	f800283a 	ret

010275a4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 10275a4:	defffa04 	addi	sp,sp,-24
 10275a8:	dfc00515 	stw	ra,20(sp)
 10275ac:	df000415 	stw	fp,16(sp)
 10275b0:	df000404 	addi	fp,sp,16
 10275b4:	e13ffd15 	stw	r4,-12(fp)
 10275b8:	e17ffe15 	stw	r5,-8(fp)
 10275bc:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 10275c0:	e0bffd17 	ldw	r2,-12(fp)
 10275c4:	00c00044 	movi	r3,1
 10275c8:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 10275cc:	e0bffd17 	ldw	r2,-12(fp)
 10275d0:	10800017 	ldw	r2,0(r2)
 10275d4:	10800104 	addi	r2,r2,4
 10275d8:	1007883a 	mov	r3,r2
 10275dc:	e0bffd17 	ldw	r2,-12(fp)
 10275e0:	10800817 	ldw	r2,32(r2)
 10275e4:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 10275e8:	e0bffe17 	ldw	r2,-8(fp)
 10275ec:	e0ffff17 	ldw	r3,-4(fp)
 10275f0:	d8000015 	stw	zero,0(sp)
 10275f4:	e1fffd17 	ldw	r7,-12(fp)
 10275f8:	018040b4 	movhi	r6,258
 10275fc:	319d9904 	addi	r6,r6,30308
 1027600:	180b883a 	mov	r5,r3
 1027604:	1009883a 	mov	r4,r2
 1027608:	102685c0 	call	102685c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 102760c:	e0bffd17 	ldw	r2,-12(fp)
 1027610:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 1027614:	e0bffd17 	ldw	r2,-12(fp)
 1027618:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 102761c:	d0e76017 	ldw	r3,-25216(gp)
 1027620:	e1fffd17 	ldw	r7,-12(fp)
 1027624:	018040b4 	movhi	r6,258
 1027628:	319e1c04 	addi	r6,r6,30832
 102762c:	180b883a 	mov	r5,r3
 1027630:	1009883a 	mov	r4,r2
 1027634:	10282680 	call	1028268 <alt_alarm_start>
 1027638:	1000040e 	bge	r2,zero,102764c <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 102763c:	e0fffd17 	ldw	r3,-12(fp)
 1027640:	00a00034 	movhi	r2,32768
 1027644:	10bfffc4 	addi	r2,r2,-1
 1027648:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 102764c:	0001883a 	nop
 1027650:	e037883a 	mov	sp,fp
 1027654:	dfc00117 	ldw	ra,4(sp)
 1027658:	df000017 	ldw	fp,0(sp)
 102765c:	dec00204 	addi	sp,sp,8
 1027660:	f800283a 	ret

01027664 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 1027664:	defff804 	addi	sp,sp,-32
 1027668:	df000715 	stw	fp,28(sp)
 102766c:	df000704 	addi	fp,sp,28
 1027670:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 1027674:	e0bfff17 	ldw	r2,-4(fp)
 1027678:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 102767c:	e0bffb17 	ldw	r2,-20(fp)
 1027680:	10800017 	ldw	r2,0(r2)
 1027684:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1027688:	e0bffc17 	ldw	r2,-16(fp)
 102768c:	10800104 	addi	r2,r2,4
 1027690:	10800037 	ldwio	r2,0(r2)
 1027694:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 1027698:	e0bffd17 	ldw	r2,-12(fp)
 102769c:	1080c00c 	andi	r2,r2,768
 10276a0:	10006d26 	beq	r2,zero,1027858 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 10276a4:	e0bffd17 	ldw	r2,-12(fp)
 10276a8:	1080400c 	andi	r2,r2,256
 10276ac:	10003526 	beq	r2,zero,1027784 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 10276b0:	00800074 	movhi	r2,1
 10276b4:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 10276b8:	e0bffb17 	ldw	r2,-20(fp)
 10276bc:	10800a17 	ldw	r2,40(r2)
 10276c0:	10800044 	addi	r2,r2,1
 10276c4:	1081ffcc 	andi	r2,r2,2047
 10276c8:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 10276cc:	e0bffb17 	ldw	r2,-20(fp)
 10276d0:	10c00b17 	ldw	r3,44(r2)
 10276d4:	e0bffe17 	ldw	r2,-8(fp)
 10276d8:	18801526 	beq	r3,r2,1027730 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 10276dc:	e0bffc17 	ldw	r2,-16(fp)
 10276e0:	10800037 	ldwio	r2,0(r2)
 10276e4:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 10276e8:	e0bff917 	ldw	r2,-28(fp)
 10276ec:	10a0000c 	andi	r2,r2,32768
 10276f0:	10001126 	beq	r2,zero,1027738 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 10276f4:	e0bffb17 	ldw	r2,-20(fp)
 10276f8:	10800a17 	ldw	r2,40(r2)
 10276fc:	e0fff917 	ldw	r3,-28(fp)
 1027700:	1809883a 	mov	r4,r3
 1027704:	e0fffb17 	ldw	r3,-20(fp)
 1027708:	1885883a 	add	r2,r3,r2
 102770c:	10800e04 	addi	r2,r2,56
 1027710:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1027714:	e0bffb17 	ldw	r2,-20(fp)
 1027718:	10800a17 	ldw	r2,40(r2)
 102771c:	10800044 	addi	r2,r2,1
 1027720:	10c1ffcc 	andi	r3,r2,2047
 1027724:	e0bffb17 	ldw	r2,-20(fp)
 1027728:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 102772c:	003fe206 	br	10276b8 <__alt_data_end+0xff0276b8>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 1027730:	0001883a 	nop
 1027734:	00000106 	br	102773c <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 1027738:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 102773c:	e0bff917 	ldw	r2,-28(fp)
 1027740:	10bfffec 	andhi	r2,r2,65535
 1027744:	10000f26 	beq	r2,zero,1027784 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1027748:	e0bffb17 	ldw	r2,-20(fp)
 102774c:	10c00817 	ldw	r3,32(r2)
 1027750:	00bfff84 	movi	r2,-2
 1027754:	1886703a 	and	r3,r3,r2
 1027758:	e0bffb17 	ldw	r2,-20(fp)
 102775c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 1027760:	e0bffc17 	ldw	r2,-16(fp)
 1027764:	10800104 	addi	r2,r2,4
 1027768:	1007883a 	mov	r3,r2
 102776c:	e0bffb17 	ldw	r2,-20(fp)
 1027770:	10800817 	ldw	r2,32(r2)
 1027774:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1027778:	e0bffc17 	ldw	r2,-16(fp)
 102777c:	10800104 	addi	r2,r2,4
 1027780:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 1027784:	e0bffd17 	ldw	r2,-12(fp)
 1027788:	1080800c 	andi	r2,r2,512
 102778c:	103fbe26 	beq	r2,zero,1027688 <__alt_data_end+0xff027688>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 1027790:	e0bffd17 	ldw	r2,-12(fp)
 1027794:	1004d43a 	srli	r2,r2,16
 1027798:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 102779c:	00001406 	br	10277f0 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 10277a0:	e0bffc17 	ldw	r2,-16(fp)
 10277a4:	e0fffb17 	ldw	r3,-20(fp)
 10277a8:	18c00d17 	ldw	r3,52(r3)
 10277ac:	e13ffb17 	ldw	r4,-20(fp)
 10277b0:	20c7883a 	add	r3,r4,r3
 10277b4:	18c20e04 	addi	r3,r3,2104
 10277b8:	18c00003 	ldbu	r3,0(r3)
 10277bc:	18c03fcc 	andi	r3,r3,255
 10277c0:	18c0201c 	xori	r3,r3,128
 10277c4:	18ffe004 	addi	r3,r3,-128
 10277c8:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 10277cc:	e0bffb17 	ldw	r2,-20(fp)
 10277d0:	10800d17 	ldw	r2,52(r2)
 10277d4:	10800044 	addi	r2,r2,1
 10277d8:	10c1ffcc 	andi	r3,r2,2047
 10277dc:	e0bffb17 	ldw	r2,-20(fp)
 10277e0:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 10277e4:	e0bffa17 	ldw	r2,-24(fp)
 10277e8:	10bfffc4 	addi	r2,r2,-1
 10277ec:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 10277f0:	e0bffa17 	ldw	r2,-24(fp)
 10277f4:	10000526 	beq	r2,zero,102780c <altera_avalon_jtag_uart_irq+0x1a8>
 10277f8:	e0bffb17 	ldw	r2,-20(fp)
 10277fc:	10c00d17 	ldw	r3,52(r2)
 1027800:	e0bffb17 	ldw	r2,-20(fp)
 1027804:	10800c17 	ldw	r2,48(r2)
 1027808:	18bfe51e 	bne	r3,r2,10277a0 <__alt_data_end+0xff0277a0>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 102780c:	e0bffa17 	ldw	r2,-24(fp)
 1027810:	103f9d26 	beq	r2,zero,1027688 <__alt_data_end+0xff027688>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 1027814:	e0bffb17 	ldw	r2,-20(fp)
 1027818:	10c00817 	ldw	r3,32(r2)
 102781c:	00bfff44 	movi	r2,-3
 1027820:	1886703a 	and	r3,r3,r2
 1027824:	e0bffb17 	ldw	r2,-20(fp)
 1027828:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 102782c:	e0bffb17 	ldw	r2,-20(fp)
 1027830:	10800017 	ldw	r2,0(r2)
 1027834:	10800104 	addi	r2,r2,4
 1027838:	1007883a 	mov	r3,r2
 102783c:	e0bffb17 	ldw	r2,-20(fp)
 1027840:	10800817 	ldw	r2,32(r2)
 1027844:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1027848:	e0bffc17 	ldw	r2,-16(fp)
 102784c:	10800104 	addi	r2,r2,4
 1027850:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 1027854:	003f8c06 	br	1027688 <__alt_data_end+0xff027688>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 1027858:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 102785c:	0001883a 	nop
 1027860:	e037883a 	mov	sp,fp
 1027864:	df000017 	ldw	fp,0(sp)
 1027868:	dec00104 	addi	sp,sp,4
 102786c:	f800283a 	ret

01027870 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 1027870:	defff804 	addi	sp,sp,-32
 1027874:	df000715 	stw	fp,28(sp)
 1027878:	df000704 	addi	fp,sp,28
 102787c:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 1027880:	e0bffb17 	ldw	r2,-20(fp)
 1027884:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 1027888:	e0bff917 	ldw	r2,-28(fp)
 102788c:	10800017 	ldw	r2,0(r2)
 1027890:	10800104 	addi	r2,r2,4
 1027894:	10800037 	ldwio	r2,0(r2)
 1027898:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 102789c:	e0bffa17 	ldw	r2,-24(fp)
 10278a0:	1081000c 	andi	r2,r2,1024
 10278a4:	10000b26 	beq	r2,zero,10278d4 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 10278a8:	e0bff917 	ldw	r2,-28(fp)
 10278ac:	10800017 	ldw	r2,0(r2)
 10278b0:	10800104 	addi	r2,r2,4
 10278b4:	1007883a 	mov	r3,r2
 10278b8:	e0bff917 	ldw	r2,-28(fp)
 10278bc:	10800817 	ldw	r2,32(r2)
 10278c0:	10810014 	ori	r2,r2,1024
 10278c4:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 10278c8:	e0bff917 	ldw	r2,-28(fp)
 10278cc:	10000915 	stw	zero,36(r2)
 10278d0:	00000a06 	br	10278fc <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 10278d4:	e0bff917 	ldw	r2,-28(fp)
 10278d8:	10c00917 	ldw	r3,36(r2)
 10278dc:	00a00034 	movhi	r2,32768
 10278e0:	10bfff04 	addi	r2,r2,-4
 10278e4:	10c00536 	bltu	r2,r3,10278fc <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 10278e8:	e0bff917 	ldw	r2,-28(fp)
 10278ec:	10800917 	ldw	r2,36(r2)
 10278f0:	10c00044 	addi	r3,r2,1
 10278f4:	e0bff917 	ldw	r2,-28(fp)
 10278f8:	10c00915 	stw	r3,36(r2)
 10278fc:	d0a76017 	ldw	r2,-25216(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 1027900:	e037883a 	mov	sp,fp
 1027904:	df000017 	ldw	fp,0(sp)
 1027908:	dec00104 	addi	sp,sp,4
 102790c:	f800283a 	ret

01027910 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 1027910:	defffd04 	addi	sp,sp,-12
 1027914:	df000215 	stw	fp,8(sp)
 1027918:	df000204 	addi	fp,sp,8
 102791c:	e13ffe15 	stw	r4,-8(fp)
 1027920:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 1027924:	00000506 	br	102793c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 1027928:	e0bfff17 	ldw	r2,-4(fp)
 102792c:	1090000c 	andi	r2,r2,16384
 1027930:	10000226 	beq	r2,zero,102793c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 1027934:	00bffd44 	movi	r2,-11
 1027938:	00000b06 	br	1027968 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 102793c:	e0bffe17 	ldw	r2,-8(fp)
 1027940:	10c00d17 	ldw	r3,52(r2)
 1027944:	e0bffe17 	ldw	r2,-8(fp)
 1027948:	10800c17 	ldw	r2,48(r2)
 102794c:	18800526 	beq	r3,r2,1027964 <altera_avalon_jtag_uart_close+0x54>
 1027950:	e0bffe17 	ldw	r2,-8(fp)
 1027954:	10c00917 	ldw	r3,36(r2)
 1027958:	e0bffe17 	ldw	r2,-8(fp)
 102795c:	10800117 	ldw	r2,4(r2)
 1027960:	18bff136 	bltu	r3,r2,1027928 <__alt_data_end+0xff027928>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 1027964:	0005883a 	mov	r2,zero
}
 1027968:	e037883a 	mov	sp,fp
 102796c:	df000017 	ldw	fp,0(sp)
 1027970:	dec00104 	addi	sp,sp,4
 1027974:	f800283a 	ret

01027978 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 1027978:	defffa04 	addi	sp,sp,-24
 102797c:	df000515 	stw	fp,20(sp)
 1027980:	df000504 	addi	fp,sp,20
 1027984:	e13ffd15 	stw	r4,-12(fp)
 1027988:	e17ffe15 	stw	r5,-8(fp)
 102798c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 1027990:	00bff9c4 	movi	r2,-25
 1027994:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 1027998:	e0bffe17 	ldw	r2,-8(fp)
 102799c:	10da8060 	cmpeqi	r3,r2,27137
 10279a0:	1800031e 	bne	r3,zero,10279b0 <altera_avalon_jtag_uart_ioctl+0x38>
 10279a4:	109a80a0 	cmpeqi	r2,r2,27138
 10279a8:	1000181e 	bne	r2,zero,1027a0c <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 10279ac:	00002906 	br	1027a54 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 10279b0:	e0bffd17 	ldw	r2,-12(fp)
 10279b4:	10c00117 	ldw	r3,4(r2)
 10279b8:	00a00034 	movhi	r2,32768
 10279bc:	10bfffc4 	addi	r2,r2,-1
 10279c0:	18802126 	beq	r3,r2,1027a48 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 10279c4:	e0bfff17 	ldw	r2,-4(fp)
 10279c8:	10800017 	ldw	r2,0(r2)
 10279cc:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 10279d0:	e0bffc17 	ldw	r2,-16(fp)
 10279d4:	10800090 	cmplti	r2,r2,2
 10279d8:	1000061e 	bne	r2,zero,10279f4 <altera_avalon_jtag_uart_ioctl+0x7c>
 10279dc:	e0fffc17 	ldw	r3,-16(fp)
 10279e0:	00a00034 	movhi	r2,32768
 10279e4:	10bfffc4 	addi	r2,r2,-1
 10279e8:	18800226 	beq	r3,r2,10279f4 <altera_avalon_jtag_uart_ioctl+0x7c>
 10279ec:	e0bffc17 	ldw	r2,-16(fp)
 10279f0:	00000206 	br	10279fc <altera_avalon_jtag_uart_ioctl+0x84>
 10279f4:	00a00034 	movhi	r2,32768
 10279f8:	10bfff84 	addi	r2,r2,-2
 10279fc:	e0fffd17 	ldw	r3,-12(fp)
 1027a00:	18800115 	stw	r2,4(r3)
      rc = 0;
 1027a04:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 1027a08:	00000f06 	br	1027a48 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 1027a0c:	e0bffd17 	ldw	r2,-12(fp)
 1027a10:	10c00117 	ldw	r3,4(r2)
 1027a14:	00a00034 	movhi	r2,32768
 1027a18:	10bfffc4 	addi	r2,r2,-1
 1027a1c:	18800c26 	beq	r3,r2,1027a50 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 1027a20:	e0bffd17 	ldw	r2,-12(fp)
 1027a24:	10c00917 	ldw	r3,36(r2)
 1027a28:	e0bffd17 	ldw	r2,-12(fp)
 1027a2c:	10800117 	ldw	r2,4(r2)
 1027a30:	1885803a 	cmpltu	r2,r3,r2
 1027a34:	10c03fcc 	andi	r3,r2,255
 1027a38:	e0bfff17 	ldw	r2,-4(fp)
 1027a3c:	10c00015 	stw	r3,0(r2)
      rc = 0;
 1027a40:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 1027a44:	00000206 	br	1027a50 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 1027a48:	0001883a 	nop
 1027a4c:	00000106 	br	1027a54 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 1027a50:	0001883a 	nop

  default:
    break;
  }

  return rc;
 1027a54:	e0bffb17 	ldw	r2,-20(fp)
}
 1027a58:	e037883a 	mov	sp,fp
 1027a5c:	df000017 	ldw	fp,0(sp)
 1027a60:	dec00104 	addi	sp,sp,4
 1027a64:	f800283a 	ret

01027a68 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 1027a68:	defff304 	addi	sp,sp,-52
 1027a6c:	dfc00c15 	stw	ra,48(sp)
 1027a70:	df000b15 	stw	fp,44(sp)
 1027a74:	df000b04 	addi	fp,sp,44
 1027a78:	e13ffc15 	stw	r4,-16(fp)
 1027a7c:	e17ffd15 	stw	r5,-12(fp)
 1027a80:	e1bffe15 	stw	r6,-8(fp)
 1027a84:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 1027a88:	e0bffd17 	ldw	r2,-12(fp)
 1027a8c:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 1027a90:	00004706 	br	1027bb0 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 1027a94:	e0bffc17 	ldw	r2,-16(fp)
 1027a98:	10800a17 	ldw	r2,40(r2)
 1027a9c:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 1027aa0:	e0bffc17 	ldw	r2,-16(fp)
 1027aa4:	10800b17 	ldw	r2,44(r2)
 1027aa8:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 1027aac:	e0fff717 	ldw	r3,-36(fp)
 1027ab0:	e0bff817 	ldw	r2,-32(fp)
 1027ab4:	18800536 	bltu	r3,r2,1027acc <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 1027ab8:	e0fff717 	ldw	r3,-36(fp)
 1027abc:	e0bff817 	ldw	r2,-32(fp)
 1027ac0:	1885c83a 	sub	r2,r3,r2
 1027ac4:	e0bff615 	stw	r2,-40(fp)
 1027ac8:	00000406 	br	1027adc <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 1027acc:	00c20004 	movi	r3,2048
 1027ad0:	e0bff817 	ldw	r2,-32(fp)
 1027ad4:	1885c83a 	sub	r2,r3,r2
 1027ad8:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 1027adc:	e0bff617 	ldw	r2,-40(fp)
 1027ae0:	10001e26 	beq	r2,zero,1027b5c <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 1027ae4:	e0fffe17 	ldw	r3,-8(fp)
 1027ae8:	e0bff617 	ldw	r2,-40(fp)
 1027aec:	1880022e 	bgeu	r3,r2,1027af8 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 1027af0:	e0bffe17 	ldw	r2,-8(fp)
 1027af4:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 1027af8:	e0bffc17 	ldw	r2,-16(fp)
 1027afc:	10c00e04 	addi	r3,r2,56
 1027b00:	e0bff817 	ldw	r2,-32(fp)
 1027b04:	1885883a 	add	r2,r3,r2
 1027b08:	e1bff617 	ldw	r6,-40(fp)
 1027b0c:	100b883a 	mov	r5,r2
 1027b10:	e13ff517 	ldw	r4,-44(fp)
 1027b14:	10158f40 	call	10158f4 <memcpy>
      ptr   += n;
 1027b18:	e0fff517 	ldw	r3,-44(fp)
 1027b1c:	e0bff617 	ldw	r2,-40(fp)
 1027b20:	1885883a 	add	r2,r3,r2
 1027b24:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 1027b28:	e0fffe17 	ldw	r3,-8(fp)
 1027b2c:	e0bff617 	ldw	r2,-40(fp)
 1027b30:	1885c83a 	sub	r2,r3,r2
 1027b34:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1027b38:	e0fff817 	ldw	r3,-32(fp)
 1027b3c:	e0bff617 	ldw	r2,-40(fp)
 1027b40:	1885883a 	add	r2,r3,r2
 1027b44:	10c1ffcc 	andi	r3,r2,2047
 1027b48:	e0bffc17 	ldw	r2,-16(fp)
 1027b4c:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 1027b50:	e0bffe17 	ldw	r2,-8(fp)
 1027b54:	00bfcf16 	blt	zero,r2,1027a94 <__alt_data_end+0xff027a94>
 1027b58:	00000106 	br	1027b60 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 1027b5c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 1027b60:	e0fff517 	ldw	r3,-44(fp)
 1027b64:	e0bffd17 	ldw	r2,-12(fp)
 1027b68:	1880141e 	bne	r3,r2,1027bbc <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 1027b6c:	e0bfff17 	ldw	r2,-4(fp)
 1027b70:	1090000c 	andi	r2,r2,16384
 1027b74:	1000131e 	bne	r2,zero,1027bc4 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 1027b78:	0001883a 	nop
 1027b7c:	e0bffc17 	ldw	r2,-16(fp)
 1027b80:	10c00a17 	ldw	r3,40(r2)
 1027b84:	e0bff717 	ldw	r2,-36(fp)
 1027b88:	1880051e 	bne	r3,r2,1027ba0 <altera_avalon_jtag_uart_read+0x138>
 1027b8c:	e0bffc17 	ldw	r2,-16(fp)
 1027b90:	10c00917 	ldw	r3,36(r2)
 1027b94:	e0bffc17 	ldw	r2,-16(fp)
 1027b98:	10800117 	ldw	r2,4(r2)
 1027b9c:	18bff736 	bltu	r3,r2,1027b7c <__alt_data_end+0xff027b7c>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 1027ba0:	e0bffc17 	ldw	r2,-16(fp)
 1027ba4:	10c00a17 	ldw	r3,40(r2)
 1027ba8:	e0bff717 	ldw	r2,-36(fp)
 1027bac:	18800726 	beq	r3,r2,1027bcc <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 1027bb0:	e0bffe17 	ldw	r2,-8(fp)
 1027bb4:	00bfb716 	blt	zero,r2,1027a94 <__alt_data_end+0xff027a94>
 1027bb8:	00000506 	br	1027bd0 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 1027bbc:	0001883a 	nop
 1027bc0:	00000306 	br	1027bd0 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 1027bc4:	0001883a 	nop
 1027bc8:	00000106 	br	1027bd0 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 1027bcc:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 1027bd0:	e0fff517 	ldw	r3,-44(fp)
 1027bd4:	e0bffd17 	ldw	r2,-12(fp)
 1027bd8:	18801826 	beq	r3,r2,1027c3c <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1027bdc:	0005303a 	rdctl	r2,status
 1027be0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1027be4:	e0fffb17 	ldw	r3,-20(fp)
 1027be8:	00bfff84 	movi	r2,-2
 1027bec:	1884703a 	and	r2,r3,r2
 1027bf0:	1001703a 	wrctl	status,r2
  
  return context;
 1027bf4:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 1027bf8:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1027bfc:	e0bffc17 	ldw	r2,-16(fp)
 1027c00:	10800817 	ldw	r2,32(r2)
 1027c04:	10c00054 	ori	r3,r2,1
 1027c08:	e0bffc17 	ldw	r2,-16(fp)
 1027c0c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1027c10:	e0bffc17 	ldw	r2,-16(fp)
 1027c14:	10800017 	ldw	r2,0(r2)
 1027c18:	10800104 	addi	r2,r2,4
 1027c1c:	1007883a 	mov	r3,r2
 1027c20:	e0bffc17 	ldw	r2,-16(fp)
 1027c24:	10800817 	ldw	r2,32(r2)
 1027c28:	18800035 	stwio	r2,0(r3)
 1027c2c:	e0bffa17 	ldw	r2,-24(fp)
 1027c30:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1027c34:	e0bff917 	ldw	r2,-28(fp)
 1027c38:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 1027c3c:	e0fff517 	ldw	r3,-44(fp)
 1027c40:	e0bffd17 	ldw	r2,-12(fp)
 1027c44:	18800426 	beq	r3,r2,1027c58 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 1027c48:	e0fff517 	ldw	r3,-44(fp)
 1027c4c:	e0bffd17 	ldw	r2,-12(fp)
 1027c50:	1885c83a 	sub	r2,r3,r2
 1027c54:	00000606 	br	1027c70 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 1027c58:	e0bfff17 	ldw	r2,-4(fp)
 1027c5c:	1090000c 	andi	r2,r2,16384
 1027c60:	10000226 	beq	r2,zero,1027c6c <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 1027c64:	00bffd44 	movi	r2,-11
 1027c68:	00000106 	br	1027c70 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 1027c6c:	00bffec4 	movi	r2,-5
}
 1027c70:	e037883a 	mov	sp,fp
 1027c74:	dfc00117 	ldw	ra,4(sp)
 1027c78:	df000017 	ldw	fp,0(sp)
 1027c7c:	dec00204 	addi	sp,sp,8
 1027c80:	f800283a 	ret

01027c84 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 1027c84:	defff304 	addi	sp,sp,-52
 1027c88:	dfc00c15 	stw	ra,48(sp)
 1027c8c:	df000b15 	stw	fp,44(sp)
 1027c90:	df000b04 	addi	fp,sp,44
 1027c94:	e13ffc15 	stw	r4,-16(fp)
 1027c98:	e17ffd15 	stw	r5,-12(fp)
 1027c9c:	e1bffe15 	stw	r6,-8(fp)
 1027ca0:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 1027ca4:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 1027ca8:	e0bffd17 	ldw	r2,-12(fp)
 1027cac:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 1027cb0:	00003706 	br	1027d90 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 1027cb4:	e0bffc17 	ldw	r2,-16(fp)
 1027cb8:	10800c17 	ldw	r2,48(r2)
 1027cbc:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 1027cc0:	e0bffc17 	ldw	r2,-16(fp)
 1027cc4:	10800d17 	ldw	r2,52(r2)
 1027cc8:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 1027ccc:	e0fff917 	ldw	r3,-28(fp)
 1027cd0:	e0bff517 	ldw	r2,-44(fp)
 1027cd4:	1880062e 	bgeu	r3,r2,1027cf0 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 1027cd8:	e0fff517 	ldw	r3,-44(fp)
 1027cdc:	e0bff917 	ldw	r2,-28(fp)
 1027ce0:	1885c83a 	sub	r2,r3,r2
 1027ce4:	10bfffc4 	addi	r2,r2,-1
 1027ce8:	e0bff615 	stw	r2,-40(fp)
 1027cec:	00000b06 	br	1027d1c <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 1027cf0:	e0bff517 	ldw	r2,-44(fp)
 1027cf4:	10000526 	beq	r2,zero,1027d0c <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 1027cf8:	00c20004 	movi	r3,2048
 1027cfc:	e0bff917 	ldw	r2,-28(fp)
 1027d00:	1885c83a 	sub	r2,r3,r2
 1027d04:	e0bff615 	stw	r2,-40(fp)
 1027d08:	00000406 	br	1027d1c <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 1027d0c:	00c1ffc4 	movi	r3,2047
 1027d10:	e0bff917 	ldw	r2,-28(fp)
 1027d14:	1885c83a 	sub	r2,r3,r2
 1027d18:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 1027d1c:	e0bff617 	ldw	r2,-40(fp)
 1027d20:	10001e26 	beq	r2,zero,1027d9c <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 1027d24:	e0fffe17 	ldw	r3,-8(fp)
 1027d28:	e0bff617 	ldw	r2,-40(fp)
 1027d2c:	1880022e 	bgeu	r3,r2,1027d38 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 1027d30:	e0bffe17 	ldw	r2,-8(fp)
 1027d34:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 1027d38:	e0bffc17 	ldw	r2,-16(fp)
 1027d3c:	10c20e04 	addi	r3,r2,2104
 1027d40:	e0bff917 	ldw	r2,-28(fp)
 1027d44:	1885883a 	add	r2,r3,r2
 1027d48:	e1bff617 	ldw	r6,-40(fp)
 1027d4c:	e17ffd17 	ldw	r5,-12(fp)
 1027d50:	1009883a 	mov	r4,r2
 1027d54:	10158f40 	call	10158f4 <memcpy>
      ptr   += n;
 1027d58:	e0fffd17 	ldw	r3,-12(fp)
 1027d5c:	e0bff617 	ldw	r2,-40(fp)
 1027d60:	1885883a 	add	r2,r3,r2
 1027d64:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 1027d68:	e0fffe17 	ldw	r3,-8(fp)
 1027d6c:	e0bff617 	ldw	r2,-40(fp)
 1027d70:	1885c83a 	sub	r2,r3,r2
 1027d74:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1027d78:	e0fff917 	ldw	r3,-28(fp)
 1027d7c:	e0bff617 	ldw	r2,-40(fp)
 1027d80:	1885883a 	add	r2,r3,r2
 1027d84:	10c1ffcc 	andi	r3,r2,2047
 1027d88:	e0bffc17 	ldw	r2,-16(fp)
 1027d8c:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 1027d90:	e0bffe17 	ldw	r2,-8(fp)
 1027d94:	00bfc716 	blt	zero,r2,1027cb4 <__alt_data_end+0xff027cb4>
 1027d98:	00000106 	br	1027da0 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 1027d9c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1027da0:	0005303a 	rdctl	r2,status
 1027da4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1027da8:	e0fffb17 	ldw	r3,-20(fp)
 1027dac:	00bfff84 	movi	r2,-2
 1027db0:	1884703a 	and	r2,r3,r2
 1027db4:	1001703a 	wrctl	status,r2
  
  return context;
 1027db8:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 1027dbc:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 1027dc0:	e0bffc17 	ldw	r2,-16(fp)
 1027dc4:	10800817 	ldw	r2,32(r2)
 1027dc8:	10c00094 	ori	r3,r2,2
 1027dcc:	e0bffc17 	ldw	r2,-16(fp)
 1027dd0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1027dd4:	e0bffc17 	ldw	r2,-16(fp)
 1027dd8:	10800017 	ldw	r2,0(r2)
 1027ddc:	10800104 	addi	r2,r2,4
 1027de0:	1007883a 	mov	r3,r2
 1027de4:	e0bffc17 	ldw	r2,-16(fp)
 1027de8:	10800817 	ldw	r2,32(r2)
 1027dec:	18800035 	stwio	r2,0(r3)
 1027df0:	e0bffa17 	ldw	r2,-24(fp)
 1027df4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1027df8:	e0bff817 	ldw	r2,-32(fp)
 1027dfc:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 1027e00:	e0bffe17 	ldw	r2,-8(fp)
 1027e04:	0080100e 	bge	zero,r2,1027e48 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 1027e08:	e0bfff17 	ldw	r2,-4(fp)
 1027e0c:	1090000c 	andi	r2,r2,16384
 1027e10:	1000101e 	bne	r2,zero,1027e54 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 1027e14:	0001883a 	nop
 1027e18:	e0bffc17 	ldw	r2,-16(fp)
 1027e1c:	10c00d17 	ldw	r3,52(r2)
 1027e20:	e0bff517 	ldw	r2,-44(fp)
 1027e24:	1880051e 	bne	r3,r2,1027e3c <altera_avalon_jtag_uart_write+0x1b8>
 1027e28:	e0bffc17 	ldw	r2,-16(fp)
 1027e2c:	10c00917 	ldw	r3,36(r2)
 1027e30:	e0bffc17 	ldw	r2,-16(fp)
 1027e34:	10800117 	ldw	r2,4(r2)
 1027e38:	18bff736 	bltu	r3,r2,1027e18 <__alt_data_end+0xff027e18>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 1027e3c:	e0bffc17 	ldw	r2,-16(fp)
 1027e40:	10800917 	ldw	r2,36(r2)
 1027e44:	1000051e 	bne	r2,zero,1027e5c <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 1027e48:	e0bffe17 	ldw	r2,-8(fp)
 1027e4c:	00bfd016 	blt	zero,r2,1027d90 <__alt_data_end+0xff027d90>
 1027e50:	00000306 	br	1027e60 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 1027e54:	0001883a 	nop
 1027e58:	00000106 	br	1027e60 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 1027e5c:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 1027e60:	e0fffd17 	ldw	r3,-12(fp)
 1027e64:	e0bff717 	ldw	r2,-36(fp)
 1027e68:	18800426 	beq	r3,r2,1027e7c <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 1027e6c:	e0fffd17 	ldw	r3,-12(fp)
 1027e70:	e0bff717 	ldw	r2,-36(fp)
 1027e74:	1885c83a 	sub	r2,r3,r2
 1027e78:	00000606 	br	1027e94 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 1027e7c:	e0bfff17 	ldw	r2,-4(fp)
 1027e80:	1090000c 	andi	r2,r2,16384
 1027e84:	10000226 	beq	r2,zero,1027e90 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 1027e88:	00bffd44 	movi	r2,-11
 1027e8c:	00000106 	br	1027e94 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 1027e90:	00bffec4 	movi	r2,-5
}
 1027e94:	e037883a 	mov	sp,fp
 1027e98:	dfc00117 	ldw	ra,4(sp)
 1027e9c:	df000017 	ldw	fp,0(sp)
 1027ea0:	dec00204 	addi	sp,sp,8
 1027ea4:	f800283a 	ret

01027ea8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1027ea8:	defffe04 	addi	sp,sp,-8
 1027eac:	dfc00115 	stw	ra,4(sp)
 1027eb0:	df000015 	stw	fp,0(sp)
 1027eb4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1027eb8:	d0a01517 	ldw	r2,-32684(gp)
 1027ebc:	10000326 	beq	r2,zero,1027ecc <alt_get_errno+0x24>
 1027ec0:	d0a01517 	ldw	r2,-32684(gp)
 1027ec4:	103ee83a 	callr	r2
 1027ec8:	00000106 	br	1027ed0 <alt_get_errno+0x28>
 1027ecc:	d0a75b04 	addi	r2,gp,-25236
}
 1027ed0:	e037883a 	mov	sp,fp
 1027ed4:	dfc00117 	ldw	ra,4(sp)
 1027ed8:	df000017 	ldw	fp,0(sp)
 1027edc:	dec00204 	addi	sp,sp,8
 1027ee0:	f800283a 	ret

01027ee4 <alt_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
static int alt_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
 1027ee4:	defff904 	addi	sp,sp,-28
 1027ee8:	df000615 	stw	fp,24(sp)
 1027eec:	df000604 	addi	fp,sp,24
 1027ef0:	e13ffe15 	stw	r4,-8(fp)
 1027ef4:	e17fff15 	stw	r5,-4(fp)
  alt_u32 id, data, check;
  int ret_code = -1;
 1027ef8:	00bfffc4 	movi	r2,-1
 1027efc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_READ_CPUID(id);
 1027f00:	0005317a 	rdctl	r2,cpuid
 1027f04:	e0bffb15 	stw	r2,-20(fp)

  /* the data we want the mutex to hold */
  data = (id << ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST) | value;
 1027f08:	e0bffb17 	ldw	r2,-20(fp)
 1027f0c:	1006943a 	slli	r3,r2,16
 1027f10:	e0bfff17 	ldw	r2,-4(fp)
 1027f14:	1884b03a 	or	r2,r3,r2
 1027f18:	e0bffc15 	stw	r2,-16(fp)

  /* attempt to write to the mutex */
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, data);
 1027f1c:	e0bffe17 	ldw	r2,-8(fp)
 1027f20:	10800317 	ldw	r2,12(r2)
 1027f24:	e0fffc17 	ldw	r3,-16(fp)
 1027f28:	10c00035 	stwio	r3,0(r2)
  
  check = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
 1027f2c:	e0bffe17 	ldw	r2,-8(fp)
 1027f30:	10800317 	ldw	r2,12(r2)
 1027f34:	10800037 	ldwio	r2,0(r2)
 1027f38:	e0bffd15 	stw	r2,-12(fp)

  if ( check == data)
 1027f3c:	e0fffd17 	ldw	r3,-12(fp)
 1027f40:	e0bffc17 	ldw	r2,-16(fp)
 1027f44:	1880011e 	bne	r3,r2,1027f4c <alt_mutex_trylock+0x68>
  {
    ret_code = 0;
 1027f48:	e03ffa15 	stw	zero,-24(fp)
  }

  return ret_code;
 1027f4c:	e0bffa17 	ldw	r2,-24(fp)
}
 1027f50:	e037883a 	mov	sp,fp
 1027f54:	df000017 	ldw	fp,0(sp)
 1027f58:	dec00104 	addi	sp,sp,4
 1027f5c:	f800283a 	ret

01027f60 <altera_avalon_mutex_open>:
 * Search the list of registered mutexes for one with the supplied name.
 *
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
alt_mutex_dev* altera_avalon_mutex_open (const char* name)
{
 1027f60:	defffc04 	addi	sp,sp,-16
 1027f64:	dfc00315 	stw	ra,12(sp)
 1027f68:	df000215 	stw	fp,8(sp)
 1027f6c:	df000204 	addi	fp,sp,8
 1027f70:	e13fff15 	stw	r4,-4(fp)
  alt_mutex_dev* dev;

  dev = (alt_mutex_dev*) alt_find_dev (name, &alt_mutex_list);
 1027f74:	d1601804 	addi	r5,gp,-32672
 1027f78:	e13fff17 	ldw	r4,-4(fp)
 1027f7c:	102868c0 	call	102868c <alt_find_dev>
 1027f80:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev)
 1027f84:	e0bffe17 	ldw	r2,-8(fp)
 1027f88:	1000041e 	bne	r2,zero,1027f9c <altera_avalon_mutex_open+0x3c>
  {
    ALT_ERRNO = ENODEV;
 1027f8c:	1027ea80 	call	1027ea8 <alt_get_errno>
 1027f90:	1007883a 	mov	r3,r2
 1027f94:	008004c4 	movi	r2,19
 1027f98:	18800015 	stw	r2,0(r3)
  }

  return dev;
 1027f9c:	e0bffe17 	ldw	r2,-8(fp)
}
 1027fa0:	e037883a 	mov	sp,fp
 1027fa4:	dfc00117 	ldw	ra,4(sp)
 1027fa8:	df000017 	ldw	fp,0(sp)
 1027fac:	dec00204 	addi	sp,sp,8
 1027fb0:	f800283a 	ret

01027fb4 <altera_avalon_mutex_close>:
 * altera_avalon_mutex_close - Does nothing at the moment, but included for 
 * completeness
 *
 */
void altera_avalon_mutex_close (alt_mutex_dev* dev)
{
 1027fb4:	defffe04 	addi	sp,sp,-8
 1027fb8:	df000115 	stw	fp,4(sp)
 1027fbc:	df000104 	addi	fp,sp,4
 1027fc0:	e13fff15 	stw	r4,-4(fp)
  return;
 1027fc4:	0001883a 	nop
}
 1027fc8:	e037883a 	mov	sp,fp
 1027fcc:	df000017 	ldw	fp,0(sp)
 1027fd0:	dec00104 	addi	sp,sp,4
 1027fd4:	f800283a 	ret

01027fd8 <altera_avalon_mutex_lock>:
/*
 * altera_avalon_mutex_lock - Lock the hardware mutex
 *
 */
void altera_avalon_mutex_lock( alt_mutex_dev* dev, alt_u32 value )
{
 1027fd8:	defffc04 	addi	sp,sp,-16
 1027fdc:	dfc00315 	stw	ra,12(sp)
 1027fe0:	df000215 	stw	fp,8(sp)
 1027fe4:	df000204 	addi	fp,sp,8
 1027fe8:	e13ffe15 	stw	r4,-8(fp)
 1027fec:	e17fff15 	stw	r5,-4(fp)
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (dev->lock, 0);

  while ( alt_mutex_trylock( dev, value ) != 0);
 1027ff0:	0001883a 	nop
 1027ff4:	e17fff17 	ldw	r5,-4(fp)
 1027ff8:	e13ffe17 	ldw	r4,-8(fp)
 1027ffc:	1027ee40 	call	1027ee4 <alt_mutex_trylock>
 1028000:	103ffc1e 	bne	r2,zero,1027ff4 <__alt_data_end+0xff027ff4>
}
 1028004:	0001883a 	nop
 1028008:	e037883a 	mov	sp,fp
 102800c:	dfc00117 	ldw	ra,4(sp)
 1028010:	df000017 	ldw	fp,0(sp)
 1028014:	dec00204 	addi	sp,sp,8
 1028018:	f800283a 	ret

0102801c <altera_avalon_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
int altera_avalon_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
 102801c:	defffa04 	addi	sp,sp,-24
 1028020:	dfc00515 	stw	ra,20(sp)
 1028024:	df000415 	stw	fp,16(sp)
 1028028:	df000404 	addi	fp,sp,16
 102802c:	e13ffd15 	stw	r4,-12(fp)
 1028030:	e17ffe15 	stw	r5,-8(fp)
  int ret_code;

  ALT_SEM_PEND (dev->lock, 0);

  ret_code = alt_mutex_trylock( dev, value);
 1028034:	e17ffe17 	ldw	r5,-8(fp)
 1028038:	e13ffd17 	ldw	r4,-12(fp)
 102803c:	1027ee40 	call	1027ee4 <alt_mutex_trylock>
 1028040:	e0bffc15 	stw	r2,-16(fp)
  if (ret_code)
  {
    ALT_SEM_POST (dev->lock);
  }

  return ret_code;
 1028044:	e0bffc17 	ldw	r2,-16(fp)
}
 1028048:	e037883a 	mov	sp,fp
 102804c:	dfc00117 	ldw	ra,4(sp)
 1028050:	df000017 	ldw	fp,0(sp)
 1028054:	dec00204 	addi	sp,sp,8
 1028058:	f800283a 	ret

0102805c <altera_avalon_mutex_unlock>:
 * This function does not check that you own the Mutex if you try to release
 * a Mutex you do not own the behaviour is undefined
 *
 */
void altera_avalon_mutex_unlock( alt_mutex_dev* dev )
{
 102805c:	defffd04 	addi	sp,sp,-12
 1028060:	df000215 	stw	fp,8(sp)
 1028064:	df000204 	addi	fp,sp,8
 1028068:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id;
  NIOS2_READ_CPUID(id);
 102806c:	0005317a 	rdctl	r2,cpuid
 1028070:	e0bffe15 	stw	r2,-8(fp)

  /*
  * This Mutex has been claimed and released since Reset so clear the Reset bit
  * This MUST happen before we release the MUTEX
  */
  IOWR_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base, 
 1028074:	e0bfff17 	ldw	r2,-4(fp)
 1028078:	10800317 	ldw	r2,12(r2)
 102807c:	10800104 	addi	r2,r2,4
 1028080:	00c00044 	movi	r3,1
 1028084:	10c00035 	stwio	r3,0(r2)
                                  ALTERA_AVALON_MUTEX_RESET_RESET_MSK);
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, 
 1028088:	e0bfff17 	ldw	r2,-4(fp)
 102808c:	10800317 	ldw	r2,12(r2)
 1028090:	e0fffe17 	ldw	r3,-8(fp)
 1028094:	1806943a 	slli	r3,r3,16
 1028098:	10c00035 	stwio	r3,0(r2)

  /*
  * Now that access to the hardware Mutex is complete, release the thread lock
  */
  ALT_SEM_POST (dev->lock);
}
 102809c:	0001883a 	nop
 10280a0:	e037883a 	mov	sp,fp
 10280a4:	df000017 	ldw	fp,0(sp)
 10280a8:	dec00104 	addi	sp,sp,4
 10280ac:	f800283a 	ret

010280b0 <altera_avalon_mutex_is_mine>:
 * altera_avalon_mutex_is_mine - Do I own the Mutex?
 *
 *  returns non zero if the mutex is owned by this CPU
 */
int altera_avalon_mutex_is_mine( alt_mutex_dev* dev )
{
 10280b0:	defff904 	addi	sp,sp,-28
 10280b4:	df000615 	stw	fp,24(sp)
 10280b8:	df000604 	addi	fp,sp,24
 10280bc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id, data, owner, value;
  int ret_code = 0;
 10280c0:	e03ffa15 	stw	zero,-24(fp)

  NIOS2_READ_CPUID(id);
 10280c4:	0005317a 	rdctl	r2,cpuid
 10280c8:	e0bffb15 	stw	r2,-20(fp)

  /* retrieve the contents of the mutex */
  data = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
 10280cc:	e0bfff17 	ldw	r2,-4(fp)
 10280d0:	10800317 	ldw	r2,12(r2)
 10280d4:	10800037 	ldwio	r2,0(r2)
 10280d8:	e0bffc15 	stw	r2,-16(fp)
  owner = (data & ALTERA_AVALON_MUTEX_MUTEX_OWNER_MSK) >> 
 10280dc:	e0bffc17 	ldw	r2,-16(fp)
 10280e0:	1004d43a 	srli	r2,r2,16
 10280e4:	e0bffd15 	stw	r2,-12(fp)
              ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST;

  if (owner == id) 
 10280e8:	e0fffd17 	ldw	r3,-12(fp)
 10280ec:	e0bffb17 	ldw	r2,-20(fp)
 10280f0:	1880071e 	bne	r3,r2,1028110 <altera_avalon_mutex_is_mine+0x60>
  {
    value = (data & ALTERA_AVALON_MUTEX_MUTEX_VALUE_MSK) >> 
 10280f4:	e0bffc17 	ldw	r2,-16(fp)
 10280f8:	10bfffcc 	andi	r2,r2,65535
 10280fc:	e0bffe15 	stw	r2,-8(fp)
                  ALTERA_AVALON_MUTEX_MUTEX_VALUE_OFST;
    if (value != 0)
 1028100:	e0bffe17 	ldw	r2,-8(fp)
 1028104:	10000226 	beq	r2,zero,1028110 <altera_avalon_mutex_is_mine+0x60>
    {
      ret_code = 1;
 1028108:	00800044 	movi	r2,1
 102810c:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  return ret_code;
 1028110:	e0bffa17 	ldw	r2,-24(fp)
}
 1028114:	e037883a 	mov	sp,fp
 1028118:	df000017 	ldw	fp,0(sp)
 102811c:	dec00104 	addi	sp,sp,4
 1028120:	f800283a 	ret

01028124 <altera_avalon_mutex_first_lock>:
 *
 * Has this Mutex been released since reset if not return 1
 * otherwise return 0
 */
int altera_avalon_mutex_first_lock( alt_mutex_dev* dev )
{
 1028124:	defffc04 	addi	sp,sp,-16
 1028128:	df000315 	stw	fp,12(sp)
 102812c:	df000304 	addi	fp,sp,12
 1028130:	e13fff15 	stw	r4,-4(fp)
  alt_u32 data;
  int ret_code = 0;
 1028134:	e03ffd15 	stw	zero,-12(fp)

  data = IORD_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base);
 1028138:	e0bfff17 	ldw	r2,-4(fp)
 102813c:	10800317 	ldw	r2,12(r2)
 1028140:	10800104 	addi	r2,r2,4
 1028144:	10800037 	ldwio	r2,0(r2)
 1028148:	e0bffe15 	stw	r2,-8(fp)

  if (data & ALTERA_AVALON_MUTEX_RESET_RESET_MSK) 
 102814c:	e0bffe17 	ldw	r2,-8(fp)
 1028150:	1080004c 	andi	r2,r2,1
 1028154:	10000226 	beq	r2,zero,1028160 <altera_avalon_mutex_first_lock+0x3c>
  {
    ret_code = 1;
 1028158:	00800044 	movi	r2,1
 102815c:	e0bffd15 	stw	r2,-12(fp)
  }

  return ret_code;
 1028160:	e0bffd17 	ldw	r2,-12(fp)
}
 1028164:	e037883a 	mov	sp,fp
 1028168:	df000017 	ldw	fp,0(sp)
 102816c:	dec00104 	addi	sp,sp,4
 1028170:	f800283a 	ret

01028174 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 1028174:	defffa04 	addi	sp,sp,-24
 1028178:	dfc00515 	stw	ra,20(sp)
 102817c:	df000415 	stw	fp,16(sp)
 1028180:	df000404 	addi	fp,sp,16
 1028184:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 1028188:	0007883a 	mov	r3,zero
 102818c:	e0bfff17 	ldw	r2,-4(fp)
 1028190:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 1028194:	e0bfff17 	ldw	r2,-4(fp)
 1028198:	10800104 	addi	r2,r2,4
 102819c:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10281a0:	0005303a 	rdctl	r2,status
 10281a4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10281a8:	e0fffd17 	ldw	r3,-12(fp)
 10281ac:	00bfff84 	movi	r2,-2
 10281b0:	1884703a 	and	r2,r3,r2
 10281b4:	1001703a 	wrctl	status,r2
  
  return context;
 10281b8:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 10281bc:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 10281c0:	1028b800 	call	1028b80 <alt_tick>
 10281c4:	e0bffc17 	ldw	r2,-16(fp)
 10281c8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10281cc:	e0bffe17 	ldw	r2,-8(fp)
 10281d0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 10281d4:	0001883a 	nop
 10281d8:	e037883a 	mov	sp,fp
 10281dc:	dfc00117 	ldw	ra,4(sp)
 10281e0:	df000017 	ldw	fp,0(sp)
 10281e4:	dec00204 	addi	sp,sp,8
 10281e8:	f800283a 	ret

010281ec <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 10281ec:	defff804 	addi	sp,sp,-32
 10281f0:	dfc00715 	stw	ra,28(sp)
 10281f4:	df000615 	stw	fp,24(sp)
 10281f8:	df000604 	addi	fp,sp,24
 10281fc:	e13ffc15 	stw	r4,-16(fp)
 1028200:	e17ffd15 	stw	r5,-12(fp)
 1028204:	e1bffe15 	stw	r6,-8(fp)
 1028208:	e1ffff15 	stw	r7,-4(fp)
 102820c:	e0bfff17 	ldw	r2,-4(fp)
 1028210:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 1028214:	d0a76017 	ldw	r2,-25216(gp)
 1028218:	1000021e 	bne	r2,zero,1028224 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 102821c:	e0bffb17 	ldw	r2,-20(fp)
 1028220:	d0a76015 	stw	r2,-25216(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 1028224:	e0bffc17 	ldw	r2,-16(fp)
 1028228:	10800104 	addi	r2,r2,4
 102822c:	00c001c4 	movi	r3,7
 1028230:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 1028234:	d8000015 	stw	zero,0(sp)
 1028238:	e1fffc17 	ldw	r7,-16(fp)
 102823c:	018040f4 	movhi	r6,259
 1028240:	31a05d04 	addi	r6,r6,-32396
 1028244:	e17ffe17 	ldw	r5,-8(fp)
 1028248:	e13ffd17 	ldw	r4,-12(fp)
 102824c:	102685c0 	call	102685c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 1028250:	0001883a 	nop
 1028254:	e037883a 	mov	sp,fp
 1028258:	dfc00117 	ldw	ra,4(sp)
 102825c:	df000017 	ldw	fp,0(sp)
 1028260:	dec00204 	addi	sp,sp,8
 1028264:	f800283a 	ret

01028268 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 1028268:	defff504 	addi	sp,sp,-44
 102826c:	df000a15 	stw	fp,40(sp)
 1028270:	df000a04 	addi	fp,sp,40
 1028274:	e13ffc15 	stw	r4,-16(fp)
 1028278:	e17ffd15 	stw	r5,-12(fp)
 102827c:	e1bffe15 	stw	r6,-8(fp)
 1028280:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 1028284:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1028288:	d0a76017 	ldw	r2,-25216(gp)
  
  if (alt_ticks_per_second ())
 102828c:	10003c26 	beq	r2,zero,1028380 <alt_alarm_start+0x118>
  {
    if (alarm)
 1028290:	e0bffc17 	ldw	r2,-16(fp)
 1028294:	10003826 	beq	r2,zero,1028378 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 1028298:	e0bffc17 	ldw	r2,-16(fp)
 102829c:	e0fffe17 	ldw	r3,-8(fp)
 10282a0:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 10282a4:	e0bffc17 	ldw	r2,-16(fp)
 10282a8:	e0ffff17 	ldw	r3,-4(fp)
 10282ac:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10282b0:	0005303a 	rdctl	r2,status
 10282b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10282b8:	e0fff917 	ldw	r3,-28(fp)
 10282bc:	00bfff84 	movi	r2,-2
 10282c0:	1884703a 	and	r2,r3,r2
 10282c4:	1001703a 	wrctl	status,r2
  
  return context;
 10282c8:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 10282cc:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 10282d0:	d0a76117 	ldw	r2,-25212(gp)
      
      current_nticks = alt_nticks();
 10282d4:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 10282d8:	e0fffd17 	ldw	r3,-12(fp)
 10282dc:	e0bff617 	ldw	r2,-40(fp)
 10282e0:	1885883a 	add	r2,r3,r2
 10282e4:	10c00044 	addi	r3,r2,1
 10282e8:	e0bffc17 	ldw	r2,-16(fp)
 10282ec:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 10282f0:	e0bffc17 	ldw	r2,-16(fp)
 10282f4:	10c00217 	ldw	r3,8(r2)
 10282f8:	e0bff617 	ldw	r2,-40(fp)
 10282fc:	1880042e 	bgeu	r3,r2,1028310 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 1028300:	e0bffc17 	ldw	r2,-16(fp)
 1028304:	00c00044 	movi	r3,1
 1028308:	10c00405 	stb	r3,16(r2)
 102830c:	00000206 	br	1028318 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 1028310:	e0bffc17 	ldw	r2,-16(fp)
 1028314:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 1028318:	e0bffc17 	ldw	r2,-16(fp)
 102831c:	d0e01a04 	addi	r3,gp,-32664
 1028320:	e0fffa15 	stw	r3,-24(fp)
 1028324:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1028328:	e0bffb17 	ldw	r2,-20(fp)
 102832c:	e0fffa17 	ldw	r3,-24(fp)
 1028330:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1028334:	e0bffa17 	ldw	r2,-24(fp)
 1028338:	10c00017 	ldw	r3,0(r2)
 102833c:	e0bffb17 	ldw	r2,-20(fp)
 1028340:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1028344:	e0bffa17 	ldw	r2,-24(fp)
 1028348:	10800017 	ldw	r2,0(r2)
 102834c:	e0fffb17 	ldw	r3,-20(fp)
 1028350:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 1028354:	e0bffa17 	ldw	r2,-24(fp)
 1028358:	e0fffb17 	ldw	r3,-20(fp)
 102835c:	10c00015 	stw	r3,0(r2)
 1028360:	e0bff817 	ldw	r2,-32(fp)
 1028364:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1028368:	e0bff717 	ldw	r2,-36(fp)
 102836c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 1028370:	0005883a 	mov	r2,zero
 1028374:	00000306 	br	1028384 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 1028378:	00bffa84 	movi	r2,-22
 102837c:	00000106 	br	1028384 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 1028380:	00bfde84 	movi	r2,-134
  }
}
 1028384:	e037883a 	mov	sp,fp
 1028388:	df000017 	ldw	fp,0(sp)
 102838c:	dec00104 	addi	sp,sp,4
 1028390:	f800283a 	ret

01028394 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 1028394:	defffa04 	addi	sp,sp,-24
 1028398:	dfc00515 	stw	ra,20(sp)
 102839c:	df000415 	stw	fp,16(sp)
 10283a0:	df000404 	addi	fp,sp,16
 10283a4:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 10283a8:	008000c4 	movi	r2,3
 10283ac:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 10283b0:	e0fffd17 	ldw	r3,-12(fp)
 10283b4:	008003f4 	movhi	r2,15
 10283b8:	10909004 	addi	r2,r2,16960
 10283bc:	1885383a 	mul	r2,r3,r2
 10283c0:	100b883a 	mov	r5,r2
 10283c4:	01017db4 	movhi	r4,1526
 10283c8:	21384004 	addi	r4,r4,-7936
 10283cc:	1023e000 	call	1023e00 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 10283d0:	100b883a 	mov	r5,r2
 10283d4:	01200034 	movhi	r4,32768
 10283d8:	213fffc4 	addi	r4,r4,-1
 10283dc:	1023e000 	call	1023e00 <__udivsi3>
 10283e0:	100b883a 	mov	r5,r2
 10283e4:	e13fff17 	ldw	r4,-4(fp)
 10283e8:	1023e000 	call	1023e00 <__udivsi3>
 10283ec:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 10283f0:	e0bffe17 	ldw	r2,-8(fp)
 10283f4:	10002a26 	beq	r2,zero,10284a0 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 10283f8:	e03ffc15 	stw	zero,-16(fp)
 10283fc:	00001706 	br	102845c <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 1028400:	00a00034 	movhi	r2,32768
 1028404:	10bfffc4 	addi	r2,r2,-1
 1028408:	10bfffc4 	addi	r2,r2,-1
 102840c:	103ffe1e 	bne	r2,zero,1028408 <__alt_data_end+0xff028408>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 1028410:	e0fffd17 	ldw	r3,-12(fp)
 1028414:	008003f4 	movhi	r2,15
 1028418:	10909004 	addi	r2,r2,16960
 102841c:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 1028420:	100b883a 	mov	r5,r2
 1028424:	01017db4 	movhi	r4,1526
 1028428:	21384004 	addi	r4,r4,-7936
 102842c:	1023e000 	call	1023e00 <__udivsi3>
 1028430:	100b883a 	mov	r5,r2
 1028434:	01200034 	movhi	r4,32768
 1028438:	213fffc4 	addi	r4,r4,-1
 102843c:	1023e000 	call	1023e00 <__udivsi3>
 1028440:	1007883a 	mov	r3,r2
 1028444:	e0bfff17 	ldw	r2,-4(fp)
 1028448:	10c5c83a 	sub	r2,r2,r3
 102844c:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 1028450:	e0bffc17 	ldw	r2,-16(fp)
 1028454:	10800044 	addi	r2,r2,1
 1028458:	e0bffc15 	stw	r2,-16(fp)
 102845c:	e0fffc17 	ldw	r3,-16(fp)
 1028460:	e0bffe17 	ldw	r2,-8(fp)
 1028464:	18bfe616 	blt	r3,r2,1028400 <__alt_data_end+0xff028400>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 1028468:	e0fffd17 	ldw	r3,-12(fp)
 102846c:	008003f4 	movhi	r2,15
 1028470:	10909004 	addi	r2,r2,16960
 1028474:	1885383a 	mul	r2,r3,r2
 1028478:	100b883a 	mov	r5,r2
 102847c:	01017db4 	movhi	r4,1526
 1028480:	21384004 	addi	r4,r4,-7936
 1028484:	1023e000 	call	1023e00 <__udivsi3>
 1028488:	1007883a 	mov	r3,r2
 102848c:	e0bfff17 	ldw	r2,-4(fp)
 1028490:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 1028494:	10bfffc4 	addi	r2,r2,-1
 1028498:	103ffe1e 	bne	r2,zero,1028494 <__alt_data_end+0xff028494>
 102849c:	00000d06 	br	10284d4 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 10284a0:	e0fffd17 	ldw	r3,-12(fp)
 10284a4:	008003f4 	movhi	r2,15
 10284a8:	10909004 	addi	r2,r2,16960
 10284ac:	1885383a 	mul	r2,r3,r2
 10284b0:	100b883a 	mov	r5,r2
 10284b4:	01017db4 	movhi	r4,1526
 10284b8:	21384004 	addi	r4,r4,-7936
 10284bc:	1023e000 	call	1023e00 <__udivsi3>
 10284c0:	1007883a 	mov	r3,r2
 10284c4:	e0bfff17 	ldw	r2,-4(fp)
 10284c8:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 10284cc:	10bfffc4 	addi	r2,r2,-1
 10284d0:	00bffe16 	blt	zero,r2,10284cc <__alt_data_end+0xff0284cc>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 10284d4:	0005883a 	mov	r2,zero
}
 10284d8:	e037883a 	mov	sp,fp
 10284dc:	dfc00117 	ldw	ra,4(sp)
 10284e0:	df000017 	ldw	fp,0(sp)
 10284e4:	dec00204 	addi	sp,sp,8
 10284e8:	f800283a 	ret

010284ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 10284ec:	defffe04 	addi	sp,sp,-8
 10284f0:	dfc00115 	stw	ra,4(sp)
 10284f4:	df000015 	stw	fp,0(sp)
 10284f8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 10284fc:	d0a01517 	ldw	r2,-32684(gp)
 1028500:	10000326 	beq	r2,zero,1028510 <alt_get_errno+0x24>
 1028504:	d0a01517 	ldw	r2,-32684(gp)
 1028508:	103ee83a 	callr	r2
 102850c:	00000106 	br	1028514 <alt_get_errno+0x28>
 1028510:	d0a75b04 	addi	r2,gp,-25236
}
 1028514:	e037883a 	mov	sp,fp
 1028518:	dfc00117 	ldw	ra,4(sp)
 102851c:	df000017 	ldw	fp,0(sp)
 1028520:	dec00204 	addi	sp,sp,8
 1028524:	f800283a 	ret

01028528 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 1028528:	defffa04 	addi	sp,sp,-24
 102852c:	dfc00515 	stw	ra,20(sp)
 1028530:	df000415 	stw	fp,16(sp)
 1028534:	df000404 	addi	fp,sp,16
 1028538:	e13ffe15 	stw	r4,-8(fp)
 102853c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 1028540:	e0bffe17 	ldw	r2,-8(fp)
 1028544:	10000326 	beq	r2,zero,1028554 <alt_dev_llist_insert+0x2c>
 1028548:	e0bffe17 	ldw	r2,-8(fp)
 102854c:	10800217 	ldw	r2,8(r2)
 1028550:	1000061e 	bne	r2,zero,102856c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 1028554:	10284ec0 	call	10284ec <alt_get_errno>
 1028558:	1007883a 	mov	r3,r2
 102855c:	00800584 	movi	r2,22
 1028560:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 1028564:	00bffa84 	movi	r2,-22
 1028568:	00001306 	br	10285b8 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 102856c:	e0bffe17 	ldw	r2,-8(fp)
 1028570:	e0ffff17 	ldw	r3,-4(fp)
 1028574:	e0fffc15 	stw	r3,-16(fp)
 1028578:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 102857c:	e0bffd17 	ldw	r2,-12(fp)
 1028580:	e0fffc17 	ldw	r3,-16(fp)
 1028584:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1028588:	e0bffc17 	ldw	r2,-16(fp)
 102858c:	10c00017 	ldw	r3,0(r2)
 1028590:	e0bffd17 	ldw	r2,-12(fp)
 1028594:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1028598:	e0bffc17 	ldw	r2,-16(fp)
 102859c:	10800017 	ldw	r2,0(r2)
 10285a0:	e0fffd17 	ldw	r3,-12(fp)
 10285a4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 10285a8:	e0bffc17 	ldw	r2,-16(fp)
 10285ac:	e0fffd17 	ldw	r3,-12(fp)
 10285b0:	10c00015 	stw	r3,0(r2)

  return 0;  
 10285b4:	0005883a 	mov	r2,zero
}
 10285b8:	e037883a 	mov	sp,fp
 10285bc:	dfc00117 	ldw	ra,4(sp)
 10285c0:	df000017 	ldw	fp,0(sp)
 10285c4:	dec00204 	addi	sp,sp,8
 10285c8:	f800283a 	ret

010285cc <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 10285cc:	defffd04 	addi	sp,sp,-12
 10285d0:	dfc00215 	stw	ra,8(sp)
 10285d4:	df000115 	stw	fp,4(sp)
 10285d8:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 10285dc:	008040f4 	movhi	r2,259
 10285e0:	10a47604 	addi	r2,r2,-28200
 10285e4:	e0bfff15 	stw	r2,-4(fp)
 10285e8:	00000606 	br	1028604 <_do_ctors+0x38>
        (*ctor) (); 
 10285ec:	e0bfff17 	ldw	r2,-4(fp)
 10285f0:	10800017 	ldw	r2,0(r2)
 10285f4:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 10285f8:	e0bfff17 	ldw	r2,-4(fp)
 10285fc:	10bfff04 	addi	r2,r2,-4
 1028600:	e0bfff15 	stw	r2,-4(fp)
 1028604:	e0ffff17 	ldw	r3,-4(fp)
 1028608:	008040f4 	movhi	r2,259
 102860c:	10a47304 	addi	r2,r2,-28212
 1028610:	18bff62e 	bgeu	r3,r2,10285ec <__alt_data_end+0xff0285ec>
        (*ctor) (); 
}
 1028614:	0001883a 	nop
 1028618:	e037883a 	mov	sp,fp
 102861c:	dfc00117 	ldw	ra,4(sp)
 1028620:	df000017 	ldw	fp,0(sp)
 1028624:	dec00204 	addi	sp,sp,8
 1028628:	f800283a 	ret

0102862c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 102862c:	defffd04 	addi	sp,sp,-12
 1028630:	dfc00215 	stw	ra,8(sp)
 1028634:	df000115 	stw	fp,4(sp)
 1028638:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 102863c:	008040f4 	movhi	r2,259
 1028640:	10a47604 	addi	r2,r2,-28200
 1028644:	e0bfff15 	stw	r2,-4(fp)
 1028648:	00000606 	br	1028664 <_do_dtors+0x38>
        (*dtor) (); 
 102864c:	e0bfff17 	ldw	r2,-4(fp)
 1028650:	10800017 	ldw	r2,0(r2)
 1028654:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 1028658:	e0bfff17 	ldw	r2,-4(fp)
 102865c:	10bfff04 	addi	r2,r2,-4
 1028660:	e0bfff15 	stw	r2,-4(fp)
 1028664:	e0ffff17 	ldw	r3,-4(fp)
 1028668:	008040f4 	movhi	r2,259
 102866c:	10a47704 	addi	r2,r2,-28196
 1028670:	18bff62e 	bgeu	r3,r2,102864c <__alt_data_end+0xff02864c>
        (*dtor) (); 
}
 1028674:	0001883a 	nop
 1028678:	e037883a 	mov	sp,fp
 102867c:	dfc00117 	ldw	ra,4(sp)
 1028680:	df000017 	ldw	fp,0(sp)
 1028684:	dec00204 	addi	sp,sp,8
 1028688:	f800283a 	ret

0102868c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 102868c:	defffa04 	addi	sp,sp,-24
 1028690:	dfc00515 	stw	ra,20(sp)
 1028694:	df000415 	stw	fp,16(sp)
 1028698:	df000404 	addi	fp,sp,16
 102869c:	e13ffe15 	stw	r4,-8(fp)
 10286a0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 10286a4:	e0bfff17 	ldw	r2,-4(fp)
 10286a8:	10800017 	ldw	r2,0(r2)
 10286ac:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 10286b0:	e13ffe17 	ldw	r4,-8(fp)
 10286b4:	10165b40 	call	10165b4 <strlen>
 10286b8:	10800044 	addi	r2,r2,1
 10286bc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 10286c0:	00000d06 	br	10286f8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 10286c4:	e0bffc17 	ldw	r2,-16(fp)
 10286c8:	10800217 	ldw	r2,8(r2)
 10286cc:	e0fffd17 	ldw	r3,-12(fp)
 10286d0:	180d883a 	mov	r6,r3
 10286d4:	e17ffe17 	ldw	r5,-8(fp)
 10286d8:	1009883a 	mov	r4,r2
 10286dc:	10158780 	call	1015878 <memcmp>
 10286e0:	1000021e 	bne	r2,zero,10286ec <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 10286e4:	e0bffc17 	ldw	r2,-16(fp)
 10286e8:	00000706 	br	1028708 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 10286ec:	e0bffc17 	ldw	r2,-16(fp)
 10286f0:	10800017 	ldw	r2,0(r2)
 10286f4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 10286f8:	e0fffc17 	ldw	r3,-16(fp)
 10286fc:	e0bfff17 	ldw	r2,-4(fp)
 1028700:	18bff01e 	bne	r3,r2,10286c4 <__alt_data_end+0xff0286c4>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 1028704:	0005883a 	mov	r2,zero
}
 1028708:	e037883a 	mov	sp,fp
 102870c:	dfc00117 	ldw	ra,4(sp)
 1028710:	df000017 	ldw	fp,0(sp)
 1028714:	dec00204 	addi	sp,sp,8
 1028718:	f800283a 	ret

0102871c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 102871c:	defffe04 	addi	sp,sp,-8
 1028720:	dfc00115 	stw	ra,4(sp)
 1028724:	df000015 	stw	fp,0(sp)
 1028728:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 102872c:	01420004 	movi	r5,2048
 1028730:	0009883a 	mov	r4,zero
 1028734:	1028e580 	call	1028e58 <alt_icache_flush>
#endif
}
 1028738:	0001883a 	nop
 102873c:	e037883a 	mov	sp,fp
 1028740:	dfc00117 	ldw	ra,4(sp)
 1028744:	df000017 	ldw	fp,0(sp)
 1028748:	dec00204 	addi	sp,sp,8
 102874c:	f800283a 	ret

01028750 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 1028750:	defff904 	addi	sp,sp,-28
 1028754:	dfc00615 	stw	ra,24(sp)
 1028758:	df000515 	stw	fp,20(sp)
 102875c:	df000504 	addi	fp,sp,20
 1028760:	e13ffc15 	stw	r4,-16(fp)
 1028764:	e17ffd15 	stw	r5,-12(fp)
 1028768:	e1bffe15 	stw	r6,-8(fp)
 102876c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 1028770:	e1bfff17 	ldw	r6,-4(fp)
 1028774:	e17ffe17 	ldw	r5,-8(fp)
 1028778:	e13ffd17 	ldw	r4,-12(fp)
 102877c:	10289900 	call	1028990 <open>
 1028780:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 1028784:	e0bffb17 	ldw	r2,-20(fp)
 1028788:	10001c16 	blt	r2,zero,10287fc <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 102878c:	008040f4 	movhi	r2,259
 1028790:	10add604 	addi	r2,r2,-18600
 1028794:	e0fffb17 	ldw	r3,-20(fp)
 1028798:	18c00324 	muli	r3,r3,12
 102879c:	10c5883a 	add	r2,r2,r3
 10287a0:	10c00017 	ldw	r3,0(r2)
 10287a4:	e0bffc17 	ldw	r2,-16(fp)
 10287a8:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 10287ac:	008040f4 	movhi	r2,259
 10287b0:	10add604 	addi	r2,r2,-18600
 10287b4:	e0fffb17 	ldw	r3,-20(fp)
 10287b8:	18c00324 	muli	r3,r3,12
 10287bc:	10c5883a 	add	r2,r2,r3
 10287c0:	10800104 	addi	r2,r2,4
 10287c4:	10c00017 	ldw	r3,0(r2)
 10287c8:	e0bffc17 	ldw	r2,-16(fp)
 10287cc:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 10287d0:	008040f4 	movhi	r2,259
 10287d4:	10add604 	addi	r2,r2,-18600
 10287d8:	e0fffb17 	ldw	r3,-20(fp)
 10287dc:	18c00324 	muli	r3,r3,12
 10287e0:	10c5883a 	add	r2,r2,r3
 10287e4:	10800204 	addi	r2,r2,8
 10287e8:	10c00017 	ldw	r3,0(r2)
 10287ec:	e0bffc17 	ldw	r2,-16(fp)
 10287f0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 10287f4:	e13ffb17 	ldw	r4,-20(fp)
 10287f8:	10270500 	call	1027050 <alt_release_fd>
  }
} 
 10287fc:	0001883a 	nop
 1028800:	e037883a 	mov	sp,fp
 1028804:	dfc00117 	ldw	ra,4(sp)
 1028808:	df000017 	ldw	fp,0(sp)
 102880c:	dec00204 	addi	sp,sp,8
 1028810:	f800283a 	ret

01028814 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 1028814:	defffb04 	addi	sp,sp,-20
 1028818:	dfc00415 	stw	ra,16(sp)
 102881c:	df000315 	stw	fp,12(sp)
 1028820:	df000304 	addi	fp,sp,12
 1028824:	e13ffd15 	stw	r4,-12(fp)
 1028828:	e17ffe15 	stw	r5,-8(fp)
 102882c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 1028830:	01c07fc4 	movi	r7,511
 1028834:	01800044 	movi	r6,1
 1028838:	e17ffd17 	ldw	r5,-12(fp)
 102883c:	010040f4 	movhi	r4,259
 1028840:	212dd904 	addi	r4,r4,-18588
 1028844:	10287500 	call	1028750 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 1028848:	01c07fc4 	movi	r7,511
 102884c:	000d883a 	mov	r6,zero
 1028850:	e17ffe17 	ldw	r5,-8(fp)
 1028854:	010040f4 	movhi	r4,259
 1028858:	212dd604 	addi	r4,r4,-18600
 102885c:	10287500 	call	1028750 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 1028860:	01c07fc4 	movi	r7,511
 1028864:	01800044 	movi	r6,1
 1028868:	e17fff17 	ldw	r5,-4(fp)
 102886c:	010040f4 	movhi	r4,259
 1028870:	212ddc04 	addi	r4,r4,-18576
 1028874:	10287500 	call	1028750 <alt_open_fd>
}  
 1028878:	0001883a 	nop
 102887c:	e037883a 	mov	sp,fp
 1028880:	dfc00117 	ldw	ra,4(sp)
 1028884:	df000017 	ldw	fp,0(sp)
 1028888:	dec00204 	addi	sp,sp,8
 102888c:	f800283a 	ret

01028890 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1028890:	defffe04 	addi	sp,sp,-8
 1028894:	dfc00115 	stw	ra,4(sp)
 1028898:	df000015 	stw	fp,0(sp)
 102889c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 10288a0:	d0a01517 	ldw	r2,-32684(gp)
 10288a4:	10000326 	beq	r2,zero,10288b4 <alt_get_errno+0x24>
 10288a8:	d0a01517 	ldw	r2,-32684(gp)
 10288ac:	103ee83a 	callr	r2
 10288b0:	00000106 	br	10288b8 <alt_get_errno+0x28>
 10288b4:	d0a75b04 	addi	r2,gp,-25236
}
 10288b8:	e037883a 	mov	sp,fp
 10288bc:	dfc00117 	ldw	ra,4(sp)
 10288c0:	df000017 	ldw	fp,0(sp)
 10288c4:	dec00204 	addi	sp,sp,8
 10288c8:	f800283a 	ret

010288cc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 10288cc:	defffd04 	addi	sp,sp,-12
 10288d0:	df000215 	stw	fp,8(sp)
 10288d4:	df000204 	addi	fp,sp,8
 10288d8:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 10288dc:	e0bfff17 	ldw	r2,-4(fp)
 10288e0:	10800217 	ldw	r2,8(r2)
 10288e4:	10d00034 	orhi	r3,r2,16384
 10288e8:	e0bfff17 	ldw	r2,-4(fp)
 10288ec:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 10288f0:	e03ffe15 	stw	zero,-8(fp)
 10288f4:	00001d06 	br	102896c <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 10288f8:	008040f4 	movhi	r2,259
 10288fc:	10add604 	addi	r2,r2,-18600
 1028900:	e0fffe17 	ldw	r3,-8(fp)
 1028904:	18c00324 	muli	r3,r3,12
 1028908:	10c5883a 	add	r2,r2,r3
 102890c:	10c00017 	ldw	r3,0(r2)
 1028910:	e0bfff17 	ldw	r2,-4(fp)
 1028914:	10800017 	ldw	r2,0(r2)
 1028918:	1880111e 	bne	r3,r2,1028960 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 102891c:	008040f4 	movhi	r2,259
 1028920:	10add604 	addi	r2,r2,-18600
 1028924:	e0fffe17 	ldw	r3,-8(fp)
 1028928:	18c00324 	muli	r3,r3,12
 102892c:	10c5883a 	add	r2,r2,r3
 1028930:	10800204 	addi	r2,r2,8
 1028934:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 1028938:	1000090e 	bge	r2,zero,1028960 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 102893c:	e0bffe17 	ldw	r2,-8(fp)
 1028940:	10c00324 	muli	r3,r2,12
 1028944:	008040f4 	movhi	r2,259
 1028948:	10add604 	addi	r2,r2,-18600
 102894c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1028950:	e0bfff17 	ldw	r2,-4(fp)
 1028954:	18800226 	beq	r3,r2,1028960 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 1028958:	00bffcc4 	movi	r2,-13
 102895c:	00000806 	br	1028980 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1028960:	e0bffe17 	ldw	r2,-8(fp)
 1028964:	10800044 	addi	r2,r2,1
 1028968:	e0bffe15 	stw	r2,-8(fp)
 102896c:	d0a01417 	ldw	r2,-32688(gp)
 1028970:	1007883a 	mov	r3,r2
 1028974:	e0bffe17 	ldw	r2,-8(fp)
 1028978:	18bfdf2e 	bgeu	r3,r2,10288f8 <__alt_data_end+0xff0288f8>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 102897c:	0005883a 	mov	r2,zero
}
 1028980:	e037883a 	mov	sp,fp
 1028984:	df000017 	ldw	fp,0(sp)
 1028988:	dec00104 	addi	sp,sp,4
 102898c:	f800283a 	ret

01028990 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 1028990:	defff604 	addi	sp,sp,-40
 1028994:	dfc00915 	stw	ra,36(sp)
 1028998:	df000815 	stw	fp,32(sp)
 102899c:	df000804 	addi	fp,sp,32
 10289a0:	e13ffd15 	stw	r4,-12(fp)
 10289a4:	e17ffe15 	stw	r5,-8(fp)
 10289a8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 10289ac:	00bfffc4 	movi	r2,-1
 10289b0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 10289b4:	00bffb44 	movi	r2,-19
 10289b8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 10289bc:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 10289c0:	d1601204 	addi	r5,gp,-32696
 10289c4:	e13ffd17 	ldw	r4,-12(fp)
 10289c8:	102868c0 	call	102868c <alt_find_dev>
 10289cc:	e0bff815 	stw	r2,-32(fp)
 10289d0:	e0bff817 	ldw	r2,-32(fp)
 10289d4:	1000051e 	bne	r2,zero,10289ec <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 10289d8:	e13ffd17 	ldw	r4,-12(fp)
 10289dc:	1028cac0 	call	1028cac <alt_find_file>
 10289e0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 10289e4:	00800044 	movi	r2,1
 10289e8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 10289ec:	e0bff817 	ldw	r2,-32(fp)
 10289f0:	10002926 	beq	r2,zero,1028a98 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 10289f4:	e13ff817 	ldw	r4,-32(fp)
 10289f8:	1028db40 	call	1028db4 <alt_get_fd>
 10289fc:	e0bff915 	stw	r2,-28(fp)
 1028a00:	e0bff917 	ldw	r2,-28(fp)
 1028a04:	1000030e 	bge	r2,zero,1028a14 <open+0x84>
    {
      status = index;
 1028a08:	e0bff917 	ldw	r2,-28(fp)
 1028a0c:	e0bffa15 	stw	r2,-24(fp)
 1028a10:	00002306 	br	1028aa0 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 1028a14:	e0bff917 	ldw	r2,-28(fp)
 1028a18:	10c00324 	muli	r3,r2,12
 1028a1c:	008040f4 	movhi	r2,259
 1028a20:	10add604 	addi	r2,r2,-18600
 1028a24:	1885883a 	add	r2,r3,r2
 1028a28:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 1028a2c:	e0fffe17 	ldw	r3,-8(fp)
 1028a30:	00900034 	movhi	r2,16384
 1028a34:	10bfffc4 	addi	r2,r2,-1
 1028a38:	1886703a 	and	r3,r3,r2
 1028a3c:	e0bffc17 	ldw	r2,-16(fp)
 1028a40:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 1028a44:	e0bffb17 	ldw	r2,-20(fp)
 1028a48:	1000051e 	bne	r2,zero,1028a60 <open+0xd0>
 1028a4c:	e13ffc17 	ldw	r4,-16(fp)
 1028a50:	10288cc0 	call	10288cc <alt_file_locked>
 1028a54:	e0bffa15 	stw	r2,-24(fp)
 1028a58:	e0bffa17 	ldw	r2,-24(fp)
 1028a5c:	10001016 	blt	r2,zero,1028aa0 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 1028a60:	e0bff817 	ldw	r2,-32(fp)
 1028a64:	10800317 	ldw	r2,12(r2)
 1028a68:	10000826 	beq	r2,zero,1028a8c <open+0xfc>
 1028a6c:	e0bff817 	ldw	r2,-32(fp)
 1028a70:	10800317 	ldw	r2,12(r2)
 1028a74:	e1ffff17 	ldw	r7,-4(fp)
 1028a78:	e1bffe17 	ldw	r6,-8(fp)
 1028a7c:	e17ffd17 	ldw	r5,-12(fp)
 1028a80:	e13ffc17 	ldw	r4,-16(fp)
 1028a84:	103ee83a 	callr	r2
 1028a88:	00000106 	br	1028a90 <open+0x100>
 1028a8c:	0005883a 	mov	r2,zero
 1028a90:	e0bffa15 	stw	r2,-24(fp)
 1028a94:	00000206 	br	1028aa0 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 1028a98:	00bffb44 	movi	r2,-19
 1028a9c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 1028aa0:	e0bffa17 	ldw	r2,-24(fp)
 1028aa4:	1000090e 	bge	r2,zero,1028acc <open+0x13c>
  {
    alt_release_fd (index);  
 1028aa8:	e13ff917 	ldw	r4,-28(fp)
 1028aac:	10270500 	call	1027050 <alt_release_fd>
    ALT_ERRNO = -status;
 1028ab0:	10288900 	call	1028890 <alt_get_errno>
 1028ab4:	1007883a 	mov	r3,r2
 1028ab8:	e0bffa17 	ldw	r2,-24(fp)
 1028abc:	0085c83a 	sub	r2,zero,r2
 1028ac0:	18800015 	stw	r2,0(r3)
    return -1;
 1028ac4:	00bfffc4 	movi	r2,-1
 1028ac8:	00000106 	br	1028ad0 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 1028acc:	e0bff917 	ldw	r2,-28(fp)
}
 1028ad0:	e037883a 	mov	sp,fp
 1028ad4:	dfc00117 	ldw	ra,4(sp)
 1028ad8:	df000017 	ldw	fp,0(sp)
 1028adc:	dec00204 	addi	sp,sp,8
 1028ae0:	f800283a 	ret

01028ae4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 1028ae4:	defffa04 	addi	sp,sp,-24
 1028ae8:	df000515 	stw	fp,20(sp)
 1028aec:	df000504 	addi	fp,sp,20
 1028af0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1028af4:	0005303a 	rdctl	r2,status
 1028af8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1028afc:	e0fffc17 	ldw	r3,-16(fp)
 1028b00:	00bfff84 	movi	r2,-2
 1028b04:	1884703a 	and	r2,r3,r2
 1028b08:	1001703a 	wrctl	status,r2
  
  return context;
 1028b0c:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 1028b10:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 1028b14:	e0bfff17 	ldw	r2,-4(fp)
 1028b18:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 1028b1c:	e0bffd17 	ldw	r2,-12(fp)
 1028b20:	10800017 	ldw	r2,0(r2)
 1028b24:	e0fffd17 	ldw	r3,-12(fp)
 1028b28:	18c00117 	ldw	r3,4(r3)
 1028b2c:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 1028b30:	e0bffd17 	ldw	r2,-12(fp)
 1028b34:	10800117 	ldw	r2,4(r2)
 1028b38:	e0fffd17 	ldw	r3,-12(fp)
 1028b3c:	18c00017 	ldw	r3,0(r3)
 1028b40:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 1028b44:	e0bffd17 	ldw	r2,-12(fp)
 1028b48:	e0fffd17 	ldw	r3,-12(fp)
 1028b4c:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 1028b50:	e0bffd17 	ldw	r2,-12(fp)
 1028b54:	e0fffd17 	ldw	r3,-12(fp)
 1028b58:	10c00015 	stw	r3,0(r2)
 1028b5c:	e0bffb17 	ldw	r2,-20(fp)
 1028b60:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1028b64:	e0bffe17 	ldw	r2,-8(fp)
 1028b68:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 1028b6c:	0001883a 	nop
 1028b70:	e037883a 	mov	sp,fp
 1028b74:	df000017 	ldw	fp,0(sp)
 1028b78:	dec00104 	addi	sp,sp,4
 1028b7c:	f800283a 	ret

01028b80 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 1028b80:	defffb04 	addi	sp,sp,-20
 1028b84:	dfc00415 	stw	ra,16(sp)
 1028b88:	df000315 	stw	fp,12(sp)
 1028b8c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 1028b90:	d0a01a17 	ldw	r2,-32664(gp)
 1028b94:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 1028b98:	d0a76117 	ldw	r2,-25212(gp)
 1028b9c:	10800044 	addi	r2,r2,1
 1028ba0:	d0a76115 	stw	r2,-25212(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 1028ba4:	00002e06 	br	1028c60 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 1028ba8:	e0bffd17 	ldw	r2,-12(fp)
 1028bac:	10800017 	ldw	r2,0(r2)
 1028bb0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 1028bb4:	e0bffd17 	ldw	r2,-12(fp)
 1028bb8:	10800403 	ldbu	r2,16(r2)
 1028bbc:	10803fcc 	andi	r2,r2,255
 1028bc0:	10000426 	beq	r2,zero,1028bd4 <alt_tick+0x54>
 1028bc4:	d0a76117 	ldw	r2,-25212(gp)
 1028bc8:	1000021e 	bne	r2,zero,1028bd4 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 1028bcc:	e0bffd17 	ldw	r2,-12(fp)
 1028bd0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 1028bd4:	e0bffd17 	ldw	r2,-12(fp)
 1028bd8:	10800217 	ldw	r2,8(r2)
 1028bdc:	d0e76117 	ldw	r3,-25212(gp)
 1028be0:	18801d36 	bltu	r3,r2,1028c58 <alt_tick+0xd8>
 1028be4:	e0bffd17 	ldw	r2,-12(fp)
 1028be8:	10800403 	ldbu	r2,16(r2)
 1028bec:	10803fcc 	andi	r2,r2,255
 1028bf0:	1000191e 	bne	r2,zero,1028c58 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 1028bf4:	e0bffd17 	ldw	r2,-12(fp)
 1028bf8:	10800317 	ldw	r2,12(r2)
 1028bfc:	e0fffd17 	ldw	r3,-12(fp)
 1028c00:	18c00517 	ldw	r3,20(r3)
 1028c04:	1809883a 	mov	r4,r3
 1028c08:	103ee83a 	callr	r2
 1028c0c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 1028c10:	e0bfff17 	ldw	r2,-4(fp)
 1028c14:	1000031e 	bne	r2,zero,1028c24 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 1028c18:	e13ffd17 	ldw	r4,-12(fp)
 1028c1c:	1028ae40 	call	1028ae4 <alt_alarm_stop>
 1028c20:	00000d06 	br	1028c58 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 1028c24:	e0bffd17 	ldw	r2,-12(fp)
 1028c28:	10c00217 	ldw	r3,8(r2)
 1028c2c:	e0bfff17 	ldw	r2,-4(fp)
 1028c30:	1887883a 	add	r3,r3,r2
 1028c34:	e0bffd17 	ldw	r2,-12(fp)
 1028c38:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 1028c3c:	e0bffd17 	ldw	r2,-12(fp)
 1028c40:	10c00217 	ldw	r3,8(r2)
 1028c44:	d0a76117 	ldw	r2,-25212(gp)
 1028c48:	1880032e 	bgeu	r3,r2,1028c58 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 1028c4c:	e0bffd17 	ldw	r2,-12(fp)
 1028c50:	00c00044 	movi	r3,1
 1028c54:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 1028c58:	e0bffe17 	ldw	r2,-8(fp)
 1028c5c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 1028c60:	e0fffd17 	ldw	r3,-12(fp)
 1028c64:	d0a01a04 	addi	r2,gp,-32664
 1028c68:	18bfcf1e 	bne	r3,r2,1028ba8 <__alt_data_end+0xff028ba8>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 1028c6c:	0001883a 	nop
}
 1028c70:	0001883a 	nop
 1028c74:	e037883a 	mov	sp,fp
 1028c78:	dfc00117 	ldw	ra,4(sp)
 1028c7c:	df000017 	ldw	fp,0(sp)
 1028c80:	dec00204 	addi	sp,sp,8
 1028c84:	f800283a 	ret

01028c88 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 1028c88:	deffff04 	addi	sp,sp,-4
 1028c8c:	df000015 	stw	fp,0(sp)
 1028c90:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 1028c94:	000170fa 	wrctl	ienable,zero
}
 1028c98:	0001883a 	nop
 1028c9c:	e037883a 	mov	sp,fp
 1028ca0:	df000017 	ldw	fp,0(sp)
 1028ca4:	dec00104 	addi	sp,sp,4
 1028ca8:	f800283a 	ret

01028cac <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 1028cac:	defffb04 	addi	sp,sp,-20
 1028cb0:	dfc00415 	stw	ra,16(sp)
 1028cb4:	df000315 	stw	fp,12(sp)
 1028cb8:	df000304 	addi	fp,sp,12
 1028cbc:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 1028cc0:	d0a01017 	ldw	r2,-32704(gp)
 1028cc4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 1028cc8:	00003106 	br	1028d90 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 1028ccc:	e0bffd17 	ldw	r2,-12(fp)
 1028cd0:	10800217 	ldw	r2,8(r2)
 1028cd4:	1009883a 	mov	r4,r2
 1028cd8:	10165b40 	call	10165b4 <strlen>
 1028cdc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 1028ce0:	e0bffd17 	ldw	r2,-12(fp)
 1028ce4:	10c00217 	ldw	r3,8(r2)
 1028ce8:	e0bffe17 	ldw	r2,-8(fp)
 1028cec:	10bfffc4 	addi	r2,r2,-1
 1028cf0:	1885883a 	add	r2,r3,r2
 1028cf4:	10800003 	ldbu	r2,0(r2)
 1028cf8:	10803fcc 	andi	r2,r2,255
 1028cfc:	1080201c 	xori	r2,r2,128
 1028d00:	10bfe004 	addi	r2,r2,-128
 1028d04:	10800bd8 	cmpnei	r2,r2,47
 1028d08:	1000031e 	bne	r2,zero,1028d18 <alt_find_file+0x6c>
    {
      len -= 1;
 1028d0c:	e0bffe17 	ldw	r2,-8(fp)
 1028d10:	10bfffc4 	addi	r2,r2,-1
 1028d14:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 1028d18:	e0bffe17 	ldw	r2,-8(fp)
 1028d1c:	e0ffff17 	ldw	r3,-4(fp)
 1028d20:	1885883a 	add	r2,r3,r2
 1028d24:	10800003 	ldbu	r2,0(r2)
 1028d28:	10803fcc 	andi	r2,r2,255
 1028d2c:	1080201c 	xori	r2,r2,128
 1028d30:	10bfe004 	addi	r2,r2,-128
 1028d34:	10800be0 	cmpeqi	r2,r2,47
 1028d38:	1000081e 	bne	r2,zero,1028d5c <alt_find_file+0xb0>
 1028d3c:	e0bffe17 	ldw	r2,-8(fp)
 1028d40:	e0ffff17 	ldw	r3,-4(fp)
 1028d44:	1885883a 	add	r2,r3,r2
 1028d48:	10800003 	ldbu	r2,0(r2)
 1028d4c:	10803fcc 	andi	r2,r2,255
 1028d50:	1080201c 	xori	r2,r2,128
 1028d54:	10bfe004 	addi	r2,r2,-128
 1028d58:	10000a1e 	bne	r2,zero,1028d84 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 1028d5c:	e0bffd17 	ldw	r2,-12(fp)
 1028d60:	10800217 	ldw	r2,8(r2)
 1028d64:	e0fffe17 	ldw	r3,-8(fp)
 1028d68:	180d883a 	mov	r6,r3
 1028d6c:	e17fff17 	ldw	r5,-4(fp)
 1028d70:	1009883a 	mov	r4,r2
 1028d74:	10158780 	call	1015878 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 1028d78:	1000021e 	bne	r2,zero,1028d84 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 1028d7c:	e0bffd17 	ldw	r2,-12(fp)
 1028d80:	00000706 	br	1028da0 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 1028d84:	e0bffd17 	ldw	r2,-12(fp)
 1028d88:	10800017 	ldw	r2,0(r2)
 1028d8c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 1028d90:	e0fffd17 	ldw	r3,-12(fp)
 1028d94:	d0a01004 	addi	r2,gp,-32704
 1028d98:	18bfcc1e 	bne	r3,r2,1028ccc <__alt_data_end+0xff028ccc>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 1028d9c:	0005883a 	mov	r2,zero
}
 1028da0:	e037883a 	mov	sp,fp
 1028da4:	dfc00117 	ldw	ra,4(sp)
 1028da8:	df000017 	ldw	fp,0(sp)
 1028dac:	dec00204 	addi	sp,sp,8
 1028db0:	f800283a 	ret

01028db4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 1028db4:	defffc04 	addi	sp,sp,-16
 1028db8:	df000315 	stw	fp,12(sp)
 1028dbc:	df000304 	addi	fp,sp,12
 1028dc0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 1028dc4:	00bffa04 	movi	r2,-24
 1028dc8:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 1028dcc:	e03ffd15 	stw	zero,-12(fp)
 1028dd0:	00001906 	br	1028e38 <alt_get_fd+0x84>
  {
    if (!alt_fd_list[i].dev)
 1028dd4:	008040f4 	movhi	r2,259
 1028dd8:	10add604 	addi	r2,r2,-18600
 1028ddc:	e0fffd17 	ldw	r3,-12(fp)
 1028de0:	18c00324 	muli	r3,r3,12
 1028de4:	10c5883a 	add	r2,r2,r3
 1028de8:	10800017 	ldw	r2,0(r2)
 1028dec:	10000f1e 	bne	r2,zero,1028e2c <alt_get_fd+0x78>
    {
      alt_fd_list[i].dev = dev;
 1028df0:	008040f4 	movhi	r2,259
 1028df4:	10add604 	addi	r2,r2,-18600
 1028df8:	e0fffd17 	ldw	r3,-12(fp)
 1028dfc:	18c00324 	muli	r3,r3,12
 1028e00:	10c5883a 	add	r2,r2,r3
 1028e04:	e0ffff17 	ldw	r3,-4(fp)
 1028e08:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 1028e0c:	d0e01417 	ldw	r3,-32688(gp)
 1028e10:	e0bffd17 	ldw	r2,-12(fp)
 1028e14:	1880020e 	bge	r3,r2,1028e20 <alt_get_fd+0x6c>
      {
        alt_max_fd = i;
 1028e18:	e0bffd17 	ldw	r2,-12(fp)
 1028e1c:	d0a01415 	stw	r2,-32688(gp)
      }
      rc = i;
 1028e20:	e0bffd17 	ldw	r2,-12(fp)
 1028e24:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 1028e28:	00000606 	br	1028e44 <alt_get_fd+0x90>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 1028e2c:	e0bffd17 	ldw	r2,-12(fp)
 1028e30:	10800044 	addi	r2,r2,1
 1028e34:	e0bffd15 	stw	r2,-12(fp)
 1028e38:	e0bffd17 	ldw	r2,-12(fp)
 1028e3c:	10800810 	cmplti	r2,r2,32
 1028e40:	103fe41e 	bne	r2,zero,1028dd4 <__alt_data_end+0xff028dd4>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 1028e44:	e0bffe17 	ldw	r2,-8(fp)
}
 1028e48:	e037883a 	mov	sp,fp
 1028e4c:	df000017 	ldw	fp,0(sp)
 1028e50:	dec00104 	addi	sp,sp,4
 1028e54:	f800283a 	ret

01028e58 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 1028e58:	defffb04 	addi	sp,sp,-20
 1028e5c:	df000415 	stw	fp,16(sp)
 1028e60:	df000404 	addi	fp,sp,16
 1028e64:	e13ffe15 	stw	r4,-8(fp)
 1028e68:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 1028e6c:	e0bfff17 	ldw	r2,-4(fp)
 1028e70:	10820070 	cmpltui	r2,r2,2049
 1028e74:	1000021e 	bne	r2,zero,1028e80 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 1028e78:	00820004 	movi	r2,2048
 1028e7c:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 1028e80:	e0fffe17 	ldw	r3,-8(fp)
 1028e84:	e0bfff17 	ldw	r2,-4(fp)
 1028e88:	1885883a 	add	r2,r3,r2
 1028e8c:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 1028e90:	e0bffe17 	ldw	r2,-8(fp)
 1028e94:	e0bffc15 	stw	r2,-16(fp)
 1028e98:	00000506 	br	1028eb0 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 1028e9c:	e0bffc17 	ldw	r2,-16(fp)
 1028ea0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 1028ea4:	e0bffc17 	ldw	r2,-16(fp)
 1028ea8:	10800804 	addi	r2,r2,32
 1028eac:	e0bffc15 	stw	r2,-16(fp)
 1028eb0:	e0fffc17 	ldw	r3,-16(fp)
 1028eb4:	e0bffd17 	ldw	r2,-12(fp)
 1028eb8:	18bff836 	bltu	r3,r2,1028e9c <__alt_data_end+0xff028e9c>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 1028ebc:	e0bffe17 	ldw	r2,-8(fp)
 1028ec0:	108007cc 	andi	r2,r2,31
 1028ec4:	10000226 	beq	r2,zero,1028ed0 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 1028ec8:	e0bffc17 	ldw	r2,-16(fp)
 1028ecc:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 1028ed0:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 1028ed4:	0001883a 	nop
 1028ed8:	e037883a 	mov	sp,fp
 1028edc:	df000017 	ldw	fp,0(sp)
 1028ee0:	dec00104 	addi	sp,sp,4
 1028ee4:	f800283a 	ret

01028ee8 <atexit>:
 1028ee8:	200b883a 	mov	r5,r4
 1028eec:	000f883a 	mov	r7,zero
 1028ef0:	000d883a 	mov	r6,zero
 1028ef4:	0009883a 	mov	r4,zero
 1028ef8:	1028f341 	jmpi	1028f34 <__register_exitproc>

01028efc <exit>:
 1028efc:	defffe04 	addi	sp,sp,-8
 1028f00:	000b883a 	mov	r5,zero
 1028f04:	dc000015 	stw	r16,0(sp)
 1028f08:	dfc00115 	stw	ra,4(sp)
 1028f0c:	2021883a 	mov	r16,r4
 1028f10:	102904c0 	call	102904c <__call_exitprocs>
 1028f14:	008040f4 	movhi	r2,259
 1028f18:	10b25c04 	addi	r2,r2,-13968
 1028f1c:	11000017 	ldw	r4,0(r2)
 1028f20:	20800f17 	ldw	r2,60(r4)
 1028f24:	10000126 	beq	r2,zero,1028f2c <exit+0x30>
 1028f28:	103ee83a 	callr	r2
 1028f2c:	8009883a 	mov	r4,r16
 1028f30:	102671c0 	call	102671c <_exit>

01028f34 <__register_exitproc>:
 1028f34:	defffa04 	addi	sp,sp,-24
 1028f38:	dc000315 	stw	r16,12(sp)
 1028f3c:	040040f4 	movhi	r16,259
 1028f40:	84325c04 	addi	r16,r16,-13968
 1028f44:	80c00017 	ldw	r3,0(r16)
 1028f48:	dc400415 	stw	r17,16(sp)
 1028f4c:	dfc00515 	stw	ra,20(sp)
 1028f50:	18805217 	ldw	r2,328(r3)
 1028f54:	2023883a 	mov	r17,r4
 1028f58:	10003726 	beq	r2,zero,1029038 <__register_exitproc+0x104>
 1028f5c:	10c00117 	ldw	r3,4(r2)
 1028f60:	010007c4 	movi	r4,31
 1028f64:	20c00e16 	blt	r4,r3,1028fa0 <__register_exitproc+0x6c>
 1028f68:	1a000044 	addi	r8,r3,1
 1028f6c:	8800221e 	bne	r17,zero,1028ff8 <__register_exitproc+0xc4>
 1028f70:	18c00084 	addi	r3,r3,2
 1028f74:	18c7883a 	add	r3,r3,r3
 1028f78:	18c7883a 	add	r3,r3,r3
 1028f7c:	12000115 	stw	r8,4(r2)
 1028f80:	10c7883a 	add	r3,r2,r3
 1028f84:	19400015 	stw	r5,0(r3)
 1028f88:	0005883a 	mov	r2,zero
 1028f8c:	dfc00517 	ldw	ra,20(sp)
 1028f90:	dc400417 	ldw	r17,16(sp)
 1028f94:	dc000317 	ldw	r16,12(sp)
 1028f98:	dec00604 	addi	sp,sp,24
 1028f9c:	f800283a 	ret
 1028fa0:	00800034 	movhi	r2,0
 1028fa4:	10800004 	addi	r2,r2,0
 1028fa8:	10002626 	beq	r2,zero,1029044 <__register_exitproc+0x110>
 1028fac:	01006404 	movi	r4,400
 1028fb0:	d9400015 	stw	r5,0(sp)
 1028fb4:	d9800115 	stw	r6,4(sp)
 1028fb8:	d9c00215 	stw	r7,8(sp)
 1028fbc:	00000000 	call	0 <__reset-0x1000000>
 1028fc0:	d9400017 	ldw	r5,0(sp)
 1028fc4:	d9800117 	ldw	r6,4(sp)
 1028fc8:	d9c00217 	ldw	r7,8(sp)
 1028fcc:	10001d26 	beq	r2,zero,1029044 <__register_exitproc+0x110>
 1028fd0:	81000017 	ldw	r4,0(r16)
 1028fd4:	10000115 	stw	zero,4(r2)
 1028fd8:	02000044 	movi	r8,1
 1028fdc:	22405217 	ldw	r9,328(r4)
 1028fe0:	0007883a 	mov	r3,zero
 1028fe4:	12400015 	stw	r9,0(r2)
 1028fe8:	20805215 	stw	r2,328(r4)
 1028fec:	10006215 	stw	zero,392(r2)
 1028ff0:	10006315 	stw	zero,396(r2)
 1028ff4:	883fde26 	beq	r17,zero,1028f70 <__alt_data_end+0xff028f70>
 1028ff8:	18c9883a 	add	r4,r3,r3
 1028ffc:	2109883a 	add	r4,r4,r4
 1029000:	1109883a 	add	r4,r2,r4
 1029004:	21802215 	stw	r6,136(r4)
 1029008:	01800044 	movi	r6,1
 102900c:	12406217 	ldw	r9,392(r2)
 1029010:	30cc983a 	sll	r6,r6,r3
 1029014:	4992b03a 	or	r9,r9,r6
 1029018:	12406215 	stw	r9,392(r2)
 102901c:	21c04215 	stw	r7,264(r4)
 1029020:	01000084 	movi	r4,2
 1029024:	893fd21e 	bne	r17,r4,1028f70 <__alt_data_end+0xff028f70>
 1029028:	11006317 	ldw	r4,396(r2)
 102902c:	218cb03a 	or	r6,r4,r6
 1029030:	11806315 	stw	r6,396(r2)
 1029034:	003fce06 	br	1028f70 <__alt_data_end+0xff028f70>
 1029038:	18805304 	addi	r2,r3,332
 102903c:	18805215 	stw	r2,328(r3)
 1029040:	003fc606 	br	1028f5c <__alt_data_end+0xff028f5c>
 1029044:	00bfffc4 	movi	r2,-1
 1029048:	003fd006 	br	1028f8c <__alt_data_end+0xff028f8c>

0102904c <__call_exitprocs>:
 102904c:	defff504 	addi	sp,sp,-44
 1029050:	df000915 	stw	fp,36(sp)
 1029054:	dd400615 	stw	r21,24(sp)
 1029058:	dc800315 	stw	r18,12(sp)
 102905c:	dfc00a15 	stw	ra,40(sp)
 1029060:	ddc00815 	stw	r23,32(sp)
 1029064:	dd800715 	stw	r22,28(sp)
 1029068:	dd000515 	stw	r20,20(sp)
 102906c:	dcc00415 	stw	r19,16(sp)
 1029070:	dc400215 	stw	r17,8(sp)
 1029074:	dc000115 	stw	r16,4(sp)
 1029078:	d9000015 	stw	r4,0(sp)
 102907c:	2839883a 	mov	fp,r5
 1029080:	04800044 	movi	r18,1
 1029084:	057fffc4 	movi	r21,-1
 1029088:	008040f4 	movhi	r2,259
 102908c:	10b25c04 	addi	r2,r2,-13968
 1029090:	12000017 	ldw	r8,0(r2)
 1029094:	45005217 	ldw	r20,328(r8)
 1029098:	44c05204 	addi	r19,r8,328
 102909c:	a0001c26 	beq	r20,zero,1029110 <__call_exitprocs+0xc4>
 10290a0:	a0800117 	ldw	r2,4(r20)
 10290a4:	15ffffc4 	addi	r23,r2,-1
 10290a8:	b8000d16 	blt	r23,zero,10290e0 <__call_exitprocs+0x94>
 10290ac:	14000044 	addi	r16,r2,1
 10290b0:	8421883a 	add	r16,r16,r16
 10290b4:	8421883a 	add	r16,r16,r16
 10290b8:	84402004 	addi	r17,r16,128
 10290bc:	a463883a 	add	r17,r20,r17
 10290c0:	a421883a 	add	r16,r20,r16
 10290c4:	e0001e26 	beq	fp,zero,1029140 <__call_exitprocs+0xf4>
 10290c8:	80804017 	ldw	r2,256(r16)
 10290cc:	e0801c26 	beq	fp,r2,1029140 <__call_exitprocs+0xf4>
 10290d0:	bdffffc4 	addi	r23,r23,-1
 10290d4:	843fff04 	addi	r16,r16,-4
 10290d8:	8c7fff04 	addi	r17,r17,-4
 10290dc:	bd7ff91e 	bne	r23,r21,10290c4 <__alt_data_end+0xff0290c4>
 10290e0:	00800034 	movhi	r2,0
 10290e4:	10800004 	addi	r2,r2,0
 10290e8:	10000926 	beq	r2,zero,1029110 <__call_exitprocs+0xc4>
 10290ec:	a0800117 	ldw	r2,4(r20)
 10290f0:	1000301e 	bne	r2,zero,10291b4 <__call_exitprocs+0x168>
 10290f4:	a0800017 	ldw	r2,0(r20)
 10290f8:	10003226 	beq	r2,zero,10291c4 <__call_exitprocs+0x178>
 10290fc:	a009883a 	mov	r4,r20
 1029100:	98800015 	stw	r2,0(r19)
 1029104:	00000000 	call	0 <__reset-0x1000000>
 1029108:	9d000017 	ldw	r20,0(r19)
 102910c:	a03fe41e 	bne	r20,zero,10290a0 <__alt_data_end+0xff0290a0>
 1029110:	dfc00a17 	ldw	ra,40(sp)
 1029114:	df000917 	ldw	fp,36(sp)
 1029118:	ddc00817 	ldw	r23,32(sp)
 102911c:	dd800717 	ldw	r22,28(sp)
 1029120:	dd400617 	ldw	r21,24(sp)
 1029124:	dd000517 	ldw	r20,20(sp)
 1029128:	dcc00417 	ldw	r19,16(sp)
 102912c:	dc800317 	ldw	r18,12(sp)
 1029130:	dc400217 	ldw	r17,8(sp)
 1029134:	dc000117 	ldw	r16,4(sp)
 1029138:	dec00b04 	addi	sp,sp,44
 102913c:	f800283a 	ret
 1029140:	a0800117 	ldw	r2,4(r20)
 1029144:	80c00017 	ldw	r3,0(r16)
 1029148:	10bfffc4 	addi	r2,r2,-1
 102914c:	15c01426 	beq	r2,r23,10291a0 <__call_exitprocs+0x154>
 1029150:	80000015 	stw	zero,0(r16)
 1029154:	183fde26 	beq	r3,zero,10290d0 <__alt_data_end+0xff0290d0>
 1029158:	95c8983a 	sll	r4,r18,r23
 102915c:	a0806217 	ldw	r2,392(r20)
 1029160:	a5800117 	ldw	r22,4(r20)
 1029164:	2084703a 	and	r2,r4,r2
 1029168:	10000b26 	beq	r2,zero,1029198 <__call_exitprocs+0x14c>
 102916c:	a0806317 	ldw	r2,396(r20)
 1029170:	2088703a 	and	r4,r4,r2
 1029174:	20000c1e 	bne	r4,zero,10291a8 <__call_exitprocs+0x15c>
 1029178:	89400017 	ldw	r5,0(r17)
 102917c:	d9000017 	ldw	r4,0(sp)
 1029180:	183ee83a 	callr	r3
 1029184:	a0800117 	ldw	r2,4(r20)
 1029188:	15bfbf1e 	bne	r2,r22,1029088 <__alt_data_end+0xff029088>
 102918c:	98800017 	ldw	r2,0(r19)
 1029190:	153fcf26 	beq	r2,r20,10290d0 <__alt_data_end+0xff0290d0>
 1029194:	003fbc06 	br	1029088 <__alt_data_end+0xff029088>
 1029198:	183ee83a 	callr	r3
 102919c:	003ff906 	br	1029184 <__alt_data_end+0xff029184>
 10291a0:	a5c00115 	stw	r23,4(r20)
 10291a4:	003feb06 	br	1029154 <__alt_data_end+0xff029154>
 10291a8:	89000017 	ldw	r4,0(r17)
 10291ac:	183ee83a 	callr	r3
 10291b0:	003ff406 	br	1029184 <__alt_data_end+0xff029184>
 10291b4:	a0800017 	ldw	r2,0(r20)
 10291b8:	a027883a 	mov	r19,r20
 10291bc:	1029883a 	mov	r20,r2
 10291c0:	003fb606 	br	102909c <__alt_data_end+0xff02909c>
 10291c4:	0005883a 	mov	r2,zero
 10291c8:	003ffb06 	br	10291b8 <__alt_data_end+0xff0291b8>
 10291cc:	01006df4 	movhi	r4,439
 10291d0:	01006f84 	movi	r4,446
 10291d4:	01007494 	movui	r4,466
 10291d8:	01007a24 	muli	r4,zero,488
